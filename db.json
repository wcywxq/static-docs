{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/stellar/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/plugins/friends.js","path":"js/plugins/friends.js","modified":0,"renderable":1},{"_id":"themes/stellar/source/js/plugins/sites.js","path":"js/plugins/sites.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1617775672555},{"_id":"source/_posts/大前端/前端自动化测试.md","hash":"569b903614aa3e1dfcd4a974d4f2e541b1e08dd2","modified":1617779561441},{"_id":"themes/stellar/.gitignore","hash":"cf4e2dcaa760ff6f7520fd032ce44574e2970e54","modified":1617776232782},{"_id":"themes/stellar/.npmignore","hash":"59be8a065e2fd8ae12002de7c5b13fec660a315f","modified":1617776232782},{"_id":"themes/stellar/LICENSE","hash":"7fdfdb5dbc7d672fa28a2a3c9efa03ff8df5917d","modified":1617776232782},{"_id":"themes/stellar/README.md","hash":"380d7b4de3fa89275e072a91d763f90925f9eb30","modified":1617776232782},{"_id":"themes/stellar/_config.yml","hash":"1b4fde522b2af6779abb6e623483a2de0bc5dd20","modified":1617776232782},{"_id":"themes/stellar/npm-publish.sh","hash":"cceb7463d6ec8588c744b9aaf7cc86da4cadf802","modified":1617776232798},{"_id":"themes/stellar/package.json","hash":"267c6360ab558aaba941e0ac40703cafdf9a80af","modified":1617776232798},{"_id":"themes/stellar/utterances.json","hash":"2d081c929dc790e3811eef037470194a19844da9","modified":1617776232830},{"_id":"themes/stellar/languages/en.yml","hash":"1864baaa91c996d7893655269731a8068d25659a","modified":1617776232783},{"_id":"themes/stellar/languages/zh-CN.yml","hash":"aea20515a3203b6236ef8a2f8fedbe8b0c2ecc74","modified":1617776232783},{"_id":"themes/stellar/languages/zh-TW.yml","hash":"391e7df8baff845efb094bcd73f77040ad091dbb","modified":1617776232783},{"_id":"themes/stellar/layout/404.ejs","hash":"c939d1f916f6ca3fc591ce7fb0b745642da79e73","modified":1617776232784},{"_id":"themes/stellar/layout/archive.ejs","hash":"32af3fd52bb7ac653816a3cf5f2b542226081518","modified":1617776232796},{"_id":"themes/stellar/layout/categories.ejs","hash":"80da9b1a714fe0868abe7d45cebff08164d06af1","modified":1617776232796},{"_id":"themes/stellar/layout/index.ejs","hash":"0d4a884fc1f6e999aa18f2b4347f11b09048fc7a","modified":1617776232796},{"_id":"themes/stellar/layout/layout.ejs","hash":"fa4f0803326acf105a3bbab6176f45f7a334ff3b","modified":1617776232796},{"_id":"themes/stellar/layout/page.ejs","hash":"90170dbc9ed8ffdaa9e02d2c246cdb8cc3f093ec","modified":1617776232797},{"_id":"themes/stellar/layout/post.ejs","hash":"ff002b086e0b1de72ddb80a1b692d9ba5c76a6a0","modified":1617776232797},{"_id":"themes/stellar/layout/tags.ejs","hash":"e0a6002fe01a2a93e2d84426383014a48b99a1aa","modified":1617776232797},{"_id":"themes/stellar/layout/wiki.ejs","hash":"aa030ca65bee4fde0923653402d9b7bd249b8c94","modified":1617776232797},{"_id":"themes/stellar/.github/config/label-commenter-config.yml","hash":"9c403157b2fd65b8210e85d5bc2a8942511868d4","modified":1617776232781},{"_id":"themes/stellar/.github/workflows/label-commenter.yml","hash":"6b338899366eba62473a3204e4b0408f06b0e070","modified":1617776232781},{"_id":"themes/stellar/.github/workflows/npm-publish.yml","hash":"9fffa22fb47867e6550a7dd8c049b5eeb96b900f","modified":1617776232781},{"_id":"themes/stellar/layout/_partial/head.ejs","hash":"3f455e4f979ff8da0fa812510fd8c0b20d03d0bc","modified":1617776232784},{"_id":"themes/stellar/layout/_partial/menubtn.ejs","hash":"b8407e7d00e896a1563d8708e04da4118cf83e39","modified":1617776232790},{"_id":"themes/stellar/scripts/events/index.js","hash":"97c1101964fef94c797b11edd0e564abbb5e3471","modified":1617776232798},{"_id":"themes/stellar/scripts/filters/index.js","hash":"5667f028990dd556133080090a5fcb00c64f05ac","modified":1617776232799},{"_id":"themes/stellar/scripts/generators/404.js","hash":"294c2e12ebc858cb47363626e5c6edcf4a5d67fa","modified":1617776232800},{"_id":"themes/stellar/scripts/generators/categories.js","hash":"37a443389795bf9047ab530e6111a5dde8567db5","modified":1617776232801},{"_id":"themes/stellar/scripts/generators/tags.js","hash":"9f9421ec4dc85e2bb8c3a376d4eb1c7c59d3b211","modified":1617776232801},{"_id":"themes/stellar/scripts/generators/wiki.js","hash":"a496297955c12817dc510ba9bc5a8f423d103416","modified":1617776232801},{"_id":"themes/stellar/scripts/helpers/category_color.js","hash":"35f459e5dcd845eef3d9b7a6205f015b92399d24","modified":1617776232802},{"_id":"themes/stellar/scripts/helpers/doc_tree.js","hash":"b8264dbd82e3239d2a787e76c7e98ba1926904b8","modified":1617776232802},{"_id":"themes/stellar/scripts/helpers/parse_config.js","hash":"c9712de293586ca529b9df8789b79e561acf85a9","modified":1617776232803},{"_id":"themes/stellar/scripts/helpers/related_posts.js","hash":"65075125851131ced601afb12a9b0d8c392a3e0d","modified":1617776232804},{"_id":"themes/stellar/scripts/helpers/scrollreveal.js","hash":"aecbaf28dfafe100bca014381e3f6e8f799da4d1","modified":1617776232804},{"_id":"themes/stellar/scripts/helpers/stellar_info.js","hash":"5b7a10c8b09237a467767f5467749c7d9378c2c1","modified":1617776232806},{"_id":"themes/stellar/scripts/tags/about.js","hash":"acd4cfea4ca8d3203c76afbb8752b50b0b9f5904","modified":1617776232806},{"_id":"themes/stellar/scripts/tags/checkbox.js","hash":"85a0f422a338cb5fa5c70ef30c93da95ef5ebbcf","modified":1617776232807},{"_id":"themes/stellar/scripts/tags/copy.js","hash":"26c9bc88aafda3b2c6c21aa8ce85607969cc3b00","modified":1617776232807},{"_id":"themes/stellar/scripts/tags/folding.js","hash":"b9cd2ff097aafcfcd461a898f20c2d6cd25ecc5b","modified":1617776232807},{"_id":"themes/stellar/scripts/tags/frame.js","hash":"6eba9dab0fde8908234df632b85efa6a312e7bf3","modified":1617776232808},{"_id":"themes/stellar/scripts/tags/friends.js","hash":"a2e9827810122e47f583f3cf1e418bf7933f781d","modified":1617776232808},{"_id":"themes/stellar/scripts/tags/ghcard.js","hash":"33d6d41ba4e01232eb72915b5b17fb0ed44f899c","modified":1617776232808},{"_id":"themes/stellar/scripts/tags/image.js","hash":"770c5e98ebd1e16a4fdbccbedaee490c4f476231","modified":1617776232808},{"_id":"themes/stellar/scripts/tags/index.js","hash":"eef64269ad7d7519fb3563f0118faff135760a2f","modified":1617776232809},{"_id":"themes/stellar/scripts/tags/inline-labels.js","hash":"08fbdc0ea622270e1236a28778f875c8ad2e5516","modified":1617776232809},{"_id":"themes/stellar/scripts/tags/issues.js","hash":"2028247a41e8427755b0007a6cf629f9f094f233","modified":1617776232809},{"_id":"themes/stellar/scripts/tags/link.js","hash":"857210520d82218bd9b61ac19414353ae5cb618c","modified":1617776232809},{"_id":"themes/stellar/scripts/tags/navbar.js","hash":"b403df437e2ac3c436461abb640d281b520bb0b8","modified":1617776232810},{"_id":"themes/stellar/scripts/tags/note.js","hash":"de6080779751eb6256912418383b2ea9afafe9d8","modified":1617776232810},{"_id":"themes/stellar/scripts/tags/site.js","hash":"5d32da930d4b10338386c20ca7e3414803954a1c","modified":1617776232810},{"_id":"themes/stellar/scripts/tags/swiper.js","hash":"dcecff446269b9553d280778640ff434391bfe9b","modified":1617776232811},{"_id":"themes/stellar/scripts/tags/timeline.js","hash":"549a5aeecea2f4dc730a08fb14e39de307d0844e","modified":1617776232811},{"_id":"themes/stellar/source/css/_custom.styl","hash":"90251301e412e44bb036345c411d4723c6c47e76","modified":1617776232816},{"_id":"themes/stellar/source/css/main.styl","hash":"28f7f6f69ed6aa3083784c0f4c1b17955dc5924e","modified":1617776232829},{"_id":"themes/stellar/source/js/main.js","hash":"a9f17a43d63c00994a40b156a5fb45e89dd5b272","modified":1617776232829},{"_id":"themes/stellar/layout/_partial/main/footer.ejs","hash":"77c785070f5e96d03217f846ad77065e97620432","modified":1617776232786},{"_id":"themes/stellar/layout/_partial/scripts/index.ejs","hash":"85c8728b1fb9a59577fb6e1f4fcd8ca8eb63bc22","modified":1617776232793},{"_id":"themes/stellar/layout/_partial/sidebar/header.ejs","hash":"c2569ecab9b22bb7861a13f6bce095338027b3b6","modified":1617776232794},{"_id":"themes/stellar/layout/_partial/sidebar/index.ejs","hash":"0a32b2f28cd802a06bde4a1de09fa29c5475d6e8","modified":1617776232794},{"_id":"themes/stellar/layout/_partial/sidebar/logo.ejs","hash":"456f2969188af91146653ffb423e9033a93f1f32","modified":1617776232794},{"_id":"themes/stellar/scripts/events/lib/config.js","hash":"a7c1b1d9009e3c84a8f18e97c9c12406bea07f42","modified":1617776232799},{"_id":"themes/stellar/scripts/events/lib/utils.js","hash":"2c342ae9ada7275beb6eaf51d010ee1cccf1033d","modified":1617776232799},{"_id":"themes/stellar/scripts/filters/lib/img_lazyload.js","hash":"b3dedcc1fc4189589e63d4fa6f169a70e9d63cd1","modified":1617776232800},{"_id":"themes/stellar/scripts/filters/lib/img_onerror.js","hash":"d44a8e20d4d537c0cf85b980e1fc3bc84865a2d3","modified":1617776232800},{"_id":"themes/stellar/scripts/tags/lib/tabs.js","hash":"79109c237faa248d38445effd75a748f550daeca","modified":1617776232809},{"_id":"themes/stellar/source/css/_common/base.styl","hash":"5a0aa29da6cb2bdaa9821add153c10f33498e4c8","modified":1617776232812},{"_id":"themes/stellar/source/css/_common/blur.styl","hash":"565c4598e306a7f69120ed9da6241cd66820d09a","modified":1617776232812},{"_id":"themes/stellar/source/css/_common/button.styl","hash":"29629862102ce14ebc5858c572e640d9e38917ce","modified":1617776232812},{"_id":"themes/stellar/source/css/_common/control.styl","hash":"75081ca9d522a76ec4acffb8111c918b2297650a","modified":1617776232813},{"_id":"themes/stellar/source/css/_common/cap.styl","hash":"41d81510d3781bf938987265ebd6b6fdaeac027c","modified":1617776232813},{"_id":"themes/stellar/source/css/_common/highlight.styl","hash":"5ae1a5c07319fc5296276301f688e3536d7044d7","modified":1617776232813},{"_id":"themes/stellar/source/css/_common/html.styl","hash":"fc4bf71512a12ae58b08da251394df7ac6e545c6","modified":1617776232813},{"_id":"themes/stellar/source/css/_common/image.styl","hash":"cca1103a9185202b13be49e16d77d259e9ffb482","modified":1617776232813},{"_id":"themes/stellar/source/css/_common/input.styl","hash":"2a765355617dd96c5974e7872c34eabc0052ed6f","modified":1617776232814},{"_id":"themes/stellar/source/css/_common/loading.styl","hash":"e05f621d367cd2b19c5f4c629f5213fbf3f39343","modified":1617776232814},{"_id":"themes/stellar/source/css/_common/mobile-only.styl","hash":"d357f92a758d51108886b8be575bddc9e4a5a3c8","modified":1617776232814},{"_id":"themes/stellar/source/css/_common/span.styl","hash":"78cf1b0b82fd60234e1f352501c3a27d1fe3be6b","modified":1617776232814},{"_id":"themes/stellar/source/css/_common/svg.styl","hash":"dd2fbe25de3e3cf475279d375e0d5e925f9058ea","modified":1617776232815},{"_id":"themes/stellar/source/css/_common/title.styl","hash":"a82504c42ae16920192370e4936d8a48ddf39cbe","modified":1617776232815},{"_id":"themes/stellar/source/css/_common/toast.styl","hash":"61ca6b42ded511bcc99fd684800bf84c5ab9454a","modified":1617776232815},{"_id":"themes/stellar/source/css/_defines/const.styl","hash":"1fc5588e6eeff7af7fcf4be3ba9be43cca7c1b6a","modified":1617776232816},{"_id":"themes/stellar/source/css/_defines/func.styl","hash":"229cf061e589443d065c106cde560967e8cdd8fa","modified":1617776232816},{"_id":"themes/stellar/source/css/_defines/theme.styl","hash":"8fe20db2b1d1ce2002123b624683310605068536","modified":1617776232816},{"_id":"themes/stellar/source/css/_layout/index.styl","hash":"388efb67ba82dc257f142281759519c69aba86ce","modified":1617776232817},{"_id":"themes/stellar/source/css/_layout/layout.styl","hash":"b086ecce84a5c319f071dea52bbdcd33645454ae","modified":1617776232817},{"_id":"themes/stellar/source/css/_layout/list.styl","hash":"5c386939f89ea3c5795706ac05033417857aa5b0","modified":1617776232817},{"_id":"themes/stellar/source/css/_layout/main.styl","hash":"1849a1615f632545fc5a32692bb3a52e04466ba0","modified":1617776232818},{"_id":"themes/stellar/source/css/_layout/md.styl","hash":"c00942b52d80fe887663edf3d7a2b085dfe47413","modified":1617776232818},{"_id":"themes/stellar/source/css/_plugins/index.styl","hash":"a5f73c7e6af62a2372adbe4dcc15970fa23bdb69","modified":1617776232827},{"_id":"themes/stellar/source/css/_plugins/lazyload.styl","hash":"a77e3ee71ab03628ce6085acdbfc35ef59faaf27","modified":1617776232827},{"_id":"themes/stellar/source/css/_plugins/scrollreveal.styl","hash":"bfeabad9cdaaa77ea0fa1fc0f20dc91520356a6f","modified":1617776232827},{"_id":"themes/stellar/source/css/_plugins/swiper.styl","hash":"4c7862c3de6922c92b715609a5c20b063335f193","modified":1617776232828},{"_id":"themes/stellar/source/js/plugins/friends.js","hash":"9815baf1e18d7cc2c8cb0623ce032a584cb2d40a","modified":1617776232830},{"_id":"themes/stellar/source/js/plugins/sites.js","hash":"dff454cd2bc34b718692dc4e941976311c73f670","modified":1617776232830},{"_id":"themes/stellar/layout/_partial/main/article/article_footer.ejs","hash":"4f3b6cfe51985f4ac081465a60c043e7ccd8dffa","modified":1617776232785},{"_id":"themes/stellar/layout/_partial/main/article/read_next.ejs","hash":"3db49086f591294225cfa39eac2343fdab701410","modified":1617776232785},{"_id":"themes/stellar/layout/_partial/main/article/related_posts.ejs","hash":"43c0fcdd9c55f287c65b8cd61c6e4a48e6f49dc8","modified":1617776232785},{"_id":"themes/stellar/layout/_partial/main/article/wiki_cover.ejs","hash":"44ed20ec39b6973ff00513e4c0bf6f2dd615d8ed","modified":1617776232785},{"_id":"themes/stellar/layout/_partial/main/header/index.ejs","hash":"bf1d8a6979daf4339e5452be1a2d23a152b44729","modified":1617776232786},{"_id":"themes/stellar/layout/_partial/main/navbar/breadcrumb.ejs","hash":"d9db4297891154b76b50c50c688b6818de52b68f","modified":1617776232786},{"_id":"themes/stellar/layout/_partial/main/navbar/list_post.ejs","hash":"7061ddc45c81a3c2fbc2f0376f2b1203d3835248","modified":1617776232787},{"_id":"themes/stellar/layout/_partial/main/navbar/list_wiki.ejs","hash":"bac0a90762e71f25f6fbf5134734c5dd44310308","modified":1617776232788},{"_id":"themes/stellar/layout/_partial/main/post_list/paginator.ejs","hash":"285c00bd0a97b9ff2c0daf30eee20739eb64d2c8","modified":1617776232788},{"_id":"themes/stellar/layout/_partial/main/post_list/post_card.ejs","hash":"3e0fdafed6a1b3d9f6b2cfe9a9b05a1f5379e929","modified":1617776232789},{"_id":"themes/stellar/layout/_partial/main/post_list/wiki_card.ejs","hash":"8f4a365b093f8743ab39256d8b1ddc08d650292d","modified":1617776232789},{"_id":"themes/stellar/layout/_partial/plugins/comments/layout.ejs","hash":"5f678bf8dac466fad0eea60fe7dced95737b716e","modified":1617776232790},{"_id":"themes/stellar/layout/_partial/plugins/comments/script.ejs","hash":"a9dce8066723ada71d91960d5dd07ab194cc3b05","modified":1617776232791},{"_id":"themes/stellar/layout/_partial/sidebar/widgets/markdown.ejs","hash":"2f14098e0834ad2b98b0dff3b6d19eed435ca689","modified":1617776232795},{"_id":"themes/stellar/layout/_partial/sidebar/widgets/recent.ejs","hash":"a9a215a52fd93be7ecf93cb70d4384d5fead01b2","modified":1617776232795},{"_id":"themes/stellar/layout/_partial/sidebar/widgets/toc.ejs","hash":"293fc23edbdc1224da7865106df9a86680edc249","modified":1617776232795},{"_id":"themes/stellar/layout/_partial/sidebar/widgets/wiki_more.ejs","hash":"ce52d61b9018c3c7688b0e9d05e8ab24a108ecf6","modified":1617776232795},{"_id":"themes/stellar/source/css/_layout/pages/archives.styl","hash":"f2fed99aebbdd42bcf80d00d9c2880f4107265b4","modified":1617776232818},{"_id":"themes/stellar/source/css/_layout/pages/error.styl","hash":"4c93c760b22d0e21800c45d7dc6f9e50c50da590","modified":1617776232819},{"_id":"themes/stellar/source/css/_layout/partial/article-footer.styl","hash":"b9041521e7557f13b876d51bc53eca966e3db49a","modified":1617776232819},{"_id":"themes/stellar/source/css/_layout/partial/bread-nav.styl","hash":"478d2f568f42a4fdf3cc7b43157070d1d2897d4b","modified":1617776232820},{"_id":"themes/stellar/source/css/_layout/partial/cover.styl","hash":"d57c16a3f3342f0189d8c3bb76d61ad159a47d25","modified":1617776232820},{"_id":"themes/stellar/source/css/_layout/partial/footer.styl","hash":"2da24b52b8c7ee98f1d55e296dc5279493ec2dd8","modified":1617776232820},{"_id":"themes/stellar/source/css/_layout/partial/navbar.styl","hash":"7a340b73437e27d763d8164a5c0116e82c955cdc","modified":1617776232820},{"_id":"themes/stellar/source/css/_layout/partial/paginator.styl","hash":"aaad37313623d12785088ab78846ead6a973dd12","modified":1617776232820},{"_id":"themes/stellar/source/css/_layout/partial/related.styl","hash":"4cabb6a1e43c470200f01e18aa406bb2d0c8f890","modified":1617776232822},{"_id":"themes/stellar/source/css/_layout/sidebar/footer.styl","hash":"283ccc89cb389b990a9fe7422f39e93cb4d07351","modified":1617776232822},{"_id":"themes/stellar/source/css/_layout/sidebar/sidebar.styl","hash":"1fc0db07afed5e2c45c7f5cd0bee4b8b26a81997","modified":1617776232823},{"_id":"themes/stellar/source/css/_layout/sidebar/toc.styl","hash":"2f2fd06702ba1a909bf3b4909b003e5dffc0f374","modified":1617776232823},{"_id":"themes/stellar/source/css/_layout/tag-plugins/about.styl","hash":"bda2ceb5a06324de67123a9c13c2c29980922839","modified":1617776232824},{"_id":"themes/stellar/source/css/_layout/tag-plugins/checkbox.styl","hash":"58f5cad89fe3879aa00bb8c9854d3f262fb2f2b4","modified":1617776232824},{"_id":"themes/stellar/source/css/_layout/tag-plugins/common.styl","hash":"373d896b12f59e049ab3fb61a8ea37943ec8251b","modified":1617776232824},{"_id":"themes/stellar/source/css/_layout/tag-plugins/copy.styl","hash":"a0c2c2d3d6b17f6bd92e4be47537cb0cc9bffdcc","modified":1617776232824},{"_id":"themes/stellar/source/css/_layout/tag-plugins/folding.styl","hash":"e18f3fe7dbe5b62d43f7cc1c23ceb2310943ff2d","modified":1617776232824},{"_id":"themes/stellar/source/css/_layout/tag-plugins/frame.styl","hash":"e15f5390951653b6ad62420afaed3ea2fe3f673c","modified":1617776232825},{"_id":"themes/stellar/source/css/_layout/tag-plugins/friends.styl","hash":"8f9e60b94c02197e4555f923d357017742bf8d7b","modified":1617776232825},{"_id":"themes/stellar/source/css/_layout/tag-plugins/ghcard.styl","hash":"98a50d3fab79ce03dd7f161fe3442d803712c284","modified":1617776232825},{"_id":"themes/stellar/source/css/_layout/tag-plugins/image.styl","hash":"6e8830da3d63216488b2d41936a553a7308907fd","modified":1617776232825},{"_id":"themes/stellar/source/css/_layout/tag-plugins/link.styl","hash":"5b53ce326172750ec895c814aab5b4574f8a44c0","modified":1617776232825},{"_id":"themes/stellar/source/css/_layout/tag-plugins/navbar.styl","hash":"e2216d3777fc49584f7e1d3f9115cfe0f08c8dac","modified":1617776232825},{"_id":"themes/stellar/source/css/_layout/tag-plugins/note.styl","hash":"3cd8f7e5264744b0d07d44cd396886ef8522bbcb","modified":1617776232826},{"_id":"themes/stellar/source/css/_layout/tag-plugins/sites.styl","hash":"df8db4a080a7b8595cad2676b94c855005cc6f19","modified":1617776232826},{"_id":"themes/stellar/source/css/_layout/tag-plugins/tabs.styl","hash":"fe272684d545563c1914a6c3ba4d323f97d099ca","modified":1617776232826},{"_id":"themes/stellar/source/css/_layout/tag-plugins/timeline.styl","hash":"50850e94bc31250b13ca616fdadb583edfe2d124","modified":1617776232826},{"_id":"themes/stellar/source/css/_plugins/comments/utterances.styl","hash":"80ef659cc375487632fab9768be482ec4bfc757a","modified":1617776232827},{"_id":"themes/stellar/source/css/_plugins/comments/valine.styl","hash":"246e66527c3eef915e4d7713ebf0fc8b7eb07d2a","modified":1617776232827},{"_id":"themes/stellar/layout/_partial/plugins/comments/utterances/layout.ejs","hash":"4e2ae1fdee9daa6bb8d92a74281d6a60ae0fc79a","modified":1617776232791},{"_id":"themes/stellar/layout/_partial/plugins/comments/utterances/script.ejs","hash":"4c00276007d6f8c327d2f7790efca5c9417ff194","modified":1617776232792},{"_id":"themes/stellar/layout/_partial/plugins/comments/valine/layout.ejs","hash":"e0b3ed8b13bb4b995b4bd8c8c7ec75e43b074d8e","modified":1617776232792},{"_id":"themes/stellar/layout/_partial/plugins/comments/valine/script.ejs","hash":"38d19501c576e444e349e7cab3d9f958d889a42b","modified":1617776232793},{"_id":"source/tags/index.md","hash":"c611dc2ac446dcc83a01ccd88bc1148bca4fe9cf","modified":1617776985657},{"_id":"source/_posts/大前端/React Hooks 的一些特性.md","hash":"6be79ec88c5c56e4be78488aa0273e39680c5fce","modified":1617779331075},{"_id":"source/_posts/大前端/Chrome 调试技巧.md","hash":"973121dcb7481de83a9799ba422da07cf79d0c37","modified":1617779556587},{"_id":"source/_posts/大前端/React16 文档.md","hash":"0ec76c9a3f4cd2f747d5a3e78b26f85ac70d4991","modified":1617779335055},{"_id":"source/_posts/大前端/Vue2 diff 算法.md","hash":"1edbf2ac974fd0dfa8639db3af0732aadcaefc1b","modified":1617779354917},{"_id":"source/_posts/大前端/Vue2 数据驱动.md","hash":"dffe02c7e09a26700a6a11385f8998c476b5c362","modified":1617779339175},{"_id":"source/_posts/大前端/Vue2 文档.md","hash":"2a2468ced4ea77d1a876a76faee6d2d7ecf35c84","modified":1617779347133},{"_id":"source/_posts/大前端/Vue2 虚拟 dom.md","hash":"d57579a1e9dfff9543e39003638746b4da95a2f5","modified":1617779351013},{"_id":"source/_posts/大前端/从图片裁剪了解 js 二进制常用 api.md","hash":"32c870e878c091d66c81043c7a679ed203f76ad8","modified":1617779528733},{"_id":"source/_posts/大前端/h5 相关问题收集.md","hash":"2f143c234480b0a73f3ff79596036e8af761b900","modified":1617779328085},{"_id":"source/_posts/大前端/编写 React 组件时常见的 5 个错误.md","hash":"c375df493d7cb29f6e89be91f92ef604ae6bcce6","modified":1617779306533},{"_id":"source/_posts/大前端/网络请求 ajax 和 fetch.md","hash":"61b6a2ca5f3aa45aa838f4a0e34e87c79a461525","modified":1617779558943},{"_id":"source/_posts/大前端/防抖和节流.md","hash":"4af0d6e03b9c4f8e5c4e3d3aab00f31027449946","modified":1617779564110},{"_id":"source/_posts/大前端/TypeScript 文档.md","hash":"d1d48af3f1fff907551510fe7b4fa49785bc551f","modified":1617779342754},{"_id":"source/_posts/前端/Vue2 diff 算法.md","hash":"f15b47fd0ab308bba07cba4e40b631b178be1623","modified":1617780197007},{"_id":"source/_posts/前端/Vue2 虚拟 dom.md","hash":"7bbbddc043abbd88321b8a78c97f7df9dad13d59","modified":1617780200285},{"_id":"source/_posts/前端/h5 相关问题收集.md","hash":"2f143c234480b0a73f3ff79596036e8af761b900","modified":1617779328085},{"_id":"source/_posts/前端/从图片裁剪了解 js 二进制常用 api.md","hash":"08a26f9721a164cc4b430e274c0a0c9fe05d0c17","modified":1617780449657},{"_id":"source/_posts/前端/前端自动化测试.md","hash":"d95988db9ab867d1c292190751fcb2ac71c65b78","modified":1617781159368},{"_id":"source/_posts/前端/编写 React 组件时常见的 5 个错误.md","hash":"a04540c87d3600e44ba10e6aba9af3c8bc9d8d27","modified":1617781151351},{"_id":"source/_posts/前端/网络请求 ajax 和 fetch.md","hash":"133f43431326d17adab05574d3f77082a8f86830","modified":1617780665441},{"_id":"source/_posts/前端/防抖和节流.md","hash":"af6241bf0789344bcc9d17967ebd309b733e3082","modified":1617780716210},{"_id":"source/_posts/前端/Chrome 调试技巧.md","hash":"cac8094ba25ca6c8f7c42ee521f4703047ef91de","modified":1617780284045},{"_id":"source/_posts/前端/Vue2 文档.md","hash":"e6748f4202c6133246495bf618bdb9782f911490","modified":1617780203482},{"_id":"source/_posts/前端/React Hooks 的一些特性.md","hash":"034f027b8b7212c04a925d47ed8b2bba818a093f","modified":1617781168001},{"_id":"source/_posts/前端/React16 文档.md","hash":"ee054eb7665598aa941883ff2390643030f9ad69","modified":1617780586117},{"_id":"source/_posts/前端/Vue2 数据驱动.md","hash":"17c5a20ccd102cf7a9a2ade40fe8be712b7349ab","modified":1617780563605},{"_id":"source/_posts/前端/TypeScript 文档.md","hash":"d46643289ccd095916c0504f2ffd3ca894e6f9b9","modified":1617780604867},{"_id":"source/_posts/前端/Hybrid 简介.md","hash":"62e57e60ef88f46b2afc973e5a5d8ac668c208f4","modified":1617780546242},{"_id":"source/_posts/前端/H5 相关问题收集.md","hash":"495bf68a0e38368ea19a392cbf2a226fe305ea8c","modified":1617780553982},{"_id":"source/_posts/前端/渐进式 web 应用程序 pwa 简介.md","hash":"74c30b5f51c6e8b6f9caa1a4ab1a3bcd3f76225a","modified":1617780427656},{"_id":"public/404.html","hash":"9eeeda2f50adb3f8ef6d2ecba60b47846fd37abb","modified":1617782521691},{"_id":"public/2020/07/21/前端/Vue2 数据驱动/index.html","hash":"3546fac83af4158eb5a86265d18f7f2224768f23","modified":1617782521691},{"_id":"public/2020/07/17/前端/Hybrid 简介/index.html","hash":"b819ad160e63476d6c6b4863814d5ee8337dad97","modified":1617782521691},{"_id":"public/2020/07/16/前端/渐进式 web 应用程序 pwa 简介/index.html","hash":"57c4d2ebd7d4f8fa585b83a5e013fdfd0587052d","modified":1617782521691},{"_id":"public/2020/07/13/前端/网络请求 ajax 和 fetch/index.html","hash":"044bd6367a1c699124d26ba157bad5002534a19e","modified":1617782521691},{"_id":"public/categories/大前端/index.html","hash":"00ded24f7adcf8596e7bd882679cbf0efa71d778","modified":1617782521691},{"_id":"public/categories/大前端/前端/index.html","hash":"710e2e7674787791e79445987e448bbfc5ff8a55","modified":1617782521691},{"_id":"public/categories/大前端/前端/js/index.html","hash":"e136b2d67860ac64c8ed81cdb3500bb1160d1726","modified":1617782521691},{"_id":"public/categories/前端/react/index.html","hash":"70d2cdeccc5c2a81b0ac730cd8c493f82b41eda4","modified":1617782521691},{"_id":"public/categories/前端/h5/index.html","hash":"e1bdce2b819d35a72925d36ba889d2898a3bb463","modified":1617782521691},{"_id":"public/categories/前端/vue/index.html","hash":"803884c4bb90bb61ea70b63bf92ac30108aec67c","modified":1617782521691},{"_id":"public/categories/前端/ts/index.html","hash":"8ee65590728b38a67a604ddb2326f515da0b6daa","modified":1617782521691},{"_id":"public/tags/react/index.html","hash":"7cdb60521e6ae040f6ceca39f1d56e37374d2235","modified":1617782521691},{"_id":"public/tags/二进制/index.html","hash":"0e64b31cdaa231ed60b2c3a2fcc5cc449446fb6b","modified":1617782521691},{"_id":"public/tags/使用技巧/index.html","hash":"229b0937ae258f7d8a4397eb6e34c8f43135ed20","modified":1617782521691},{"_id":"public/tags/自动化测试/index.html","hash":"64f0320a86dc5fb975d576534c594e90400d4106","modified":1617782521691},{"_id":"public/tags/解决方案/index.html","hash":"2f8434b391783bf02981c35e9f646c38e8fc55ca","modified":1617782521691},{"_id":"public/tags/ajax/index.html","hash":"f8eb264969b3867dbb7e93759a550119b5d1a9a9","modified":1617782521691},{"_id":"public/tags/fetch/index.html","hash":"e7a2c2392016988a3fb410c2a11dc8c696b7bc74","modified":1617782521691},{"_id":"public/tags/react-hooks/index.html","hash":"bed879dd1fdadb8dbad6057fe0cc46cd25a29186","modified":1617782521691},{"_id":"public/tags/数据驱动/index.html","hash":"63751a0b556c002dfc8afa1e46d865f290936218","modified":1617782521691},{"_id":"public/tags/文档/index.html","hash":"4912605be27c6132c43a5c08714a3300bc51685c","modified":1617782521691},{"_id":"public/tags/虚拟-dom/index.html","hash":"e6fc0eda646ed93e1e8e3df787e1143651d53e54","modified":1617782521691},{"_id":"public/tags/diff-算法/index.html","hash":"0a87ce7538d49f9f372822a9f5ecf9bab339e7dc","modified":1617782521691},{"_id":"public/tags/pwa/index.html","hash":"7ab8fa67932745d03fa40043b45e9c813a111b2f","modified":1617782521691},{"_id":"public/tags/hybrid/index.html","hash":"8138c5b8f27398fbca262cfc79ea20865ca42a18","modified":1617782521691},{"_id":"public/tags/index.html","hash":"86d2811d5456a838a6f841c0812529c692769cdb","modified":1617782521691},{"_id":"public/categories/index.html","hash":"375325dc2ee71ff86a47f3c39b6555efcbf60932","modified":1617782521691},{"_id":"public/2021/04/06/大前端/chrome 调试小技巧/index.html","hash":"761cdef392d937fe8c80610ee64ca6ff91425cbc","modified":1617782521691},{"_id":"public/2021/03/01/前端/编写 React 组件时常见的 5 个错误/index.html","hash":"c329872fbd7e78c3f28bddca128833729393592b","modified":1617782521691},{"_id":"public/2020/11/20/前端/从图片裁剪了解 js 二进制常用 api/index.html","hash":"22696e70c238c88003a2c3c94068f503c4d36e4c","modified":1617782521691},{"_id":"public/2020/10/17/前端/防抖和节流/index.html","hash":"4466907af74b568c8a1b0f1bda84255d7590ee4c","modified":1617782521691},{"_id":"public/2020/10/15/前端/Chrome 调试技巧/index.html","hash":"02fd4529c6b648e0425d6a24bc5ac960266e3f64","modified":1617782521691},{"_id":"public/2020/09/10/前端/TypeScript 文档/index.html","hash":"8261ab69bad3a817c96a11df2d76d4702e120296","modified":1617782521691},{"_id":"public/2020/08/16/前端/React Hooks 的一些特性/index.html","hash":"4ea685e45e59cfdd1c2ac0bfb646d5f481bb62eb","modified":1617782521691},{"_id":"public/2020/08/15/前端/React16 文档/index.html","hash":"0b50dfce864cdb410164e6054a7f68963bc0a99a","modified":1617782521691},{"_id":"public/2020/07/20/前端/Vue2 diff 算法/index.html","hash":"adf761c0eb7c8589fe02620cf1c694d93d4b6047","modified":1617782521691},{"_id":"public/2020/07/19/前端/H5 相关问题收集/index.html","hash":"ca4887bd9f5db8a559b1caf3c56109e1e9c07bc5","modified":1617782521691},{"_id":"public/2020/07/18/前端/Vue2 虚拟 dom/index.html","hash":"0674fcaef4c697a20f8c05167dc79b21bc15ac95","modified":1617782521691},{"_id":"public/2020/07/15/前端/Vue2 文档/index.html","hash":"2735e6d52bfca50323fd0d21a44c3d9d87ae1113","modified":1617782521691},{"_id":"public/2020/02/17/前端/前端自动化测试/index.html","hash":"abdab86c14d3570b2915d09db4cd7229849f71a3","modified":1617782521691},{"_id":"public/archives/index.html","hash":"e825a4c702f3df008dc583349bec4188463ddc8e","modified":1617782521691},{"_id":"public/archives/page/2/index.html","hash":"e2362640d76c65406388b92b2c2b145c2914331b","modified":1617782521691},{"_id":"public/archives/2020/index.html","hash":"8fe48a983d36bf9e560dc06050333f078189f938","modified":1617782521691},{"_id":"public/archives/2020/page/2/index.html","hash":"43c1292efab05aa7877a21664e8c66724fec9fef","modified":1617782521691},{"_id":"public/archives/2020/02/index.html","hash":"ecce8a26973ca6df8ad066d471519f719c5ed39d","modified":1617782521691},{"_id":"public/archives/2020/07/index.html","hash":"9734617fbeabf9bd954fe4520a31d6390ae20750","modified":1617782521691},{"_id":"public/archives/2020/08/index.html","hash":"8a4e1a94f5c3f73ac642488170556087a831fd3d","modified":1617782521691},{"_id":"public/archives/2020/09/index.html","hash":"52b22f16cac8ce6de2d0b2dad6fe417ffb131604","modified":1617782521691},{"_id":"public/archives/2020/10/index.html","hash":"3636a3287b41fb88a673c23be955fcb3380659da","modified":1617782521691},{"_id":"public/archives/2020/11/index.html","hash":"2bcb95696e41ca5e02c093e0359d65a58f5961f4","modified":1617782521691},{"_id":"public/archives/2021/index.html","hash":"25c8c9cb5a41c953ca45eb7f5ce0863d72eebcd3","modified":1617782521691},{"_id":"public/archives/2021/03/index.html","hash":"4df2b139fa52a1abcbf415f87a42a6f8e47fcb66","modified":1617782521691},{"_id":"public/archives/2021/04/index.html","hash":"4eb7586b237dff3efa5793d0c7e8dd7856b1a535","modified":1617782521691},{"_id":"public/categories/前端/index.html","hash":"b6507f57f1daa3bf161258176e8711451ba8cc4f","modified":1617782521691},{"_id":"public/categories/前端/page/2/index.html","hash":"d46b4d3d1961c7924d637f4e12e293d8f088de73","modified":1617782521691},{"_id":"public/categories/前端/js/index.html","hash":"03583abae51030cd3a1cfefff2d176f81927f309","modified":1617782521691},{"_id":"public/index.html","hash":"3f1a1a698eb7491cb3cf8247dc1128a16291cd65","modified":1617782521691},{"_id":"public/page/2/index.html","hash":"c76a9de28f9c44a6be7836fafb4b044c81e2b7dd","modified":1617782521691},{"_id":"public/js/main.js","hash":"a9f17a43d63c00994a40b156a5fb45e89dd5b272","modified":1617782521691},{"_id":"public/js/plugins/friends.js","hash":"9815baf1e18d7cc2c8cb0623ce032a584cb2d40a","modified":1617782521691},{"_id":"public/js/plugins/sites.js","hash":"dff454cd2bc34b718692dc4e941976311c73f670","modified":1617782521691},{"_id":"public/css/main.css","hash":"b0e1d0a6610fe2a2525ddb1d87c0524a1bc5b6e6","modified":1617782521691}],"Category":[{"name":"大前端","_id":"ckn724nl000024d7y3eu5gt0i"},{"name":"javascript","parent":"ckn724nl000024d7y3eu5gt0i","_id":"ckn73cy0z000o4f7yg2dt947h"},{"name":"使用技巧","parent":"ckn724nl000024d7y3eu5gt0i","_id":"ckn73ey0r000r4f7ybtxc3k7n"},{"name":"前端","parent":"ckn724nl000024d7y3eu5gt0i","_id":"ckn73g6cm000v4f7y0pks8fht"},{"name":"js","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73gnhk000x4f7y1wry0ks4"},{"name":"react","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73grzz00104f7y9x6ogo1d"},{"name":"二进制","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73gvv400124f7ybheh9nsv"},{"name":"使用技巧","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73hddp00154f7y8uknga3u"},{"name":"自动化测试","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73hseb00184f7y84nv0xu5"},{"name":"解决方案","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73jbgh001j4f7yeeo93fgh"},{"name":"h5","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73motu001z4f7y8qsfb5n4"},{"name":"vue","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73paob002a4f7ybpnebfei"},{"name":"typescript","parent":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73sgs7002v4f7y386idm2r"},{"name":"前端","_id":"ckn73y16y00002b7yhsgu5ukt"},{"name":"react","parent":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn73y16z00012b7y8cj11ow7"},{"name":"js","parent":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn73yagp00222b7yftoc34u4"},{"name":"h5","parent":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn73yq2u002d2b7y8v6r4oxf"},{"name":"typescript","parent":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn73z6fa002k2b7y2yj1b6rf"},{"name":"vue","parent":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn73z9ui002n2b7yduwfbvhf"},{"name":"javascript","parent":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn745toq0000yx7y2d9704vp"},{"name":"jjavascripts","parent":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7463j00005yx7y933s9lnd"},{"name":"ts","parent":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn747lph003jyx7ya58sbihb"}],"Data":[],"Page":[],"Post":[{"title":"前端自动化测试","date":"2021-04-05T16:00:00.000Z","_content":"\n在前端大型项目开发的过程中，自动化测试都是不可缺少的一环。自动化测试不但可以降低 bug 出现的频率，也可让项目更加健壮\n\n<!-- more -->\n\n> 官方文档: [https://developers.google.com/](https://developers.google.com/)\n\n> 隆重感谢: [掘金小册-你不知道的 Chrome 调试技巧](https://juejin.cn/book/6844733783166418958)\n\n### 1、快速打印想要的 dom 元素\n\n- 控制台输入 `$0`  即可打印出当前指针所选中的元素\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273)\n\n### 2、如何给 Dom 元素打断点\n\n- 鼠标右键选中元素，选中 `Break on`。\n- `subtree modifications` 监听任何它内部的节点被 `移除` 或者 `添加`的事件\n- `Break > attribute modifications`  监听任何当前选中的节点被 `添加`，`移除` 或者 `被修改值`的事件。此时属性被修改后将会产生断点调试。\n- `Break > node removal`  监听被选中的元素被 `移除` 的事件。此时属性被删除后将会产生断点调试。\n\n### 3、debug 函数\n\n- 可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435)\n\n### 4、console.log 添加样式\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654)\n\n### 5、发现问题并定位代码的内存泄漏\n\n- 选中 `Memory > Heap snapshot`  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。\n- 选中垃圾回收按钮右侧下拉菜单里的 `Comparison` ，即可将选中的快照与它上一次快照进行对比。如 `delta`  的数据对比，从而快速定位到问题出现的位置。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919)\n\n### 6、$ 快速选中元素\n\n- Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567)\n\n### 7、使用 chrome 调试 node.js 程序\n\n- `node --inspect-brk 文件名`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868)\n\n### 8、点击一个元素，获取下面所有代码执行过程\n\n- 方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 `debug`，确定执行过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623)\n\n- 方案 2: 找到当前点击所造成的影响（如：删除元素， `XHR`）等，通过点击 `Break > node removal` 等操作，在造成影响的位置下断点，通过查看 `call stack` 查看执行过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938)\n\n- 方案 3: 使用 `getEventListeners` 获取 `Dom` 元素上绑定的事件。(注意：此方法只能在 `Chrome` 控制台使用)\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740)\n\n### 9、如何使用 Chrome 调试 Webpack 程序\n\n1. 在想要调试的代码为止使用 debugger 打断点\n1. 定位 webpack-dev-server 的命令文件\n1. 使用 node --inspect-brk 打开调试服务\n1. 打开 chrome devtool 进行调试\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101)\n\n### 10、使用错误断点，让程序在错误处暂停\n\n- 方案 1: 在控制面板里直接点击错误信息\n- 方案 2: 点击 `Sources`  后点击 `Pause on exceptions`  最后勾选 `Pause on exceptions`。之后刷新页面即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901)\n\n### 11、使用 Chrome 作为代码编辑工具\n\n- 选中 `Sources > Filesystem`  然后关联本地文件夹即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067)\n\n### 12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码\n\n- 选中 `Sources > Snippets`  创建新的代码片段\n- 输入 `Command + p`  后输入 `i`  后执行\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845)\n\n### 13、使用 Chome 实时保存更改的 css 样式\n\n- 选中 `Source > Overrides` ，之后点击 `+`  选择一个本地文件夹用来保存更改后的样式，最后勾选 `Enable Local Overrides` 。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831)\n\n### 14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比\n\n- 输入 `Command + shift + p` ，搜索 `show changes`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928)\n\n### 15、查看 Chrome 请求是由谁发起的\n\n- 选择 `NetWork > Initialtor` ，不但可以查看调用位置，也可获取触发位置。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744)\n\n### 16、Chrome 性能监测工具\n\n- `Command + shift + p`  输入 `show performance monitor`  即可实时查看程序运行的性能。\n  - `CPU usage` ： `cpu` 的监听\n  - `JS heap size` : 内存占用监听，如添加到 `window`  对象上的事件不回收会造成内存溢出。\n  - `DOM Nodes`: 内存中所分配的 `dom` 节点的个数\n  - `JS envnt listeners`: `js` 中已经绑定的事件个数\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919)\n\n### 17、使用 Chrome 做性能调优，迅速定位问题\n\n- 选择 `performance`  点击录制按钮，可以查看从录制开始到停止时间内 `js` 代码运行的情况。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919)\n\n### 18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率\n\n- `Command + shift + p`  输入 `show animations`  打开动画的调试器。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919)\n\n### 19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况\n\n- `Command + shift +p`  输入 `show coverage`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893)\n\n### 20、copy() 复制控制台内容\n\n- 可以通过全局的方法  `copy()`  在  `console`  里  `copy`  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  `copy($_)`  或  `copy($0)`\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332)\n\n### 21、$\\_查看上一次程序执行结果\n\n- `$_`  是对上次执行的结果的 **引用**\n\n\\*\\*\n**![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507)**\n\n### 22、$i 配合 chrome 插件引入第三方包\n\n- 有时你只是想玩玩新出的 `npm` 包，现在不用再大费周章去建一个项目测试了，只需要在 [Chrome 插件:Console Importer](https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related) 的帮助之下，快速的在 `console` 中引入和测试一些 `npm` 库。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332)\n\n### 23、使用实时表达式\n\n- `DevTools` 在 `Console` 面板中引入了一个非常漂亮的附加功能，这是一个名为 `Live expression` 的工具。只需按下 \"眼睛\" 符号，你就可以在那里定义任何 `JavaScript` 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102)\n\n### 24、通过 'h' 来隐藏元素\n\n- 按一下  `'h'`  就可以隐藏你在元素面板中选择的元素。再次按下 '`h`' 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332)\n\n### 25、拖动 & 放置 元素\n\n- 当你想看看页面的某一部分在  `DOM`  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)\n\n![2.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066)\n\n### 26、使用 `control` (按钮) 来移动元素!\n\n- 如果你只是想移动你当前选中的元素，在  `DOM`  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用`[ctrl]` + `[⬆]` / `[ctrl]` + `[⬇]` (`[⌘]` + `[⬆]` / `[⌘]` + `[⬇]` on Mac).\n\n![3.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332)\n\n### 27、元素面板中类似于基础编辑器的操作\n\n- 从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 `[ctrl]` + `[v]` 来粘贴)， 所以我们可以在元素面板里把 `HTML` 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？\n\n- 使用`[ctrl]` + `[z]` (`[⌘]` + `[z]` on Mac)撤销我们的任何改动。 使用 `[ctrl]` + `[shift]` + `[z]`重新编辑我们的任何修改。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066)\n\n### 28、`Shadow editor` 阴影编辑器\n\n- 你可以通过在  `Style`  面板中点击靠近  `box-shadow`  属性或者  `text-shadow`  属性的  `阴影方形符号`  来打开它：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576)\n\n### 29、Timing function editor 定时函数编辑器\n\n- 也称为 `Cubic bezier(贝塞尔)` 编辑器。贝塞尔曲线是一串用来定义 `CSS` 的动画速度在整个动画过程中如何变化的 `魔法数值` 。我们将其定义为 `transition-timing-function` 或者 `animation-timing-function` CSS 属性。\n\n- 像之前说的 `Color picker` 和 `Shadow editor` 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：`trasition`， `animation` - 请注意：如果`timing` 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474)\n\n### 30、插入样式规则的按钮\n\n当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 `Color` 和 `Shadow` 编辑器添加 `CSS` 属性的按钮：\n\n- `text-shadow`\n\n- `box-shadow`\n\n- `color`\n\n- `background-color`\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632)\n\n### 31、在元素面板中展开所有的子节点\n\n- 一个一个的去点击级联的  `▶`  按钮太慢了，不如使用右击节点后的  `expand recursively`  命令：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760)\n\n### 32、控制传感器\n\n- 如果你正在你的应用中使用一些获取位置信息的 `API` 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。\n\n- `Drawer` 里的 `Sensors(传感器)` 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 `navigator.geolocation.watchPosition`（或 `.getCurrentPosition` ）报告。\n\n- 如果你的 `App` 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774)\n","source":"_posts/大前端/chrome 调试小技巧.md","raw":"---\ntitle: 前端自动化测试\ndate: 2021-04-06\ncategories: [大前端, 前端, js]\ntags: \n  - 使用技巧\n---\n\n在前端大型项目开发的过程中，自动化测试都是不可缺少的一环。自动化测试不但可以降低 bug 出现的频率，也可让项目更加健壮\n\n<!-- more -->\n\n> 官方文档: [https://developers.google.com/](https://developers.google.com/)\n\n> 隆重感谢: [掘金小册-你不知道的 Chrome 调试技巧](https://juejin.cn/book/6844733783166418958)\n\n### 1、快速打印想要的 dom 元素\n\n- 控制台输入 `$0`  即可打印出当前指针所选中的元素\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273)\n\n### 2、如何给 Dom 元素打断点\n\n- 鼠标右键选中元素，选中 `Break on`。\n- `subtree modifications` 监听任何它内部的节点被 `移除` 或者 `添加`的事件\n- `Break > attribute modifications`  监听任何当前选中的节点被 `添加`，`移除` 或者 `被修改值`的事件。此时属性被修改后将会产生断点调试。\n- `Break > node removal`  监听被选中的元素被 `移除` 的事件。此时属性被删除后将会产生断点调试。\n\n### 3、debug 函数\n\n- 可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435)\n\n### 4、console.log 添加样式\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654)\n\n### 5、发现问题并定位代码的内存泄漏\n\n- 选中 `Memory > Heap snapshot`  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。\n- 选中垃圾回收按钮右侧下拉菜单里的 `Comparison` ，即可将选中的快照与它上一次快照进行对比。如 `delta`  的数据对比，从而快速定位到问题出现的位置。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919)\n\n### 6、$ 快速选中元素\n\n- Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567)\n\n### 7、使用 chrome 调试 node.js 程序\n\n- `node --inspect-brk 文件名`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868)\n\n### 8、点击一个元素，获取下面所有代码执行过程\n\n- 方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 `debug`，确定执行过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623)\n\n- 方案 2: 找到当前点击所造成的影响（如：删除元素， `XHR`）等，通过点击 `Break > node removal` 等操作，在造成影响的位置下断点，通过查看 `call stack` 查看执行过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938)\n\n- 方案 3: 使用 `getEventListeners` 获取 `Dom` 元素上绑定的事件。(注意：此方法只能在 `Chrome` 控制台使用)\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740)\n\n### 9、如何使用 Chrome 调试 Webpack 程序\n\n1. 在想要调试的代码为止使用 debugger 打断点\n1. 定位 webpack-dev-server 的命令文件\n1. 使用 node --inspect-brk 打开调试服务\n1. 打开 chrome devtool 进行调试\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101)\n\n### 10、使用错误断点，让程序在错误处暂停\n\n- 方案 1: 在控制面板里直接点击错误信息\n- 方案 2: 点击 `Sources`  后点击 `Pause on exceptions`  最后勾选 `Pause on exceptions`。之后刷新页面即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901)\n\n### 11、使用 Chrome 作为代码编辑工具\n\n- 选中 `Sources > Filesystem`  然后关联本地文件夹即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067)\n\n### 12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码\n\n- 选中 `Sources > Snippets`  创建新的代码片段\n- 输入 `Command + p`  后输入 `i`  后执行\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845)\n\n### 13、使用 Chome 实时保存更改的 css 样式\n\n- 选中 `Source > Overrides` ，之后点击 `+`  选择一个本地文件夹用来保存更改后的样式，最后勾选 `Enable Local Overrides` 。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831)\n\n### 14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比\n\n- 输入 `Command + shift + p` ，搜索 `show changes`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928)\n\n### 15、查看 Chrome 请求是由谁发起的\n\n- 选择 `NetWork > Initialtor` ，不但可以查看调用位置，也可获取触发位置。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744)\n\n### 16、Chrome 性能监测工具\n\n- `Command + shift + p`  输入 `show performance monitor`  即可实时查看程序运行的性能。\n  - `CPU usage` ： `cpu` 的监听\n  - `JS heap size` : 内存占用监听，如添加到 `window`  对象上的事件不回收会造成内存溢出。\n  - `DOM Nodes`: 内存中所分配的 `dom` 节点的个数\n  - `JS envnt listeners`: `js` 中已经绑定的事件个数\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919)\n\n### 17、使用 Chrome 做性能调优，迅速定位问题\n\n- 选择 `performance`  点击录制按钮，可以查看从录制开始到停止时间内 `js` 代码运行的情况。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919)\n\n### 18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率\n\n- `Command + shift + p`  输入 `show animations`  打开动画的调试器。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919)\n\n### 19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况\n\n- `Command + shift +p`  输入 `show coverage`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893)\n\n### 20、copy() 复制控制台内容\n\n- 可以通过全局的方法  `copy()`  在  `console`  里  `copy`  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  `copy($_)`  或  `copy($0)`\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332)\n\n### 21、$\\_查看上一次程序执行结果\n\n- `$_`  是对上次执行的结果的 **引用**\n\n\\*\\*\n**![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507)**\n\n### 22、$i 配合 chrome 插件引入第三方包\n\n- 有时你只是想玩玩新出的 `npm` 包，现在不用再大费周章去建一个项目测试了，只需要在 [Chrome 插件:Console Importer](https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related) 的帮助之下，快速的在 `console` 中引入和测试一些 `npm` 库。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332)\n\n### 23、使用实时表达式\n\n- `DevTools` 在 `Console` 面板中引入了一个非常漂亮的附加功能，这是一个名为 `Live expression` 的工具。只需按下 \"眼睛\" 符号，你就可以在那里定义任何 `JavaScript` 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102)\n\n### 24、通过 'h' 来隐藏元素\n\n- 按一下  `'h'`  就可以隐藏你在元素面板中选择的元素。再次按下 '`h`' 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332)\n\n### 25、拖动 & 放置 元素\n\n- 当你想看看页面的某一部分在  `DOM`  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)\n\n![2.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066)\n\n### 26、使用 `control` (按钮) 来移动元素!\n\n- 如果你只是想移动你当前选中的元素，在  `DOM`  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用`[ctrl]` + `[⬆]` / `[ctrl]` + `[⬇]` (`[⌘]` + `[⬆]` / `[⌘]` + `[⬇]` on Mac).\n\n![3.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332)\n\n### 27、元素面板中类似于基础编辑器的操作\n\n- 从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 `[ctrl]` + `[v]` 来粘贴)， 所以我们可以在元素面板里把 `HTML` 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？\n\n- 使用`[ctrl]` + `[z]` (`[⌘]` + `[z]` on Mac)撤销我们的任何改动。 使用 `[ctrl]` + `[shift]` + `[z]`重新编辑我们的任何修改。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066)\n\n### 28、`Shadow editor` 阴影编辑器\n\n- 你可以通过在  `Style`  面板中点击靠近  `box-shadow`  属性或者  `text-shadow`  属性的  `阴影方形符号`  来打开它：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576)\n\n### 29、Timing function editor 定时函数编辑器\n\n- 也称为 `Cubic bezier(贝塞尔)` 编辑器。贝塞尔曲线是一串用来定义 `CSS` 的动画速度在整个动画过程中如何变化的 `魔法数值` 。我们将其定义为 `transition-timing-function` 或者 `animation-timing-function` CSS 属性。\n\n- 像之前说的 `Color picker` 和 `Shadow editor` 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：`trasition`， `animation` - 请注意：如果`timing` 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474)\n\n### 30、插入样式规则的按钮\n\n当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 `Color` 和 `Shadow` 编辑器添加 `CSS` 属性的按钮：\n\n- `text-shadow`\n\n- `box-shadow`\n\n- `color`\n\n- `background-color`\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632)\n\n### 31、在元素面板中展开所有的子节点\n\n- 一个一个的去点击级联的  `▶`  按钮太慢了，不如使用右击节点后的  `expand recursively`  命令：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760)\n\n### 32、控制传感器\n\n- 如果你正在你的应用中使用一些获取位置信息的 `API` 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。\n\n- `Drawer` 里的 `Sensors(传感器)` 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 `navigator.geolocation.watchPosition`（或 `.getCurrentPosition` ）报告。\n\n- 如果你的 `App` 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774)\n","slug":"大前端/chrome 调试小技巧","published":1,"updated":"2021-04-07T07:03:58.165Z","_id":"ckn72xyzx00014f7ybq9j8n0k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在前端大型项目开发的过程中，自动化测试都是不可缺少的一环。自动化测试不但可以降低 bug 出现的频率，也可让项目更加健壮</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>官方文档: <a href=\"https://developers.google.com/\">https://developers.google.com/</a></p>\n</blockquote>\n<blockquote>\n<p>隆重感谢: <a href=\"https://juejin.cn/book/6844733783166418958\">掘金小册-你不知道的 Chrome 调试技巧</a></p>\n</blockquote>\n<h3 id=\"1、快速打印想要的-dom-元素\"><a href=\"#1、快速打印想要的-dom-元素\" class=\"headerlink\" title=\"1、快速打印想要的 dom 元素\"></a>1、快速打印想要的 dom 元素</h3><ul>\n<li>控制台输入 <code>$0</code>  即可打印出当前指针所选中的元素</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273\" alt=\"image.png\"></p>\n<h3 id=\"2、如何给-Dom-元素打断点\"><a href=\"#2、如何给-Dom-元素打断点\" class=\"headerlink\" title=\"2、如何给 Dom 元素打断点\"></a>2、如何给 Dom 元素打断点</h3><ul>\n<li>鼠标右键选中元素，选中 <code>Break on</code>。</li>\n<li><code>subtree modifications</code> 监听任何它内部的节点被 <code>移除</code> 或者 <code>添加</code>的事件</li>\n<li><code>Break &gt; attribute modifications</code>  监听任何当前选中的节点被 <code>添加</code>，<code>移除</code> 或者 <code>被修改值</code>的事件。此时属性被修改后将会产生断点调试。</li>\n<li><code>Break &gt; node removal</code>  监听被选中的元素被 <code>移除</code> 的事件。此时属性被删除后将会产生断点调试。</li>\n</ul>\n<h3 id=\"3、debug-函数\"><a href=\"#3、debug-函数\" class=\"headerlink\" title=\"3、debug 函数\"></a>3、debug 函数</h3><ul>\n<li>可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435\" alt=\"image.png\"></p>\n<h3 id=\"4、console-log-添加样式\"><a href=\"#4、console-log-添加样式\" class=\"headerlink\" title=\"4、console.log 添加样式\"></a>4、console.log 添加样式</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654\" alt=\"image.png\"></p>\n<h3 id=\"5、发现问题并定位代码的内存泄漏\"><a href=\"#5、发现问题并定位代码的内存泄漏\" class=\"headerlink\" title=\"5、发现问题并定位代码的内存泄漏\"></a>5、发现问题并定位代码的内存泄漏</h3><ul>\n<li>选中 <code>Memory &gt; Heap snapshot</code>  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。</li>\n<li>选中垃圾回收按钮右侧下拉菜单里的 <code>Comparison</code> ，即可将选中的快照与它上一次快照进行对比。如 <code>delta</code>  的数据对比，从而快速定位到问题出现的位置。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"6、-快速选中元素\"><a href=\"#6、-快速选中元素\" class=\"headerlink\" title=\"6、$ 快速选中元素\"></a>6、$ 快速选中元素</h3><ul>\n<li>Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567\" alt=\"image.png\"></p>\n<h3 id=\"7、使用-chrome-调试-node-js-程序\"><a href=\"#7、使用-chrome-调试-node-js-程序\" class=\"headerlink\" title=\"7、使用 chrome 调试 node.js 程序\"></a>7、使用 chrome 调试 node.js 程序</h3><ul>\n<li><code>node --inspect-brk 文件名</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868\" alt=\"image.png\"></p>\n<h3 id=\"8、点击一个元素，获取下面所有代码执行过程\"><a href=\"#8、点击一个元素，获取下面所有代码执行过程\" class=\"headerlink\" title=\"8、点击一个元素，获取下面所有代码执行过程\"></a>8、点击一个元素，获取下面所有代码执行过程</h3><ul>\n<li>方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 <code>debug</code>，确定执行过程。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623\" alt=\"image.png\"></p>\n<ul>\n<li>方案 2: 找到当前点击所造成的影响（如：删除元素， <code>XHR</code>）等，通过点击 <code>Break &gt; node removal</code> 等操作，在造成影响的位置下断点，通过查看 <code>call stack</code> 查看执行过程。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938\" alt=\"image.png\"></p>\n<ul>\n<li>方案 3: 使用 <code>getEventListeners</code> 获取 <code>Dom</code> 元素上绑定的事件。(注意：此方法只能在 <code>Chrome</code> 控制台使用)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740\" alt=\"image.png\"></p>\n<h3 id=\"9、如何使用-Chrome-调试-Webpack-程序\"><a href=\"#9、如何使用-Chrome-调试-Webpack-程序\" class=\"headerlink\" title=\"9、如何使用 Chrome 调试 Webpack 程序\"></a>9、如何使用 Chrome 调试 Webpack 程序</h3><ol>\n<li>在想要调试的代码为止使用 debugger 打断点</li>\n<li>定位 webpack-dev-server 的命令文件</li>\n<li>使用 node –inspect-brk 打开调试服务</li>\n<li>打开 chrome devtool 进行调试</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101\" alt=\"image.png\"></p>\n<h3 id=\"10、使用错误断点，让程序在错误处暂停\"><a href=\"#10、使用错误断点，让程序在错误处暂停\" class=\"headerlink\" title=\"10、使用错误断点，让程序在错误处暂停\"></a>10、使用错误断点，让程序在错误处暂停</h3><ul>\n<li>方案 1: 在控制面板里直接点击错误信息</li>\n<li>方案 2: 点击 <code>Sources</code>  后点击 <code>Pause on exceptions</code>  最后勾选 <code>Pause on exceptions</code>。之后刷新页面即可</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901\" alt=\"image.png\"></p>\n<h3 id=\"11、使用-Chrome-作为代码编辑工具\"><a href=\"#11、使用-Chrome-作为代码编辑工具\" class=\"headerlink\" title=\"11、使用 Chrome 作为代码编辑工具\"></a>11、使用 Chrome 作为代码编辑工具</h3><ul>\n<li>选中 <code>Sources &gt; Filesystem</code>  然后关联本地文件夹即可</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067\" alt=\"image.png\"></p>\n<h3 id=\"12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码\"><a href=\"#12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码\" class=\"headerlink\" title=\"12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码\"></a>12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码</h3><ul>\n<li>选中 <code>Sources &gt; Snippets</code>  创建新的代码片段</li>\n<li>输入 <code>Command + p</code>  后输入 <code>i</code>  后执行</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845\" alt=\"image.png\"></p>\n<h3 id=\"13、使用-Chome-实时保存更改的-css-样式\"><a href=\"#13、使用-Chome-实时保存更改的-css-样式\" class=\"headerlink\" title=\"13、使用 Chome 实时保存更改的 css 样式\"></a>13、使用 Chome 实时保存更改的 css 样式</h3><ul>\n<li>选中 <code>Source &gt; Overrides</code> ，之后点击 <code>+</code>  选择一个本地文件夹用来保存更改后的样式，最后勾选 <code>Enable Local Overrides</code> 。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831\" alt=\"image.png\"></p>\n<h3 id=\"14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比\"><a href=\"#14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比\" class=\"headerlink\" title=\"14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比\"></a>14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比</h3><ul>\n<li>输入 <code>Command + shift + p</code> ，搜索 <code>show changes</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928\" alt=\"image.png\"></p>\n<h3 id=\"15、查看-Chrome-请求是由谁发起的\"><a href=\"#15、查看-Chrome-请求是由谁发起的\" class=\"headerlink\" title=\"15、查看 Chrome 请求是由谁发起的\"></a>15、查看 Chrome 请求是由谁发起的</h3><ul>\n<li>选择 <code>NetWork &gt; Initialtor</code> ，不但可以查看调用位置，也可获取触发位置。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744\" alt=\"image.png\"></p>\n<h3 id=\"16、Chrome-性能监测工具\"><a href=\"#16、Chrome-性能监测工具\" class=\"headerlink\" title=\"16、Chrome 性能监测工具\"></a>16、Chrome 性能监测工具</h3><ul>\n<li><code>Command + shift + p</code>  输入 <code>show performance monitor</code>  即可实时查看程序运行的性能。<ul>\n<li><code>CPU usage</code> ： <code>cpu</code> 的监听</li>\n<li><code>JS heap size</code> : 内存占用监听，如添加到 <code>window</code>  对象上的事件不回收会造成内存溢出。</li>\n<li><code>DOM Nodes</code>: 内存中所分配的 <code>dom</code> 节点的个数</li>\n<li><code>JS envnt listeners</code>: <code>js</code> 中已经绑定的事件个数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"17、使用-Chrome-做性能调优，迅速定位问题\"><a href=\"#17、使用-Chrome-做性能调优，迅速定位问题\" class=\"headerlink\" title=\"17、使用 Chrome 做性能调优，迅速定位问题\"></a>17、使用 Chrome 做性能调优，迅速定位问题</h3><ul>\n<li>选择 <code>performance</code>  点击录制按钮，可以查看从录制开始到停止时间内 <code>js</code> 代码运行的情况。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率\"><a href=\"#18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率\" class=\"headerlink\" title=\"18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率\"></a>18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率</h3><ul>\n<li><code>Command + shift + p</code>  输入 <code>show animations</code>  打开动画的调试器。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况\"><a href=\"#19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况\" class=\"headerlink\" title=\"19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况\"></a>19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况</h3><ul>\n<li><code>Command + shift +p</code>  输入 <code>show coverage</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893\" alt=\"image.png\"></p>\n<h3 id=\"20、copy-复制控制台内容\"><a href=\"#20、copy-复制控制台内容\" class=\"headerlink\" title=\"20、copy() 复制控制台内容\"></a>20、copy() 复制控制台内容</h3><ul>\n<li>可以通过全局的方法  <code>copy()</code>  在  <code>console</code>  里  <code>copy</code>  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  <code>copy($_)</code>  或  <code>copy($0)</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"21、-查看上一次程序执行结果\"><a href=\"#21、-查看上一次程序执行结果\" class=\"headerlink\" title=\"21、$_查看上一次程序执行结果\"></a>21、$_查看上一次程序执行结果</h3><ul>\n<li><code>$_</code>  是对上次执行的结果的 <strong>引用</strong></li>\n</ul>\n<p>**<br><strong><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507\" alt=\"image.png\"></strong></p>\n<h3 id=\"22、-i-配合-chrome-插件引入第三方包\"><a href=\"#22、-i-配合-chrome-插件引入第三方包\" class=\"headerlink\" title=\"22、$i 配合 chrome 插件引入第三方包\"></a>22、$i 配合 chrome 插件引入第三方包</h3><ul>\n<li>有时你只是想玩玩新出的 <code>npm</code> 包，现在不用再大费周章去建一个项目测试了，只需要在 <a href=\"https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related\">Chrome 插件:Console Importer</a> 的帮助之下，快速的在 <code>console</code> 中引入和测试一些 <code>npm</code> 库。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"23、使用实时表达式\"><a href=\"#23、使用实时表达式\" class=\"headerlink\" title=\"23、使用实时表达式\"></a>23、使用实时表达式</h3><ul>\n<li><code>DevTools</code> 在 <code>Console</code> 面板中引入了一个非常漂亮的附加功能，这是一个名为 <code>Live expression</code> 的工具。只需按下 “眼睛” 符号，你就可以在那里定义任何 <code>JavaScript</code> 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102\" alt=\"1.gif\"></p>\n<h3 id=\"24、通过-‘h’-来隐藏元素\"><a href=\"#24、通过-‘h’-来隐藏元素\" class=\"headerlink\" title=\"24、通过 ‘h’ 来隐藏元素\"></a>24、通过 ‘h’ 来隐藏元素</h3><ul>\n<li>按一下  <code>&#39;h&#39;</code>  就可以隐藏你在元素面板中选择的元素。再次按下 ‘<code>h</code>‘ 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"25、拖动-amp-放置-元素\"><a href=\"#25、拖动-amp-放置-元素\" class=\"headerlink\" title=\"25、拖动 &amp; 放置 元素\"></a>25、拖动 &amp; 放置 元素</h3><ul>\n<li>当你想看看页面的某一部分在  <code>DOM</code>  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066\" alt=\"2.gif\"></p>\n<h3 id=\"26、使用-control-按钮-来移动元素\"><a href=\"#26、使用-control-按钮-来移动元素\" class=\"headerlink\" title=\"26、使用 control (按钮) 来移动元素!\"></a>26、使用 <code>control</code> (按钮) 来移动元素!</h3><ul>\n<li>如果你只是想移动你当前选中的元素，在  <code>DOM</code>  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用<code>[ctrl]</code> + <code>[⬆]</code> / <code>[ctrl]</code> + <code>[⬇]</code> (<code>[⌘]</code> + <code>[⬆]</code> / <code>[⌘]</code> + <code>[⬇]</code> on Mac).</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332\" alt=\"3.gif\"></p>\n<h3 id=\"27、元素面板中类似于基础编辑器的操作\"><a href=\"#27、元素面板中类似于基础编辑器的操作\" class=\"headerlink\" title=\"27、元素面板中类似于基础编辑器的操作\"></a>27、元素面板中类似于基础编辑器的操作</h3><ul>\n<li><p>从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 <code>[ctrl]</code> + <code>[v]</code> 来粘贴)， 所以我们可以在元素面板里把 <code>HTML</code> 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？</p>\n</li>\n<li><p>使用<code>[ctrl]</code> + <code>[z]</code> (<code>[⌘]</code> + <code>[z]</code> on Mac)撤销我们的任何改动。 使用 <code>[ctrl]</code> + <code>[shift]</code> + <code>[z]</code>重新编辑我们的任何修改。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066\" alt=\"1.gif\"></p>\n<h3 id=\"28、Shadow-editor-阴影编辑器\"><a href=\"#28、Shadow-editor-阴影编辑器\" class=\"headerlink\" title=\"28、Shadow editor 阴影编辑器\"></a>28、<code>Shadow editor</code> 阴影编辑器</h3><ul>\n<li>你可以通过在  <code>Style</code>  面板中点击靠近  <code>box-shadow</code>  属性或者  <code>text-shadow</code>  属性的  <code>阴影方形符号</code>  来打开它：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576\" alt=\"1.gif\"></p>\n<h3 id=\"29、Timing-function-editor-定时函数编辑器\"><a href=\"#29、Timing-function-editor-定时函数编辑器\" class=\"headerlink\" title=\"29、Timing function editor 定时函数编辑器\"></a>29、Timing function editor 定时函数编辑器</h3><ul>\n<li><p>也称为 <code>Cubic bezier(贝塞尔)</code> 编辑器。贝塞尔曲线是一串用来定义 <code>CSS</code> 的动画速度在整个动画过程中如何变化的 <code>魔法数值</code> 。我们将其定义为 <code>transition-timing-function</code> 或者 <code>animation-timing-function</code> CSS 属性。</p>\n</li>\n<li><p>像之前说的 <code>Color picker</code> 和 <code>Shadow editor</code> 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：<code>trasition</code>， <code>animation</code> - 请注意：如果<code>timing</code> 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474\" alt=\"1.gif\"></p>\n<h3 id=\"30、插入样式规则的按钮\"><a href=\"#30、插入样式规则的按钮\" class=\"headerlink\" title=\"30、插入样式规则的按钮\"></a>30、插入样式规则的按钮</h3><p>当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 <code>Color</code> 和 <code>Shadow</code> 编辑器添加 <code>CSS</code> 属性的按钮：</p>\n<ul>\n<li><p><code>text-shadow</code></p>\n</li>\n<li><p><code>box-shadow</code></p>\n</li>\n<li><p><code>color</code></p>\n</li>\n<li><p><code>background-color</code></p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632\" alt=\"1.gif\"></p>\n<h3 id=\"31、在元素面板中展开所有的子节点\"><a href=\"#31、在元素面板中展开所有的子节点\" class=\"headerlink\" title=\"31、在元素面板中展开所有的子节点\"></a>31、在元素面板中展开所有的子节点</h3><ul>\n<li>一个一个的去点击级联的  <code>▶</code>  按钮太慢了，不如使用右击节点后的  <code>expand recursively</code>  命令：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760\" alt=\"1.gif\"></p>\n<h3 id=\"32、控制传感器\"><a href=\"#32、控制传感器\" class=\"headerlink\" title=\"32、控制传感器\"></a>32、控制传感器</h3><ul>\n<li><p>如果你正在你的应用中使用一些获取位置信息的 <code>API</code> 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。</p>\n</li>\n<li><p><code>Drawer</code> 里的 <code>Sensors(传感器)</code> 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 <code>navigator.geolocation.watchPosition</code>（或 <code>.getCurrentPosition</code> ）报告。</p>\n</li>\n<li><p>如果你的 <code>App</code> 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774\" alt=\"1.gif\"></p>\n","site":{"data":{}},"excerpt":"<p>在前端大型项目开发的过程中，自动化测试都是不可缺少的一环。自动化测试不但可以降低 bug 出现的频率，也可让项目更加健壮</p>","more":"<blockquote>\n<p>官方文档: <a href=\"https://developers.google.com/\">https://developers.google.com/</a></p>\n</blockquote>\n<blockquote>\n<p>隆重感谢: <a href=\"https://juejin.cn/book/6844733783166418958\">掘金小册-你不知道的 Chrome 调试技巧</a></p>\n</blockquote>\n<h3 id=\"1、快速打印想要的-dom-元素\"><a href=\"#1、快速打印想要的-dom-元素\" class=\"headerlink\" title=\"1、快速打印想要的 dom 元素\"></a>1、快速打印想要的 dom 元素</h3><ul>\n<li>控制台输入 <code>$0</code>  即可打印出当前指针所选中的元素</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273\" alt=\"image.png\"></p>\n<h3 id=\"2、如何给-Dom-元素打断点\"><a href=\"#2、如何给-Dom-元素打断点\" class=\"headerlink\" title=\"2、如何给 Dom 元素打断点\"></a>2、如何给 Dom 元素打断点</h3><ul>\n<li>鼠标右键选中元素，选中 <code>Break on</code>。</li>\n<li><code>subtree modifications</code> 监听任何它内部的节点被 <code>移除</code> 或者 <code>添加</code>的事件</li>\n<li><code>Break &gt; attribute modifications</code>  监听任何当前选中的节点被 <code>添加</code>，<code>移除</code> 或者 <code>被修改值</code>的事件。此时属性被修改后将会产生断点调试。</li>\n<li><code>Break &gt; node removal</code>  监听被选中的元素被 <code>移除</code> 的事件。此时属性被删除后将会产生断点调试。</li>\n</ul>\n<h3 id=\"3、debug-函数\"><a href=\"#3、debug-函数\" class=\"headerlink\" title=\"3、debug 函数\"></a>3、debug 函数</h3><ul>\n<li>可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435\" alt=\"image.png\"></p>\n<h3 id=\"4、console-log-添加样式\"><a href=\"#4、console-log-添加样式\" class=\"headerlink\" title=\"4、console.log 添加样式\"></a>4、console.log 添加样式</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654\" alt=\"image.png\"></p>\n<h3 id=\"5、发现问题并定位代码的内存泄漏\"><a href=\"#5、发现问题并定位代码的内存泄漏\" class=\"headerlink\" title=\"5、发现问题并定位代码的内存泄漏\"></a>5、发现问题并定位代码的内存泄漏</h3><ul>\n<li>选中 <code>Memory &gt; Heap snapshot</code>  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。</li>\n<li>选中垃圾回收按钮右侧下拉菜单里的 <code>Comparison</code> ，即可将选中的快照与它上一次快照进行对比。如 <code>delta</code>  的数据对比，从而快速定位到问题出现的位置。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"6、-快速选中元素\"><a href=\"#6、-快速选中元素\" class=\"headerlink\" title=\"6、$ 快速选中元素\"></a>6、$ 快速选中元素</h3><ul>\n<li>Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567\" alt=\"image.png\"></p>\n<h3 id=\"7、使用-chrome-调试-node-js-程序\"><a href=\"#7、使用-chrome-调试-node-js-程序\" class=\"headerlink\" title=\"7、使用 chrome 调试 node.js 程序\"></a>7、使用 chrome 调试 node.js 程序</h3><ul>\n<li><code>node --inspect-brk 文件名</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868\" alt=\"image.png\"></p>\n<h3 id=\"8、点击一个元素，获取下面所有代码执行过程\"><a href=\"#8、点击一个元素，获取下面所有代码执行过程\" class=\"headerlink\" title=\"8、点击一个元素，获取下面所有代码执行过程\"></a>8、点击一个元素，获取下面所有代码执行过程</h3><ul>\n<li>方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 <code>debug</code>，确定执行过程。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623\" alt=\"image.png\"></p>\n<ul>\n<li>方案 2: 找到当前点击所造成的影响（如：删除元素， <code>XHR</code>）等，通过点击 <code>Break &gt; node removal</code> 等操作，在造成影响的位置下断点，通过查看 <code>call stack</code> 查看执行过程。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938\" alt=\"image.png\"></p>\n<ul>\n<li>方案 3: 使用 <code>getEventListeners</code> 获取 <code>Dom</code> 元素上绑定的事件。(注意：此方法只能在 <code>Chrome</code> 控制台使用)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740\" alt=\"image.png\"></p>\n<h3 id=\"9、如何使用-Chrome-调试-Webpack-程序\"><a href=\"#9、如何使用-Chrome-调试-Webpack-程序\" class=\"headerlink\" title=\"9、如何使用 Chrome 调试 Webpack 程序\"></a>9、如何使用 Chrome 调试 Webpack 程序</h3><ol>\n<li>在想要调试的代码为止使用 debugger 打断点</li>\n<li>定位 webpack-dev-server 的命令文件</li>\n<li>使用 node –inspect-brk 打开调试服务</li>\n<li>打开 chrome devtool 进行调试</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101\" alt=\"image.png\"></p>\n<h3 id=\"10、使用错误断点，让程序在错误处暂停\"><a href=\"#10、使用错误断点，让程序在错误处暂停\" class=\"headerlink\" title=\"10、使用错误断点，让程序在错误处暂停\"></a>10、使用错误断点，让程序在错误处暂停</h3><ul>\n<li>方案 1: 在控制面板里直接点击错误信息</li>\n<li>方案 2: 点击 <code>Sources</code>  后点击 <code>Pause on exceptions</code>  最后勾选 <code>Pause on exceptions</code>。之后刷新页面即可</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901\" alt=\"image.png\"></p>\n<h3 id=\"11、使用-Chrome-作为代码编辑工具\"><a href=\"#11、使用-Chrome-作为代码编辑工具\" class=\"headerlink\" title=\"11、使用 Chrome 作为代码编辑工具\"></a>11、使用 Chrome 作为代码编辑工具</h3><ul>\n<li>选中 <code>Sources &gt; Filesystem</code>  然后关联本地文件夹即可</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067\" alt=\"image.png\"></p>\n<h3 id=\"12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码\"><a href=\"#12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码\" class=\"headerlink\" title=\"12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码\"></a>12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码</h3><ul>\n<li>选中 <code>Sources &gt; Snippets</code>  创建新的代码片段</li>\n<li>输入 <code>Command + p</code>  后输入 <code>i</code>  后执行</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845\" alt=\"image.png\"></p>\n<h3 id=\"13、使用-Chome-实时保存更改的-css-样式\"><a href=\"#13、使用-Chome-实时保存更改的-css-样式\" class=\"headerlink\" title=\"13、使用 Chome 实时保存更改的 css 样式\"></a>13、使用 Chome 实时保存更改的 css 样式</h3><ul>\n<li>选中 <code>Source &gt; Overrides</code> ，之后点击 <code>+</code>  选择一个本地文件夹用来保存更改后的样式，最后勾选 <code>Enable Local Overrides</code> 。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831\" alt=\"image.png\"></p>\n<h3 id=\"14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比\"><a href=\"#14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比\" class=\"headerlink\" title=\"14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比\"></a>14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比</h3><ul>\n<li>输入 <code>Command + shift + p</code> ，搜索 <code>show changes</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928\" alt=\"image.png\"></p>\n<h3 id=\"15、查看-Chrome-请求是由谁发起的\"><a href=\"#15、查看-Chrome-请求是由谁发起的\" class=\"headerlink\" title=\"15、查看 Chrome 请求是由谁发起的\"></a>15、查看 Chrome 请求是由谁发起的</h3><ul>\n<li>选择 <code>NetWork &gt; Initialtor</code> ，不但可以查看调用位置，也可获取触发位置。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744\" alt=\"image.png\"></p>\n<h3 id=\"16、Chrome-性能监测工具\"><a href=\"#16、Chrome-性能监测工具\" class=\"headerlink\" title=\"16、Chrome 性能监测工具\"></a>16、Chrome 性能监测工具</h3><ul>\n<li><code>Command + shift + p</code>  输入 <code>show performance monitor</code>  即可实时查看程序运行的性能。<ul>\n<li><code>CPU usage</code> ： <code>cpu</code> 的监听</li>\n<li><code>JS heap size</code> : 内存占用监听，如添加到 <code>window</code>  对象上的事件不回收会造成内存溢出。</li>\n<li><code>DOM Nodes</code>: 内存中所分配的 <code>dom</code> 节点的个数</li>\n<li><code>JS envnt listeners</code>: <code>js</code> 中已经绑定的事件个数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"17、使用-Chrome-做性能调优，迅速定位问题\"><a href=\"#17、使用-Chrome-做性能调优，迅速定位问题\" class=\"headerlink\" title=\"17、使用 Chrome 做性能调优，迅速定位问题\"></a>17、使用 Chrome 做性能调优，迅速定位问题</h3><ul>\n<li>选择 <code>performance</code>  点击录制按钮，可以查看从录制开始到停止时间内 <code>js</code> 代码运行的情况。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率\"><a href=\"#18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率\" class=\"headerlink\" title=\"18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率\"></a>18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率</h3><ul>\n<li><code>Command + shift + p</code>  输入 <code>show animations</code>  打开动画的调试器。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况\"><a href=\"#19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况\" class=\"headerlink\" title=\"19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况\"></a>19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况</h3><ul>\n<li><code>Command + shift +p</code>  输入 <code>show coverage</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893\" alt=\"image.png\"></p>\n<h3 id=\"20、copy-复制控制台内容\"><a href=\"#20、copy-复制控制台内容\" class=\"headerlink\" title=\"20、copy() 复制控制台内容\"></a>20、copy() 复制控制台内容</h3><ul>\n<li>可以通过全局的方法  <code>copy()</code>  在  <code>console</code>  里  <code>copy</code>  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  <code>copy($_)</code>  或  <code>copy($0)</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"21、-查看上一次程序执行结果\"><a href=\"#21、-查看上一次程序执行结果\" class=\"headerlink\" title=\"21、$_查看上一次程序执行结果\"></a>21、$_查看上一次程序执行结果</h3><ul>\n<li><code>$_</code>  是对上次执行的结果的 <strong>引用</strong></li>\n</ul>\n<p>**<br><strong><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507\" alt=\"image.png\"></strong></p>\n<h3 id=\"22、-i-配合-chrome-插件引入第三方包\"><a href=\"#22、-i-配合-chrome-插件引入第三方包\" class=\"headerlink\" title=\"22、$i 配合 chrome 插件引入第三方包\"></a>22、$i 配合 chrome 插件引入第三方包</h3><ul>\n<li>有时你只是想玩玩新出的 <code>npm</code> 包，现在不用再大费周章去建一个项目测试了，只需要在 <a href=\"https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related\">Chrome 插件:Console Importer</a> 的帮助之下，快速的在 <code>console</code> 中引入和测试一些 <code>npm</code> 库。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"23、使用实时表达式\"><a href=\"#23、使用实时表达式\" class=\"headerlink\" title=\"23、使用实时表达式\"></a>23、使用实时表达式</h3><ul>\n<li><code>DevTools</code> 在 <code>Console</code> 面板中引入了一个非常漂亮的附加功能，这是一个名为 <code>Live expression</code> 的工具。只需按下 “眼睛” 符号，你就可以在那里定义任何 <code>JavaScript</code> 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102\" alt=\"1.gif\"></p>\n<h3 id=\"24、通过-‘h’-来隐藏元素\"><a href=\"#24、通过-‘h’-来隐藏元素\" class=\"headerlink\" title=\"24、通过 ‘h’ 来隐藏元素\"></a>24、通过 ‘h’ 来隐藏元素</h3><ul>\n<li>按一下  <code>&#39;h&#39;</code>  就可以隐藏你在元素面板中选择的元素。再次按下 ‘<code>h</code>‘ 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"25、拖动-amp-放置-元素\"><a href=\"#25、拖动-amp-放置-元素\" class=\"headerlink\" title=\"25、拖动 &amp; 放置 元素\"></a>25、拖动 &amp; 放置 元素</h3><ul>\n<li>当你想看看页面的某一部分在  <code>DOM</code>  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066\" alt=\"2.gif\"></p>\n<h3 id=\"26、使用-control-按钮-来移动元素\"><a href=\"#26、使用-control-按钮-来移动元素\" class=\"headerlink\" title=\"26、使用 control (按钮) 来移动元素!\"></a>26、使用 <code>control</code> (按钮) 来移动元素!</h3><ul>\n<li>如果你只是想移动你当前选中的元素，在  <code>DOM</code>  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用<code>[ctrl]</code> + <code>[⬆]</code> / <code>[ctrl]</code> + <code>[⬇]</code> (<code>[⌘]</code> + <code>[⬆]</code> / <code>[⌘]</code> + <code>[⬇]</code> on Mac).</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332\" alt=\"3.gif\"></p>\n<h3 id=\"27、元素面板中类似于基础编辑器的操作\"><a href=\"#27、元素面板中类似于基础编辑器的操作\" class=\"headerlink\" title=\"27、元素面板中类似于基础编辑器的操作\"></a>27、元素面板中类似于基础编辑器的操作</h3><ul>\n<li><p>从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 <code>[ctrl]</code> + <code>[v]</code> 来粘贴)， 所以我们可以在元素面板里把 <code>HTML</code> 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？</p>\n</li>\n<li><p>使用<code>[ctrl]</code> + <code>[z]</code> (<code>[⌘]</code> + <code>[z]</code> on Mac)撤销我们的任何改动。 使用 <code>[ctrl]</code> + <code>[shift]</code> + <code>[z]</code>重新编辑我们的任何修改。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066\" alt=\"1.gif\"></p>\n<h3 id=\"28、Shadow-editor-阴影编辑器\"><a href=\"#28、Shadow-editor-阴影编辑器\" class=\"headerlink\" title=\"28、Shadow editor 阴影编辑器\"></a>28、<code>Shadow editor</code> 阴影编辑器</h3><ul>\n<li>你可以通过在  <code>Style</code>  面板中点击靠近  <code>box-shadow</code>  属性或者  <code>text-shadow</code>  属性的  <code>阴影方形符号</code>  来打开它：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576\" alt=\"1.gif\"></p>\n<h3 id=\"29、Timing-function-editor-定时函数编辑器\"><a href=\"#29、Timing-function-editor-定时函数编辑器\" class=\"headerlink\" title=\"29、Timing function editor 定时函数编辑器\"></a>29、Timing function editor 定时函数编辑器</h3><ul>\n<li><p>也称为 <code>Cubic bezier(贝塞尔)</code> 编辑器。贝塞尔曲线是一串用来定义 <code>CSS</code> 的动画速度在整个动画过程中如何变化的 <code>魔法数值</code> 。我们将其定义为 <code>transition-timing-function</code> 或者 <code>animation-timing-function</code> CSS 属性。</p>\n</li>\n<li><p>像之前说的 <code>Color picker</code> 和 <code>Shadow editor</code> 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：<code>trasition</code>， <code>animation</code> - 请注意：如果<code>timing</code> 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474\" alt=\"1.gif\"></p>\n<h3 id=\"30、插入样式规则的按钮\"><a href=\"#30、插入样式规则的按钮\" class=\"headerlink\" title=\"30、插入样式规则的按钮\"></a>30、插入样式规则的按钮</h3><p>当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 <code>Color</code> 和 <code>Shadow</code> 编辑器添加 <code>CSS</code> 属性的按钮：</p>\n<ul>\n<li><p><code>text-shadow</code></p>\n</li>\n<li><p><code>box-shadow</code></p>\n</li>\n<li><p><code>color</code></p>\n</li>\n<li><p><code>background-color</code></p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632\" alt=\"1.gif\"></p>\n<h3 id=\"31、在元素面板中展开所有的子节点\"><a href=\"#31、在元素面板中展开所有的子节点\" class=\"headerlink\" title=\"31、在元素面板中展开所有的子节点\"></a>31、在元素面板中展开所有的子节点</h3><ul>\n<li>一个一个的去点击级联的  <code>▶</code>  按钮太慢了，不如使用右击节点后的  <code>expand recursively</code>  命令：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760\" alt=\"1.gif\"></p>\n<h3 id=\"32、控制传感器\"><a href=\"#32、控制传感器\" class=\"headerlink\" title=\"32、控制传感器\"></a>32、控制传感器</h3><ul>\n<li><p>如果你正在你的应用中使用一些获取位置信息的 <code>API</code> 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。</p>\n</li>\n<li><p><code>Drawer</code> 里的 <code>Sensors(传感器)</code> 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 <code>navigator.geolocation.watchPosition</code>（或 <code>.getCurrentPosition</code> ）报告。</p>\n</li>\n<li><p>如果你的 <code>App</code> 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774\" alt=\"1.gif\"></p>"},{"title":"React Hooks 的一些特性","date":"2020-08-15T16:00:00.000Z","_content":"\n## 1. 逆潮而动\n\n每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state\n\n```jsx\nfunction Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);\n    }, 1000);\n  });\n}\n\n// 等效于\n\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);\n    });\n  });\n}\n```\n\n## 2. effects 中的清理\n\n目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。\n\neffect 的清除并不会读取 \"最新\" 的 props。它只能读取到定义它的那次渲染中的 props 的值\n\n```jsx\n// First render, props are {id: 10}\nfunction Example() {\n  // ...\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    // cleanup for effect from first render\n    return () => {\n      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    };\n  });\n  // ...\n}\n// Next render, props are {id: 20}\nfunction Example() {\n  // ...\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    return () => {\n      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    };\n  });\n  // ...\n}\n```\n\n## 3. 避免重复调用\n\n为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)\n\n```jsx\nuseEffect(() => {\n  document.title = \"Hello, \" + title;\n}, [name]);\n```\n\n如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。\n\n## 4. 两种诚实告知依赖的方法\n\n- 在依赖中包含所有 effect 中用到的组件内的值\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    });\n    return () => clearInterval(id);\n  }, [count]);\n\n  return (\n    <div>\n      <p>you clicked it {count} times</p>\n      <button onClick={() => setCount(count + 1)}>click me</button>\n    </div>\n  );\n}\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n- 修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。\n\n## 5. 让 Effect 自给自足\n\n我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, []);\n```\n\n这正是 setCount(c => c + 1) 做的事情。你可以认为它是在给 React \"发送指令\" 告知如何更新状态。这种 \"更新形式\" 在其他情况下也有帮助，比如你需要 \"批量更新\"。\n\n## 6. 解耦来自 Actions 的更新\n\n当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。\n\n当你写类似 setSomething(something => ...) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 **把组件内发生了什么(actions)** 和 **状态如何响应并更新** 分开表述。\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\nuseEffect(() => {\n    const id = setInterval(() => {\n        dispatch({ type: \"tick\" }); // Instead of setCount(c => c + step) }, 1000);\n        return () => clearInterval(id);\n}, [dispatch]);\n```\n\n相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。\n\n```jsx\nconst initialState = {\n  count: 0,\n  step: 1\n};\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === \"tick\") {\n    return { count: count + step, step };\n  } else if (action.type === \"step\") {\n    return { count, step: action.step };\n  } else {\n    throw new Error();\n  }\n}\n```\n\n## 7. 为什么 useReducer 是 Hooks 的作弊模式\n\n假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 `<Counter step={1} />`。确定的是，在这种情况下，我们没法避免依赖 props.step 。\n\n实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。\n\n```jsx\nfunction Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n  function reducer(state, action) {\n    if (action.type === \"tick\") {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: \"tick\" });\n    }, 1000);\n  }, [dispatch]);\n  return <h1>{count}</h1>;\n}\n```\n\n注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。\n\n它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。\n\n## 8. 如何不把函数放到 Effect 里\n\n有时候我们可能不想把函数移入 effect 里。\n\n比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。\n\n函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:\n\n```jsx\nfunction SearchResults() {\n  function getFetchUrl(query) {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }\n\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  // ...\n}\n```\n\n我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。\n\n### 8.1 方法一\n\n- 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用\n\n```jsx\n// ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。\n\n### 8.2 方法二\n\n- 你也可以把它包装成 useCallback Hook\n\n```jsx\nfunction SearchResults() {\n  // ✅ Preserves identity when its own deps are the same\n  const getFetchUrl = useCallback(query => {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }, []); // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\nuseCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。\n\n如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。\n\n如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState(\"react\");\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() => {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }, [query]); // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用\n\n```jsx\nfunction Parent() {\n  const [query, setQuery] = useState(\"react\");\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() => {\n    const url = \"https://hn.algolia.com/api/v1/search?query=\" + query;\n    // ... Fetch data and return it ...\n  }, [query]); // ✅ Callback deps are OK\n  return <Child fetchData={fetchData} />;\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n  // ...\n}\n```\n\n因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。\n\n## 9. 函数是数据流的一部分么\n\n在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 \"diff\"。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。\n\n使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。\n\n类似地，useMemo 可以让我们对复杂对象做类似的事情。\n\n```jsx\nfunction ColorPicker() {\n  // Doesn't break Child's shallow equality prop check\n  // unless the color actually changes.\n  const [color, setColor] = useState(\"pink\");\n  const style = useMemo(() => ({ color }), [color]);\n  return <Child style={style} />;\n}\n```\n\n## 10. 竞态\n\n下面是一个典型的在 class 组件里发请求的例子：\n\n```jsx\nclass Article extends React.Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      this.fetchData(this.props.id);\n    }\n  }\n  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}\n```\n\n这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。\n\nEffects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。\n\n- 解决方式\n\n1. \n如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。\n\n2. \n或者，最简单的权宜之计是用一个布尔值来跟踪它。\n\n\n```jsx\nfunction Article({ id }) {\n  const [article, setArticle] = useState(null);\n\n  useEffect(() => {\n    let didCancel = false;\n    const fetchData = async () => {\n      const article = await API.fetchArticle(id);\n      if (!didCancel) {\n        setArticle(article);\n      }\n    };\n    fetchData();\n    return () => {\n      didCancel = true;\n    };\n  }, [id]);\n  // ...\n}\n```\n","source":"_posts/前端/React Hooks 的一些特性.md","raw":"---\ntitle: React Hooks 的一些特性\ndate: 2020-08-16\ncategories: [前端, react]\ntags:\n  - react-hooks\n---\n\n## 1. 逆潮而动\n\n每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state\n\n```jsx\nfunction Example(props) {\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(props.counter);\n    }, 1000);\n  });\n}\n\n// 等效于\n\nfunction Example(props) {\n  const counter = props.counter;\n  useEffect(() => {\n    setTimeout(() => {\n      console.log(counter);\n    });\n  });\n}\n```\n\n## 2. effects 中的清理\n\n目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。\n\neffect 的清除并不会读取 \"最新\" 的 props。它只能读取到定义它的那次渲染中的 props 的值\n\n```jsx\n// First render, props are {id: 10}\nfunction Example() {\n  // ...\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    // cleanup for effect from first render\n    return () => {\n      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);\n    };\n  });\n  // ...\n}\n// Next render, props are {id: 20}\nfunction Example() {\n  // ...\n  useEffect(() => {\n    ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    return () => {\n      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);\n    };\n  });\n  // ...\n}\n```\n\n## 3. 避免重复调用\n\n为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)\n\n```jsx\nuseEffect(() => {\n  document.title = \"Hello, \" + title;\n}, [name]);\n```\n\n如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。\n\n## 4. 两种诚实告知依赖的方法\n\n- 在依赖中包含所有 effect 中用到的组件内的值\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nexport default function App() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    });\n    return () => clearInterval(id);\n  }, [count]);\n\n  return (\n    <div>\n      <p>you clicked it {count} times</p>\n      <button onClick={() => setCount(count + 1)}>click me</button>\n    </div>\n  );\n}\nReactDOM.render(<App />, document.getElementById(\"root\"));\n```\n\n- 修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。\n\n## 5. 让 Effect 自给自足\n\n我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式\n\n```jsx\nuseEffect(() => {\n  const id = setInterval(() => {\n    setCount(c => c + 1);\n  }, 1000);\n  return () => clearInterval(id);\n}, []);\n```\n\n这正是 setCount(c => c + 1) 做的事情。你可以认为它是在给 React \"发送指令\" 告知如何更新状态。这种 \"更新形式\" 在其他情况下也有帮助，比如你需要 \"批量更新\"。\n\n## 6. 解耦来自 Actions 的更新\n\n当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。\n\n当你写类似 setSomething(something => ...) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 **把组件内发生了什么(actions)** 和 **状态如何响应并更新** 分开表述。\n\n```jsx\nconst [state, dispatch] = useReducer(reducer, initialState);\nconst { count, step } = state;\nuseEffect(() => {\n    const id = setInterval(() => {\n        dispatch({ type: \"tick\" }); // Instead of setCount(c => c + step) }, 1000);\n        return () => clearInterval(id);\n}, [dispatch]);\n```\n\n相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。\n\n```jsx\nconst initialState = {\n  count: 0,\n  step: 1\n};\nfunction reducer(state, action) {\n  const { count, step } = state;\n  if (action.type === \"tick\") {\n    return { count: count + step, step };\n  } else if (action.type === \"step\") {\n    return { count, step: action.step };\n  } else {\n    throw new Error();\n  }\n}\n```\n\n## 7. 为什么 useReducer 是 Hooks 的作弊模式\n\n假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 `<Counter step={1} />`。确定的是，在这种情况下，我们没法避免依赖 props.step 。\n\n实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。\n\n```jsx\nfunction Counter({ step }) {\n  const [count, dispatch] = useReducer(reducer, 0);\n  function reducer(state, action) {\n    if (action.type === \"tick\") {\n      return state + step;\n    } else {\n      throw new Error();\n    }\n  }\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: \"tick\" });\n    }, 1000);\n  }, [dispatch]);\n  return <h1>{count}</h1>;\n}\n```\n\n注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。\n\n它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。\n\n## 8. 如何不把函数放到 Effect 里\n\n有时候我们可能不想把函数移入 effect 里。\n\n比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。\n\n函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:\n\n```jsx\nfunction SearchResults() {\n  function getFetchUrl(query) {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }\n\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, []); // 🔴 Missing dep: getFetchUrl\n\n  // ...\n}\n```\n\n我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。\n\n### 8.1 方法一\n\n- 如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用\n\n```jsx\n// ✅ Not affected by the data flow\nfunction getFetchUrl(query) {\n  return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n}\n\nfunction SearchResults() {\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, []); // ✅ Deps are OK\n\n  // ...\n}\n```\n\n你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。\n\n### 8.2 方法二\n\n- 你也可以把它包装成 useCallback Hook\n\n```jsx\nfunction SearchResults() {\n  // ✅ Preserves identity when its own deps are the same\n  const getFetchUrl = useCallback(query => {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }, []); // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"react\");\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl(\"redux\");\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\nuseCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。\n\n如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。\n\n如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：\n\n```jsx\nfunction SearchResults() {\n  const [query, setQuery] = useState(\"react\");\n\n  // ✅ Preserves identity until query changes\n  const getFetchUrl = useCallback(() => {\n    return \"https://hn.algolia.com/api/v1/search?query=\" + query;\n  }, [query]); // ✅ Callback deps are OK\n\n  useEffect(() => {\n    const url = getFetchUrl();\n    // ... Fetch data and do something ...\n  }, [getFetchUrl]); // ✅ Effect deps are OK\n\n  // ...\n}\n```\n\n这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用\n\n```jsx\nfunction Parent() {\n  const [query, setQuery] = useState(\"react\");\n  // ✅ Preserves identity until query changes\n  const fetchData = useCallback(() => {\n    const url = \"https://hn.algolia.com/api/v1/search?query=\" + query;\n    // ... Fetch data and return it ...\n  }, [query]); // ✅ Callback deps are OK\n  return <Child fetchData={fetchData} />;\n}\n\nfunction Child({ fetchData }) {\n  let [data, setData] = useState(null);\n\n  useEffect(() => {\n    fetchData().then(setData);\n  }, [fetchData]); // ✅ Effect deps are OK\n  // ...\n}\n```\n\n因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。\n\n## 9. 函数是数据流的一部分么\n\n在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 \"diff\"。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。\n\n使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。\n\n类似地，useMemo 可以让我们对复杂对象做类似的事情。\n\n```jsx\nfunction ColorPicker() {\n  // Doesn't break Child's shallow equality prop check\n  // unless the color actually changes.\n  const [color, setColor] = useState(\"pink\");\n  const style = useMemo(() => ({ color }), [color]);\n  return <Child style={style} />;\n}\n```\n\n## 10. 竞态\n\n下面是一个典型的在 class 组件里发请求的例子：\n\n```jsx\nclass Article extends React.Component {\n  state = {\n    article: null\n  };\n  componentDidMount() {\n    this.fetchData(this.props.id);\n  }\n  componentDidUpdate(prevProps) {\n    if (prevProps.id !== this.props.id) {\n      this.fetchData(this.props.id);\n    }\n  }\n  async fetchData(id) {\n    const article = await API.fetchArticle(id);\n    this.setState({ article });\n  }\n  // ...\n}\n```\n\n这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。\n\nEffects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。\n\n- 解决方式\n\n1. \n如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。\n\n2. \n或者，最简单的权宜之计是用一个布尔值来跟踪它。\n\n\n```jsx\nfunction Article({ id }) {\n  const [article, setArticle] = useState(null);\n\n  useEffect(() => {\n    let didCancel = false;\n    const fetchData = async () => {\n      const article = await API.fetchArticle(id);\n      if (!didCancel) {\n        setArticle(article);\n      }\n    };\n    fetchData();\n    return () => {\n      didCancel = true;\n    };\n  }, [id]);\n  // ...\n}\n```\n","slug":"前端/React Hooks 的一些特性","published":1,"updated":"2021-04-07T07:39:28.001Z","_id":"ckn7476ad001yyx7ybs7v7hez","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-逆潮而动\"><a href=\"#1-逆潮而动\" class=\"headerlink\" title=\"1. 逆潮而动\"></a>1. 逆潮而动</h2><p>每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(props.counter);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等效于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> counter = props.counter;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(counter);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-effects-中的清理\"><a href=\"#2-effects-中的清理\" class=\"headerlink\" title=\"2. effects 中的清理\"></a>2. effects 中的清理</h2><p>目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。</p>\n<p>effect 的清除并不会读取 “最新” 的 props。它只能读取到定义它的那次渲染中的 props 的值</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// First render, props are &#123;id: 10&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(<span class=\"number\">10</span>, handleStatusChange);</span><br><span class=\"line\">    <span class=\"comment\">// cleanup for effect from first render</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      ChatAPI.subscribeToFriendStatus(<span class=\"number\">10</span>, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Next render, props are &#123;id: 20&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(<span class=\"number\">20</span>, handleStatusChange);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      ChatAPI.subscribeToFriendStatus(<span class=\"number\">20</span>, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-避免重复调用\"><a href=\"#3-避免重复调用\" class=\"headerlink\" title=\"3. 避免重复调用\"></a>3. 避免重复调用</h2><p>为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Hello, &quot;</span> + title;</span><br><span class=\"line\">&#125;, [name]);</span><br></pre></td></tr></table></figure>\n\n<p>如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。</p>\n<h2 id=\"4-两种诚实告知依赖的方法\"><a href=\"#4-两种诚实告知依赖的方法\" class=\"headerlink\" title=\"4. 两种诚实告知依赖的方法\"></a>4. 两种诚实告知依赖的方法</h2><ul>\n<li>在依赖中包含所有 effect 中用到的组件内的值</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-dom&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> id = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      setCount(count + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(id);</span><br><span class=\"line\">  &#125;, [count]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;you clicked it &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> setCount(count + <span class=\"number\">1</span>)&#125;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。</li>\n</ul>\n<h2 id=\"5-让-Effect-自给自足\"><a href=\"#5-让-Effect-自给自足\" class=\"headerlink\" title=\"5. 让 Effect 自给自足\"></a>5. 让 Effect 自给自足</h2><p>我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> id = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    setCount(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(id);</span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n\n<p>这正是 setCount(c =&gt; c + 1) 做的事情。你可以认为它是在给 React “发送指令” 告知如何更新状态。这种 “更新形式” 在其他情况下也有帮助，比如你需要 “批量更新”。</p>\n<h2 id=\"6-解耦来自-Actions-的更新\"><a href=\"#6-解耦来自-Actions-的更新\" class=\"headerlink\" title=\"6. 解耦来自 Actions 的更新\"></a>6. 解耦来自 Actions 的更新</h2><p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。</p>\n<p>当你写类似 setSomething(something =&gt; …) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 <strong>把组件内发生了什么(actions)</strong> 和 <strong>状态如何响应并更新</strong> 分开表述。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; count, step &#125; = state;</span><br><span class=\"line\">useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> id = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;tick&quot;</span> &#125;); <span class=\"comment\">// Instead of setCount(c =&gt; c + step) &#125;, 1000);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(id);</span><br><span class=\"line\">&#125;, [dispatch]);</span><br></pre></td></tr></table></figure>\n\n<p>相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">0</span>,</span><br><span class=\"line\">  step: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; count, step &#125; = state;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type === <span class=\"string\">&quot;tick&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">count</span>: count + step, step &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action.type === <span class=\"string\">&quot;step&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; count, <span class=\"attr\">step</span>: action.step &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-为什么-useReducer-是-Hooks-的作弊模式\"><a href=\"#7-为什么-useReducer-是-Hooks-的作弊模式\" class=\"headerlink\" title=\"7. 为什么 useReducer 是 Hooks 的作弊模式\"></a>7. 为什么 useReducer 是 Hooks 的作弊模式</h2><p>假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 <code>&lt;Counter step=&#123;1&#125; /&gt;</code>。确定的是，在这种情况下，我们没法避免依赖 props.step 。</p>\n<p>实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\">&#123; step &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, dispatch] = useReducer(reducer, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action.type === <span class=\"string\">&quot;tick&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + step;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> id = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;tick&quot;</span> &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;, [dispatch]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。</p>\n<p>它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。</p>\n<h2 id=\"8-如何不把函数放到-Effect-里\"><a href=\"#8-如何不把函数放到-Effect-里\" class=\"headerlink\" title=\"8. 如何不把函数放到 Effect 里\"></a>8. 如何不把函数放到 Effect 里</h2><p>有时候我们可能不想把函数移入 effect 里。</p>\n<p>比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。</p>\n<p>函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\">query</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// 🔴 Missing dep: getFetchUrl</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;redux&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// 🔴 Missing dep: getFetchUrl</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。</p>\n<h3 id=\"8-1-方法一\"><a href=\"#8-1-方法一\" class=\"headerlink\" title=\"8.1 方法一\"></a>8.1 方法一</h3><ul>\n<li>如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ✅ Not affected by the data flow</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\">query</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// ✅ Deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;redux&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// ✅ Deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。</p>\n<h3 id=\"8-2-方法二\"><a href=\"#8-2-方法二\" class=\"headerlink\" title=\"8.2 方法二\"></a>8.2 方法二</h3><ul>\n<li>你也可以把它包装成 useCallback Hook</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ✅ Preserves identity when its own deps are the same</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getFetchUrl = useCallback(<span class=\"function\"><span class=\"params\">query</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// ✅ Callback deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, [getFetchUrl]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;redux&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, [getFetchUrl]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>useCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。</p>\n<p>如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。</p>\n<p>如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useState(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ✅ Preserves identity until query changes</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getFetchUrl = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">  &#125;, [query]); <span class=\"comment\">// ✅ Callback deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl();</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, [getFetchUrl]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useState(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ✅ Preserves identity until query changes</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and return it ...</span></span><br><span class=\"line\">  &#125;, [query]); <span class=\"comment\">// ✅ Callback deps are OK</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">fetchData</span>=<span class=\"string\">&#123;fetchData&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">&#123; fetchData &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> [data, setData] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData().then(setData);</span><br><span class=\"line\">  &#125;, [fetchData]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。</p>\n<h2 id=\"9-函数是数据流的一部分么\"><a href=\"#9-函数是数据流的一部分么\" class=\"headerlink\" title=\"9. 函数是数据流的一部分么\"></a>9. 函数是数据流的一部分么</h2><p>在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 “diff”。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。</p>\n<p>使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。</p>\n<p>类似地，useMemo 可以让我们对复杂对象做类似的事情。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ColorPicker</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Doesn&#x27;t break Child&#x27;s shallow equality prop check</span></span><br><span class=\"line\">  <span class=\"comment\">// unless the color actually changes.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [color, setColor] = useState(<span class=\"string\">&quot;pink&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> style = useMemo(<span class=\"function\">() =&gt;</span> (&#123; color &#125;), [color]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;style&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-竞态\"><a href=\"#10-竞态\" class=\"headerlink\" title=\"10. 竞态\"></a>10. 竞态</h2><p>下面是一个典型的在 class 组件里发请求的例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Article</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    article: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.fetchData(<span class=\"built_in\">this</span>.props.id);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidUpdate</span>(<span class=\"params\">prevProps</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prevProps.id !== <span class=\"built_in\">this</span>.props.id) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.fetchData(<span class=\"built_in\">this</span>.props.id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">fetchData</span>(<span class=\"params\">id</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> article = <span class=\"keyword\">await</span> API.fetchArticle(id);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(&#123; article &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。</p>\n<p>Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。</p>\n<ul>\n<li>解决方式</li>\n</ul>\n<ol>\n<li><p>如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。</p>\n</li>\n<li><p>或者，最简单的权宜之计是用一个布尔值来跟踪它。</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Article</span>(<span class=\"params\">&#123; id &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [article, setArticle] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> didCancel = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fetchData = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> article = <span class=\"keyword\">await</span> API.fetchArticle(id);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!didCancel) &#123;</span><br><span class=\"line\">        setArticle(article);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      didCancel = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, [id]);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-逆潮而动\"><a href=\"#1-逆潮而动\" class=\"headerlink\" title=\"1. 逆潮而动\"></a>1. 逆潮而动</h2><p>每一个组件内的函数(包括事件处理函数、effects、定时器 或者 API 调用等等)会捕捉某次渲染中定义的 props 和 state</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(props.counter);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等效于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> counter = props.counter;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(counter);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-effects-中的清理\"><a href=\"#2-effects-中的清理\" class=\"headerlink\" title=\"2. effects 中的清理\"></a>2. effects 中的清理</h2><p>目的: 有些 effects 可能需要有一个清理步骤。本质上，它的目的是消除副作用的 effect，比如取消订阅。</p>\n<p>effect 的清除并不会读取 “最新” 的 props。它只能读取到定义它的那次渲染中的 props 的值</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// First render, props are &#123;id: 10&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(<span class=\"number\">10</span>, handleStatusChange);</span><br><span class=\"line\">    <span class=\"comment\">// cleanup for effect from first render</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      ChatAPI.subscribeToFriendStatus(<span class=\"number\">10</span>, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Next render, props are &#123;id: 20&#125;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(<span class=\"number\">20</span>, handleStatusChange);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      ChatAPI.subscribeToFriendStatus(<span class=\"number\">20</span>, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-避免重复调用\"><a href=\"#3-避免重复调用\" class=\"headerlink\" title=\"3. 避免重复调用\"></a>3. 避免重复调用</h2><p>为了避免 effects 不必要的重复调用，我们可以提供给 useEffect 一个依赖数组参数(deps)</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.title = <span class=\"string\">&quot;Hello, &quot;</span> + title;</span><br><span class=\"line\">&#125;, [name]);</span><br></pre></td></tr></table></figure>\n\n<p>如果当前渲染中的这些依赖项和上一次运行这个 effect 的时候值一样，因为没有什么需要同步 React 会自动跳过这次 effect。</p>\n<h2 id=\"4-两种诚实告知依赖的方法\"><a href=\"#4-两种诚实告知依赖的方法\" class=\"headerlink\" title=\"4. 两种诚实告知依赖的方法\"></a>4. 两种诚实告知依赖的方法</h2><ul>\n<li>在依赖中包含所有 effect 中用到的组件内的值</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-dom&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> id = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      setCount(count + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(id);</span><br><span class=\"line\">  &#125;, [count]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;you clicked it &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> setCount(count + <span class=\"number\">1</span>)&#125;&gt;click me&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改 effect 内部的代码以确保它包含的值只会在需要的时候发生变更。我们不想告知错误的依赖 - 我们只是修改 effect 使依赖更少。</li>\n</ul>\n<h2 id=\"5-让-Effect-自给自足\"><a href=\"#5-让-Effect-自给自足\" class=\"headerlink\" title=\"5. 让 Effect 自给自足\"></a>5. 让 Effect 自给自足</h2><p>我们想要根据前一个状态更新状态的时候，我们可以使用 setState 的 函数形式</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> id = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    setCount(<span class=\"function\"><span class=\"params\">c</span> =&gt;</span> c + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(id);</span><br><span class=\"line\">&#125;, []);</span><br></pre></td></tr></table></figure>\n\n<p>这正是 setCount(c =&gt; c + 1) 做的事情。你可以认为它是在给 React “发送指令” 告知如何更新状态。这种 “更新形式” 在其他情况下也有帮助，比如你需要 “批量更新”。</p>\n<h2 id=\"6-解耦来自-Actions-的更新\"><a href=\"#6-解耦来自-Actions-的更新\" class=\"headerlink\" title=\"6. 解耦来自 Actions 的更新\"></a>6. 解耦来自 Actions 的更新</h2><p>当你想更新一个状态，并且这个状态更新依赖于另一个状态的值时，你可能需要用 useReducer 去替换它们。</p>\n<p>当你写类似 setSomething(something =&gt; …) 这种代码的时候，也许就是考虑使用 reducer 的契机。reducer 可以让你 <strong>把组件内发生了什么(actions)</strong> 和 <strong>状态如何响应并更新</strong> 分开表述。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; count, step &#125; = state;</span><br><span class=\"line\">useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> id = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;tick&quot;</span> &#125;); <span class=\"comment\">// Instead of setCount(c =&gt; c + step) &#125;, 1000);</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> <span class=\"built_in\">clearInterval</span>(id);</span><br><span class=\"line\">&#125;, [dispatch]);</span><br></pre></td></tr></table></figure>\n\n<p>相比于直接在 effect 里面读取状态，它 dispatch 了一个 action 来描述发生了什么。这使得我们的 effect 和 step 状态解耦。我们的 effect 不再关心怎么更新状态，它只负责告诉我们发生了什么。更新的逻辑全都交由 reducer 去统一处理。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">0</span>,</span><br><span class=\"line\">  step: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; count, step &#125; = state;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type === <span class=\"string\">&quot;tick&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">count</span>: count + step, step &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action.type === <span class=\"string\">&quot;step&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; count, <span class=\"attr\">step</span>: action.step &#125;;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-为什么-useReducer-是-Hooks-的作弊模式\"><a href=\"#7-为什么-useReducer-是-Hooks-的作弊模式\" class=\"headerlink\" title=\"7. 为什么 useReducer 是 Hooks 的作弊模式\"></a>7. 为什么 useReducer 是 Hooks 的作弊模式</h2><p>假如我们需要依赖 props 去计算下一个状态。举个例子，也许我们的 API 是 <code>&lt;Counter step=&#123;1&#125; /&gt;</code>。确定的是，在这种情况下，我们没法避免依赖 props.step 。</p>\n<p>实际上， 我们可以避免！我们可以把 reducer 函数放到组件内去读取 props。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\">&#123; step &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, dispatch] = useReducer(reducer, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (action.type === <span class=\"string\">&quot;tick&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + step;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> id = <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;tick&quot;</span> &#125;);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;, [dispatch]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：这种模式会使一些优化失败，所以你应该避免滥用它，不过如果你需要，完全可以在 reducer 里面访问 props。</p>\n<p>它可以把更新逻辑和描述发生了什么分开。结果是，这可以帮助我移除不必需的依赖，避免不必要的 effect 调用。</p>\n<h2 id=\"8-如何不把函数放到-Effect-里\"><a href=\"#8-如何不把函数放到-Effect-里\" class=\"headerlink\" title=\"8. 如何不把函数放到 Effect 里\"></a>8. 如何不把函数放到 Effect 里</h2><p>有时候我们可能不想把函数移入 effect 里。</p>\n<p>比如，组件内有几个 effect 使用了相同的函数，你不想在每个 effect 里复制黏贴一遍这个逻辑。也或许这个函数是一个 prop。</p>\n<p>函数每次渲染都会改变这个事实本身就是个问题。比如有两个 effects 会调用 getFetchUrl:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\">query</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// 🔴 Missing dep: getFetchUrl</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;redux&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// 🔴 Missing dep: getFetchUrl</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可能不想把 getFetchUrl 移到 effect 中，因为你想复用逻辑。</p>\n<h3 id=\"8-1-方法一\"><a href=\"#8-1-方法一\" class=\"headerlink\" title=\"8.1 方法一\"></a>8.1 方法一</h3><ul>\n<li>如果一个函数没有使用组件内的任何值，你应该把它提到组件外面去定义，然后就可以自由地在 effects 中使用</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ✅ Not affected by the data flow</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\">query</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// ✅ Deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;redux&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// ✅ Deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>你不再需要把它设为依赖，因为它们不在渲染范围内，因此不会被数据流影响。它不可能突然意外地依赖于 props 或 state 。</p>\n<h3 id=\"8-2-方法二\"><a href=\"#8-2-方法二\" class=\"headerlink\" title=\"8.2 方法二\"></a>8.2 方法二</h3><ul>\n<li>你也可以把它包装成 useCallback Hook</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ✅ Preserves identity when its own deps are the same</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getFetchUrl = useCallback(<span class=\"function\"><span class=\"params\">query</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">  &#125;, []); <span class=\"comment\">// ✅ Callback deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, [getFetchUrl]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">&quot;redux&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, [getFetchUrl]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>useCallback 本质上是添加了一层依赖检查。它以另一种方式解决了问题 - 我们使函数本身只在需要的时候才改变，而不是去掉对函数的依赖。</p>\n<p>如果我们想添加一个输入框允许你输入任意的查询条件(query)。不同于传递 query 参数的方式，现在 getFetchUrl 会从状态中读取。</p>\n<p>如果我们把 query 添加到 useCallback 的依赖中，任何调用了 getFetchUrl 的 effect 在 query 改变后都会重新运行：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SearchResults</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useState(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ✅ Preserves identity until query changes</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> getFetchUrl = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">  &#125;, [query]); <span class=\"comment\">// ✅ Callback deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl();</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and do something ...</span></span><br><span class=\"line\">  &#125;, [getFetchUrl]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这正是拥抱数据流和同步思维的结果。对于通过属性从父组件传入的函数这个方法也适用</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [query, setQuery] = useState(<span class=\"string\">&quot;react&quot;</span>);</span><br><span class=\"line\">  <span class=\"comment\">// ✅ Preserves identity until query changes</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = <span class=\"string\">&quot;https://hn.algolia.com/api/v1/search?query=&quot;</span> + query;</span><br><span class=\"line\">    <span class=\"comment\">// ... Fetch data and return it ...</span></span><br><span class=\"line\">  &#125;, [query]); <span class=\"comment\">// ✅ Callback deps are OK</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">fetchData</span>=<span class=\"string\">&#123;fetchData&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">&#123; fetchData &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> [data, setData] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData().then(setData);</span><br><span class=\"line\">  &#125;, [fetchData]); <span class=\"comment\">// ✅ Effect deps are OK</span></span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为 fetchData 只有在 Parent 的 query 状态变更时才会改变，所以我们的 Child 只会在需要的时候才去重新请求数据。</p>\n<h2 id=\"9-函数是数据流的一部分么\"><a href=\"#9-函数是数据流的一部分么\" class=\"headerlink\" title=\"9. 函数是数据流的一部分么\"></a>9. 函数是数据流的一部分么</h2><p>在 class 组件中，函数属性本身并不是数据流的一部分。组件的方法中包含了可变的 this 变量导致我们不能确定无疑地认为它是不变的。因此，即使我们只需要一个函数，我们也必须把一堆数据传递下去仅仅是为了做 “diff”。我们无法知道传入的 this.props.fetchData 是否依赖状态，并且不知道它依赖的状态是否改变了。</p>\n<p>使用 useCallback，函数完全可以参与到数据流中。我们可以说如果一个函数的输入改变了，这个函数就改变了。如果没有，函数也不会改变。使用的 useCallback，属性 props.fetchData 的改变也会自动传递下去。</p>\n<p>类似地，useMemo 可以让我们对复杂对象做类似的事情。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ColorPicker</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Doesn&#x27;t break Child&#x27;s shallow equality prop check</span></span><br><span class=\"line\">  <span class=\"comment\">// unless the color actually changes.</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [color, setColor] = useState(<span class=\"string\">&quot;pink&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> style = useMemo(<span class=\"function\">() =&gt;</span> (&#123; color &#125;), [color]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;style&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-竞态\"><a href=\"#10-竞态\" class=\"headerlink\" title=\"10. 竞态\"></a>10. 竞态</h2><p>下面是一个典型的在 class 组件里发请求的例子：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Article</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    article: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.fetchData(<span class=\"built_in\">this</span>.props.id);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidUpdate</span>(<span class=\"params\">prevProps</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prevProps.id !== <span class=\"built_in\">this</span>.props.id) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.fetchData(<span class=\"built_in\">this</span>.props.id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">fetchData</span>(<span class=\"params\">id</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> article = <span class=\"keyword\">await</span> API.fetchArticle(id);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(&#123; article &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这被叫做竞态，这在混合了 async / await（假设在等待结果返回）和自顶向下数据流的代码中非常典型（ props 和 state 可能会在 async 函数调用过程中发生改变）。</p>\n<p>Effects 并没有神奇地解决这个问题，尽管它会警告你如果你直接传了一个 async 函数给 effect。</p>\n<ul>\n<li>解决方式</li>\n</ul>\n<ol>\n<li><p>如果你使用的异步方式支持取消。你可以直接在清除函数中取消异步请求。</p>\n</li>\n<li><p>或者，最简单的权宜之计是用一个布尔值来跟踪它。</p>\n</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Article</span>(<span class=\"params\">&#123; id &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [article, setArticle] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> didCancel = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fetchData = <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> article = <span class=\"keyword\">await</span> API.fetchArticle(id);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!didCancel) &#123;</span><br><span class=\"line\">        setArticle(article);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      didCancel = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, [id]);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Vue2 diff 算法","date":"2020-07-19T16:00:00.000Z","_content":"\n## 结构图\n\n![结构图.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703926503-0a8b70ad-ee2b-4b15-9f24-cb3008e56d1e.png#align=left&display=inline&height=699&margin=%5Bobject%20Object%5D&name=%E7%BB%93%E6%9E%84%E5%9B%BE.png&originHeight=699&originWidth=1424&size=257532&status=done&style=none&width=1424)\n\n## 三个维度\n\n> 执行时按照以下顺序依次执行\n\n### tree diff\n\n> `tree diff` 是对树的每一层进行遍历,如果某个组件不存在了，则会直接销毁。\n\n> 如图所示，左边是旧属，右边是新属，第一层是 `R` 组件，一模一样，不会发生变化；\n> 第二层进入 `Component DIFF`，同一类型组件继续比较下去，发现 `A` 组件没有，所以直接删掉 `A、B、C` 组件；\n> 继续第三层，重新创建 `A、B、C` 组件。\n\n![tree-diff.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703948400-4b9d5cfa-ddf5-404f-83f0-7de2c979afd2.png#align=left&display=inline&height=317&margin=%5Bobject%20Object%5D&name=tree-diff.png&originHeight=317&originWidth=533&size=61410&status=done&style=none&width=533)\n\n### component diff\n\n> 如图所示，第一层遍历完，进行第二层遍历时，D 和 G 组件是不同类型的组件，不同类型组件直接进行替换，将 D 删掉，再将 `G` 重建。\n\n![component-diff.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703964946-362729fd-486b-461b-8210-c191053da87c.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=component-diff.png&originHeight=244&originWidth=566&size=81300&status=done&style=none&width=566)\n\n### element diff\n\n> `Element DIFF` 紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定 `key`，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。\n> 如图所示，第一步将 `D` 删掉，第二步增加 `E`，再次执行时 `A` 和 `B` 只需要移动位置即可。\n\n![element-diff.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703980058-5f99c653-2a0a-46c4-9bb5-f1af80d45afe.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=element-diff.png&originHeight=331&originWidth=523&size=81565&status=done&style=none&width=523)\n","source":"_posts/前端/Vue2 diff 算法.md","raw":"---\ntitle: Vue2 diff 算法\ndate: 2020-07-20\ncategories: [前端, vue]\ntags:\n  - diff 算法\n---\n\n## 结构图\n\n![结构图.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703926503-0a8b70ad-ee2b-4b15-9f24-cb3008e56d1e.png#align=left&display=inline&height=699&margin=%5Bobject%20Object%5D&name=%E7%BB%93%E6%9E%84%E5%9B%BE.png&originHeight=699&originWidth=1424&size=257532&status=done&style=none&width=1424)\n\n## 三个维度\n\n> 执行时按照以下顺序依次执行\n\n### tree diff\n\n> `tree diff` 是对树的每一层进行遍历,如果某个组件不存在了，则会直接销毁。\n\n> 如图所示，左边是旧属，右边是新属，第一层是 `R` 组件，一模一样，不会发生变化；\n> 第二层进入 `Component DIFF`，同一类型组件继续比较下去，发现 `A` 组件没有，所以直接删掉 `A、B、C` 组件；\n> 继续第三层，重新创建 `A、B、C` 组件。\n\n![tree-diff.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703948400-4b9d5cfa-ddf5-404f-83f0-7de2c979afd2.png#align=left&display=inline&height=317&margin=%5Bobject%20Object%5D&name=tree-diff.png&originHeight=317&originWidth=533&size=61410&status=done&style=none&width=533)\n\n### component diff\n\n> 如图所示，第一层遍历完，进行第二层遍历时，D 和 G 组件是不同类型的组件，不同类型组件直接进行替换，将 D 删掉，再将 `G` 重建。\n\n![component-diff.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703964946-362729fd-486b-461b-8210-c191053da87c.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=component-diff.png&originHeight=244&originWidth=566&size=81300&status=done&style=none&width=566)\n\n### element diff\n\n> `Element DIFF` 紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定 `key`，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。\n> 如图所示，第一步将 `D` 删掉，第二步增加 `E`，再次执行时 `A` 和 `B` 只需要移动位置即可。\n\n![element-diff.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703980058-5f99c653-2a0a-46c4-9bb5-f1af80d45afe.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=element-diff.png&originHeight=331&originWidth=523&size=81565&status=done&style=none&width=523)\n","slug":"前端/Vue2 diff 算法","published":1,"updated":"2021-04-07T07:23:17.007Z","_id":"ckn7476ad001zyx7yhda41in0","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"结构图\"><a href=\"#结构图\" class=\"headerlink\" title=\"结构图\"></a>结构图</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703926503-0a8b70ad-ee2b-4b15-9f24-cb3008e56d1e.png#align=left&display=inline&height=699&margin=%5Bobject%20Object%5D&name=%E7%BB%93%E6%9E%84%E5%9B%BE.png&originHeight=699&originWidth=1424&size=257532&status=done&style=none&width=1424\" alt=\"结构图.png\"></p>\n<h2 id=\"三个维度\"><a href=\"#三个维度\" class=\"headerlink\" title=\"三个维度\"></a>三个维度</h2><blockquote>\n<p>执行时按照以下顺序依次执行</p>\n</blockquote>\n<h3 id=\"tree-diff\"><a href=\"#tree-diff\" class=\"headerlink\" title=\"tree diff\"></a>tree diff</h3><blockquote>\n<p><code>tree diff</code> 是对树的每一层进行遍历,如果某个组件不存在了，则会直接销毁。</p>\n</blockquote>\n<blockquote>\n<p>如图所示，左边是旧属，右边是新属，第一层是 <code>R</code> 组件，一模一样，不会发生变化；<br>第二层进入 <code>Component DIFF</code>，同一类型组件继续比较下去，发现 <code>A</code> 组件没有，所以直接删掉 <code>A、B、C</code> 组件；<br>继续第三层，重新创建 <code>A、B、C</code> 组件。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703948400-4b9d5cfa-ddf5-404f-83f0-7de2c979afd2.png#align=left&display=inline&height=317&margin=%5Bobject%20Object%5D&name=tree-diff.png&originHeight=317&originWidth=533&size=61410&status=done&style=none&width=533\" alt=\"tree-diff.png\"></p>\n<h3 id=\"component-diff\"><a href=\"#component-diff\" class=\"headerlink\" title=\"component diff\"></a>component diff</h3><blockquote>\n<p>如图所示，第一层遍历完，进行第二层遍历时，D 和 G 组件是不同类型的组件，不同类型组件直接进行替换，将 D 删掉，再将 <code>G</code> 重建。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703964946-362729fd-486b-461b-8210-c191053da87c.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=component-diff.png&originHeight=244&originWidth=566&size=81300&status=done&style=none&width=566\" alt=\"component-diff.png\"></p>\n<h3 id=\"element-diff\"><a href=\"#element-diff\" class=\"headerlink\" title=\"element diff\"></a>element diff</h3><blockquote>\n<p><code>Element DIFF</code> 紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定 <code>key</code>，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。<br>如图所示，第一步将 <code>D</code> 删掉，第二步增加 <code>E</code>，再次执行时 <code>A</code> 和 <code>B</code> 只需要移动位置即可。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703980058-5f99c653-2a0a-46c4-9bb5-f1af80d45afe.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=element-diff.png&originHeight=331&originWidth=523&size=81565&status=done&style=none&width=523\" alt=\"element-diff.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"结构图\"><a href=\"#结构图\" class=\"headerlink\" title=\"结构图\"></a>结构图</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703926503-0a8b70ad-ee2b-4b15-9f24-cb3008e56d1e.png#align=left&display=inline&height=699&margin=%5Bobject%20Object%5D&name=%E7%BB%93%E6%9E%84%E5%9B%BE.png&originHeight=699&originWidth=1424&size=257532&status=done&style=none&width=1424\" alt=\"结构图.png\"></p>\n<h2 id=\"三个维度\"><a href=\"#三个维度\" class=\"headerlink\" title=\"三个维度\"></a>三个维度</h2><blockquote>\n<p>执行时按照以下顺序依次执行</p>\n</blockquote>\n<h3 id=\"tree-diff\"><a href=\"#tree-diff\" class=\"headerlink\" title=\"tree diff\"></a>tree diff</h3><blockquote>\n<p><code>tree diff</code> 是对树的每一层进行遍历,如果某个组件不存在了，则会直接销毁。</p>\n</blockquote>\n<blockquote>\n<p>如图所示，左边是旧属，右边是新属，第一层是 <code>R</code> 组件，一模一样，不会发生变化；<br>第二层进入 <code>Component DIFF</code>，同一类型组件继续比较下去，发现 <code>A</code> 组件没有，所以直接删掉 <code>A、B、C</code> 组件；<br>继续第三层，重新创建 <code>A、B、C</code> 组件。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703948400-4b9d5cfa-ddf5-404f-83f0-7de2c979afd2.png#align=left&display=inline&height=317&margin=%5Bobject%20Object%5D&name=tree-diff.png&originHeight=317&originWidth=533&size=61410&status=done&style=none&width=533\" alt=\"tree-diff.png\"></p>\n<h3 id=\"component-diff\"><a href=\"#component-diff\" class=\"headerlink\" title=\"component diff\"></a>component diff</h3><blockquote>\n<p>如图所示，第一层遍历完，进行第二层遍历时，D 和 G 组件是不同类型的组件，不同类型组件直接进行替换，将 D 删掉，再将 <code>G</code> 重建。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703964946-362729fd-486b-461b-8210-c191053da87c.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=component-diff.png&originHeight=244&originWidth=566&size=81300&status=done&style=none&width=566\" alt=\"component-diff.png\"></p>\n<h3 id=\"element-diff\"><a href=\"#element-diff\" class=\"headerlink\" title=\"element diff\"></a>element diff</h3><blockquote>\n<p><code>Element DIFF</code> 紧接着以上统一类型组件继续比较下去，常见类型就是列表。同一个列表由旧变新有三种行为，插入、移动和删除，它的比较策略是对于每一个列表指定 <code>key</code>，先将所有列表遍历一遍，确定要新增和删除的，再确定需要移动的。<br>如图所示，第一步将 <code>D</code> 删掉，第二步增加 <code>E</code>，再次执行时 <code>A</code> 和 <code>B</code> 只需要移动位置即可。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703980058-5f99c653-2a0a-46c4-9bb5-f1af80d45afe.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=element-diff.png&originHeight=331&originWidth=523&size=81565&status=done&style=none&width=523\" alt=\"element-diff.png\"></p>\n"},{"title":"Vue2 数据驱动","date":"2020-07-20T16:00:00.000Z","_content":"\n## 什么是数据驱动？\n\n> 当数据发生改变的时候，用户界面发生相应的变化，并且开发者不需要去手动操作 `dom`\n\n## 实现原理\n\n- `vue` 在实例化的过程中，会对实例化对象选项中的 `data` 选项进行遍历,遍历其所有的属性并使用 `Object.defineProperty` 把这些属性全部转化成 `getter/setter`。\n- 于此同时，每一个实例化对象都有一个 `watcher` 实例对象，他会在模板编译的过程中，用 `getter` 去访问 `data` 中的属性，`watcher` 此时就会把用到的 `data` 属性记为依赖，这样就建立了视图与数据之间的联系。\n- 之后当我们渲染视图的数据依赖发生改变（即数据的 `setter` 被调用）的时候，`watcher` 会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。\n\n## 通俗原理\n\n- 在普通 `HTML` 模板中使用特殊语法将 `DOM` “绑定”到底层数据。\n- 一旦创建了绑定，`DOM` 将与数据保持同步。\n- 每当修改了数据，`DOM` 便相应地更新。\n","source":"_posts/前端/Vue2 数据驱动.md","raw":"---\ntitle: Vue2 数据驱动\ndate: 2020-07-21\ncategories: [前端, vue]\ntags:\n  - 数据驱动\n---\n\n## 什么是数据驱动？\n\n> 当数据发生改变的时候，用户界面发生相应的变化，并且开发者不需要去手动操作 `dom`\n\n## 实现原理\n\n- `vue` 在实例化的过程中，会对实例化对象选项中的 `data` 选项进行遍历,遍历其所有的属性并使用 `Object.defineProperty` 把这些属性全部转化成 `getter/setter`。\n- 于此同时，每一个实例化对象都有一个 `watcher` 实例对象，他会在模板编译的过程中，用 `getter` 去访问 `data` 中的属性，`watcher` 此时就会把用到的 `data` 属性记为依赖，这样就建立了视图与数据之间的联系。\n- 之后当我们渲染视图的数据依赖发生改变（即数据的 `setter` 被调用）的时候，`watcher` 会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。\n\n## 通俗原理\n\n- 在普通 `HTML` 模板中使用特殊语法将 `DOM` “绑定”到底层数据。\n- 一旦创建了绑定，`DOM` 将与数据保持同步。\n- 每当修改了数据，`DOM` 便相应地更新。\n","slug":"前端/Vue2 数据驱动","published":1,"updated":"2021-04-07T07:29:23.605Z","_id":"ckn7476ae0021yx7y45at6zsv","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"什么是数据驱动？\"><a href=\"#什么是数据驱动？\" class=\"headerlink\" title=\"什么是数据驱动？\"></a>什么是数据驱动？</h2><blockquote>\n<p>当数据发生改变的时候，用户界面发生相应的变化，并且开发者不需要去手动操作 <code>dom</code></p>\n</blockquote>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><ul>\n<li><code>vue</code> 在实例化的过程中，会对实例化对象选项中的 <code>data</code> 选项进行遍历,遍历其所有的属性并使用 <code>Object.defineProperty</code> 把这些属性全部转化成 <code>getter/setter</code>。</li>\n<li>于此同时，每一个实例化对象都有一个 <code>watcher</code> 实例对象，他会在模板编译的过程中，用 <code>getter</code> 去访问 <code>data</code> 中的属性，<code>watcher</code> 此时就会把用到的 <code>data</code> 属性记为依赖，这样就建立了视图与数据之间的联系。</li>\n<li>之后当我们渲染视图的数据依赖发生改变（即数据的 <code>setter</code> 被调用）的时候，<code>watcher</code> 会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。</li>\n</ul>\n<h2 id=\"通俗原理\"><a href=\"#通俗原理\" class=\"headerlink\" title=\"通俗原理\"></a>通俗原理</h2><ul>\n<li>在普通 <code>HTML</code> 模板中使用特殊语法将 <code>DOM</code> “绑定”到底层数据。</li>\n<li>一旦创建了绑定，<code>DOM</code> 将与数据保持同步。</li>\n<li>每当修改了数据，<code>DOM</code> 便相应地更新。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是数据驱动？\"><a href=\"#什么是数据驱动？\" class=\"headerlink\" title=\"什么是数据驱动？\"></a>什么是数据驱动？</h2><blockquote>\n<p>当数据发生改变的时候，用户界面发生相应的变化，并且开发者不需要去手动操作 <code>dom</code></p>\n</blockquote>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><ul>\n<li><code>vue</code> 在实例化的过程中，会对实例化对象选项中的 <code>data</code> 选项进行遍历,遍历其所有的属性并使用 <code>Object.defineProperty</code> 把这些属性全部转化成 <code>getter/setter</code>。</li>\n<li>于此同时，每一个实例化对象都有一个 <code>watcher</code> 实例对象，他会在模板编译的过程中，用 <code>getter</code> 去访问 <code>data</code> 中的属性，<code>watcher</code> 此时就会把用到的 <code>data</code> 属性记为依赖，这样就建立了视图与数据之间的联系。</li>\n<li>之后当我们渲染视图的数据依赖发生改变（即数据的 <code>setter</code> 被调用）的时候，<code>watcher</code> 会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染。</li>\n</ul>\n<h2 id=\"通俗原理\"><a href=\"#通俗原理\" class=\"headerlink\" title=\"通俗原理\"></a>通俗原理</h2><ul>\n<li>在普通 <code>HTML</code> 模板中使用特殊语法将 <code>DOM</code> “绑定”到底层数据。</li>\n<li>一旦创建了绑定，<code>DOM</code> 将与数据保持同步。</li>\n<li>每当修改了数据，<code>DOM</code> 便相应地更新。</li>\n</ul>\n"},{"title":"Vue2 虚拟 dom","date":"2020-07-17T16:00:00.000Z","_content":"\n## 关键点\n\n### 1.Vnode 对象\n\n> 一个 `VNode` 的实例对象包含了以下属性:\n\n- `tag`: 当前节点的标签名\n- `data`: 当前节点的数据对象，具体包含哪些字段可以参考 `vue` 源码 `types/vnode.d.ts` 中对 `VNodeData` 的定义\n- `children`: 数组类型，包含了当前节点的子节点\n- `text`: 当前节点的文本，一般文本节点或注释节点会有该属性\n- `elm`: 当前虚拟节点对应的真实的 `dom` 节点\n- `ns`: 节点的 `namespace`\n- `context`: 编译作用域\n- `functionalContext`: 函数化组件的作用域\n- `key`: 节点的 `key` 属性，用于作为节点的标识，有利于 `patch` 的优化\n- `componentOptions`: 创建组件实例时会用到的选项信息\n- `child`: 当前节点对应的组件实例\n- `parent`: 组件的占位节点\n- `raw`: `raw html`\n- `isStatic`: 静态节点的标识\n- `isRootInsert`: 是否作为根节点插入，被 `<transition>` 包裹的节点，该属性的值为 `false`\n- `isComment`: 当前节点是否是注释节点\n- `isCloned`: 当前节点是否为克隆节点\n- `isOnce`: 当前节点是否有 `v-once` 指令\n\n### 2.Vnode 分类\n\n- 简介\n\n> `VNode` 可以理解为 `vue` 框架的虚拟 `dom` 的基类，通过 `new` 实例化的 `VNode` 大致可以分为几类\n\n- `EmptyVNode`: 没有内容的注释节点\n- `TextVNode`: 文本节点\n- `ElementVNode`: 普通元素节点\n- `ComponentVNode`: 组件节点\n- `CloneVNode`: 克隆节点，可以是以上任意类型的节点，唯一的区别在于 `isCloned` 属性为 `true`\n\n### 3.createElement 解析\n\n```javascript\nconst SIMPLE_NORMALIZE = 1;\nconst ALWAYS_NORMALIZE = 2;\n\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  // 兼容不传data的情况\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  // 如果alwaysNormalize是true\n  // 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值\n  if (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE;\n  // 调用_createElement创建虚拟节点\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  /**\n   * 如果存在data.__ob__，说明data是被Observer观察的数据\n   * 不能用作虚拟节点的data\n   * 需要抛出警告，并返回一个空节点\n   *\n   * 被监控的data不能被用作vnode渲染的数据的原因是：\n   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作\n   */\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== \"production\" && warn(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` + \"Always create fresh vnode data objects in each render!\", context);\n    return createEmptyVNode();\n  }\n  // 当组件的is属性被设置为一个falsy的值\n  // Vue将不会知道要把这个组件渲染成什么\n  // 所以渲染一个空节点\n  if (!tag) {\n    return createEmptyVNode();\n  }\n  // 作用域插槽\n  if (Array.isArray(children) && typeof children[0] === \"function\") {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  // 根据normalizationType的值，选择不同的处理方法\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  let vnode, ns;\n  // 如果标签名是字符串类型\n  if (typeof tag === \"string\") {\n    let Ctor;\n    // 获取标签名的命名空间\n    ns = config.getTagNamespace(tag);\n    // 判断是否为保留标签\n    if (config.isReservedTag(tag)) {\n      // 如果是保留标签,就创建一个这样的vnode\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      // 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义\n    } else if ((Ctor = resolveAsset(context.$options, \"components\", tag))) {\n      // 如果找到了这个标签的定义，就以此创建虚拟组件节点\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // 兜底方案，正常创建一个vnode\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n    // 当tag不是字符串的时候，我们认为tag是组件的构造类\n    // 所以直接创建\n  } else {\n    vnode = createComponent(tag, data, context, children);\n  }\n  // 如果有vnode\n  if (vnode) {\n    // 如果有namespace，就应用下namespace，然后返回vnode\n    if (ns) applyNS(vnode, ns);\n    return vnode;\n    // 否则，返回一个空节点\n  } else {\n    return createEmptyVNode();\n  }\n}\n```\n\n### 4.patch 原理\n\n#### patch 函数接收 6 个参数\n\n1. `oldVnode`: 旧的虚拟节点或旧的真实 `dom` 节点\n2. `vnode`: 新的虚拟节点\n3. `hydrating`: 是否要跟真实 `dom` 混合\n4. `removeOnly`: 特殊 `flag`，用于 `<transition-group>` 组件\n5. `parentElm`: 父节点\n6. `refElm`: 新节点将插入到 `refElm` 之前\n\n#### patch 的策略\n\n- 如果`vnode` 不存在但是 `oldVnode` 存在，说明意图是要销毁老节点，那么就调用 `invokeDestroyHook(oldVnode)` 来进行销毁\n- 如果 `oldVnode` 不存在但是 `vnode` 存在，说明意图是要创建新节点，那么就调用 `createElm` 来创建新节点\n- 当 `vnode` 和 `oldVnode` 都存在时\n  - 如果 `oldVnode` 和 `vnode` 是同一个节点，就调用 `patchVnode` 来进行 `patch`\n  - 当 `vnode` 和 `oldVnode` 不是同一个节点时，如果 `oldVnode` 是真实 `dom` 节点 或 `hydrating` 设置为`true`，需要用 `hydrate` 函数将虚拟 `dom` 和真实 `dom` 进行映射，然后将 `oldVnode` 设置为对应的虚拟 `dom`，找到 `oldVnode.elm` 的父节点，根据 `vnode` 创建一个真实 `dom` 节点并插入到该父节点中 `oldVnode.elm` 的位置\n\n> 这里面值得一提的是 `patchVnode` 函数，因为真正的 `patch` 算法是由它来实现的（`patchVnode` 中更新子节点的算法其实是在 `updateChildren` 函数中实现的\n\n#### patchVnode 算法\n\n1. 如果 `oldVnode` 跟 `vnode` 完全一致，那么不需要做任何事情\n2. 如果 `oldVnode` 跟 `vnode` 都是静态节点，且具有相同的 `key`，当 `vnode` 是克隆节点或是 `v-once` 指令控制的节点时，只需要把 `oldVnode.elm` 和 `oldVnode.child` 都复制到 `vnode` 上，也不用再有其他操作\n3. 否则，如果`vnode`不是文本节点或注释节点\n\n- 如果 `oldVnode`和 `vnode` 都有子节点，且双方的子节点不完全一致，就执行更新子节点的操作（这一部分其实是在 `updateChildren` 函数中实现），算法如下:\n\n> 分别获取 `oldVnode` 和 `vnode` 的 `firstChild`、`lastChild`，赋值给 `oldStartVnode`、`oldEndVnode`、`newStartVnode`、`newEndVnode`\n\n> 如果 `oldStartVnode` 和 `newStartVnode` 是同一节点，调用 `patchVnode` 进行 `patch`，然后将 `oldStartVnode` 和 `newStartVnode` 都设置为下一个子节点，重复上述流程\n> ![virtual_dom1.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704111320-57210d35-7b20-45f7-87b1-8a6a541754bc.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&name=virtual_dom1.png&originHeight=204&originWidth=667&size=20067&status=done&style=none&width=667)\n\n> 如果 `oldEndVnode` 和 `newEndVnode` 是同一节点，调用 `patchVnode` 进行 `patch`，然后将 `oldEndVnode` 和 `newEndVnode` 都设置为上一个子节点，重复上述流程\n> ![virtual_dom2.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704123342-e1a719db-cacd-4fe3-a4b5-730e73dec203.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=virtual_dom2.png&originHeight=221&originWidth=676&size=19741&status=done&style=none&width=676)\n\n> 如果 `oldStartVnode` 和 `newEndVnode` 是同一节点，调用 `patchVnode` 进行 `patch`，如果 `removeOnly` 是`false`，那么可以把 `oldStartVnode.elm` 移动到 `oldEndVnode.elm` 之后，然后把 `oldStartVnode` 设置为下一个节点，`newEndVnode` 设置为上一个节点，重复上述流程![virtual_dom3.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704137134-da7b6eab-d7ab-4e0d-bd3c-816548aa7050.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=virtual_dom3.png&originHeight=224&originWidth=826&size=24829&status=done&style=none&width=826)\n\n> 如果 `newStartVnode` 和 `oldEndVnode` 是同一节点，调用 `patchVnode` 进行 `patch`，如果 `removeOnly` 是 `false`，那么可以把 `oldEndVnode.elm` 移动到 `oldStartVnode.elm` 之前，然后把 `newStartVnode` 设置为下一个节点，`oldEndVnode` 设置为上一个节点，重复上述流程\n> ![virtual_dom4.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704166102-db7c7879-3e36-49db-9e96-9f587cfcb771.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=virtual_dom4.png&originHeight=214&originWidth=864&size=24556&status=done&style=none&width=864)\n\n> 如果以上都不匹配，就尝试在 `oldChildren` 中寻找跟 `newStartVnode` 具有相同 `key` 的节点，如果找不到相同 `key`的节点，说明 `newStartVnode` 是一个新节点，就创建一个，然后把 `newStartVnode` 设置为下一个节点\n\n> 如果上一步找到了跟 `newStartVnode` 相同 `key` 的节点，那么通过其他属性的比较来判断这 2 个节点是否是同一个节点，如果是，就调用 `patchVnode` 进行 `patch`，如果 `removeOnly` 是 `false`，就把 `newStartVnode.elm` 插入到 `oldStartVnode.elm` 之前，把 `newStartVnode` 设置为下一个节点，重复上述流程\n> ![virtual_dom5.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704181185-2af64dae-c1a4-4505-aeeb-5ec7efad8930.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=virtual_dom5.png&originHeight=227&originWidth=869&size=24398&status=done&style=none&width=869)\n\n- 如果只有 `oldVnode` 有子节点，那就把这些节点都删除\n- 如果只有 `vnode` 有子节点，那就创建这些子节点\n- 如果 `oldVnode和vnode` 都没有子节点，但是 `oldVnode` 是文本节点或注释节点，就把 `vnode.elm` 的文本设置为空字符串\n\n4. 如果 `vnode` 是文本节点或注释节点，但是 `vnode.text != oldVnode.text` 时，只需要更新 `vnode.elm` 的文本内容就可以\n\n### 生命周期\n\n- `patch` 提供了 `5` 个生命周期钩子，分别是\n  - `create`: 创建 `patch` 时\n  - `activate`: 激活组件时\n  - `update`: 更新节点时\n  - `remove`: 移除节点时\n  - `destroy`: 销毁节点时\n- `vnode`也提供了生命周期钩子，分别是\n  - `init`: `vdom` 初始化时\n  - `create`: `vdom` 创建时\n  - `prepatch`: `patch` 之前\n  - `insert`: `vdom` 插入后\n  - `update`: `vdom` 更新前\n  - `postpatch`: `patch` 之后\n  - `remove`: `vdom` 移除时\n  - `destroy`: `vdom` 销毁时\n","source":"_posts/前端/Vue2 虚拟 dom.md","raw":"---\ntitle: Vue2 虚拟 dom\ndate: 2020-07-18\ncategories: [前端, vue]\ntags:\n  - 虚拟 dom\n---\n\n## 关键点\n\n### 1.Vnode 对象\n\n> 一个 `VNode` 的实例对象包含了以下属性:\n\n- `tag`: 当前节点的标签名\n- `data`: 当前节点的数据对象，具体包含哪些字段可以参考 `vue` 源码 `types/vnode.d.ts` 中对 `VNodeData` 的定义\n- `children`: 数组类型，包含了当前节点的子节点\n- `text`: 当前节点的文本，一般文本节点或注释节点会有该属性\n- `elm`: 当前虚拟节点对应的真实的 `dom` 节点\n- `ns`: 节点的 `namespace`\n- `context`: 编译作用域\n- `functionalContext`: 函数化组件的作用域\n- `key`: 节点的 `key` 属性，用于作为节点的标识，有利于 `patch` 的优化\n- `componentOptions`: 创建组件实例时会用到的选项信息\n- `child`: 当前节点对应的组件实例\n- `parent`: 组件的占位节点\n- `raw`: `raw html`\n- `isStatic`: 静态节点的标识\n- `isRootInsert`: 是否作为根节点插入，被 `<transition>` 包裹的节点，该属性的值为 `false`\n- `isComment`: 当前节点是否是注释节点\n- `isCloned`: 当前节点是否为克隆节点\n- `isOnce`: 当前节点是否有 `v-once` 指令\n\n### 2.Vnode 分类\n\n- 简介\n\n> `VNode` 可以理解为 `vue` 框架的虚拟 `dom` 的基类，通过 `new` 实例化的 `VNode` 大致可以分为几类\n\n- `EmptyVNode`: 没有内容的注释节点\n- `TextVNode`: 文本节点\n- `ElementVNode`: 普通元素节点\n- `ComponentVNode`: 组件节点\n- `CloneVNode`: 克隆节点，可以是以上任意类型的节点，唯一的区别在于 `isCloned` 属性为 `true`\n\n### 3.createElement 解析\n\n```javascript\nconst SIMPLE_NORMALIZE = 1;\nconst ALWAYS_NORMALIZE = 2;\n\nfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n  // 兼容不传data的情况\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  // 如果alwaysNormalize是true\n  // 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值\n  if (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE;\n  // 调用_createElement创建虚拟节点\n  return _createElement(context, tag, data, children, normalizationType);\n}\n\nfunction _createElement(context, tag, data, children, normalizationType) {\n  /**\n   * 如果存在data.__ob__，说明data是被Observer观察的数据\n   * 不能用作虚拟节点的data\n   * 需要抛出警告，并返回一个空节点\n   *\n   * 被监控的data不能被用作vnode渲染的数据的原因是：\n   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作\n   */\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== \"production\" && warn(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}\\n` + \"Always create fresh vnode data objects in each render!\", context);\n    return createEmptyVNode();\n  }\n  // 当组件的is属性被设置为一个falsy的值\n  // Vue将不会知道要把这个组件渲染成什么\n  // 所以渲染一个空节点\n  if (!tag) {\n    return createEmptyVNode();\n  }\n  // 作用域插槽\n  if (Array.isArray(children) && typeof children[0] === \"function\") {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  // 根据normalizationType的值，选择不同的处理方法\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  let vnode, ns;\n  // 如果标签名是字符串类型\n  if (typeof tag === \"string\") {\n    let Ctor;\n    // 获取标签名的命名空间\n    ns = config.getTagNamespace(tag);\n    // 判断是否为保留标签\n    if (config.isReservedTag(tag)) {\n      // 如果是保留标签,就创建一个这样的vnode\n      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      // 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义\n    } else if ((Ctor = resolveAsset(context.$options, \"components\", tag))) {\n      // 如果找到了这个标签的定义，就以此创建虚拟组件节点\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // 兜底方案，正常创建一个vnode\n      vnode = new VNode(tag, data, children, undefined, undefined, context);\n    }\n    // 当tag不是字符串的时候，我们认为tag是组件的构造类\n    // 所以直接创建\n  } else {\n    vnode = createComponent(tag, data, context, children);\n  }\n  // 如果有vnode\n  if (vnode) {\n    // 如果有namespace，就应用下namespace，然后返回vnode\n    if (ns) applyNS(vnode, ns);\n    return vnode;\n    // 否则，返回一个空节点\n  } else {\n    return createEmptyVNode();\n  }\n}\n```\n\n### 4.patch 原理\n\n#### patch 函数接收 6 个参数\n\n1. `oldVnode`: 旧的虚拟节点或旧的真实 `dom` 节点\n2. `vnode`: 新的虚拟节点\n3. `hydrating`: 是否要跟真实 `dom` 混合\n4. `removeOnly`: 特殊 `flag`，用于 `<transition-group>` 组件\n5. `parentElm`: 父节点\n6. `refElm`: 新节点将插入到 `refElm` 之前\n\n#### patch 的策略\n\n- 如果`vnode` 不存在但是 `oldVnode` 存在，说明意图是要销毁老节点，那么就调用 `invokeDestroyHook(oldVnode)` 来进行销毁\n- 如果 `oldVnode` 不存在但是 `vnode` 存在，说明意图是要创建新节点，那么就调用 `createElm` 来创建新节点\n- 当 `vnode` 和 `oldVnode` 都存在时\n  - 如果 `oldVnode` 和 `vnode` 是同一个节点，就调用 `patchVnode` 来进行 `patch`\n  - 当 `vnode` 和 `oldVnode` 不是同一个节点时，如果 `oldVnode` 是真实 `dom` 节点 或 `hydrating` 设置为`true`，需要用 `hydrate` 函数将虚拟 `dom` 和真实 `dom` 进行映射，然后将 `oldVnode` 设置为对应的虚拟 `dom`，找到 `oldVnode.elm` 的父节点，根据 `vnode` 创建一个真实 `dom` 节点并插入到该父节点中 `oldVnode.elm` 的位置\n\n> 这里面值得一提的是 `patchVnode` 函数，因为真正的 `patch` 算法是由它来实现的（`patchVnode` 中更新子节点的算法其实是在 `updateChildren` 函数中实现的\n\n#### patchVnode 算法\n\n1. 如果 `oldVnode` 跟 `vnode` 完全一致，那么不需要做任何事情\n2. 如果 `oldVnode` 跟 `vnode` 都是静态节点，且具有相同的 `key`，当 `vnode` 是克隆节点或是 `v-once` 指令控制的节点时，只需要把 `oldVnode.elm` 和 `oldVnode.child` 都复制到 `vnode` 上，也不用再有其他操作\n3. 否则，如果`vnode`不是文本节点或注释节点\n\n- 如果 `oldVnode`和 `vnode` 都有子节点，且双方的子节点不完全一致，就执行更新子节点的操作（这一部分其实是在 `updateChildren` 函数中实现），算法如下:\n\n> 分别获取 `oldVnode` 和 `vnode` 的 `firstChild`、`lastChild`，赋值给 `oldStartVnode`、`oldEndVnode`、`newStartVnode`、`newEndVnode`\n\n> 如果 `oldStartVnode` 和 `newStartVnode` 是同一节点，调用 `patchVnode` 进行 `patch`，然后将 `oldStartVnode` 和 `newStartVnode` 都设置为下一个子节点，重复上述流程\n> ![virtual_dom1.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704111320-57210d35-7b20-45f7-87b1-8a6a541754bc.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&name=virtual_dom1.png&originHeight=204&originWidth=667&size=20067&status=done&style=none&width=667)\n\n> 如果 `oldEndVnode` 和 `newEndVnode` 是同一节点，调用 `patchVnode` 进行 `patch`，然后将 `oldEndVnode` 和 `newEndVnode` 都设置为上一个子节点，重复上述流程\n> ![virtual_dom2.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704123342-e1a719db-cacd-4fe3-a4b5-730e73dec203.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=virtual_dom2.png&originHeight=221&originWidth=676&size=19741&status=done&style=none&width=676)\n\n> 如果 `oldStartVnode` 和 `newEndVnode` 是同一节点，调用 `patchVnode` 进行 `patch`，如果 `removeOnly` 是`false`，那么可以把 `oldStartVnode.elm` 移动到 `oldEndVnode.elm` 之后，然后把 `oldStartVnode` 设置为下一个节点，`newEndVnode` 设置为上一个节点，重复上述流程![virtual_dom3.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704137134-da7b6eab-d7ab-4e0d-bd3c-816548aa7050.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=virtual_dom3.png&originHeight=224&originWidth=826&size=24829&status=done&style=none&width=826)\n\n> 如果 `newStartVnode` 和 `oldEndVnode` 是同一节点，调用 `patchVnode` 进行 `patch`，如果 `removeOnly` 是 `false`，那么可以把 `oldEndVnode.elm` 移动到 `oldStartVnode.elm` 之前，然后把 `newStartVnode` 设置为下一个节点，`oldEndVnode` 设置为上一个节点，重复上述流程\n> ![virtual_dom4.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704166102-db7c7879-3e36-49db-9e96-9f587cfcb771.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=virtual_dom4.png&originHeight=214&originWidth=864&size=24556&status=done&style=none&width=864)\n\n> 如果以上都不匹配，就尝试在 `oldChildren` 中寻找跟 `newStartVnode` 具有相同 `key` 的节点，如果找不到相同 `key`的节点，说明 `newStartVnode` 是一个新节点，就创建一个，然后把 `newStartVnode` 设置为下一个节点\n\n> 如果上一步找到了跟 `newStartVnode` 相同 `key` 的节点，那么通过其他属性的比较来判断这 2 个节点是否是同一个节点，如果是，就调用 `patchVnode` 进行 `patch`，如果 `removeOnly` 是 `false`，就把 `newStartVnode.elm` 插入到 `oldStartVnode.elm` 之前，把 `newStartVnode` 设置为下一个节点，重复上述流程\n> ![virtual_dom5.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608704181185-2af64dae-c1a4-4505-aeeb-5ec7efad8930.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=virtual_dom5.png&originHeight=227&originWidth=869&size=24398&status=done&style=none&width=869)\n\n- 如果只有 `oldVnode` 有子节点，那就把这些节点都删除\n- 如果只有 `vnode` 有子节点，那就创建这些子节点\n- 如果 `oldVnode和vnode` 都没有子节点，但是 `oldVnode` 是文本节点或注释节点，就把 `vnode.elm` 的文本设置为空字符串\n\n4. 如果 `vnode` 是文本节点或注释节点，但是 `vnode.text != oldVnode.text` 时，只需要更新 `vnode.elm` 的文本内容就可以\n\n### 生命周期\n\n- `patch` 提供了 `5` 个生命周期钩子，分别是\n  - `create`: 创建 `patch` 时\n  - `activate`: 激活组件时\n  - `update`: 更新节点时\n  - `remove`: 移除节点时\n  - `destroy`: 销毁节点时\n- `vnode`也提供了生命周期钩子，分别是\n  - `init`: `vdom` 初始化时\n  - `create`: `vdom` 创建时\n  - `prepatch`: `patch` 之前\n  - `insert`: `vdom` 插入后\n  - `update`: `vdom` 更新前\n  - `postpatch`: `patch` 之后\n  - `remove`: `vdom` 移除时\n  - `destroy`: `vdom` 销毁时\n","slug":"前端/Vue2 虚拟 dom","published":1,"updated":"2021-04-07T07:23:20.285Z","_id":"ckn7476af0023yx7ydfxjb6vn","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><h3 id=\"1-Vnode-对象\"><a href=\"#1-Vnode-对象\" class=\"headerlink\" title=\"1.Vnode 对象\"></a>1.Vnode 对象</h3><blockquote>\n<p>一个 <code>VNode</code> 的实例对象包含了以下属性:</p>\n</blockquote>\n<ul>\n<li><code>tag</code>: 当前节点的标签名</li>\n<li><code>data</code>: 当前节点的数据对象，具体包含哪些字段可以参考 <code>vue</code> 源码 <code>types/vnode.d.ts</code> 中对 <code>VNodeData</code> 的定义</li>\n<li><code>children</code>: 数组类型，包含了当前节点的子节点</li>\n<li><code>text</code>: 当前节点的文本，一般文本节点或注释节点会有该属性</li>\n<li><code>elm</code>: 当前虚拟节点对应的真实的 <code>dom</code> 节点</li>\n<li><code>ns</code>: 节点的 <code>namespace</code></li>\n<li><code>context</code>: 编译作用域</li>\n<li><code>functionalContext</code>: 函数化组件的作用域</li>\n<li><code>key</code>: 节点的 <code>key</code> 属性，用于作为节点的标识，有利于 <code>patch</code> 的优化</li>\n<li><code>componentOptions</code>: 创建组件实例时会用到的选项信息</li>\n<li><code>child</code>: 当前节点对应的组件实例</li>\n<li><code>parent</code>: 组件的占位节点</li>\n<li><code>raw</code>: <code>raw html</code></li>\n<li><code>isStatic</code>: 静态节点的标识</li>\n<li><code>isRootInsert</code>: 是否作为根节点插入，被 <code>&lt;transition&gt;</code> 包裹的节点，该属性的值为 <code>false</code></li>\n<li><code>isComment</code>: 当前节点是否是注释节点</li>\n<li><code>isCloned</code>: 当前节点是否为克隆节点</li>\n<li><code>isOnce</code>: 当前节点是否有 <code>v-once</code> 指令</li>\n</ul>\n<h3 id=\"2-Vnode-分类\"><a href=\"#2-Vnode-分类\" class=\"headerlink\" title=\"2.Vnode 分类\"></a>2.Vnode 分类</h3><ul>\n<li>简介</li>\n</ul>\n<blockquote>\n<p><code>VNode</code> 可以理解为 <code>vue</code> 框架的虚拟 <code>dom</code> 的基类，通过 <code>new</code> 实例化的 <code>VNode</code> 大致可以分为几类</p>\n</blockquote>\n<ul>\n<li><code>EmptyVNode</code>: 没有内容的注释节点</li>\n<li><code>TextVNode</code>: 文本节点</li>\n<li><code>ElementVNode</code>: 普通元素节点</li>\n<li><code>ComponentVNode</code>: 组件节点</li>\n<li><code>CloneVNode</code>: 克隆节点，可以是以上任意类型的节点，唯一的区别在于 <code>isCloned</code> 属性为 <code>true</code></li>\n</ul>\n<h3 id=\"3-createElement-解析\"><a href=\"#3-createElement-解析\" class=\"headerlink\" title=\"3.createElement 解析\"></a>3.createElement 解析</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SIMPLE_NORMALIZE = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ALWAYS_NORMALIZE = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">context, tag, data, children, normalizationType, alwaysNormalize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 兼容不传data的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class=\"line\">    normalizationType = children;</span><br><span class=\"line\">    children = data;</span><br><span class=\"line\">    data = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果alwaysNormalize是true</span></span><br><span class=\"line\">  <span class=\"comment\">// 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE;</span><br><span class=\"line\">  <span class=\"comment\">// 调用_createElement创建虚拟节点</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _createElement(context, tag, data, children, normalizationType);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_createElement</span>(<span class=\"params\">context, tag, data, children, normalizationType</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 如果存在data.__ob__，说明data是被Observer观察的数据</span></span><br><span class=\"line\"><span class=\"comment\">   * 不能用作虚拟节点的data</span></span><br><span class=\"line\"><span class=\"comment\">   * 需要抛出警告，并返回一个空节点</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * 被监控的data不能被用作vnode渲染的数据的原因是：</span></span><br><span class=\"line\"><span class=\"comment\">   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data &amp;&amp; data.__ob__) &#123;</span><br><span class=\"line\">    process.env.NODE_ENV !== <span class=\"string\">&quot;production&quot;</span> &amp;&amp; warn(<span class=\"string\">`Avoid using observed data object as vnode data: <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(data)&#125;</span>\\n`</span> + <span class=\"string\">&quot;Always create fresh vnode data objects in each render!&quot;</span>, context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createEmptyVNode();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当组件的is属性被设置为一个falsy的值</span></span><br><span class=\"line\">  <span class=\"comment\">// Vue将不会知道要把这个组件渲染成什么</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以渲染一个空节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!tag) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createEmptyVNode();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 作用域插槽</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children) &amp;&amp; <span class=\"keyword\">typeof</span> children[<span class=\"number\">0</span>] === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">    data = data || &#123;&#125;;</span><br><span class=\"line\">    data.scopedSlots = &#123; <span class=\"attr\">default</span>: children[<span class=\"number\">0</span>] &#125;;</span><br><span class=\"line\">    children.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 根据normalizationType的值，选择不同的处理方法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class=\"line\">    children = normalizeChildren(children);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class=\"line\">    children = simpleNormalizeChildren(children);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> vnode, ns;</span><br><span class=\"line\">  <span class=\"comment\">// 如果标签名是字符串类型</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> tag === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Ctor;</span><br><span class=\"line\">    <span class=\"comment\">// 获取标签名的命名空间</span></span><br><span class=\"line\">    ns = config.getTagNamespace(tag);</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否为保留标签</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果是保留标签,就创建一个这样的vnode</span></span><br><span class=\"line\">      vnode = <span class=\"keyword\">new</span> VNode(config.parsePlatformTagName(tag), data, children, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, context);</span><br><span class=\"line\">      <span class=\"comment\">// 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((Ctor = resolveAsset(context.$options, <span class=\"string\">&quot;components&quot;</span>, tag))) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果找到了这个标签的定义，就以此创建虚拟组件节点</span></span><br><span class=\"line\">      vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 兜底方案，正常创建一个vnode</span></span><br><span class=\"line\">      vnode = <span class=\"keyword\">new</span> VNode(tag, data, children, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当tag不是字符串的时候，我们认为tag是组件的构造类</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以直接创建</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    vnode = createComponent(tag, data, context, children);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果有vnode</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vnode) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有namespace，就应用下namespace，然后返回vnode</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ns) applyNS(vnode, ns);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vnode;</span><br><span class=\"line\">    <span class=\"comment\">// 否则，返回一个空节点</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createEmptyVNode();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-patch-原理\"><a href=\"#4-patch-原理\" class=\"headerlink\" title=\"4.patch 原理\"></a>4.patch 原理</h3><h4 id=\"patch-函数接收-6-个参数\"><a href=\"#patch-函数接收-6-个参数\" class=\"headerlink\" title=\"patch 函数接收 6 个参数\"></a>patch 函数接收 6 个参数</h4><ol>\n<li><code>oldVnode</code>: 旧的虚拟节点或旧的真实 <code>dom</code> 节点</li>\n<li><code>vnode</code>: 新的虚拟节点</li>\n<li><code>hydrating</code>: 是否要跟真实 <code>dom</code> 混合</li>\n<li><code>removeOnly</code>: 特殊 <code>flag</code>，用于 <code>&lt;transition-group&gt;</code> 组件</li>\n<li><code>parentElm</code>: 父节点</li>\n<li><code>refElm</code>: 新节点将插入到 <code>refElm</code> 之前</li>\n</ol>\n<h4 id=\"patch-的策略\"><a href=\"#patch-的策略\" class=\"headerlink\" title=\"patch 的策略\"></a>patch 的策略</h4><ul>\n<li>如果<code>vnode</code> 不存在但是 <code>oldVnode</code> 存在，说明意图是要销毁老节点，那么就调用 <code>invokeDestroyHook(oldVnode)</code> 来进行销毁</li>\n<li>如果 <code>oldVnode</code> 不存在但是 <code>vnode</code> 存在，说明意图是要创建新节点，那么就调用 <code>createElm</code> 来创建新节点</li>\n<li>当 <code>vnode</code> 和 <code>oldVnode</code> 都存在时<ul>\n<li>如果 <code>oldVnode</code> 和 <code>vnode</code> 是同一个节点，就调用 <code>patchVnode</code> 来进行 <code>patch</code></li>\n<li>当 <code>vnode</code> 和 <code>oldVnode</code> 不是同一个节点时，如果 <code>oldVnode</code> 是真实 <code>dom</code> 节点 或 <code>hydrating</code> 设置为<code>true</code>，需要用 <code>hydrate</code> 函数将虚拟 <code>dom</code> 和真实 <code>dom</code> 进行映射，然后将 <code>oldVnode</code> 设置为对应的虚拟 <code>dom</code>，找到 <code>oldVnode.elm</code> 的父节点，根据 <code>vnode</code> 创建一个真实 <code>dom</code> 节点并插入到该父节点中 <code>oldVnode.elm</code> 的位置</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这里面值得一提的是 <code>patchVnode</code> 函数，因为真正的 <code>patch</code> 算法是由它来实现的（<code>patchVnode</code> 中更新子节点的算法其实是在 <code>updateChildren</code> 函数中实现的</p>\n</blockquote>\n<h4 id=\"patchVnode-算法\"><a href=\"#patchVnode-算法\" class=\"headerlink\" title=\"patchVnode 算法\"></a>patchVnode 算法</h4><ol>\n<li>如果 <code>oldVnode</code> 跟 <code>vnode</code> 完全一致，那么不需要做任何事情</li>\n<li>如果 <code>oldVnode</code> 跟 <code>vnode</code> 都是静态节点，且具有相同的 <code>key</code>，当 <code>vnode</code> 是克隆节点或是 <code>v-once</code> 指令控制的节点时，只需要把 <code>oldVnode.elm</code> 和 <code>oldVnode.child</code> 都复制到 <code>vnode</code> 上，也不用再有其他操作</li>\n<li>否则，如果<code>vnode</code>不是文本节点或注释节点</li>\n</ol>\n<ul>\n<li>如果 <code>oldVnode</code>和 <code>vnode</code> 都有子节点，且双方的子节点不完全一致，就执行更新子节点的操作（这一部分其实是在 <code>updateChildren</code> 函数中实现），算法如下:</li>\n</ul>\n<blockquote>\n<p>分别获取 <code>oldVnode</code> 和 <code>vnode</code> 的 <code>firstChild</code>、<code>lastChild</code>，赋值给 <code>oldStartVnode</code>、<code>oldEndVnode</code>、<code>newStartVnode</code>、<code>newEndVnode</code></p>\n</blockquote>\n<blockquote>\n<p>如果 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，然后将 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 都设置为下一个子节点，重复上述流程<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704111320-57210d35-7b20-45f7-87b1-8a6a541754bc.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&name=virtual_dom1.png&originHeight=204&originWidth=667&size=20067&status=done&style=none&width=667\" alt=\"virtual_dom1.png\"></p>\n</blockquote>\n<blockquote>\n<p>如果 <code>oldEndVnode</code> 和 <code>newEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，然后将 <code>oldEndVnode</code> 和 <code>newEndVnode</code> 都设置为上一个子节点，重复上述流程<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704123342-e1a719db-cacd-4fe3-a4b5-730e73dec203.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=virtual_dom2.png&originHeight=221&originWidth=676&size=19741&status=done&style=none&width=676\" alt=\"virtual_dom2.png\"></p>\n</blockquote>\n<blockquote>\n<p>如果 <code>oldStartVnode</code> 和 <code>newEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是<code>false</code>，那么可以把 <code>oldStartVnode.elm</code> 移动到 <code>oldEndVnode.elm</code> 之后，然后把 <code>oldStartVnode</code> 设置为下一个节点，<code>newEndVnode</code> 设置为上一个节点，重复上述流程<img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704137134-da7b6eab-d7ab-4e0d-bd3c-816548aa7050.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=virtual_dom3.png&originHeight=224&originWidth=826&size=24829&status=done&style=none&width=826\" alt=\"virtual_dom3.png\"></p>\n</blockquote>\n<blockquote>\n<p>如果 <code>newStartVnode</code> 和 <code>oldEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是 <code>false</code>，那么可以把 <code>oldEndVnode.elm</code> 移动到 <code>oldStartVnode.elm</code> 之前，然后把 <code>newStartVnode</code> 设置为下一个节点，<code>oldEndVnode</code> 设置为上一个节点，重复上述流程<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704166102-db7c7879-3e36-49db-9e96-9f587cfcb771.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=virtual_dom4.png&originHeight=214&originWidth=864&size=24556&status=done&style=none&width=864\" alt=\"virtual_dom4.png\"></p>\n</blockquote>\n<blockquote>\n<p>如果以上都不匹配，就尝试在 <code>oldChildren</code> 中寻找跟 <code>newStartVnode</code> 具有相同 <code>key</code> 的节点，如果找不到相同 <code>key</code>的节点，说明 <code>newStartVnode</code> 是一个新节点，就创建一个，然后把 <code>newStartVnode</code> 设置为下一个节点</p>\n</blockquote>\n<blockquote>\n<p>如果上一步找到了跟 <code>newStartVnode</code> 相同 <code>key</code> 的节点，那么通过其他属性的比较来判断这 2 个节点是否是同一个节点，如果是，就调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是 <code>false</code>，就把 <code>newStartVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 之前，把 <code>newStartVnode</code> 设置为下一个节点，重复上述流程<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704181185-2af64dae-c1a4-4505-aeeb-5ec7efad8930.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=virtual_dom5.png&originHeight=227&originWidth=869&size=24398&status=done&style=none&width=869\" alt=\"virtual_dom5.png\"></p>\n</blockquote>\n<ul>\n<li>如果只有 <code>oldVnode</code> 有子节点，那就把这些节点都删除</li>\n<li>如果只有 <code>vnode</code> 有子节点，那就创建这些子节点</li>\n<li>如果 <code>oldVnode和vnode</code> 都没有子节点，但是 <code>oldVnode</code> 是文本节点或注释节点，就把 <code>vnode.elm</code> 的文本设置为空字符串</li>\n</ul>\n<ol start=\"4\">\n<li>如果 <code>vnode</code> 是文本节点或注释节点，但是 <code>vnode.text != oldVnode.text</code> 时，只需要更新 <code>vnode.elm</code> 的文本内容就可以</li>\n</ol>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><ul>\n<li><code>patch</code> 提供了 <code>5</code> 个生命周期钩子，分别是<ul>\n<li><code>create</code>: 创建 <code>patch</code> 时</li>\n<li><code>activate</code>: 激活组件时</li>\n<li><code>update</code>: 更新节点时</li>\n<li><code>remove</code>: 移除节点时</li>\n<li><code>destroy</code>: 销毁节点时</li>\n</ul>\n</li>\n<li><code>vnode</code>也提供了生命周期钩子，分别是<ul>\n<li><code>init</code>: <code>vdom</code> 初始化时</li>\n<li><code>create</code>: <code>vdom</code> 创建时</li>\n<li><code>prepatch</code>: <code>patch</code> 之前</li>\n<li><code>insert</code>: <code>vdom</code> 插入后</li>\n<li><code>update</code>: <code>vdom</code> 更新前</li>\n<li><code>postpatch</code>: <code>patch</code> 之后</li>\n<li><code>remove</code>: <code>vdom</code> 移除时</li>\n<li><code>destroy</code>: <code>vdom</code> 销毁时</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><h3 id=\"1-Vnode-对象\"><a href=\"#1-Vnode-对象\" class=\"headerlink\" title=\"1.Vnode 对象\"></a>1.Vnode 对象</h3><blockquote>\n<p>一个 <code>VNode</code> 的实例对象包含了以下属性:</p>\n</blockquote>\n<ul>\n<li><code>tag</code>: 当前节点的标签名</li>\n<li><code>data</code>: 当前节点的数据对象，具体包含哪些字段可以参考 <code>vue</code> 源码 <code>types/vnode.d.ts</code> 中对 <code>VNodeData</code> 的定义</li>\n<li><code>children</code>: 数组类型，包含了当前节点的子节点</li>\n<li><code>text</code>: 当前节点的文本，一般文本节点或注释节点会有该属性</li>\n<li><code>elm</code>: 当前虚拟节点对应的真实的 <code>dom</code> 节点</li>\n<li><code>ns</code>: 节点的 <code>namespace</code></li>\n<li><code>context</code>: 编译作用域</li>\n<li><code>functionalContext</code>: 函数化组件的作用域</li>\n<li><code>key</code>: 节点的 <code>key</code> 属性，用于作为节点的标识，有利于 <code>patch</code> 的优化</li>\n<li><code>componentOptions</code>: 创建组件实例时会用到的选项信息</li>\n<li><code>child</code>: 当前节点对应的组件实例</li>\n<li><code>parent</code>: 组件的占位节点</li>\n<li><code>raw</code>: <code>raw html</code></li>\n<li><code>isStatic</code>: 静态节点的标识</li>\n<li><code>isRootInsert</code>: 是否作为根节点插入，被 <code>&lt;transition&gt;</code> 包裹的节点，该属性的值为 <code>false</code></li>\n<li><code>isComment</code>: 当前节点是否是注释节点</li>\n<li><code>isCloned</code>: 当前节点是否为克隆节点</li>\n<li><code>isOnce</code>: 当前节点是否有 <code>v-once</code> 指令</li>\n</ul>\n<h3 id=\"2-Vnode-分类\"><a href=\"#2-Vnode-分类\" class=\"headerlink\" title=\"2.Vnode 分类\"></a>2.Vnode 分类</h3><ul>\n<li>简介</li>\n</ul>\n<blockquote>\n<p><code>VNode</code> 可以理解为 <code>vue</code> 框架的虚拟 <code>dom</code> 的基类，通过 <code>new</code> 实例化的 <code>VNode</code> 大致可以分为几类</p>\n</blockquote>\n<ul>\n<li><code>EmptyVNode</code>: 没有内容的注释节点</li>\n<li><code>TextVNode</code>: 文本节点</li>\n<li><code>ElementVNode</code>: 普通元素节点</li>\n<li><code>ComponentVNode</code>: 组件节点</li>\n<li><code>CloneVNode</code>: 克隆节点，可以是以上任意类型的节点，唯一的区别在于 <code>isCloned</code> 属性为 <code>true</code></li>\n</ul>\n<h3 id=\"3-createElement-解析\"><a href=\"#3-createElement-解析\" class=\"headerlink\" title=\"3.createElement 解析\"></a>3.createElement 解析</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SIMPLE_NORMALIZE = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> ALWAYS_NORMALIZE = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">context, tag, data, children, normalizationType, alwaysNormalize</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 兼容不传data的情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class=\"line\">    normalizationType = children;</span><br><span class=\"line\">    children = data;</span><br><span class=\"line\">    data = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果alwaysNormalize是true</span></span><br><span class=\"line\">  <span class=\"comment\">// 那么normalizationType应该设置为常量ALWAYS_NORMALIZE的值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE;</span><br><span class=\"line\">  <span class=\"comment\">// 调用_createElement创建虚拟节点</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> _createElement(context, tag, data, children, normalizationType);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_createElement</span>(<span class=\"params\">context, tag, data, children, normalizationType</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 如果存在data.__ob__，说明data是被Observer观察的数据</span></span><br><span class=\"line\"><span class=\"comment\">   * 不能用作虚拟节点的data</span></span><br><span class=\"line\"><span class=\"comment\">   * 需要抛出警告，并返回一个空节点</span></span><br><span class=\"line\"><span class=\"comment\">   *</span></span><br><span class=\"line\"><span class=\"comment\">   * 被监控的data不能被用作vnode渲染的数据的原因是：</span></span><br><span class=\"line\"><span class=\"comment\">   * data在vnode渲染过程中可能会被改变，这样会触发监控，导致不符合预期的操作</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (data &amp;&amp; data.__ob__) &#123;</span><br><span class=\"line\">    process.env.NODE_ENV !== <span class=\"string\">&quot;production&quot;</span> &amp;&amp; warn(<span class=\"string\">`Avoid using observed data object as vnode data: <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(data)&#125;</span>\\n`</span> + <span class=\"string\">&quot;Always create fresh vnode data objects in each render!&quot;</span>, context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createEmptyVNode();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 当组件的is属性被设置为一个falsy的值</span></span><br><span class=\"line\">  <span class=\"comment\">// Vue将不会知道要把这个组件渲染成什么</span></span><br><span class=\"line\">  <span class=\"comment\">// 所以渲染一个空节点</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!tag) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createEmptyVNode();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 作用域插槽</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(children) &amp;&amp; <span class=\"keyword\">typeof</span> children[<span class=\"number\">0</span>] === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">    data = data || &#123;&#125;;</span><br><span class=\"line\">    data.scopedSlots = &#123; <span class=\"attr\">default</span>: children[<span class=\"number\">0</span>] &#125;;</span><br><span class=\"line\">    children.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 根据normalizationType的值，选择不同的处理方法</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class=\"line\">    children = normalizeChildren(children);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class=\"line\">    children = simpleNormalizeChildren(children);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> vnode, ns;</span><br><span class=\"line\">  <span class=\"comment\">// 如果标签名是字符串类型</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> tag === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> Ctor;</span><br><span class=\"line\">    <span class=\"comment\">// 获取标签名的命名空间</span></span><br><span class=\"line\">    ns = config.getTagNamespace(tag);</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否为保留标签</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果是保留标签,就创建一个这样的vnode</span></span><br><span class=\"line\">      vnode = <span class=\"keyword\">new</span> VNode(config.parsePlatformTagName(tag), data, children, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, context);</span><br><span class=\"line\">      <span class=\"comment\">// 如果不是保留标签，那么我们将尝试从vm的components上查找是否有这个标签的定义</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((Ctor = resolveAsset(context.$options, <span class=\"string\">&quot;components&quot;</span>, tag))) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果找到了这个标签的定义，就以此创建虚拟组件节点</span></span><br><span class=\"line\">      vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 兜底方案，正常创建一个vnode</span></span><br><span class=\"line\">      vnode = <span class=\"keyword\">new</span> VNode(tag, data, children, <span class=\"literal\">undefined</span>, <span class=\"literal\">undefined</span>, context);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当tag不是字符串的时候，我们认为tag是组件的构造类</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以直接创建</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    vnode = createComponent(tag, data, context, children);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果有vnode</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vnode) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果有namespace，就应用下namespace，然后返回vnode</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ns) applyNS(vnode, ns);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vnode;</span><br><span class=\"line\">    <span class=\"comment\">// 否则，返回一个空节点</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> createEmptyVNode();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-patch-原理\"><a href=\"#4-patch-原理\" class=\"headerlink\" title=\"4.patch 原理\"></a>4.patch 原理</h3><h4 id=\"patch-函数接收-6-个参数\"><a href=\"#patch-函数接收-6-个参数\" class=\"headerlink\" title=\"patch 函数接收 6 个参数\"></a>patch 函数接收 6 个参数</h4><ol>\n<li><code>oldVnode</code>: 旧的虚拟节点或旧的真实 <code>dom</code> 节点</li>\n<li><code>vnode</code>: 新的虚拟节点</li>\n<li><code>hydrating</code>: 是否要跟真实 <code>dom</code> 混合</li>\n<li><code>removeOnly</code>: 特殊 <code>flag</code>，用于 <code>&lt;transition-group&gt;</code> 组件</li>\n<li><code>parentElm</code>: 父节点</li>\n<li><code>refElm</code>: 新节点将插入到 <code>refElm</code> 之前</li>\n</ol>\n<h4 id=\"patch-的策略\"><a href=\"#patch-的策略\" class=\"headerlink\" title=\"patch 的策略\"></a>patch 的策略</h4><ul>\n<li>如果<code>vnode</code> 不存在但是 <code>oldVnode</code> 存在，说明意图是要销毁老节点，那么就调用 <code>invokeDestroyHook(oldVnode)</code> 来进行销毁</li>\n<li>如果 <code>oldVnode</code> 不存在但是 <code>vnode</code> 存在，说明意图是要创建新节点，那么就调用 <code>createElm</code> 来创建新节点</li>\n<li>当 <code>vnode</code> 和 <code>oldVnode</code> 都存在时<ul>\n<li>如果 <code>oldVnode</code> 和 <code>vnode</code> 是同一个节点，就调用 <code>patchVnode</code> 来进行 <code>patch</code></li>\n<li>当 <code>vnode</code> 和 <code>oldVnode</code> 不是同一个节点时，如果 <code>oldVnode</code> 是真实 <code>dom</code> 节点 或 <code>hydrating</code> 设置为<code>true</code>，需要用 <code>hydrate</code> 函数将虚拟 <code>dom</code> 和真实 <code>dom</code> 进行映射，然后将 <code>oldVnode</code> 设置为对应的虚拟 <code>dom</code>，找到 <code>oldVnode.elm</code> 的父节点，根据 <code>vnode</code> 创建一个真实 <code>dom</code> 节点并插入到该父节点中 <code>oldVnode.elm</code> 的位置</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>这里面值得一提的是 <code>patchVnode</code> 函数，因为真正的 <code>patch</code> 算法是由它来实现的（<code>patchVnode</code> 中更新子节点的算法其实是在 <code>updateChildren</code> 函数中实现的</p>\n</blockquote>\n<h4 id=\"patchVnode-算法\"><a href=\"#patchVnode-算法\" class=\"headerlink\" title=\"patchVnode 算法\"></a>patchVnode 算法</h4><ol>\n<li>如果 <code>oldVnode</code> 跟 <code>vnode</code> 完全一致，那么不需要做任何事情</li>\n<li>如果 <code>oldVnode</code> 跟 <code>vnode</code> 都是静态节点，且具有相同的 <code>key</code>，当 <code>vnode</code> 是克隆节点或是 <code>v-once</code> 指令控制的节点时，只需要把 <code>oldVnode.elm</code> 和 <code>oldVnode.child</code> 都复制到 <code>vnode</code> 上，也不用再有其他操作</li>\n<li>否则，如果<code>vnode</code>不是文本节点或注释节点</li>\n</ol>\n<ul>\n<li>如果 <code>oldVnode</code>和 <code>vnode</code> 都有子节点，且双方的子节点不完全一致，就执行更新子节点的操作（这一部分其实是在 <code>updateChildren</code> 函数中实现），算法如下:</li>\n</ul>\n<blockquote>\n<p>分别获取 <code>oldVnode</code> 和 <code>vnode</code> 的 <code>firstChild</code>、<code>lastChild</code>，赋值给 <code>oldStartVnode</code>、<code>oldEndVnode</code>、<code>newStartVnode</code>、<code>newEndVnode</code></p>\n</blockquote>\n<blockquote>\n<p>如果 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，然后将 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 都设置为下一个子节点，重复上述流程<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704111320-57210d35-7b20-45f7-87b1-8a6a541754bc.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&name=virtual_dom1.png&originHeight=204&originWidth=667&size=20067&status=done&style=none&width=667\" alt=\"virtual_dom1.png\"></p>\n</blockquote>\n<blockquote>\n<p>如果 <code>oldEndVnode</code> 和 <code>newEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，然后将 <code>oldEndVnode</code> 和 <code>newEndVnode</code> 都设置为上一个子节点，重复上述流程<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704123342-e1a719db-cacd-4fe3-a4b5-730e73dec203.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=virtual_dom2.png&originHeight=221&originWidth=676&size=19741&status=done&style=none&width=676\" alt=\"virtual_dom2.png\"></p>\n</blockquote>\n<blockquote>\n<p>如果 <code>oldStartVnode</code> 和 <code>newEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是<code>false</code>，那么可以把 <code>oldStartVnode.elm</code> 移动到 <code>oldEndVnode.elm</code> 之后，然后把 <code>oldStartVnode</code> 设置为下一个节点，<code>newEndVnode</code> 设置为上一个节点，重复上述流程<img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704137134-da7b6eab-d7ab-4e0d-bd3c-816548aa7050.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&name=virtual_dom3.png&originHeight=224&originWidth=826&size=24829&status=done&style=none&width=826\" alt=\"virtual_dom3.png\"></p>\n</blockquote>\n<blockquote>\n<p>如果 <code>newStartVnode</code> 和 <code>oldEndVnode</code> 是同一节点，调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是 <code>false</code>，那么可以把 <code>oldEndVnode.elm</code> 移动到 <code>oldStartVnode.elm</code> 之前，然后把 <code>newStartVnode</code> 设置为下一个节点，<code>oldEndVnode</code> 设置为上一个节点，重复上述流程<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704166102-db7c7879-3e36-49db-9e96-9f587cfcb771.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=virtual_dom4.png&originHeight=214&originWidth=864&size=24556&status=done&style=none&width=864\" alt=\"virtual_dom4.png\"></p>\n</blockquote>\n<blockquote>\n<p>如果以上都不匹配，就尝试在 <code>oldChildren</code> 中寻找跟 <code>newStartVnode</code> 具有相同 <code>key</code> 的节点，如果找不到相同 <code>key</code>的节点，说明 <code>newStartVnode</code> 是一个新节点，就创建一个，然后把 <code>newStartVnode</code> 设置为下一个节点</p>\n</blockquote>\n<blockquote>\n<p>如果上一步找到了跟 <code>newStartVnode</code> 相同 <code>key</code> 的节点，那么通过其他属性的比较来判断这 2 个节点是否是同一个节点，如果是，就调用 <code>patchVnode</code> 进行 <code>patch</code>，如果 <code>removeOnly</code> 是 <code>false</code>，就把 <code>newStartVnode.elm</code> 插入到 <code>oldStartVnode.elm</code> 之前，把 <code>newStartVnode</code> 设置为下一个节点，重复上述流程<br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608704181185-2af64dae-c1a4-4505-aeeb-5ec7efad8930.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=virtual_dom5.png&originHeight=227&originWidth=869&size=24398&status=done&style=none&width=869\" alt=\"virtual_dom5.png\"></p>\n</blockquote>\n<ul>\n<li>如果只有 <code>oldVnode</code> 有子节点，那就把这些节点都删除</li>\n<li>如果只有 <code>vnode</code> 有子节点，那就创建这些子节点</li>\n<li>如果 <code>oldVnode和vnode</code> 都没有子节点，但是 <code>oldVnode</code> 是文本节点或注释节点，就把 <code>vnode.elm</code> 的文本设置为空字符串</li>\n</ul>\n<ol start=\"4\">\n<li>如果 <code>vnode</code> 是文本节点或注释节点，但是 <code>vnode.text != oldVnode.text</code> 时，只需要更新 <code>vnode.elm</code> 的文本内容就可以</li>\n</ol>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><ul>\n<li><code>patch</code> 提供了 <code>5</code> 个生命周期钩子，分别是<ul>\n<li><code>create</code>: 创建 <code>patch</code> 时</li>\n<li><code>activate</code>: 激活组件时</li>\n<li><code>update</code>: 更新节点时</li>\n<li><code>remove</code>: 移除节点时</li>\n<li><code>destroy</code>: 销毁节点时</li>\n</ul>\n</li>\n<li><code>vnode</code>也提供了生命周期钩子，分别是<ul>\n<li><code>init</code>: <code>vdom</code> 初始化时</li>\n<li><code>create</code>: <code>vdom</code> 创建时</li>\n<li><code>prepatch</code>: <code>patch</code> 之前</li>\n<li><code>insert</code>: <code>vdom</code> 插入后</li>\n<li><code>update</code>: <code>vdom</code> 更新前</li>\n<li><code>postpatch</code>: <code>patch</code> 之后</li>\n<li><code>remove</code>: <code>vdom</code> 移除时</li>\n<li><code>destroy</code>: <code>vdom</code> 销毁时</li>\n</ul>\n</li>\n</ul>\n"},{"title":"编写 React 组件时常见的 5 个错误","date":"2021-02-28T16:00:00.000Z","_content":"\n## 1. 在不需要重渲染时使用 useState\n\nReact 的一个核心概念是处理状态。你可以通过状态控制整个数据流和渲染过程。每次树被重新渲染时，很可能是因为状态的变化。\n\n使用 useState hook，你现在还可以在函数组件中定义状态，这种方法可以真正简洁地在 React 中处理状态。但正如以下示例所示，它也可能被滥用。\n\n关于下面这个示例我们需要说明一下。假设我们有两个按钮，一个按钮是计数器，另一个按钮使用当前计数发送请求或触发动作。但是，当前编号永远不会显示在组件内。当你单击第二个按钮时才需要这个请求。\n\n这很危险❌\n\n```jsx\nfunction ClickButton(props) {\n  const [count, setCount] = useState(0);\n  const onClickCount = () => {\n    setCount((c) => c + 1);\n  };\n  const onClickRequest = () => {\n    apiCall(count);\n  };\n  return (\n    <div>\n      <button onClick={onClickCount}>Counter</button>\n      <button onClick={onClickRequest}>Submit</button>\n    </div>\n  );\n}\n```\n\n### 问题⚡\n\n乍一看，你可能会问这到底有什么问题？状态不就是这样用的吗？你当然没错，它运行很正常，并且可能永远不会出问题，但是在 React 中，每个状态更改都将强制对该组件，很有可能还有其子级进行重渲染，但在上面的示例中，因为我们从未在渲染部分中使用这个状态，结果每次设置计数器时都会有不必要的重渲染，这可能会影响性能或产生意外的副作用。\n\n### 解决方案✅\n\n如果要在组件内部使用一个变量，希望该变量在渲染之间保持其值，但又不强制重新渲染，则可以使用 useRef hook。它将保留值，但不强制重新渲染组件。\n\n```jsx\nfunction ClickButton(props) {\n  const count = useRef(0);\n  const onClickCount = () => {\n    count.current++;\n  };\n  const onClickRequest = () => {\n    apiCall(count.current);\n  };\n  return (\n    <div>\n      <button onClick={onClickCount}>Counter</button>\n      <button onClick={onClickRequest}>Submit</button>\n    </div>\n  );\n}\n```\n\n## 2. 使用 router.push 代替链接\n\n这可能是一个显而易见的错误，其实和 React 本身没什么关系，但是当人们编写 React 组件时经常会犯这种错误。\n\n假设你要编写一个按钮，单击该按钮应将用户重定向到另一个页面。由于它是一个 SPA，因此这个动作是客户端路由机制。于是你需要某种库来执行此动作。在 React 中最流行的是 react-router，下面的示例就会使用它。\n\n所以，添加一个点击侦听器会将用户重定向到所需的页面，对吗？\n\n### 这很危险❌\n\n```jsx\nfunction ClickButton(props) {\n  const history = useHistory();\n  const onClick = () => {\n    history.push('/next-page');\n  };\n  return <button onClick={onClick}>Go to next page</button>;\n}\n```\n\n### 问题⚡\n\n就算这段代码对于大多数用户来说都可以正常工作，但这里也有严重的可访问性问题。这个按钮根本不会被标记为链接到另一个页面，于是屏幕阅读器几乎无法识别它。而且你能在新标签页或窗口中打开它吗？很可能做不到。\n\n### 解决方案✅\n\n只要指向其他页面的链接带有某种用户交互，就要尽量用 < Link> 组件或常规的 < a> 标签处理。\n\n```jsx\nfunction ClickButton(props) {\n  return (\n    <Link to=\"/next-page\">\n      <span>Go to next page</span>\n    </Link>\n  );\n}\n```\n\n优点：这也使代码更易读，更短！\n\n## 3. 通过 useEffect 处理动作\n\nReact 引入的最好用，最贴心的一个 hook 是 useEffect。它可以处理与 prop 或 state 更改相关的动作。可就算它很好用，人们也不该到处滥用它。\n\n想象一下有一个组件，其获取一个项目列表并将其渲染给 dom。另外，如果请求成功，我们将调用“onSuccess”函数，该函数作为一个 prop 传递给这个组件。\n\n### 这很危险❌\n\n```jsx\nfunction DataList({ onSuccess }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const fetchData = useCallback(() => {\n    setLoading(true);\n    callApi()\n      .then((res) => setData(res))\n      .catch((err) => setError(err))\n      .finally(() => setLoading(false));\n  }, []);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  useEffect(() => {\n    if (!loading && !error && data) {\n      onSuccess();\n    }\n  }, [loading, error, data, onSuccess]);\n  return <div>Data: {data}</div>;\n}\n```\n\n### 问题⚡\n\n一共有两个 useEffect hooks，第一个在初始渲染时处理 api 调用，第二个会调用 onSuccess 函数，假设当状态没有加载、没有错误但有数据时调用肯定成功。这很有道理是吧？\n\n对第一个调用来说这肯定是正确的，并且可能永远不会失败。但你也失去了动作和需要调用的函数之间的直接联系。同样也没有 100％的保证可以说这种情况仅在 fetch 动作成功后才会发生，而这正是我们开发人员不想看到的。\n\n### 解决方案✅\n\n一个简单明了的解决方案是将“onSuccess”函数设置为调用成功的实际位置：\n\n```jsx\nfunction DataList({ onSuccess }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const fetchData = useCallback(() => {\n    setLoading(true);\n    callApi()\n      .then((fetchedData) => {\n        setData(fetchedData);\n        onSuccess();\n      })\n      .catch((err) => setError(err))\n      .finally(() => setLoading(false));\n  }, [onSuccess]);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  return <div>{data}</div>;\n}\n```\n\n现在一目了然了，在 api 调用成功的情况下才调用 onSuccess。\n\n## 4. 单一责任组件\n\n组合组件可能不是什么轻松的事情。什么时候将一个组件拆分为几个较小的组件？如何构造组件树？使用基于组件的框架时，每天都会遇到这些问题。设计组件时常见的一个错误是将两个用例合并到一个组件中。以一个 header 为例，其在移动设备上显示一个汉堡按钮，或在桌面屏幕上显示标签。（这里的条件通过神奇的 isMobile 函数处理，这里就不深入讲解了。）\n\n### 这很危险❌\n\n```jsx\nfunction Header(props) {\n  return (\n    <header>\n      <HeaderInner menuItems={menuItems} />\n    </header>\n  );\n}\nfunction HeaderInner({ menuItems }) {\n  return isMobile() ? \n        <BurgerButton menuItems={menuItems} /> : \n        <Tabs tabData={menuItems} />;\n}\n```\n\n### 问题⚡\n\n使用这种方法时，HeaderInner 组件试图同时兼顾两件事情，而我们都知道一心最好不要二用。而且，这种组件很难在其他地方测试或重用。\n\n### 解决方案✅\n\n将条件提高一级，这样就能更容易看清组件的本来用途，搞明白它们只应该负责一个任务，不管是 Header、Tab 或 BurgerButton 也好，总之不要一心多用。\n\n```jsx\nfunction Header(props) {\n  return (\n    <header>\n        {\n            isMobile() ? \n                <BurgerButton menuItems={menuItems} /> : \n                <Tabs tabData={menuItems} />\n        }\n        </header>\n  );\n}\n```\n\n## 5. 单一责任的 useEffects\n\n还记得以前，我们只能用 componentWillReceiveProps 或 componentDidUpdate 方法挂接到 React 组件的渲染过程吗？那是一段黑暗的回忆，也让我们意识到了 useEffect hook 的美妙之处，尤其是你可以随意使用这些 hooks。\n\n但是有时因为粗心而让“useEffect”身兼数职，就会带回那些黑暗的回忆。例如，假设你有一个组件以某种方式从后端获取一些数据，并且还会根据当前位置显示面包屑。（再次使用 react-router 获取当前位置。）\n\n### 这很危险❌\n\n```jsx\nfunction Example(props) {\n  const location = useLocation();\n  const fetchData = useCallback(() => {\n    /*  Calling the api */\n  }, []);\n  const updateBreadcrumbs = useCallback(() => {\n    /* Updating the breadcrumbs*/\n  }, []);\n  useEffect(() => {\n    fetchData();\n    updateBreadcrumbs();\n  }, [location.pathname, fetchData, updateBreadcrumbs]);\n  return (\n    <div>\n      <BreadCrumbs />\n    </div>\n  );\n}\n```\n\n### 问题⚡\n\n这里有两个用例，即“数据获取”和“显示面包屑”。两者都通过 useEffect hook 更新。当 fetchData 和 updateBreadcrumbs 函数或 location 更改时，都会运行这个 useEffect hook。现在的主要问题是，当位置更改时，我们还调用了 fetchData 函数。这可能是我们没有想到的副作用。\n\n### 解决方案✅\n\n把效果拆分开来，确保它们只用于一种效果，意外的副作用也就消失了。\n\n```jsx\nfunction Example(props) {\n  const location = useLocation();\n  const updateBreadcrumbs = useCallback(() => {\n    /* Updating the breadcrumbs*/\n  }, []);\n  useEffect(() => {\n    updateBreadcrumbs();\n  }, [location.pathname, updateBreadcrumbs]);\n  const fetchData = useCallback(() => {\n    /*  Calling the api */\n  }, []);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  return (\n    <div>\n      <BreadCrumbs />\n    </div>\n  );\n}\n```\n\n**额外的收获是**，这些用例现在也在组件内按顺序排好了。\n","source":"_posts/前端/编写 React 组件时常见的 5 个错误.md","raw":"---\ntitle: 编写 React 组件时常见的 5 个错误\ndate: 2021-03-01\ncategories: [前端, react]\ntags: \n  - react\n---\n\n## 1. 在不需要重渲染时使用 useState\n\nReact 的一个核心概念是处理状态。你可以通过状态控制整个数据流和渲染过程。每次树被重新渲染时，很可能是因为状态的变化。\n\n使用 useState hook，你现在还可以在函数组件中定义状态，这种方法可以真正简洁地在 React 中处理状态。但正如以下示例所示，它也可能被滥用。\n\n关于下面这个示例我们需要说明一下。假设我们有两个按钮，一个按钮是计数器，另一个按钮使用当前计数发送请求或触发动作。但是，当前编号永远不会显示在组件内。当你单击第二个按钮时才需要这个请求。\n\n这很危险❌\n\n```jsx\nfunction ClickButton(props) {\n  const [count, setCount] = useState(0);\n  const onClickCount = () => {\n    setCount((c) => c + 1);\n  };\n  const onClickRequest = () => {\n    apiCall(count);\n  };\n  return (\n    <div>\n      <button onClick={onClickCount}>Counter</button>\n      <button onClick={onClickRequest}>Submit</button>\n    </div>\n  );\n}\n```\n\n### 问题⚡\n\n乍一看，你可能会问这到底有什么问题？状态不就是这样用的吗？你当然没错，它运行很正常，并且可能永远不会出问题，但是在 React 中，每个状态更改都将强制对该组件，很有可能还有其子级进行重渲染，但在上面的示例中，因为我们从未在渲染部分中使用这个状态，结果每次设置计数器时都会有不必要的重渲染，这可能会影响性能或产生意外的副作用。\n\n### 解决方案✅\n\n如果要在组件内部使用一个变量，希望该变量在渲染之间保持其值，但又不强制重新渲染，则可以使用 useRef hook。它将保留值，但不强制重新渲染组件。\n\n```jsx\nfunction ClickButton(props) {\n  const count = useRef(0);\n  const onClickCount = () => {\n    count.current++;\n  };\n  const onClickRequest = () => {\n    apiCall(count.current);\n  };\n  return (\n    <div>\n      <button onClick={onClickCount}>Counter</button>\n      <button onClick={onClickRequest}>Submit</button>\n    </div>\n  );\n}\n```\n\n## 2. 使用 router.push 代替链接\n\n这可能是一个显而易见的错误，其实和 React 本身没什么关系，但是当人们编写 React 组件时经常会犯这种错误。\n\n假设你要编写一个按钮，单击该按钮应将用户重定向到另一个页面。由于它是一个 SPA，因此这个动作是客户端路由机制。于是你需要某种库来执行此动作。在 React 中最流行的是 react-router，下面的示例就会使用它。\n\n所以，添加一个点击侦听器会将用户重定向到所需的页面，对吗？\n\n### 这很危险❌\n\n```jsx\nfunction ClickButton(props) {\n  const history = useHistory();\n  const onClick = () => {\n    history.push('/next-page');\n  };\n  return <button onClick={onClick}>Go to next page</button>;\n}\n```\n\n### 问题⚡\n\n就算这段代码对于大多数用户来说都可以正常工作，但这里也有严重的可访问性问题。这个按钮根本不会被标记为链接到另一个页面，于是屏幕阅读器几乎无法识别它。而且你能在新标签页或窗口中打开它吗？很可能做不到。\n\n### 解决方案✅\n\n只要指向其他页面的链接带有某种用户交互，就要尽量用 < Link> 组件或常规的 < a> 标签处理。\n\n```jsx\nfunction ClickButton(props) {\n  return (\n    <Link to=\"/next-page\">\n      <span>Go to next page</span>\n    </Link>\n  );\n}\n```\n\n优点：这也使代码更易读，更短！\n\n## 3. 通过 useEffect 处理动作\n\nReact 引入的最好用，最贴心的一个 hook 是 useEffect。它可以处理与 prop 或 state 更改相关的动作。可就算它很好用，人们也不该到处滥用它。\n\n想象一下有一个组件，其获取一个项目列表并将其渲染给 dom。另外，如果请求成功，我们将调用“onSuccess”函数，该函数作为一个 prop 传递给这个组件。\n\n### 这很危险❌\n\n```jsx\nfunction DataList({ onSuccess }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const fetchData = useCallback(() => {\n    setLoading(true);\n    callApi()\n      .then((res) => setData(res))\n      .catch((err) => setError(err))\n      .finally(() => setLoading(false));\n  }, []);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  useEffect(() => {\n    if (!loading && !error && data) {\n      onSuccess();\n    }\n  }, [loading, error, data, onSuccess]);\n  return <div>Data: {data}</div>;\n}\n```\n\n### 问题⚡\n\n一共有两个 useEffect hooks，第一个在初始渲染时处理 api 调用，第二个会调用 onSuccess 函数，假设当状态没有加载、没有错误但有数据时调用肯定成功。这很有道理是吧？\n\n对第一个调用来说这肯定是正确的，并且可能永远不会失败。但你也失去了动作和需要调用的函数之间的直接联系。同样也没有 100％的保证可以说这种情况仅在 fetch 动作成功后才会发生，而这正是我们开发人员不想看到的。\n\n### 解决方案✅\n\n一个简单明了的解决方案是将“onSuccess”函数设置为调用成功的实际位置：\n\n```jsx\nfunction DataList({ onSuccess }) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [data, setData] = useState(null);\n  const fetchData = useCallback(() => {\n    setLoading(true);\n    callApi()\n      .then((fetchedData) => {\n        setData(fetchedData);\n        onSuccess();\n      })\n      .catch((err) => setError(err))\n      .finally(() => setLoading(false));\n  }, [onSuccess]);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  return <div>{data}</div>;\n}\n```\n\n现在一目了然了，在 api 调用成功的情况下才调用 onSuccess。\n\n## 4. 单一责任组件\n\n组合组件可能不是什么轻松的事情。什么时候将一个组件拆分为几个较小的组件？如何构造组件树？使用基于组件的框架时，每天都会遇到这些问题。设计组件时常见的一个错误是将两个用例合并到一个组件中。以一个 header 为例，其在移动设备上显示一个汉堡按钮，或在桌面屏幕上显示标签。（这里的条件通过神奇的 isMobile 函数处理，这里就不深入讲解了。）\n\n### 这很危险❌\n\n```jsx\nfunction Header(props) {\n  return (\n    <header>\n      <HeaderInner menuItems={menuItems} />\n    </header>\n  );\n}\nfunction HeaderInner({ menuItems }) {\n  return isMobile() ? \n        <BurgerButton menuItems={menuItems} /> : \n        <Tabs tabData={menuItems} />;\n}\n```\n\n### 问题⚡\n\n使用这种方法时，HeaderInner 组件试图同时兼顾两件事情，而我们都知道一心最好不要二用。而且，这种组件很难在其他地方测试或重用。\n\n### 解决方案✅\n\n将条件提高一级，这样就能更容易看清组件的本来用途，搞明白它们只应该负责一个任务，不管是 Header、Tab 或 BurgerButton 也好，总之不要一心多用。\n\n```jsx\nfunction Header(props) {\n  return (\n    <header>\n        {\n            isMobile() ? \n                <BurgerButton menuItems={menuItems} /> : \n                <Tabs tabData={menuItems} />\n        }\n        </header>\n  );\n}\n```\n\n## 5. 单一责任的 useEffects\n\n还记得以前，我们只能用 componentWillReceiveProps 或 componentDidUpdate 方法挂接到 React 组件的渲染过程吗？那是一段黑暗的回忆，也让我们意识到了 useEffect hook 的美妙之处，尤其是你可以随意使用这些 hooks。\n\n但是有时因为粗心而让“useEffect”身兼数职，就会带回那些黑暗的回忆。例如，假设你有一个组件以某种方式从后端获取一些数据，并且还会根据当前位置显示面包屑。（再次使用 react-router 获取当前位置。）\n\n### 这很危险❌\n\n```jsx\nfunction Example(props) {\n  const location = useLocation();\n  const fetchData = useCallback(() => {\n    /*  Calling the api */\n  }, []);\n  const updateBreadcrumbs = useCallback(() => {\n    /* Updating the breadcrumbs*/\n  }, []);\n  useEffect(() => {\n    fetchData();\n    updateBreadcrumbs();\n  }, [location.pathname, fetchData, updateBreadcrumbs]);\n  return (\n    <div>\n      <BreadCrumbs />\n    </div>\n  );\n}\n```\n\n### 问题⚡\n\n这里有两个用例，即“数据获取”和“显示面包屑”。两者都通过 useEffect hook 更新。当 fetchData 和 updateBreadcrumbs 函数或 location 更改时，都会运行这个 useEffect hook。现在的主要问题是，当位置更改时，我们还调用了 fetchData 函数。这可能是我们没有想到的副作用。\n\n### 解决方案✅\n\n把效果拆分开来，确保它们只用于一种效果，意外的副作用也就消失了。\n\n```jsx\nfunction Example(props) {\n  const location = useLocation();\n  const updateBreadcrumbs = useCallback(() => {\n    /* Updating the breadcrumbs*/\n  }, []);\n  useEffect(() => {\n    updateBreadcrumbs();\n  }, [location.pathname, updateBreadcrumbs]);\n  const fetchData = useCallback(() => {\n    /*  Calling the api */\n  }, []);\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  return (\n    <div>\n      <BreadCrumbs />\n    </div>\n  );\n}\n```\n\n**额外的收获是**，这些用例现在也在组件内按顺序排好了。\n","slug":"前端/编写 React 组件时常见的 5 个错误","published":1,"updated":"2021-04-07T07:39:11.351Z","_id":"ckn7476ai002iyx7y4htk6ur4","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-在不需要重渲染时使用-useState\"><a href=\"#1-在不需要重渲染时使用-useState\" class=\"headerlink\" title=\"1. 在不需要重渲染时使用 useState\"></a>1. 在不需要重渲染时使用 useState</h2><p>React 的一个核心概念是处理状态。你可以通过状态控制整个数据流和渲染过程。每次树被重新渲染时，很可能是因为状态的变化。</p>\n<p>使用 useState hook，你现在还可以在函数组件中定义状态，这种方法可以真正简洁地在 React 中处理状态。但正如以下示例所示，它也可能被滥用。</p>\n<p>关于下面这个示例我们需要说明一下。假设我们有两个按钮，一个按钮是计数器，另一个按钮使用当前计数发送请求或触发动作。但是，当前编号永远不会显示在组件内。当你单击第二个按钮时才需要这个请求。</p>\n<p>这很危险❌</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ClickButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickCount = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    setCount(<span class=\"function\">(<span class=\"params\">c</span>) =&gt;</span> c + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickRequest = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    apiCall(count);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClickCount&#125;&gt;Counter&lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClickRequest&#125;&gt;Submit&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡\"><a href=\"#问题⚡\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>乍一看，你可能会问这到底有什么问题？状态不就是这样用的吗？你当然没错，它运行很正常，并且可能永远不会出问题，但是在 React 中，每个状态更改都将强制对该组件，很有可能还有其子级进行重渲染，但在上面的示例中，因为我们从未在渲染部分中使用这个状态，结果每次设置计数器时都会有不必要的重渲染，这可能会影响性能或产生意外的副作用。</p>\n<h3 id=\"解决方案✅\"><a href=\"#解决方案✅\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>如果要在组件内部使用一个变量，希望该变量在渲染之间保持其值，但又不强制重新渲染，则可以使用 useRef hook。它将保留值，但不强制重新渲染组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ClickButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = useRef(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickCount = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    count.current++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickRequest = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    apiCall(count.current);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClickCount&#125;&gt;Counter&lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClickRequest&#125;&gt;Submit&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-使用-router-push-代替链接\"><a href=\"#2-使用-router-push-代替链接\" class=\"headerlink\" title=\"2. 使用 router.push 代替链接\"></a>2. 使用 router.push 代替链接</h2><p>这可能是一个显而易见的错误，其实和 React 本身没什么关系，但是当人们编写 React 组件时经常会犯这种错误。</p>\n<p>假设你要编写一个按钮，单击该按钮应将用户重定向到另一个页面。由于它是一个 SPA，因此这个动作是客户端路由机制。于是你需要某种库来执行此动作。在 React 中最流行的是 react-router，下面的示例就会使用它。</p>\n<p>所以，添加一个点击侦听器会将用户重定向到所需的页面，对吗？</p>\n<h3 id=\"这很危险❌\"><a href=\"#这很危险❌\" class=\"headerlink\" title=\"这很危险❌\"></a>这很危险❌</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ClickButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> history = useHistory();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClick = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    history.push(<span class=\"string\">&#x27;/next-page&#x27;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClick&#125;</span>&gt;</span>Go to next page<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡-1\"><a href=\"#问题⚡-1\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>就算这段代码对于大多数用户来说都可以正常工作，但这里也有严重的可访问性问题。这个按钮根本不会被标记为链接到另一个页面，于是屏幕阅读器几乎无法识别它。而且你能在新标签页或窗口中打开它吗？很可能做不到。</p>\n<h3 id=\"解决方案✅-1\"><a href=\"#解决方案✅-1\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>只要指向其他页面的链接带有某种用户交互，就要尽量用 &lt; Link&gt; 组件或常规的 &lt; a&gt; 标签处理。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ClickButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Link to=<span class=\"string\">&quot;/next-page&quot;</span>&gt;</span><br><span class=\"line\">      &lt;span&gt;Go to next page&lt;/span&gt;</span><br><span class=\"line\">    &lt;/Link&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优点：这也使代码更易读，更短！</p>\n<h2 id=\"3-通过-useEffect-处理动作\"><a href=\"#3-通过-useEffect-处理动作\" class=\"headerlink\" title=\"3. 通过 useEffect 处理动作\"></a>3. 通过 useEffect 处理动作</h2><p>React 引入的最好用，最贴心的一个 hook 是 useEffect。它可以处理与 prop 或 state 更改相关的动作。可就算它很好用，人们也不该到处滥用它。</p>\n<p>想象一下有一个组件，其获取一个项目列表并将其渲染给 dom。另外，如果请求成功，我们将调用“onSuccess”函数，该函数作为一个 prop 传递给这个组件。</p>\n<h3 id=\"这很危险❌-1\"><a href=\"#这很危险❌-1\" class=\"headerlink\" title=\"这很危险❌\"></a>这很危险❌</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DataList</span>(<span class=\"params\">&#123; onSuccess &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [loading, setLoading] = useState(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [error, setError] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [data, setData] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    setLoading(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    callApi()</span><br><span class=\"line\">      .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> setData(res))</span><br><span class=\"line\">      .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> setError(err))</span><br><span class=\"line\">      .finally(<span class=\"function\">() =&gt;</span> setLoading(<span class=\"literal\">false</span>));</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, [fetchData]);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loading &amp;&amp; !error &amp;&amp; data) &#123;</span><br><span class=\"line\">      onSuccess();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, [loading, error, data, onSuccess]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Data: &#123;data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡-2\"><a href=\"#问题⚡-2\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>一共有两个 useEffect hooks，第一个在初始渲染时处理 api 调用，第二个会调用 onSuccess 函数，假设当状态没有加载、没有错误但有数据时调用肯定成功。这很有道理是吧？</p>\n<p>对第一个调用来说这肯定是正确的，并且可能永远不会失败。但你也失去了动作和需要调用的函数之间的直接联系。同样也没有 100％的保证可以说这种情况仅在 fetch 动作成功后才会发生，而这正是我们开发人员不想看到的。</p>\n<h3 id=\"解决方案✅-2\"><a href=\"#解决方案✅-2\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>一个简单明了的解决方案是将“onSuccess”函数设置为调用成功的实际位置：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DataList</span>(<span class=\"params\">&#123; onSuccess &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [loading, setLoading] = useState(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [error, setError] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [data, setData] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    setLoading(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    callApi()</span><br><span class=\"line\">      .then(<span class=\"function\">(<span class=\"params\">fetchedData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setData(fetchedData);</span><br><span class=\"line\">        onSuccess();</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> setError(err))</span><br><span class=\"line\">      .finally(<span class=\"function\">() =&gt;</span> setLoading(<span class=\"literal\">false</span>));</span><br><span class=\"line\">  &#125;, [onSuccess]);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, [fetchData]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在一目了然了，在 api 调用成功的情况下才调用 onSuccess。</p>\n<h2 id=\"4-单一责任组件\"><a href=\"#4-单一责任组件\" class=\"headerlink\" title=\"4. 单一责任组件\"></a>4. 单一责任组件</h2><p>组合组件可能不是什么轻松的事情。什么时候将一个组件拆分为几个较小的组件？如何构造组件树？使用基于组件的框架时，每天都会遇到这些问题。设计组件时常见的一个错误是将两个用例合并到一个组件中。以一个 header 为例，其在移动设备上显示一个汉堡按钮，或在桌面屏幕上显示标签。（这里的条件通过神奇的 isMobile 函数处理，这里就不深入讲解了。）</p>\n<h3 id=\"这很危险❌-2\"><a href=\"#这很危险❌-2\" class=\"headerlink\" title=\"这很危险❌\"></a>这很危险❌</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Header</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;HeaderInner menuItems=&#123;menuItems&#125; /&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HeaderInner</span>(<span class=\"params\">&#123; menuItems &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isMobile() ? </span><br><span class=\"line\">        &lt;BurgerButton menuItems=&#123;menuItems&#125; /&gt; : </span><br><span class=\"line\">        &lt;Tabs tabData=&#123;menuItems&#125; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡-3\"><a href=\"#问题⚡-3\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>使用这种方法时，HeaderInner 组件试图同时兼顾两件事情，而我们都知道一心最好不要二用。而且，这种组件很难在其他地方测试或重用。</p>\n<h3 id=\"解决方案✅-3\"><a href=\"#解决方案✅-3\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>将条件提高一级，这样就能更容易看清组件的本来用途，搞明白它们只应该负责一个任务，不管是 Header、Tab 或 BurgerButton 也好，总之不要一心多用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Header</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            isMobile() ? </span><br><span class=\"line\">                &lt;BurgerButton menuItems=&#123;menuItems&#125; /&gt; : </span><br><span class=\"line\">                &lt;Tabs tabData=&#123;menuItems&#125; /&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-单一责任的-useEffects\"><a href=\"#5-单一责任的-useEffects\" class=\"headerlink\" title=\"5. 单一责任的 useEffects\"></a>5. 单一责任的 useEffects</h2><p>还记得以前，我们只能用 componentWillReceiveProps 或 componentDidUpdate 方法挂接到 React 组件的渲染过程吗？那是一段黑暗的回忆，也让我们意识到了 useEffect hook 的美妙之处，尤其是你可以随意使用这些 hooks。</p>\n<p>但是有时因为粗心而让“useEffect”身兼数职，就会带回那些黑暗的回忆。例如，假设你有一个组件以某种方式从后端获取一些数据，并且还会根据当前位置显示面包屑。（再次使用 react-router 获取当前位置。）</p>\n<h3 id=\"这很危险❌-3\"><a href=\"#这很危险❌-3\" class=\"headerlink\" title=\"这很危险❌\"></a>这很危险❌</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> location = useLocation();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  Calling the api */</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> updateBreadcrumbs = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Updating the breadcrumbs*/</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">    updateBreadcrumbs();</span><br><span class=\"line\">  &#125;, [location.pathname, fetchData, updateBreadcrumbs]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;BreadCrumbs /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡-4\"><a href=\"#问题⚡-4\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>这里有两个用例，即“数据获取”和“显示面包屑”。两者都通过 useEffect hook 更新。当 fetchData 和 updateBreadcrumbs 函数或 location 更改时，都会运行这个 useEffect hook。现在的主要问题是，当位置更改时，我们还调用了 fetchData 函数。这可能是我们没有想到的副作用。</p>\n<h3 id=\"解决方案✅-4\"><a href=\"#解决方案✅-4\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>把效果拆分开来，确保它们只用于一种效果，意外的副作用也就消失了。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> location = useLocation();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> updateBreadcrumbs = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Updating the breadcrumbs*/</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    updateBreadcrumbs();</span><br><span class=\"line\">  &#125;, [location.pathname, updateBreadcrumbs]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  Calling the api */</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, [fetchData]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;BreadCrumbs /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>额外的收获是</strong>，这些用例现在也在组件内按顺序排好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-在不需要重渲染时使用-useState\"><a href=\"#1-在不需要重渲染时使用-useState\" class=\"headerlink\" title=\"1. 在不需要重渲染时使用 useState\"></a>1. 在不需要重渲染时使用 useState</h2><p>React 的一个核心概念是处理状态。你可以通过状态控制整个数据流和渲染过程。每次树被重新渲染时，很可能是因为状态的变化。</p>\n<p>使用 useState hook，你现在还可以在函数组件中定义状态，这种方法可以真正简洁地在 React 中处理状态。但正如以下示例所示，它也可能被滥用。</p>\n<p>关于下面这个示例我们需要说明一下。假设我们有两个按钮，一个按钮是计数器，另一个按钮使用当前计数发送请求或触发动作。但是，当前编号永远不会显示在组件内。当你单击第二个按钮时才需要这个请求。</p>\n<p>这很危险❌</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ClickButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickCount = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    setCount(<span class=\"function\">(<span class=\"params\">c</span>) =&gt;</span> c + <span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickRequest = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    apiCall(count);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClickCount&#125;&gt;Counter&lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClickRequest&#125;&gt;Submit&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡\"><a href=\"#问题⚡\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>乍一看，你可能会问这到底有什么问题？状态不就是这样用的吗？你当然没错，它运行很正常，并且可能永远不会出问题，但是在 React 中，每个状态更改都将强制对该组件，很有可能还有其子级进行重渲染，但在上面的示例中，因为我们从未在渲染部分中使用这个状态，结果每次设置计数器时都会有不必要的重渲染，这可能会影响性能或产生意外的副作用。</p>\n<h3 id=\"解决方案✅\"><a href=\"#解决方案✅\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>如果要在组件内部使用一个变量，希望该变量在渲染之间保持其值，但又不强制重新渲染，则可以使用 useRef hook。它将保留值，但不强制重新渲染组件。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ClickButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = useRef(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickCount = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    count.current++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClickRequest = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    apiCall(count.current);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClickCount&#125;&gt;Counter&lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;onClickRequest&#125;&gt;Submit&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-使用-router-push-代替链接\"><a href=\"#2-使用-router-push-代替链接\" class=\"headerlink\" title=\"2. 使用 router.push 代替链接\"></a>2. 使用 router.push 代替链接</h2><p>这可能是一个显而易见的错误，其实和 React 本身没什么关系，但是当人们编写 React 组件时经常会犯这种错误。</p>\n<p>假设你要编写一个按钮，单击该按钮应将用户重定向到另一个页面。由于它是一个 SPA，因此这个动作是客户端路由机制。于是你需要某种库来执行此动作。在 React 中最流行的是 react-router，下面的示例就会使用它。</p>\n<p>所以，添加一个点击侦听器会将用户重定向到所需的页面，对吗？</p>\n<h3 id=\"这很危险❌\"><a href=\"#这很危险❌\" class=\"headerlink\" title=\"这很危险❌\"></a>这很危险❌</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ClickButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> history = useHistory();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> onClick = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    history.push(<span class=\"string\">&#x27;/next-page&#x27;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;onClick&#125;</span>&gt;</span>Go to next page<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡-1\"><a href=\"#问题⚡-1\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>就算这段代码对于大多数用户来说都可以正常工作，但这里也有严重的可访问性问题。这个按钮根本不会被标记为链接到另一个页面，于是屏幕阅读器几乎无法识别它。而且你能在新标签页或窗口中打开它吗？很可能做不到。</p>\n<h3 id=\"解决方案✅-1\"><a href=\"#解决方案✅-1\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>只要指向其他页面的链接带有某种用户交互，就要尽量用 &lt; Link&gt; 组件或常规的 &lt; a&gt; 标签处理。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ClickButton</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Link to=<span class=\"string\">&quot;/next-page&quot;</span>&gt;</span><br><span class=\"line\">      &lt;span&gt;Go to next page&lt;/span&gt;</span><br><span class=\"line\">    &lt;/Link&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>优点：这也使代码更易读，更短！</p>\n<h2 id=\"3-通过-useEffect-处理动作\"><a href=\"#3-通过-useEffect-处理动作\" class=\"headerlink\" title=\"3. 通过 useEffect 处理动作\"></a>3. 通过 useEffect 处理动作</h2><p>React 引入的最好用，最贴心的一个 hook 是 useEffect。它可以处理与 prop 或 state 更改相关的动作。可就算它很好用，人们也不该到处滥用它。</p>\n<p>想象一下有一个组件，其获取一个项目列表并将其渲染给 dom。另外，如果请求成功，我们将调用“onSuccess”函数，该函数作为一个 prop 传递给这个组件。</p>\n<h3 id=\"这很危险❌-1\"><a href=\"#这很危险❌-1\" class=\"headerlink\" title=\"这很危险❌\"></a>这很危险❌</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DataList</span>(<span class=\"params\">&#123; onSuccess &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [loading, setLoading] = useState(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [error, setError] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [data, setData] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    setLoading(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    callApi()</span><br><span class=\"line\">      .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> setData(res))</span><br><span class=\"line\">      .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> setError(err))</span><br><span class=\"line\">      .finally(<span class=\"function\">() =&gt;</span> setLoading(<span class=\"literal\">false</span>));</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, [fetchData]);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loading &amp;&amp; !error &amp;&amp; data) &#123;</span><br><span class=\"line\">      onSuccess();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, [loading, error, data, onSuccess]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Data: &#123;data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡-2\"><a href=\"#问题⚡-2\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>一共有两个 useEffect hooks，第一个在初始渲染时处理 api 调用，第二个会调用 onSuccess 函数，假设当状态没有加载、没有错误但有数据时调用肯定成功。这很有道理是吧？</p>\n<p>对第一个调用来说这肯定是正确的，并且可能永远不会失败。但你也失去了动作和需要调用的函数之间的直接联系。同样也没有 100％的保证可以说这种情况仅在 fetch 动作成功后才会发生，而这正是我们开发人员不想看到的。</p>\n<h3 id=\"解决方案✅-2\"><a href=\"#解决方案✅-2\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>一个简单明了的解决方案是将“onSuccess”函数设置为调用成功的实际位置：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DataList</span>(<span class=\"params\">&#123; onSuccess &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [loading, setLoading] = useState(<span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [error, setError] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [data, setData] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    setLoading(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    callApi()</span><br><span class=\"line\">      .then(<span class=\"function\">(<span class=\"params\">fetchedData</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setData(fetchedData);</span><br><span class=\"line\">        onSuccess();</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> setError(err))</span><br><span class=\"line\">      .finally(<span class=\"function\">() =&gt;</span> setLoading(<span class=\"literal\">false</span>));</span><br><span class=\"line\">  &#125;, [onSuccess]);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, [fetchData]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;data&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在一目了然了，在 api 调用成功的情况下才调用 onSuccess。</p>\n<h2 id=\"4-单一责任组件\"><a href=\"#4-单一责任组件\" class=\"headerlink\" title=\"4. 单一责任组件\"></a>4. 单一责任组件</h2><p>组合组件可能不是什么轻松的事情。什么时候将一个组件拆分为几个较小的组件？如何构造组件树？使用基于组件的框架时，每天都会遇到这些问题。设计组件时常见的一个错误是将两个用例合并到一个组件中。以一个 header 为例，其在移动设备上显示一个汉堡按钮，或在桌面屏幕上显示标签。（这里的条件通过神奇的 isMobile 函数处理，这里就不深入讲解了。）</p>\n<h3 id=\"这很危险❌-2\"><a href=\"#这很危险❌-2\" class=\"headerlink\" title=\"这很危险❌\"></a>这很危险❌</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Header</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">      &lt;HeaderInner menuItems=&#123;menuItems&#125; /&gt;</span><br><span class=\"line\">    &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HeaderInner</span>(<span class=\"params\">&#123; menuItems &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isMobile() ? </span><br><span class=\"line\">        &lt;BurgerButton menuItems=&#123;menuItems&#125; /&gt; : </span><br><span class=\"line\">        &lt;Tabs tabData=&#123;menuItems&#125; /&gt;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡-3\"><a href=\"#问题⚡-3\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>使用这种方法时，HeaderInner 组件试图同时兼顾两件事情，而我们都知道一心最好不要二用。而且，这种组件很难在其他地方测试或重用。</p>\n<h3 id=\"解决方案✅-3\"><a href=\"#解决方案✅-3\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>将条件提高一级，这样就能更容易看清组件的本来用途，搞明白它们只应该负责一个任务，不管是 Header、Tab 或 BurgerButton 也好，总之不要一心多用。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Header</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;header&gt;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            isMobile() ? </span><br><span class=\"line\">                &lt;BurgerButton menuItems=&#123;menuItems&#125; /&gt; : </span><br><span class=\"line\">                &lt;Tabs tabData=&#123;menuItems&#125; /&gt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &lt;/header&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-单一责任的-useEffects\"><a href=\"#5-单一责任的-useEffects\" class=\"headerlink\" title=\"5. 单一责任的 useEffects\"></a>5. 单一责任的 useEffects</h2><p>还记得以前，我们只能用 componentWillReceiveProps 或 componentDidUpdate 方法挂接到 React 组件的渲染过程吗？那是一段黑暗的回忆，也让我们意识到了 useEffect hook 的美妙之处，尤其是你可以随意使用这些 hooks。</p>\n<p>但是有时因为粗心而让“useEffect”身兼数职，就会带回那些黑暗的回忆。例如，假设你有一个组件以某种方式从后端获取一些数据，并且还会根据当前位置显示面包屑。（再次使用 react-router 获取当前位置。）</p>\n<h3 id=\"这很危险❌-3\"><a href=\"#这很危险❌-3\" class=\"headerlink\" title=\"这很危险❌\"></a>这很危险❌</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> location = useLocation();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  Calling the api */</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> updateBreadcrumbs = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Updating the breadcrumbs*/</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">    updateBreadcrumbs();</span><br><span class=\"line\">  &#125;, [location.pathname, fetchData, updateBreadcrumbs]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;BreadCrumbs /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"问题⚡-4\"><a href=\"#问题⚡-4\" class=\"headerlink\" title=\"问题⚡\"></a>问题⚡</h3><p>这里有两个用例，即“数据获取”和“显示面包屑”。两者都通过 useEffect hook 更新。当 fetchData 和 updateBreadcrumbs 函数或 location 更改时，都会运行这个 useEffect hook。现在的主要问题是，当位置更改时，我们还调用了 fetchData 函数。这可能是我们没有想到的副作用。</p>\n<h3 id=\"解决方案✅-4\"><a href=\"#解决方案✅-4\" class=\"headerlink\" title=\"解决方案✅\"></a>解决方案✅</h3><p>把效果拆分开来，确保它们只用于一种效果，意外的副作用也就消失了。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> location = useLocation();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> updateBreadcrumbs = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* Updating the breadcrumbs*/</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    updateBreadcrumbs();</span><br><span class=\"line\">  &#125;, [location.pathname, updateBreadcrumbs]);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fetchData = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*  Calling the api */</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    fetchData();</span><br><span class=\"line\">  &#125;, [fetchData]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;BreadCrumbs /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>额外的收获是</strong>，这些用例现在也在组件内按顺序排好了。</p>\n"},{"title":"网络请求 ajax 和 fetch","date":"2020-07-12T16:00:00.000Z","_content":"\n## 1. ajax\n\n> `ajax` 是一种使用现有标准的新方法。指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术，接下来我们介绍一下原生的实现。\n\n### 1.1 原生 ajax 实现\n\n> 1. 创建 `XMLHttpRequest` 对象\n> 2. 发送请求\n> 3. 服务器端的响应\n\n```javascript\nvar movieUrl = \"https://***\";\n//\t1.创建XMLHttpRequest对象\nvar xmlhttp;\nif (window.XMLHttpRequest) {\n  xmlhttp = new XMLHttpRequest();\n} else {\n  xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n}\n//\t2.发送请求\nxmlhttp.open(\"GET\", movieUrl, true); //\t第三个参数 true:异步\nxmlhttp.send();\n//\t3.服务器端的响应\nxmlhttp.addEventListener(\"readystatechange\", function () {\n  if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n    var obj = JSON.parse(xmlhttp.responseText);\n    console.log(obj);\n  }\n});\n```\n","source":"_posts/前端/网络请求 ajax 和 fetch.md","raw":"---\ntitle: 网络请求 ajax 和 fetch\ndate: 2020-07-13\ncategories: [前端, js]\ntags:\n  - ajax\n  - fetch\n---\n\n## 1. ajax\n\n> `ajax` 是一种使用现有标准的新方法。指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术，接下来我们介绍一下原生的实现。\n\n### 1.1 原生 ajax 实现\n\n> 1. 创建 `XMLHttpRequest` 对象\n> 2. 发送请求\n> 3. 服务器端的响应\n\n```javascript\nvar movieUrl = \"https://***\";\n//\t1.创建XMLHttpRequest对象\nvar xmlhttp;\nif (window.XMLHttpRequest) {\n  xmlhttp = new XMLHttpRequest();\n} else {\n  xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\");\n}\n//\t2.发送请求\nxmlhttp.open(\"GET\", movieUrl, true); //\t第三个参数 true:异步\nxmlhttp.send();\n//\t3.服务器端的响应\nxmlhttp.addEventListener(\"readystatechange\", function () {\n  if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n    var obj = JSON.parse(xmlhttp.responseText);\n    console.log(obj);\n  }\n});\n```\n","slug":"前端/网络请求 ajax 和 fetch","published":1,"updated":"2021-04-07T07:31:05.441Z","_id":"ckn7476aj002jyx7ydtbx6zny","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-ajax\"><a href=\"#1-ajax\" class=\"headerlink\" title=\"1. ajax\"></a>1. ajax</h2><blockquote>\n<p><code>ajax</code> 是一种使用现有标准的新方法。指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术，接下来我们介绍一下原生的实现。</p>\n</blockquote>\n<h3 id=\"1-1-原生-ajax-实现\"><a href=\"#1-1-原生-ajax-实现\" class=\"headerlink\" title=\"1.1 原生 ajax 实现\"></a>1.1 原生 ajax 实现</h3><blockquote>\n<ol>\n<li>创建 <code>XMLHttpRequest</code> 对象</li>\n<li>发送请求</li>\n<li>服务器端的响应</li>\n</ol>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> movieUrl = <span class=\"string\">&quot;https://***&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//\t1.创建XMLHttpRequest对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xmlhttp;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest) &#123;</span><br><span class=\"line\">  xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  xmlhttp = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//\t2.发送请求</span></span><br><span class=\"line\">xmlhttp.open(<span class=\"string\">&quot;GET&quot;</span>, movieUrl, <span class=\"literal\">true</span>); <span class=\"comment\">//\t第三个参数 true:异步</span></span><br><span class=\"line\">xmlhttp.send();</span><br><span class=\"line\"><span class=\"comment\">//\t3.服务器端的响应</span></span><br><span class=\"line\">xmlhttp.addEventListener(<span class=\"string\">&quot;readystatechange&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xmlhttp.readyState == <span class=\"number\">4</span> &amp;&amp; xmlhttp.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"built_in\">JSON</span>.parse(xmlhttp.responseText);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-ajax\"><a href=\"#1-ajax\" class=\"headerlink\" title=\"1. ajax\"></a>1. ajax</h2><blockquote>\n<p><code>ajax</code> 是一种使用现有标准的新方法。指一种创建交互式、快速动态网页应用的网页开发技术，无需重新加载整个网页的情况下，能够更新部分网页的技术，接下来我们介绍一下原生的实现。</p>\n</blockquote>\n<h3 id=\"1-1-原生-ajax-实现\"><a href=\"#1-1-原生-ajax-实现\" class=\"headerlink\" title=\"1.1 原生 ajax 实现\"></a>1.1 原生 ajax 实现</h3><blockquote>\n<ol>\n<li>创建 <code>XMLHttpRequest</code> 对象</li>\n<li>发送请求</li>\n<li>服务器端的响应</li>\n</ol>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> movieUrl = <span class=\"string\">&quot;https://***&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//\t1.创建XMLHttpRequest对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xmlhttp;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.XMLHttpRequest) &#123;</span><br><span class=\"line\">  xmlhttp = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  xmlhttp = <span class=\"keyword\">new</span> ActiveXObject(<span class=\"string\">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//\t2.发送请求</span></span><br><span class=\"line\">xmlhttp.open(<span class=\"string\">&quot;GET&quot;</span>, movieUrl, <span class=\"literal\">true</span>); <span class=\"comment\">//\t第三个参数 true:异步</span></span><br><span class=\"line\">xmlhttp.send();</span><br><span class=\"line\"><span class=\"comment\">//\t3.服务器端的响应</span></span><br><span class=\"line\">xmlhttp.addEventListener(<span class=\"string\">&quot;readystatechange&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xmlhttp.readyState == <span class=\"number\">4</span> &amp;&amp; xmlhttp.status == <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = <span class=\"built_in\">JSON</span>.parse(xmlhttp.responseText);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(obj);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"防抖和节流","date":"2020-10-16T16:00:00.000Z","_content":"\n## 背景\n\n> 1. 在进行窗口的 `resize`、`scroll`\n> 2. `输入框内容校验`\n> 3. `mousedown`、`mousemove`\n> 4. `keyup`, `keydown`\n>    等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用 `debounce`（防抖）和 `throttle`（节流）的方式来减少调用频率，同时又不影响实际效果。\n\n## 防抖\n\n> 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发 `scroll` 事件时，并不执行 `handle` 函数，当 `1s` 内没有触发 `scroll`事件时，才会延时触发 `scroll` 事件。\n\n![防抖.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703595580-b3299f97-9961-476b-89e1-64db6b1090e5.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=%E9%98%B2%E6%8A%96.png&originHeight=150&originWidth=700&size=8748&status=done&style=none&width=700)\n\n### 传统防抖\n\n#### 最简单的防抖\n\n```javascript\nfunction debounce(fn, wait) {\n  var timer = null;\n  return function () {\n    if (timer !== null) {\n      clearTimeout(timer);\n      timer = setTimeout(fn, wait);\n    }\n  };\n}\n\n// 处理函数\nfunction hanlder() {\n  console.log(parseInt(Math.random()));\n}\n\n// 事件\nwindow.addEventListener(\"scroll\", debounce(handler, 1000));\n```\n\n#### 修改 this\n\n> 在 `debounce` 包裹后的 `fn` 中我们输出 `this` 会指向 `window` 对象，而有些情况下 `fn` 内的 `this` 并不指向 `window`，所以修正后的 `防抖函数` 如下\n\n```javascript\nfunction debounce(fn, wait) {\n  var timer = null;\n  return function () {\n    var context = this;\n    if (timer !== null) {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        fn.apply(context);\n      }, wait);\n    }\n  };\n}\n```\n\n#### 传递 event 事件对象\n\n> 在 `debounce` 包裹后的 `fn` 中我们输出 `event` 为 `undefined`，而不被包裹的 `fn` 中将输出相应的事件源，所以修正后的 `防抖函数` 如下\n\n```javascript\nfunction debounce(fn, wait) {\n  var timer = null;\n  return function () {\n    var context = this;\n    var args = arguments;\n    if (timer !== null) {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, wait);\n    }\n  };\n}\n```\n\n### 立即执行的防抖\n\n> 某些时候，我们不希望非要等到事件停止触发后才执行相应逻辑，希望立刻执行函数，但是要等到停止触发 `n` 秒后，才可以重新触发执行。\n> 此时我们需要增加 `immediate` 参数来进行控制是否立即执行。\n\n```javascript\nfunction debounce(func, wait, immediate) {\n  var timer = null;\n  return function () {\n    var context = this;\n    var args = arguments;\n\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n    if (immediate) {\n      // 立即执行\n      timer = setTimeout(function () {\n        timer = null;\n      }, wait);\n      if (!timer) {\n        fn.apply(context, args);\n      }\n    } else {\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, wait);\n    }\n  };\n}\n```\n\n> 此时注意一点，就是 `fn` 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 `immediate` 为  `false` 的时候，因为使用了 `setTimeout` ，我们将 `fn.apply(context, args)` 的返回值赋给变量，最后再 `return` 的时候，值将会一直是 `undefined`，所以我们只在 `immediate` 为 `true` 的时候返回函数的执行结果。\n\n```javascript\nfunction debounce(func, wait, immediate) {\n  var timer = null;\n  var result;\n  return function () {\n    var context = this;\n    var args = arguments;\n\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n    if (immediate) {\n      // 立即执行\n      timer = setTimeout(function () {\n        timer = null;\n      }, wait);\n      if (!timer) {\n        result = fn.apply(context, args);\n      }\n    } else {\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, wait);\n    }\n    return result;\n  };\n}\n```\n\n### 可以取消的防抖\n\n> 新的需求是希望能取消 `debounce` 函数，比如说 `debounce` 的时间间隔是 `10` 秒钟，`immediate` 为 `true`，这样的话，我只有等 `10` 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行。\n\n```javascript\nfunction debounce(func, wait, immediate) {\n  var timer = null;\n  var result;\n  var debounceCallback = function () {\n    var context = this;\n    var args = arguments;\n\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n    if (immediate) {\n      // 立即执行\n      timer = setTimeout(function () {\n        timer = null;\n      }, wait);\n      if (!timer) {\n        result = fn.apply(context, args);\n      }\n    } else {\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, wait);\n    }\n    return result;\n  };\n\n  debounceCallback.cancel = function () {\n    clearTimeout(timer);\n    timer = null;\n  };\n\n  return debounceCallback;\n}\n```\n\n## 节流\n\n> 当持续触发事件时，保证 `一定时间段内只调用一次` 事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发 `scroll` 事件时，并不立即执行 `handle` 函数，每隔 `1s` 才会执行一次 `handle` 函数。\n\n![节流.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703615184-c4c3dd6f-7242-4dfb-a924-fe04be39ae04.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&name=%E8%8A%82%E6%B5%81.png&originHeight=323&originWidth=330&size=8046&status=done&style=none&width=330)\n\n### 时间戳法\n\n> 当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。\n\n```javascript\nvar throttle = function (func, delay) {\n  var prev = Date.now();\n  return function () {\n    var now = Date.now();\n    var context = this;\n    var args = arguments;\n    if (now - prev >= delay) {\n      func.apply(context, args);\n      prev = Date.now();\n    }\n  };\n};\n\nfunction handler() {\n  console.log(parseInt(Math.random()));\n}\n\nwindow.addEventListener(\"scroll\", throttle(handler, 1000));\n```\n\n### 定时器法\n\n> 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\n\n```javascript\nvar throttle = function (func, delay) {\n  var timer = null;\n  return function () {\n    var context = this;\n    var args = arguments;\n    if (!timer) {\n      timer = setTimeout(function () {\n        func.apply(context, args);\n        timer = null;\n      }, delay);\n    }\n  };\n};\nfunction handle() {\n  console.log(Math.random());\n}\nwindow.addEventListener(\"scroll\", throttle(handle, 1000));\n```\n\n### 时间戳法和定时器法的比较\n\n> 时间戳法中事件会立即执行，定时器法会在 n 秒之后第一次执行\n> 时间戳法中事件停止触发后没有办法再执行事件，定时器法中事件停止触发后依然会再执行一次事件\n\n### 最终加强版本\n\n> 第一次立即执行，最后一次停止后仍会执行一次\n\n```javascript\nfunction throttle(func, delay) {\n  var timer = null;\n  var startTime = Date.now();\n  var context;\n  var args;\n\n  var later = function () {\n    startTime = Date.now();\n    timer = null;\n    func.apply(context, args);\n  };\n\n  return function () {\n    var currentTime = Date.now();\n    var remaining = delay - (currentTime - startTime);\n    context = this;\n    args = arguments;\n    // 如果没有剩余的时间或者自行修改了系统时间\n    if (remaining <= 0 || remaining > wait) {\n      func.apply(context, args);\n      startTime = Date.now();\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    }\n    if (!timer) {\n      timer = setTimeout(func, remaining);\n    }\n  };\n}\n```\n\n### 其他功能\n\n- 包括第一次立即执行，最后一次停止后不执行；第一次不立即执行，最后一次停止后再执行一次；取消节流；\n\n```javascript\nfunction throttle(func, wait, options) {\n  var timer = null;\n  var startTime = Date.now();\n  var context;\n  var args;\n\n  if (!options) options = {};\n\n  var later = function () {\n    startTime = options.leading === false ? 0 : Date.now();\n    timer = null;\n    func.apply(context, args);\n    if (!timer) context = args = null;\n  };\n\n  var throttled = function () {\n    var now = Date.now();\n    if (!startTime && options.leading === false) startTime = now;\n    var remaining = wait - (now - startTime);\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      startTime = now;\n      func.apply(context, args);\n      if (!timer) context = args = null;\n    } else if (!timer && options.trailing !== false) {\n      timer = setTimeout(later, remaining);\n    }\n  };\n\n  throttled.cancel = function () {\n    clearTimeout(timeout);\n    startTime = 0;\n    timeout = null;\n  };\n\n  return throttled;\n}\n```\n\n## 总结\n\n- 防抖\n\n> `将几次操作合并为一此操作进行`。原理是维护一个计时器，规定在 `delay` 时间后触发函数，但是在 `delay` 时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n- 节流\n\n> `使得一定时间内只触发一次函数`。原理是通过判断是否到达一定时间来触发函数。\n\n> 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 `Ajax` 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。\n","source":"_posts/前端/防抖和节流.md","raw":"---\ntitle: 防抖和节流\ndate: 2020-10-17\ncategories: [前端, js]\ntags:\n  - 解决方案\n---\n\n## 背景\n\n> 1. 在进行窗口的 `resize`、`scroll`\n> 2. `输入框内容校验`\n> 3. `mousedown`、`mousemove`\n> 4. `keyup`, `keydown`\n>    等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用 `debounce`（防抖）和 `throttle`（节流）的方式来减少调用频率，同时又不影响实际效果。\n\n## 防抖\n\n> 当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发 `scroll` 事件时，并不执行 `handle` 函数，当 `1s` 内没有触发 `scroll`事件时，才会延时触发 `scroll` 事件。\n\n![防抖.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703595580-b3299f97-9961-476b-89e1-64db6b1090e5.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=%E9%98%B2%E6%8A%96.png&originHeight=150&originWidth=700&size=8748&status=done&style=none&width=700)\n\n### 传统防抖\n\n#### 最简单的防抖\n\n```javascript\nfunction debounce(fn, wait) {\n  var timer = null;\n  return function () {\n    if (timer !== null) {\n      clearTimeout(timer);\n      timer = setTimeout(fn, wait);\n    }\n  };\n}\n\n// 处理函数\nfunction hanlder() {\n  console.log(parseInt(Math.random()));\n}\n\n// 事件\nwindow.addEventListener(\"scroll\", debounce(handler, 1000));\n```\n\n#### 修改 this\n\n> 在 `debounce` 包裹后的 `fn` 中我们输出 `this` 会指向 `window` 对象，而有些情况下 `fn` 内的 `this` 并不指向 `window`，所以修正后的 `防抖函数` 如下\n\n```javascript\nfunction debounce(fn, wait) {\n  var timer = null;\n  return function () {\n    var context = this;\n    if (timer !== null) {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        fn.apply(context);\n      }, wait);\n    }\n  };\n}\n```\n\n#### 传递 event 事件对象\n\n> 在 `debounce` 包裹后的 `fn` 中我们输出 `event` 为 `undefined`，而不被包裹的 `fn` 中将输出相应的事件源，所以修正后的 `防抖函数` 如下\n\n```javascript\nfunction debounce(fn, wait) {\n  var timer = null;\n  return function () {\n    var context = this;\n    var args = arguments;\n    if (timer !== null) {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, wait);\n    }\n  };\n}\n```\n\n### 立即执行的防抖\n\n> 某些时候，我们不希望非要等到事件停止触发后才执行相应逻辑，希望立刻执行函数，但是要等到停止触发 `n` 秒后，才可以重新触发执行。\n> 此时我们需要增加 `immediate` 参数来进行控制是否立即执行。\n\n```javascript\nfunction debounce(func, wait, immediate) {\n  var timer = null;\n  return function () {\n    var context = this;\n    var args = arguments;\n\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n    if (immediate) {\n      // 立即执行\n      timer = setTimeout(function () {\n        timer = null;\n      }, wait);\n      if (!timer) {\n        fn.apply(context, args);\n      }\n    } else {\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, wait);\n    }\n  };\n}\n```\n\n> 此时注意一点，就是 `fn` 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 `immediate` 为  `false` 的时候，因为使用了 `setTimeout` ，我们将 `fn.apply(context, args)` 的返回值赋给变量，最后再 `return` 的时候，值将会一直是 `undefined`，所以我们只在 `immediate` 为 `true` 的时候返回函数的执行结果。\n\n```javascript\nfunction debounce(func, wait, immediate) {\n  var timer = null;\n  var result;\n  return function () {\n    var context = this;\n    var args = arguments;\n\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n    if (immediate) {\n      // 立即执行\n      timer = setTimeout(function () {\n        timer = null;\n      }, wait);\n      if (!timer) {\n        result = fn.apply(context, args);\n      }\n    } else {\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, wait);\n    }\n    return result;\n  };\n}\n```\n\n### 可以取消的防抖\n\n> 新的需求是希望能取消 `debounce` 函数，比如说 `debounce` 的时间间隔是 `10` 秒钟，`immediate` 为 `true`，这样的话，我只有等 `10` 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行。\n\n```javascript\nfunction debounce(func, wait, immediate) {\n  var timer = null;\n  var result;\n  var debounceCallback = function () {\n    var context = this;\n    var args = arguments;\n\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n    if (immediate) {\n      // 立即执行\n      timer = setTimeout(function () {\n        timer = null;\n      }, wait);\n      if (!timer) {\n        result = fn.apply(context, args);\n      }\n    } else {\n      timer = setTimeout(function () {\n        fn.apply(context, args);\n      }, wait);\n    }\n    return result;\n  };\n\n  debounceCallback.cancel = function () {\n    clearTimeout(timer);\n    timer = null;\n  };\n\n  return debounceCallback;\n}\n```\n\n## 节流\n\n> 当持续触发事件时，保证 `一定时间段内只调用一次` 事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发 `scroll` 事件时，并不立即执行 `handle` 函数，每隔 `1s` 才会执行一次 `handle` 函数。\n\n![节流.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703615184-c4c3dd6f-7242-4dfb-a924-fe04be39ae04.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&name=%E8%8A%82%E6%B5%81.png&originHeight=323&originWidth=330&size=8046&status=done&style=none&width=330)\n\n### 时间戳法\n\n> 当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。\n\n```javascript\nvar throttle = function (func, delay) {\n  var prev = Date.now();\n  return function () {\n    var now = Date.now();\n    var context = this;\n    var args = arguments;\n    if (now - prev >= delay) {\n      func.apply(context, args);\n      prev = Date.now();\n    }\n  };\n};\n\nfunction handler() {\n  console.log(parseInt(Math.random()));\n}\n\nwindow.addEventListener(\"scroll\", throttle(handler, 1000));\n```\n\n### 定时器法\n\n> 当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\n\n```javascript\nvar throttle = function (func, delay) {\n  var timer = null;\n  return function () {\n    var context = this;\n    var args = arguments;\n    if (!timer) {\n      timer = setTimeout(function () {\n        func.apply(context, args);\n        timer = null;\n      }, delay);\n    }\n  };\n};\nfunction handle() {\n  console.log(Math.random());\n}\nwindow.addEventListener(\"scroll\", throttle(handle, 1000));\n```\n\n### 时间戳法和定时器法的比较\n\n> 时间戳法中事件会立即执行，定时器法会在 n 秒之后第一次执行\n> 时间戳法中事件停止触发后没有办法再执行事件，定时器法中事件停止触发后依然会再执行一次事件\n\n### 最终加强版本\n\n> 第一次立即执行，最后一次停止后仍会执行一次\n\n```javascript\nfunction throttle(func, delay) {\n  var timer = null;\n  var startTime = Date.now();\n  var context;\n  var args;\n\n  var later = function () {\n    startTime = Date.now();\n    timer = null;\n    func.apply(context, args);\n  };\n\n  return function () {\n    var currentTime = Date.now();\n    var remaining = delay - (currentTime - startTime);\n    context = this;\n    args = arguments;\n    // 如果没有剩余的时间或者自行修改了系统时间\n    if (remaining <= 0 || remaining > wait) {\n      func.apply(context, args);\n      startTime = Date.now();\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    }\n    if (!timer) {\n      timer = setTimeout(func, remaining);\n    }\n  };\n}\n```\n\n### 其他功能\n\n- 包括第一次立即执行，最后一次停止后不执行；第一次不立即执行，最后一次停止后再执行一次；取消节流；\n\n```javascript\nfunction throttle(func, wait, options) {\n  var timer = null;\n  var startTime = Date.now();\n  var context;\n  var args;\n\n  if (!options) options = {};\n\n  var later = function () {\n    startTime = options.leading === false ? 0 : Date.now();\n    timer = null;\n    func.apply(context, args);\n    if (!timer) context = args = null;\n  };\n\n  var throttled = function () {\n    var now = Date.now();\n    if (!startTime && options.leading === false) startTime = now;\n    var remaining = wait - (now - startTime);\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n      startTime = now;\n      func.apply(context, args);\n      if (!timer) context = args = null;\n    } else if (!timer && options.trailing !== false) {\n      timer = setTimeout(later, remaining);\n    }\n  };\n\n  throttled.cancel = function () {\n    clearTimeout(timeout);\n    startTime = 0;\n    timeout = null;\n  };\n\n  return throttled;\n}\n```\n\n## 总结\n\n- 防抖\n\n> `将几次操作合并为一此操作进行`。原理是维护一个计时器，规定在 `delay` 时间后触发函数，但是在 `delay` 时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n- 节流\n\n> `使得一定时间内只触发一次函数`。原理是通过判断是否到达一定时间来触发函数。\n\n> 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 `Ajax` 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。\n","slug":"前端/防抖和节流","published":1,"updated":"2021-04-07T07:31:56.210Z","_id":"ckn7476ak002lyx7y36092igs","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><blockquote>\n<ol>\n<li>在进行窗口的 <code>resize</code>、<code>scroll</code></li>\n<li><code>输入框内容校验</code></li>\n<li><code>mousedown</code>、<code>mousemove</code></li>\n<li><code>keyup</code>, <code>keydown</code><br>等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用 <code>debounce</code>（防抖）和 <code>throttle</code>（节流）的方式来减少调用频率，同时又不影响实际效果。</li>\n</ol>\n</blockquote>\n<h2 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h2><blockquote>\n<p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发 <code>scroll</code> 事件时，并不执行 <code>handle</code> 函数，当 <code>1s</code> 内没有触发 <code>scroll</code>事件时，才会延时触发 <code>scroll</code> 事件。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703595580-b3299f97-9961-476b-89e1-64db6b1090e5.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=%E9%98%B2%E6%8A%96.png&originHeight=150&originWidth=700&size=8748&status=done&style=none&width=700\" alt=\"防抖.png\"></p>\n<h3 id=\"传统防抖\"><a href=\"#传统防抖\" class=\"headerlink\" title=\"传统防抖\"></a>传统防抖</h3><h4 id=\"最简单的防抖\"><a href=\"#最简单的防抖\" class=\"headerlink\" title=\"最简单的防抖\"></a>最简单的防抖</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(fn, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hanlder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 事件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, debounce(handler, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改-this\"><a href=\"#修改-this\" class=\"headerlink\" title=\"修改 this\"></a>修改 this</h4><blockquote>\n<p>在 <code>debounce</code> 包裹后的 <code>fn</code> 中我们输出 <code>this</code> 会指向 <code>window</code> 对象，而有些情况下 <code>fn</code> 内的 <code>this</code> 并不指向 <code>window</code>，所以修正后的 <code>防抖函数</code> 如下</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"传递-event-事件对象\"><a href=\"#传递-event-事件对象\" class=\"headerlink\" title=\"传递 event 事件对象\"></a>传递 event 事件对象</h4><blockquote>\n<p>在 <code>debounce</code> 包裹后的 <code>fn</code> 中我们输出 <code>event</code> 为 <code>undefined</code>，而不被包裹的 <code>fn</code> 中将输出相应的事件源，所以修正后的 <code>防抖函数</code> 如下</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"立即执行的防抖\"><a href=\"#立即执行的防抖\" class=\"headerlink\" title=\"立即执行的防抖\"></a>立即执行的防抖</h3><blockquote>\n<p>某些时候，我们不希望非要等到事件停止触发后才执行相应逻辑，希望立刻执行函数，但是要等到停止触发 <code>n</code> 秒后，才可以重新触发执行。<br>此时我们需要增加 <code>immediate</code> 参数来进行控制是否立即执行。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此时注意一点，就是 <code>fn</code> 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 <code>immediate</code> 为  <code>false</code> 的时候，因为使用了 <code>setTimeout</code> ，我们将 <code>fn.apply(context, args)</code> 的返回值赋给变量，最后再 <code>return</code> 的时候，值将会一直是 <code>undefined</code>，所以我们只在 <code>immediate</code> 为 <code>true</code> 的时候返回函数的执行结果。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">        result = fn.apply(context, args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可以取消的防抖\"><a href=\"#可以取消的防抖\" class=\"headerlink\" title=\"可以取消的防抖\"></a>可以取消的防抖</h3><blockquote>\n<p>新的需求是希望能取消 <code>debounce</code> 函数，比如说 <code>debounce</code> 的时间间隔是 <code>10</code> 秒钟，<code>immediate</code> 为 <code>true</code>，这样的话，我只有等 <code>10</code> 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> debounceCallback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">        result = fn.apply(context, args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  debounceCallback.cancel = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounceCallback;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h2><blockquote>\n<p>当持续触发事件时，保证 <code>一定时间段内只调用一次</code> 事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发 <code>scroll</code> 事件时，并不立即执行 <code>handle</code> 函数，每隔 <code>1s</code> 才会执行一次 <code>handle</code> 函数。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703615184-c4c3dd6f-7242-4dfb-a924-fe04be39ae04.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&name=%E8%8A%82%E6%B5%81.png&originHeight=323&originWidth=330&size=8046&status=done&style=none&width=330\" alt=\"节流.png\"></p>\n<h3 id=\"时间戳法\"><a href=\"#时间戳法\" class=\"headerlink\" title=\"时间戳法\"></a>时间戳法</h3><blockquote>\n<p>当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now - prev &gt;= delay) &#123;</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">      prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, throttle(handler, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器法\"><a href=\"#定时器法\" class=\"headerlink\" title=\"定时器法\"></a>定时器法</h3><blockquote>\n<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        func.apply(context, args);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, delay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"时间戳法和定时器法的比较\"><a href=\"#时间戳法和定时器法的比较\" class=\"headerlink\" title=\"时间戳法和定时器法的比较\"></a>时间戳法和定时器法的比较</h3><blockquote>\n<p>时间戳法中事件会立即执行，定时器法会在 n 秒之后第一次执行<br>时间戳法中事件停止触发后没有办法再执行事件，定时器法中事件停止触发后依然会再执行一次事件</p>\n</blockquote>\n<h3 id=\"最终加强版本\"><a href=\"#最终加强版本\" class=\"headerlink\" title=\"最终加强版本\"></a>最终加强版本</h3><blockquote>\n<p>第一次立即执行，最后一次停止后仍会执行一次</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> context;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    func.apply(context, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = delay - (currentTime - startTime);</span><br><span class=\"line\">    context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有剩余的时间或者自行修改了系统时间</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">      startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(func, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h3><ul>\n<li>包括第一次立即执行，最后一次停止后不执行；第一次不立即执行，最后一次停止后再执行一次；取消节流；</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> context;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    startTime = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    func.apply(context, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> throttled = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!startTime &amp;&amp; options.leading === <span class=\"literal\">false</span>) startTime = now;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - startTime);</span><br><span class=\"line\">    context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      startTime = now;</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timer) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timer &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  throttled.cancel = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    startTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>防抖</li>\n</ul>\n<blockquote>\n<p><code>将几次操作合并为一此操作进行</code>。原理是维护一个计时器，规定在 <code>delay</code> 时间后触发函数，但是在 <code>delay</code> 时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>\n</blockquote>\n<ul>\n<li>节流</li>\n</ul>\n<blockquote>\n<p><code>使得一定时间内只触发一次函数</code>。原理是通过判断是否到达一定时间来触发函数。</p>\n</blockquote>\n<blockquote>\n<p>函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 <code>Ajax</code> 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><blockquote>\n<ol>\n<li>在进行窗口的 <code>resize</code>、<code>scroll</code></li>\n<li><code>输入框内容校验</code></li>\n<li><code>mousedown</code>、<code>mousemove</code></li>\n<li><code>keyup</code>, <code>keydown</code><br>等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用 <code>debounce</code>（防抖）和 <code>throttle</code>（节流）的方式来减少调用频率，同时又不影响实际效果。</li>\n</ol>\n</blockquote>\n<h2 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h2><blockquote>\n<p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。如下图，持续触发 <code>scroll</code> 事件时，并不执行 <code>handle</code> 函数，当 <code>1s</code> 内没有触发 <code>scroll</code>事件时，才会延时触发 <code>scroll</code> 事件。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703595580-b3299f97-9961-476b-89e1-64db6b1090e5.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=%E9%98%B2%E6%8A%96.png&originHeight=150&originWidth=700&size=8748&status=done&style=none&width=700\" alt=\"防抖.png\"></p>\n<h3 id=\"传统防抖\"><a href=\"#传统防抖\" class=\"headerlink\" title=\"传统防抖\"></a>传统防抖</h3><h4 id=\"最简单的防抖\"><a href=\"#最简单的防抖\" class=\"headerlink\" title=\"最简单的防抖\"></a>最简单的防抖</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(fn, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hanlder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 事件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, debounce(handler, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"修改-this\"><a href=\"#修改-this\" class=\"headerlink\" title=\"修改 this\"></a>修改 this</h4><blockquote>\n<p>在 <code>debounce</code> 包裹后的 <code>fn</code> 中我们输出 <code>this</code> 会指向 <code>window</code> 对象，而有些情况下 <code>fn</code> 内的 <code>this</code> 并不指向 <code>window</code>，所以修正后的 <code>防抖函数</code> 如下</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"传递-event-事件对象\"><a href=\"#传递-event-事件对象\" class=\"headerlink\" title=\"传递 event 事件对象\"></a>传递 event 事件对象</h4><blockquote>\n<p>在 <code>debounce</code> 包裹后的 <code>fn</code> 中我们输出 <code>event</code> 为 <code>undefined</code>，而不被包裹的 <code>fn</code> 中将输出相应的事件源，所以修正后的 <code>防抖函数</code> 如下</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">fn, wait</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"立即执行的防抖\"><a href=\"#立即执行的防抖\" class=\"headerlink\" title=\"立即执行的防抖\"></a>立即执行的防抖</h3><blockquote>\n<p>某些时候，我们不希望非要等到事件停止触发后才执行相应逻辑，希望立刻执行函数，但是要等到停止触发 <code>n</code> 秒后，才可以重新触发执行。<br>此时我们需要增加 <code>immediate</code> 参数来进行控制是否立即执行。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此时注意一点，就是 <code>fn</code> 函数可能是有返回值的，所以我们也要返回函数的执行结果，但是当 <code>immediate</code> 为  <code>false</code> 的时候，因为使用了 <code>setTimeout</code> ，我们将 <code>fn.apply(context, args)</code> 的返回值赋给变量，最后再 <code>return</code> 的时候，值将会一直是 <code>undefined</code>，所以我们只在 <code>immediate</code> 为 <code>true</code> 的时候返回函数的执行结果。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">        result = fn.apply(context, args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可以取消的防抖\"><a href=\"#可以取消的防抖\" class=\"headerlink\" title=\"可以取消的防抖\"></a>可以取消的防抖</h3><blockquote>\n<p>新的需求是希望能取消 <code>debounce</code> 函数，比如说 <code>debounce</code> 的时间间隔是 <code>10</code> 秒钟，<code>immediate</code> 为 <code>true</code>，这样的话，我只有等 <code>10</code> 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait, immediate</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> debounceCallback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (timer != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (immediate) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 立即执行</span></span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">        result = fn.apply(context, args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        fn.apply(context, args);</span><br><span class=\"line\">      &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  debounceCallback.cancel = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">    timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> debounceCallback;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h2><blockquote>\n<p>当持续触发事件时，保证 <code>一定时间段内只调用一次</code> 事件处理函数。节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。如下图，持续触发 <code>scroll</code> 事件时，并不立即执行 <code>handle</code> 函数，每隔 <code>1s</code> 才会执行一次 <code>handle</code> 函数。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703615184-c4c3dd6f-7242-4dfb-a924-fe04be39ae04.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&name=%E8%8A%82%E6%B5%81.png&originHeight=323&originWidth=330&size=8046&status=done&style=none&width=330\" alt=\"节流.png\"></p>\n<h3 id=\"时间戳法\"><a href=\"#时间戳法\" class=\"headerlink\" title=\"时间戳法\"></a>时间戳法</h3><blockquote>\n<p>当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (now - prev &gt;= delay) &#123;</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">      prev = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.random()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, throttle(handler, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"定时器法\"><a href=\"#定时器法\" class=\"headerlink\" title=\"定时器法\"></a>定时器法</h3><blockquote>\n<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        func.apply(context, args);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;, delay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handle</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, throttle(handle, <span class=\"number\">1000</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"时间戳法和定时器法的比较\"><a href=\"#时间戳法和定时器法的比较\" class=\"headerlink\" title=\"时间戳法和定时器法的比较\"></a>时间戳法和定时器法的比较</h3><blockquote>\n<p>时间戳法中事件会立即执行，定时器法会在 n 秒之后第一次执行<br>时间戳法中事件停止触发后没有办法再执行事件，定时器法中事件停止触发后依然会再执行一次事件</p>\n</blockquote>\n<h3 id=\"最终加强版本\"><a href=\"#最终加强版本\" class=\"headerlink\" title=\"最终加强版本\"></a>最终加强版本</h3><blockquote>\n<p>第一次立即执行，最后一次停止后仍会执行一次</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, delay</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> context;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    func.apply(context, args);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = delay - (currentTime - startTime);</span><br><span class=\"line\">    context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有剩余的时间或者自行修改了系统时间</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">      startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(func, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h3><ul>\n<li>包括第一次立即执行，最后一次停止后不执行；第一次不立即执行，最后一次停止后再执行一次；取消节流；</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> startTime = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> context;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!options) options = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> later = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    startTime = options.leading === <span class=\"literal\">false</span> ? <span class=\"number\">0</span> : <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    func.apply(context, args);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!timer) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> throttled = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> now = <span class=\"built_in\">Date</span>.now();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!startTime &amp;&amp; options.leading === <span class=\"literal\">false</span>) startTime = now;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> remaining = wait - (now - startTime);</span><br><span class=\"line\">    context = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (remaining &lt;= <span class=\"number\">0</span> || remaining &gt; wait) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (timer) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">clearTimeout</span>(timer);</span><br><span class=\"line\">        timer = <span class=\"literal\">null</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      startTime = now;</span><br><span class=\"line\">      func.apply(context, args);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!timer) context = args = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!timer &amp;&amp; options.trailing !== <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">      timer = <span class=\"built_in\">setTimeout</span>(later, remaining);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  throttled.cancel = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">clearTimeout</span>(timeout);</span><br><span class=\"line\">    startTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">    timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> throttled;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>防抖</li>\n</ul>\n<blockquote>\n<p><code>将几次操作合并为一此操作进行</code>。原理是维护一个计时器，规定在 <code>delay</code> 时间后触发函数，但是在 <code>delay</code> 时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</p>\n</blockquote>\n<ul>\n<li>节流</li>\n</ul>\n<blockquote>\n<p><code>使得一定时间内只触发一次函数</code>。原理是通过判断是否到达一定时间来触发函数。</p>\n</blockquote>\n<blockquote>\n<p>函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 <code>Ajax</code> 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。</p>\n</blockquote>\n"},{"title":"Chrome 调试技巧","date":"2020-10-14T16:00:00.000Z","_content":"\n> 官方文档: [https://developers.google.com/](https://developers.google.com/)\n\n> 隆重感谢: [掘金小册-你不知道的 Chrome 调试技巧](https://juejin.cn/book/6844733783166418958)\n\n### 1、快速打印想要的 dom 元素\n\n- 控制台输入 `$0`  即可打印出当前指针所选中的元素\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273)\n\n### 2、如何给 Dom 元素打断点\n\n- 鼠标右键选中元素，选中 `Break on`。\n- `subtree modifications` 监听任何它内部的节点被 `移除` 或者 `添加`的事件\n- `Break > attribute modifications`  监听任何当前选中的节点被 `添加`，`移除` 或者 `被修改值`的事件。此时属性被修改后将会产生断点调试。\n- `Break > node removal`  监听被选中的元素被 `移除` 的事件。此时属性被删除后将会产生断点调试。\n\n### 3、debug 函数\n\n- 可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435)\n\n### 4、console.log 添加样式\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654)\n\n### 5、发现问题并定位代码的内存泄漏\n\n- 选中 `Memory > Heap snapshot`  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。\n- 选中垃圾回收按钮右侧下拉菜单里的 `Comparison` ，即可将选中的快照与它上一次快照进行对比。如 `delta`  的数据对比，从而快速定位到问题出现的位置。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919)\n\n### 6、$ 快速选中元素\n\n- Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567)\n\n### 7、使用 chrome 调试 node.js 程序\n\n- `node --inspect-brk 文件名`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868)\n\n### 8、点击一个元素，获取下面所有代码执行过程\n\n- 方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 `debug`，确定执行过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623)\n\n- 方案 2: 找到当前点击所造成的影响（如：删除元素， `XHR`）等，通过点击 `Break > node removal` 等操作，在造成影响的位置下断点，通过查看 `call stack` 查看执行过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938)\n\n- 方案 3: 使用 `getEventListeners` 获取 `Dom` 元素上绑定的事件。(注意：此方法只能在 `Chrome` 控制台使用)\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740)\n\n### 9、如何使用 Chrome 调试 Webpack 程序\n\n1. 在想要调试的代码为止使用 debugger 打断点\n1. 定位 webpack-dev-server 的命令文件\n1. 使用 node --inspect-brk 打开调试服务\n1. 打开 chrome devtool 进行调试\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101)\n\n### 10、使用错误断点，让程序在错误处暂停\n\n- 方案 1: 在控制面板里直接点击错误信息\n- 方案 2: 点击 `Sources`  后点击 `Pause on exceptions`  最后勾选 `Pause on exceptions`。之后刷新页面即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901)\n\n### 11、使用 Chrome 作为代码编辑工具\n\n- 选中 `Sources > Filesystem`  然后关联本地文件夹即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067)\n\n### 12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码\n\n- 选中 `Sources > Snippets`  创建新的代码片段\n- 输入 `Command + p`  后输入 `i`  后执行\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845)\n\n### 13、使用 Chome 实时保存更改的 css 样式\n\n- 选中 `Source > Overrides` ，之后点击 `+`  选择一个本地文件夹用来保存更改后的样式，最后勾选 `Enable Local Overrides` 。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831)\n\n### 14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比\n\n- 输入 `Command + shift + p` ，搜索 `show changes`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928)\n\n### 15、查看 Chrome 请求是由谁发起的\n\n- 选择 `NetWork > Initialtor` ，不但可以查看调用位置，也可获取触发位置。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744)\n\n### 16、Chrome 性能监测工具\n\n- `Command + shift + p`  输入 `show performance monitor`  即可实时查看程序运行的性能。\n  - `CPU usage` ： `cpu` 的监听\n  - `JS heap size` : 内存占用监听，如添加到 `window`  对象上的事件不回收会造成内存溢出。\n  - `DOM Nodes`: 内存中所分配的 `dom` 节点的个数\n  - `JS envnt listeners`: `js` 中已经绑定的事件个数\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919)\n\n### 17、使用 Chrome 做性能调优，迅速定位问题\n\n- 选择 `performance`  点击录制按钮，可以查看从录制开始到停止时间内 `js` 代码运行的情况。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919)\n\n### 18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率\n\n- `Command + shift + p`  输入 `show animations`  打开动画的调试器。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919)\n\n### 19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况\n\n- `Command + shift +p`  输入 `show coverage`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893)\n\n### 20、copy() 复制控制台内容\n\n- 可以通过全局的方法  `copy()`  在  `console`  里  `copy`  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  `copy($_)`  或  `copy($0)`\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332)\n\n### 21、$\\_查看上一次程序执行结果\n\n- `$_`  是对上次执行的结果的 **引用**\n\n\\*\\*\n**![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507)**\n\n### 22、$i 配合 chrome 插件引入第三方包\n\n- 有时你只是想玩玩新出的 `npm` 包，现在不用再大费周章去建一个项目测试了，只需要在 [Chrome 插件:Console Importer](https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related) 的帮助之下，快速的在 `console` 中引入和测试一些 `npm` 库。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332)\n\n### 23、使用实时表达式\n\n- `DevTools` 在 `Console` 面板中引入了一个非常漂亮的附加功能，这是一个名为 `Live expression` 的工具。只需按下 \"眼睛\" 符号，你就可以在那里定义任何 `JavaScript` 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102)\n\n### 24、通过 'h' 来隐藏元素\n\n- 按一下  `'h'`  就可以隐藏你在元素面板中选择的元素。再次按下 '`h`' 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332)\n\n### 25、拖动 & 放置 元素\n\n- 当你想看看页面的某一部分在  `DOM`  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)\n\n![2.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066)\n\n### 26、使用 `control` (按钮) 来移动元素!\n\n- 如果你只是想移动你当前选中的元素，在  `DOM`  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用`[ctrl]` + `[⬆]` / `[ctrl]` + `[⬇]` (`[⌘]` + `[⬆]` / `[⌘]` + `[⬇]` on Mac).\n\n![3.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332)\n\n### 27、元素面板中类似于基础编辑器的操作\n\n- 从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 `[ctrl]` + `[v]` 来粘贴)， 所以我们可以在元素面板里把 `HTML` 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？\n\n- 使用`[ctrl]` + `[z]` (`[⌘]` + `[z]` on Mac)撤销我们的任何改动。 使用 `[ctrl]` + `[shift]` + `[z]`重新编辑我们的任何修改。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066)\n\n### 28、`Shadow editor` 阴影编辑器\n\n- 你可以通过在  `Style`  面板中点击靠近  `box-shadow`  属性或者  `text-shadow`  属性的  `阴影方形符号`  来打开它：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576)\n\n### 29、Timing function editor 定时函数编辑器\n\n- 也称为 `Cubic bezier(贝塞尔)` 编辑器。贝塞尔曲线是一串用来定义 `CSS` 的动画速度在整个动画过程中如何变化的 `魔法数值` 。我们将其定义为 `transition-timing-function` 或者 `animation-timing-function` CSS 属性。\n\n- 像之前说的 `Color picker` 和 `Shadow editor` 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：`trasition`， `animation` - 请注意：如果`timing` 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474)\n\n### 30、插入样式规则的按钮\n\n当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 `Color` 和 `Shadow` 编辑器添加 `CSS` 属性的按钮：\n\n- `text-shadow`\n\n- `box-shadow`\n\n- `color`\n\n- `background-color`\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632)\n\n### 31、在元素面板中展开所有的子节点\n\n- 一个一个的去点击级联的  `▶`  按钮太慢了，不如使用右击节点后的  `expand recursively`  命令：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760)\n\n### 32、控制传感器\n\n- 如果你正在你的应用中使用一些获取位置信息的 `API` 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。\n\n- `Drawer` 里的 `Sensors(传感器)` 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 `navigator.geolocation.watchPosition`（或 `.getCurrentPosition` ）报告。\n\n- 如果你的 `App` 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774)\n","source":"_posts/前端/Chrome 调试技巧.md","raw":"---\ntitle: Chrome 调试技巧\ndate: 2020-10-15\ncategories: [前端, js]\ntags: \n  - 使用技巧\n---\n\n> 官方文档: [https://developers.google.com/](https://developers.google.com/)\n\n> 隆重感谢: [掘金小册-你不知道的 Chrome 调试技巧](https://juejin.cn/book/6844733783166418958)\n\n### 1、快速打印想要的 dom 元素\n\n- 控制台输入 `$0`  即可打印出当前指针所选中的元素\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273)\n\n### 2、如何给 Dom 元素打断点\n\n- 鼠标右键选中元素，选中 `Break on`。\n- `subtree modifications` 监听任何它内部的节点被 `移除` 或者 `添加`的事件\n- `Break > attribute modifications`  监听任何当前选中的节点被 `添加`，`移除` 或者 `被修改值`的事件。此时属性被修改后将会产生断点调试。\n- `Break > node removal`  监听被选中的元素被 `移除` 的事件。此时属性被删除后将会产生断点调试。\n\n### 3、debug 函数\n\n- 可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435)\n\n### 4、console.log 添加样式\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654)\n\n### 5、发现问题并定位代码的内存泄漏\n\n- 选中 `Memory > Heap snapshot`  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。\n- 选中垃圾回收按钮右侧下拉菜单里的 `Comparison` ，即可将选中的快照与它上一次快照进行对比。如 `delta`  的数据对比，从而快速定位到问题出现的位置。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919)\n\n### 6、$ 快速选中元素\n\n- Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567)\n\n### 7、使用 chrome 调试 node.js 程序\n\n- `node --inspect-brk 文件名`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868)\n\n### 8、点击一个元素，获取下面所有代码执行过程\n\n- 方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 `debug`，确定执行过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623)\n\n- 方案 2: 找到当前点击所造成的影响（如：删除元素， `XHR`）等，通过点击 `Break > node removal` 等操作，在造成影响的位置下断点，通过查看 `call stack` 查看执行过程。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938)\n\n- 方案 3: 使用 `getEventListeners` 获取 `Dom` 元素上绑定的事件。(注意：此方法只能在 `Chrome` 控制台使用)\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740)\n\n### 9、如何使用 Chrome 调试 Webpack 程序\n\n1. 在想要调试的代码为止使用 debugger 打断点\n1. 定位 webpack-dev-server 的命令文件\n1. 使用 node --inspect-brk 打开调试服务\n1. 打开 chrome devtool 进行调试\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101)\n\n### 10、使用错误断点，让程序在错误处暂停\n\n- 方案 1: 在控制面板里直接点击错误信息\n- 方案 2: 点击 `Sources`  后点击 `Pause on exceptions`  最后勾选 `Pause on exceptions`。之后刷新页面即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901)\n\n### 11、使用 Chrome 作为代码编辑工具\n\n- 选中 `Sources > Filesystem`  然后关联本地文件夹即可\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067)\n\n### 12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码\n\n- 选中 `Sources > Snippets`  创建新的代码片段\n- 输入 `Command + p`  后输入 `i`  后执行\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845)\n\n### 13、使用 Chome 实时保存更改的 css 样式\n\n- 选中 `Source > Overrides` ，之后点击 `+`  选择一个本地文件夹用来保存更改后的样式，最后勾选 `Enable Local Overrides` 。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831)\n\n### 14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比\n\n- 输入 `Command + shift + p` ，搜索 `show changes`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928)\n\n### 15、查看 Chrome 请求是由谁发起的\n\n- 选择 `NetWork > Initialtor` ，不但可以查看调用位置，也可获取触发位置。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077)\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744)\n\n### 16、Chrome 性能监测工具\n\n- `Command + shift + p`  输入 `show performance monitor`  即可实时查看程序运行的性能。\n  - `CPU usage` ： `cpu` 的监听\n  - `JS heap size` : 内存占用监听，如添加到 `window`  对象上的事件不回收会造成内存溢出。\n  - `DOM Nodes`: 内存中所分配的 `dom` 节点的个数\n  - `JS envnt listeners`: `js` 中已经绑定的事件个数\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919)\n\n### 17、使用 Chrome 做性能调优，迅速定位问题\n\n- 选择 `performance`  点击录制按钮，可以查看从录制开始到停止时间内 `js` 代码运行的情况。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919)\n\n### 18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率\n\n- `Command + shift + p`  输入 `show animations`  打开动画的调试器。\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919)\n\n### 19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况\n\n- `Command + shift +p`  输入 `show coverage`\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893)\n\n### 20、copy() 复制控制台内容\n\n- 可以通过全局的方法  `copy()`  在  `console`  里  `copy`  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  `copy($_)`  或  `copy($0)`\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332)\n\n### 21、$\\_查看上一次程序执行结果\n\n- `$_`  是对上次执行的结果的 **引用**\n\n\\*\\*\n**![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507)**\n\n### 22、$i 配合 chrome 插件引入第三方包\n\n- 有时你只是想玩玩新出的 `npm` 包，现在不用再大费周章去建一个项目测试了，只需要在 [Chrome 插件:Console Importer](https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related) 的帮助之下，快速的在 `console` 中引入和测试一些 `npm` 库。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332)\n\n### 23、使用实时表达式\n\n- `DevTools` 在 `Console` 面板中引入了一个非常漂亮的附加功能，这是一个名为 `Live expression` 的工具。只需按下 \"眼睛\" 符号，你就可以在那里定义任何 `JavaScript` 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102)\n\n### 24、通过 'h' 来隐藏元素\n\n- 按一下  `'h'`  就可以隐藏你在元素面板中选择的元素。再次按下 '`h`' 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332)\n\n### 25、拖动 & 放置 元素\n\n- 当你想看看页面的某一部分在  `DOM`  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)\n\n![2.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066)\n\n### 26、使用 `control` (按钮) 来移动元素!\n\n- 如果你只是想移动你当前选中的元素，在  `DOM`  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用`[ctrl]` + `[⬆]` / `[ctrl]` + `[⬇]` (`[⌘]` + `[⬆]` / `[⌘]` + `[⬇]` on Mac).\n\n![3.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332)\n\n### 27、元素面板中类似于基础编辑器的操作\n\n- 从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 `[ctrl]` + `[v]` 来粘贴)， 所以我们可以在元素面板里把 `HTML` 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？\n\n- 使用`[ctrl]` + `[z]` (`[⌘]` + `[z]` on Mac)撤销我们的任何改动。 使用 `[ctrl]` + `[shift]` + `[z]`重新编辑我们的任何修改。\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066)\n\n### 28、`Shadow editor` 阴影编辑器\n\n- 你可以通过在  `Style`  面板中点击靠近  `box-shadow`  属性或者  `text-shadow`  属性的  `阴影方形符号`  来打开它：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576)\n\n### 29、Timing function editor 定时函数编辑器\n\n- 也称为 `Cubic bezier(贝塞尔)` 编辑器。贝塞尔曲线是一串用来定义 `CSS` 的动画速度在整个动画过程中如何变化的 `魔法数值` 。我们将其定义为 `transition-timing-function` 或者 `animation-timing-function` CSS 属性。\n\n- 像之前说的 `Color picker` 和 `Shadow editor` 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：`trasition`， `animation` - 请注意：如果`timing` 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474)\n\n### 30、插入样式规则的按钮\n\n当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 `Color` 和 `Shadow` 编辑器添加 `CSS` 属性的按钮：\n\n- `text-shadow`\n\n- `box-shadow`\n\n- `color`\n\n- `background-color`\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632)\n\n### 31、在元素面板中展开所有的子节点\n\n- 一个一个的去点击级联的  `▶`  按钮太慢了，不如使用右击节点后的  `expand recursively`  命令：\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760)\n\n### 32、控制传感器\n\n- 如果你正在你的应用中使用一些获取位置信息的 `API` 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。\n\n- `Drawer` 里的 `Sensors(传感器)` 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 `navigator.geolocation.watchPosition`（或 `.getCurrentPosition` ）报告。\n\n- 如果你的 `App` 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！\n\n![1.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774)\n","slug":"前端/Chrome 调试技巧","published":1,"updated":"2021-04-07T07:24:44.045Z","_id":"ckn7476ak002nyx7yfi4b9int","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p>官方文档: <a href=\"https://developers.google.com/\">https://developers.google.com/</a></p>\n</blockquote>\n<blockquote>\n<p>隆重感谢: <a href=\"https://juejin.cn/book/6844733783166418958\">掘金小册-你不知道的 Chrome 调试技巧</a></p>\n</blockquote>\n<h3 id=\"1、快速打印想要的-dom-元素\"><a href=\"#1、快速打印想要的-dom-元素\" class=\"headerlink\" title=\"1、快速打印想要的 dom 元素\"></a>1、快速打印想要的 dom 元素</h3><ul>\n<li>控制台输入 <code>$0</code>  即可打印出当前指针所选中的元素</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273\" alt=\"image.png\"></p>\n<h3 id=\"2、如何给-Dom-元素打断点\"><a href=\"#2、如何给-Dom-元素打断点\" class=\"headerlink\" title=\"2、如何给 Dom 元素打断点\"></a>2、如何给 Dom 元素打断点</h3><ul>\n<li>鼠标右键选中元素，选中 <code>Break on</code>。</li>\n<li><code>subtree modifications</code> 监听任何它内部的节点被 <code>移除</code> 或者 <code>添加</code>的事件</li>\n<li><code>Break &gt; attribute modifications</code>  监听任何当前选中的节点被 <code>添加</code>，<code>移除</code> 或者 <code>被修改值</code>的事件。此时属性被修改后将会产生断点调试。</li>\n<li><code>Break &gt; node removal</code>  监听被选中的元素被 <code>移除</code> 的事件。此时属性被删除后将会产生断点调试。</li>\n</ul>\n<h3 id=\"3、debug-函数\"><a href=\"#3、debug-函数\" class=\"headerlink\" title=\"3、debug 函数\"></a>3、debug 函数</h3><ul>\n<li>可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435\" alt=\"image.png\"></p>\n<h3 id=\"4、console-log-添加样式\"><a href=\"#4、console-log-添加样式\" class=\"headerlink\" title=\"4、console.log 添加样式\"></a>4、console.log 添加样式</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654\" alt=\"image.png\"></p>\n<h3 id=\"5、发现问题并定位代码的内存泄漏\"><a href=\"#5、发现问题并定位代码的内存泄漏\" class=\"headerlink\" title=\"5、发现问题并定位代码的内存泄漏\"></a>5、发现问题并定位代码的内存泄漏</h3><ul>\n<li>选中 <code>Memory &gt; Heap snapshot</code>  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。</li>\n<li>选中垃圾回收按钮右侧下拉菜单里的 <code>Comparison</code> ，即可将选中的快照与它上一次快照进行对比。如 <code>delta</code>  的数据对比，从而快速定位到问题出现的位置。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"6、-快速选中元素\"><a href=\"#6、-快速选中元素\" class=\"headerlink\" title=\"6、$ 快速选中元素\"></a>6、$ 快速选中元素</h3><ul>\n<li>Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567\" alt=\"image.png\"></p>\n<h3 id=\"7、使用-chrome-调试-node-js-程序\"><a href=\"#7、使用-chrome-调试-node-js-程序\" class=\"headerlink\" title=\"7、使用 chrome 调试 node.js 程序\"></a>7、使用 chrome 调试 node.js 程序</h3><ul>\n<li><code>node --inspect-brk 文件名</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868\" alt=\"image.png\"></p>\n<h3 id=\"8、点击一个元素，获取下面所有代码执行过程\"><a href=\"#8、点击一个元素，获取下面所有代码执行过程\" class=\"headerlink\" title=\"8、点击一个元素，获取下面所有代码执行过程\"></a>8、点击一个元素，获取下面所有代码执行过程</h3><ul>\n<li>方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 <code>debug</code>，确定执行过程。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623\" alt=\"image.png\"></p>\n<ul>\n<li>方案 2: 找到当前点击所造成的影响（如：删除元素， <code>XHR</code>）等，通过点击 <code>Break &gt; node removal</code> 等操作，在造成影响的位置下断点，通过查看 <code>call stack</code> 查看执行过程。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938\" alt=\"image.png\"></p>\n<ul>\n<li>方案 3: 使用 <code>getEventListeners</code> 获取 <code>Dom</code> 元素上绑定的事件。(注意：此方法只能在 <code>Chrome</code> 控制台使用)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740\" alt=\"image.png\"></p>\n<h3 id=\"9、如何使用-Chrome-调试-Webpack-程序\"><a href=\"#9、如何使用-Chrome-调试-Webpack-程序\" class=\"headerlink\" title=\"9、如何使用 Chrome 调试 Webpack 程序\"></a>9、如何使用 Chrome 调试 Webpack 程序</h3><ol>\n<li>在想要调试的代码为止使用 debugger 打断点</li>\n<li>定位 webpack-dev-server 的命令文件</li>\n<li>使用 node –inspect-brk 打开调试服务</li>\n<li>打开 chrome devtool 进行调试</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101\" alt=\"image.png\"></p>\n<h3 id=\"10、使用错误断点，让程序在错误处暂停\"><a href=\"#10、使用错误断点，让程序在错误处暂停\" class=\"headerlink\" title=\"10、使用错误断点，让程序在错误处暂停\"></a>10、使用错误断点，让程序在错误处暂停</h3><ul>\n<li>方案 1: 在控制面板里直接点击错误信息</li>\n<li>方案 2: 点击 <code>Sources</code>  后点击 <code>Pause on exceptions</code>  最后勾选 <code>Pause on exceptions</code>。之后刷新页面即可</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901\" alt=\"image.png\"></p>\n<h3 id=\"11、使用-Chrome-作为代码编辑工具\"><a href=\"#11、使用-Chrome-作为代码编辑工具\" class=\"headerlink\" title=\"11、使用 Chrome 作为代码编辑工具\"></a>11、使用 Chrome 作为代码编辑工具</h3><ul>\n<li>选中 <code>Sources &gt; Filesystem</code>  然后关联本地文件夹即可</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067\" alt=\"image.png\"></p>\n<h3 id=\"12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码\"><a href=\"#12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码\" class=\"headerlink\" title=\"12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码\"></a>12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码</h3><ul>\n<li>选中 <code>Sources &gt; Snippets</code>  创建新的代码片段</li>\n<li>输入 <code>Command + p</code>  后输入 <code>i</code>  后执行</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845\" alt=\"image.png\"></p>\n<h3 id=\"13、使用-Chome-实时保存更改的-css-样式\"><a href=\"#13、使用-Chome-实时保存更改的-css-样式\" class=\"headerlink\" title=\"13、使用 Chome 实时保存更改的 css 样式\"></a>13、使用 Chome 实时保存更改的 css 样式</h3><ul>\n<li>选中 <code>Source &gt; Overrides</code> ，之后点击 <code>+</code>  选择一个本地文件夹用来保存更改后的样式，最后勾选 <code>Enable Local Overrides</code> 。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831\" alt=\"image.png\"></p>\n<h3 id=\"14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比\"><a href=\"#14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比\" class=\"headerlink\" title=\"14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比\"></a>14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比</h3><ul>\n<li>输入 <code>Command + shift + p</code> ，搜索 <code>show changes</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928\" alt=\"image.png\"></p>\n<h3 id=\"15、查看-Chrome-请求是由谁发起的\"><a href=\"#15、查看-Chrome-请求是由谁发起的\" class=\"headerlink\" title=\"15、查看 Chrome 请求是由谁发起的\"></a>15、查看 Chrome 请求是由谁发起的</h3><ul>\n<li>选择 <code>NetWork &gt; Initialtor</code> ，不但可以查看调用位置，也可获取触发位置。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744\" alt=\"image.png\"></p>\n<h3 id=\"16、Chrome-性能监测工具\"><a href=\"#16、Chrome-性能监测工具\" class=\"headerlink\" title=\"16、Chrome 性能监测工具\"></a>16、Chrome 性能监测工具</h3><ul>\n<li><code>Command + shift + p</code>  输入 <code>show performance monitor</code>  即可实时查看程序运行的性能。<ul>\n<li><code>CPU usage</code> ： <code>cpu</code> 的监听</li>\n<li><code>JS heap size</code> : 内存占用监听，如添加到 <code>window</code>  对象上的事件不回收会造成内存溢出。</li>\n<li><code>DOM Nodes</code>: 内存中所分配的 <code>dom</code> 节点的个数</li>\n<li><code>JS envnt listeners</code>: <code>js</code> 中已经绑定的事件个数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"17、使用-Chrome-做性能调优，迅速定位问题\"><a href=\"#17、使用-Chrome-做性能调优，迅速定位问题\" class=\"headerlink\" title=\"17、使用 Chrome 做性能调优，迅速定位问题\"></a>17、使用 Chrome 做性能调优，迅速定位问题</h3><ul>\n<li>选择 <code>performance</code>  点击录制按钮，可以查看从录制开始到停止时间内 <code>js</code> 代码运行的情况。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率\"><a href=\"#18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率\" class=\"headerlink\" title=\"18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率\"></a>18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率</h3><ul>\n<li><code>Command + shift + p</code>  输入 <code>show animations</code>  打开动画的调试器。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况\"><a href=\"#19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况\" class=\"headerlink\" title=\"19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况\"></a>19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况</h3><ul>\n<li><code>Command + shift +p</code>  输入 <code>show coverage</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893\" alt=\"image.png\"></p>\n<h3 id=\"20、copy-复制控制台内容\"><a href=\"#20、copy-复制控制台内容\" class=\"headerlink\" title=\"20、copy() 复制控制台内容\"></a>20、copy() 复制控制台内容</h3><ul>\n<li>可以通过全局的方法  <code>copy()</code>  在  <code>console</code>  里  <code>copy</code>  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  <code>copy($_)</code>  或  <code>copy($0)</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"21、-查看上一次程序执行结果\"><a href=\"#21、-查看上一次程序执行结果\" class=\"headerlink\" title=\"21、$_查看上一次程序执行结果\"></a>21、$_查看上一次程序执行结果</h3><ul>\n<li><code>$_</code>  是对上次执行的结果的 <strong>引用</strong></li>\n</ul>\n<p>**<br><strong><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507\" alt=\"image.png\"></strong></p>\n<h3 id=\"22、-i-配合-chrome-插件引入第三方包\"><a href=\"#22、-i-配合-chrome-插件引入第三方包\" class=\"headerlink\" title=\"22、$i 配合 chrome 插件引入第三方包\"></a>22、$i 配合 chrome 插件引入第三方包</h3><ul>\n<li>有时你只是想玩玩新出的 <code>npm</code> 包，现在不用再大费周章去建一个项目测试了，只需要在 <a href=\"https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related\">Chrome 插件:Console Importer</a> 的帮助之下，快速的在 <code>console</code> 中引入和测试一些 <code>npm</code> 库。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"23、使用实时表达式\"><a href=\"#23、使用实时表达式\" class=\"headerlink\" title=\"23、使用实时表达式\"></a>23、使用实时表达式</h3><ul>\n<li><code>DevTools</code> 在 <code>Console</code> 面板中引入了一个非常漂亮的附加功能，这是一个名为 <code>Live expression</code> 的工具。只需按下 “眼睛” 符号，你就可以在那里定义任何 <code>JavaScript</code> 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102\" alt=\"1.gif\"></p>\n<h3 id=\"24、通过-‘h’-来隐藏元素\"><a href=\"#24、通过-‘h’-来隐藏元素\" class=\"headerlink\" title=\"24、通过 ‘h’ 来隐藏元素\"></a>24、通过 ‘h’ 来隐藏元素</h3><ul>\n<li>按一下  <code>&#39;h&#39;</code>  就可以隐藏你在元素面板中选择的元素。再次按下 ‘<code>h</code>‘ 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"25、拖动-amp-放置-元素\"><a href=\"#25、拖动-amp-放置-元素\" class=\"headerlink\" title=\"25、拖动 &amp; 放置 元素\"></a>25、拖动 &amp; 放置 元素</h3><ul>\n<li>当你想看看页面的某一部分在  <code>DOM</code>  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066\" alt=\"2.gif\"></p>\n<h3 id=\"26、使用-control-按钮-来移动元素\"><a href=\"#26、使用-control-按钮-来移动元素\" class=\"headerlink\" title=\"26、使用 control (按钮) 来移动元素!\"></a>26、使用 <code>control</code> (按钮) 来移动元素!</h3><ul>\n<li>如果你只是想移动你当前选中的元素，在  <code>DOM</code>  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用<code>[ctrl]</code> + <code>[⬆]</code> / <code>[ctrl]</code> + <code>[⬇]</code> (<code>[⌘]</code> + <code>[⬆]</code> / <code>[⌘]</code> + <code>[⬇]</code> on Mac).</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332\" alt=\"3.gif\"></p>\n<h3 id=\"27、元素面板中类似于基础编辑器的操作\"><a href=\"#27、元素面板中类似于基础编辑器的操作\" class=\"headerlink\" title=\"27、元素面板中类似于基础编辑器的操作\"></a>27、元素面板中类似于基础编辑器的操作</h3><ul>\n<li><p>从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 <code>[ctrl]</code> + <code>[v]</code> 来粘贴)， 所以我们可以在元素面板里把 <code>HTML</code> 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？</p>\n</li>\n<li><p>使用<code>[ctrl]</code> + <code>[z]</code> (<code>[⌘]</code> + <code>[z]</code> on Mac)撤销我们的任何改动。 使用 <code>[ctrl]</code> + <code>[shift]</code> + <code>[z]</code>重新编辑我们的任何修改。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066\" alt=\"1.gif\"></p>\n<h3 id=\"28、Shadow-editor-阴影编辑器\"><a href=\"#28、Shadow-editor-阴影编辑器\" class=\"headerlink\" title=\"28、Shadow editor 阴影编辑器\"></a>28、<code>Shadow editor</code> 阴影编辑器</h3><ul>\n<li>你可以通过在  <code>Style</code>  面板中点击靠近  <code>box-shadow</code>  属性或者  <code>text-shadow</code>  属性的  <code>阴影方形符号</code>  来打开它：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576\" alt=\"1.gif\"></p>\n<h3 id=\"29、Timing-function-editor-定时函数编辑器\"><a href=\"#29、Timing-function-editor-定时函数编辑器\" class=\"headerlink\" title=\"29、Timing function editor 定时函数编辑器\"></a>29、Timing function editor 定时函数编辑器</h3><ul>\n<li><p>也称为 <code>Cubic bezier(贝塞尔)</code> 编辑器。贝塞尔曲线是一串用来定义 <code>CSS</code> 的动画速度在整个动画过程中如何变化的 <code>魔法数值</code> 。我们将其定义为 <code>transition-timing-function</code> 或者 <code>animation-timing-function</code> CSS 属性。</p>\n</li>\n<li><p>像之前说的 <code>Color picker</code> 和 <code>Shadow editor</code> 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：<code>trasition</code>， <code>animation</code> - 请注意：如果<code>timing</code> 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474\" alt=\"1.gif\"></p>\n<h3 id=\"30、插入样式规则的按钮\"><a href=\"#30、插入样式规则的按钮\" class=\"headerlink\" title=\"30、插入样式规则的按钮\"></a>30、插入样式规则的按钮</h3><p>当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 <code>Color</code> 和 <code>Shadow</code> 编辑器添加 <code>CSS</code> 属性的按钮：</p>\n<ul>\n<li><p><code>text-shadow</code></p>\n</li>\n<li><p><code>box-shadow</code></p>\n</li>\n<li><p><code>color</code></p>\n</li>\n<li><p><code>background-color</code></p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632\" alt=\"1.gif\"></p>\n<h3 id=\"31、在元素面板中展开所有的子节点\"><a href=\"#31、在元素面板中展开所有的子节点\" class=\"headerlink\" title=\"31、在元素面板中展开所有的子节点\"></a>31、在元素面板中展开所有的子节点</h3><ul>\n<li>一个一个的去点击级联的  <code>▶</code>  按钮太慢了，不如使用右击节点后的  <code>expand recursively</code>  命令：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760\" alt=\"1.gif\"></p>\n<h3 id=\"32、控制传感器\"><a href=\"#32、控制传感器\" class=\"headerlink\" title=\"32、控制传感器\"></a>32、控制传感器</h3><ul>\n<li><p>如果你正在你的应用中使用一些获取位置信息的 <code>API</code> 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。</p>\n</li>\n<li><p><code>Drawer</code> 里的 <code>Sensors(传感器)</code> 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 <code>navigator.geolocation.watchPosition</code>（或 <code>.getCurrentPosition</code> ）报告。</p>\n</li>\n<li><p>如果你的 <code>App</code> 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774\" alt=\"1.gif\"></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>官方文档: <a href=\"https://developers.google.com/\">https://developers.google.com/</a></p>\n</blockquote>\n<blockquote>\n<p>隆重感谢: <a href=\"https://juejin.cn/book/6844733783166418958\">掘金小册-你不知道的 Chrome 调试技巧</a></p>\n</blockquote>\n<h3 id=\"1、快速打印想要的-dom-元素\"><a href=\"#1、快速打印想要的-dom-元素\" class=\"headerlink\" title=\"1、快速打印想要的 dom 元素\"></a>1、快速打印想要的 dom 元素</h3><ul>\n<li>控制台输入 <code>$0</code>  即可打印出当前指针所选中的元素</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962961066-f8c6bcff-e407-4e61-a727-4f67246c1891.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=273&size=3469&status=done&style=none&width=273\" alt=\"image.png\"></p>\n<h3 id=\"2、如何给-Dom-元素打断点\"><a href=\"#2、如何给-Dom-元素打断点\" class=\"headerlink\" title=\"2、如何给 Dom 元素打断点\"></a>2、如何给 Dom 元素打断点</h3><ul>\n<li>鼠标右键选中元素，选中 <code>Break on</code>。</li>\n<li><code>subtree modifications</code> 监听任何它内部的节点被 <code>移除</code> 或者 <code>添加</code>的事件</li>\n<li><code>Break &gt; attribute modifications</code>  监听任何当前选中的节点被 <code>添加</code>，<code>移除</code> 或者 <code>被修改值</code>的事件。此时属性被修改后将会产生断点调试。</li>\n<li><code>Break &gt; node removal</code>  监听被选中的元素被 <code>移除</code> 的事件。此时属性被删除后将会产生断点调试。</li>\n</ul>\n<h3 id=\"3、debug-函数\"><a href=\"#3、debug-函数\" class=\"headerlink\" title=\"3、debug 函数\"></a>3、debug 函数</h3><ul>\n<li>可以将想要打断点的函数传入进去，之后函数被调用时将会自动开启断点模式。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962755747-0c7f7146-c878-47de-9ce8-b686d323fdbf.png#align=left&display=inline&height=124&margin=%5Bobject%20Object%5D&name=image.png&originHeight=124&originWidth=352&size=8413&status=done&style=none&width=352\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962788973-1b1642f8-c89b-4ad6-a58a-62c3b386cfe5.png#align=left&display=inline&height=418&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1435&size=55406&status=done&style=none&width=1435\" alt=\"image.png\"></p>\n<h3 id=\"4、console-log-添加样式\"><a href=\"#4、console-log-添加样式\" class=\"headerlink\" title=\"4、console.log 添加样式\"></a>4、console.log 添加样式</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962692139-67609724-968f-48a4-b9cb-d3a17e89ef35.png#align=left&display=inline&height=55&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=654&size=12329&status=done&style=none&width=654\" alt=\"image.png\"></p>\n<h3 id=\"5、发现问题并定位代码的内存泄漏\"><a href=\"#5、发现问题并定位代码的内存泄漏\" class=\"headerlink\" title=\"5、发现问题并定位代码的内存泄漏\"></a>5、发现问题并定位代码的内存泄漏</h3><ul>\n<li>选中 <code>Memory &gt; Heap snapshot</code>  点击开始录制的小圆圈之后，chrome 将会生成快照，为了防止某些不必要的影响，录制之前最好先点一下垃圾回收。反复的执行可能被认为内存泄漏的部分后，多次生成快照，若内存一直在增加，没有被回收，说明内存已经泄漏。</li>\n<li>选中垃圾回收按钮右侧下拉菜单里的 <code>Comparison</code> ，即可将选中的快照与它上一次快照进行对比。如 <code>delta</code>  的数据对比，从而快速定位到问题出现的位置。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963059293-544a6af9-6f7c-40c1-9c70-0953335483ef.png#align=left&display=inline&height=793&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=1919&size=95966&status=done&style=none&width=1919\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963178973-dbc985f5-aefc-4bac-ae79-e9b62bf19485.png#align=left&display=inline&height=631&margin=%5Bobject%20Object%5D&name=image.png&originHeight=631&originWidth=1919&size=122190&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"6、-快速选中元素\"><a href=\"#6、-快速选中元素\" class=\"headerlink\" title=\"6、$ 快速选中元素\"></a>6、$ 快速选中元素</h3><ul>\n<li>Chrome 内置了 $ 函数，它和 document.querySelector 功能相同，但只能选择到一个元素。$$ 将匹配到选择器所找到的所有元素</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962607992-66922bde-af81-4856-a03a-920c36bb1671.png#align=left&display=inline&height=737&margin=%5Bobject%20Object%5D&name=image.png&originHeight=737&originWidth=567&size=74761&status=done&style=none&width=567\" alt=\"image.png\"></p>\n<h3 id=\"7、使用-chrome-调试-node-js-程序\"><a href=\"#7、使用-chrome-调试-node-js-程序\" class=\"headerlink\" title=\"7、使用 chrome 调试 node.js 程序\"></a>7、使用 chrome 调试 node.js 程序</h3><ul>\n<li><code>node --inspect-brk 文件名</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963302502-b4507a3c-9d9f-4653-ad80-353e509adf07.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=39&originWidth=1033&size=8284&status=done&style=none&width=1033\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963324179-88589108-e39a-462e-803e-a70bb2096085.png#align=left&display=inline&height=708&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=2868&size=152314&status=done&style=none&width=2868\" alt=\"image.png\"></p>\n<h3 id=\"8、点击一个元素，获取下面所有代码执行过程\"><a href=\"#8、点击一个元素，获取下面所有代码执行过程\" class=\"headerlink\" title=\"8、点击一个元素，获取下面所有代码执行过程\"></a>8、点击一个元素，获取下面所有代码执行过程</h3><ul>\n<li>方案 1: 定位该元素的时间处理函数，然后从该函数往后执行 <code>debug</code>，确定执行过程。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962134298-7d0081df-45c3-497b-9ede-a1354c8a667e.png#align=left&display=inline&height=304&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=623&size=27216&status=done&style=none&width=623\" alt=\"image.png\"></p>\n<ul>\n<li>方案 2: 找到当前点击所造成的影响（如：删除元素， <code>XHR</code>）等，通过点击 <code>Break &gt; node removal</code> 等操作，在造成影响的位置下断点，通过查看 <code>call stack</code> 查看执行过程。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606962517481-012784d3-353b-47a6-a7ff-78abf31f6f32.png#align=left&display=inline&height=563&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=938&size=57934&status=done&style=none&width=938\" alt=\"image.png\"></p>\n<ul>\n<li>方案 3: 使用 <code>getEventListeners</code> 获取 <code>Dom</code> 元素上绑定的事件。(注意：此方法只能在 <code>Chrome</code> 控制台使用)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967025807-3772a909-f699-4caf-add2-c5731f96873c.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=740&size=38124&status=done&style=none&width=740\" alt=\"image.png\"></p>\n<h3 id=\"9、如何使用-Chrome-调试-Webpack-程序\"><a href=\"#9、如何使用-Chrome-调试-Webpack-程序\" class=\"headerlink\" title=\"9、如何使用 Chrome 调试 Webpack 程序\"></a>9、如何使用 Chrome 调试 Webpack 程序</h3><ol>\n<li>在想要调试的代码为止使用 debugger 打断点</li>\n<li>定位 webpack-dev-server 的命令文件</li>\n<li>使用 node –inspect-brk 打开调试服务</li>\n<li>打开 chrome devtool 进行调试</li>\n</ol>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963641175-f70486be-9e35-4e1f-9623-e82720f7f850.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1445&size=61528&status=done&style=none&width=1445\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963678848-aaef5b5b-790f-41b5-baaf-a8f7323db103.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&name=image.png&originHeight=603&originWidth=991&size=81341&status=done&style=none&width=991\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606963786975-515fd78b-8273-4ea0-9f23-9ecd0432c169.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=1101&size=16555&status=done&style=none&width=1101\" alt=\"image.png\"></p>\n<h3 id=\"10、使用错误断点，让程序在错误处暂停\"><a href=\"#10、使用错误断点，让程序在错误处暂停\" class=\"headerlink\" title=\"10、使用错误断点，让程序在错误处暂停\"></a>10、使用错误断点，让程序在错误处暂停</h3><ul>\n<li>方案 1: 在控制面板里直接点击错误信息</li>\n<li>方案 2: 点击 <code>Sources</code>  后点击 <code>Pause on exceptions</code>  最后勾选 <code>Pause on exceptions</code>。之后刷新页面即可</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964277828-1264593c-59f8-43c4-b13a-4bf37b26b95e.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=901&size=46311&status=done&style=none&width=901\" alt=\"image.png\"></p>\n<h3 id=\"11、使用-Chrome-作为代码编辑工具\"><a href=\"#11、使用-Chrome-作为代码编辑工具\" class=\"headerlink\" title=\"11、使用 Chrome 作为代码编辑工具\"></a>11、使用 Chrome 作为代码编辑工具</h3><ul>\n<li>选中 <code>Sources &gt; Filesystem</code>  然后关联本地文件夹即可</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964541164-bfa7a598-c5df-4ac4-9782-93fc5e7cdd82.png#align=left&display=inline&height=620&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=1067&size=131817&status=done&style=none&width=1067\" alt=\"image.png\"></p>\n<h3 id=\"12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码\"><a href=\"#12、使用-Chrome-的-Snippets-功能保存代码片段，拒绝重复的代码\" class=\"headerlink\" title=\"12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码\"></a>12、使用 Chrome 的 Snippets 功能保存代码片段，拒绝重复的代码</h3><ul>\n<li>选中 <code>Sources &gt; Snippets</code>  创建新的代码片段</li>\n<li>输入 <code>Command + p</code>  后输入 <code>i</code>  后执行</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606964857768-858ca1ae-b5d2-4147-b2f8-1632e49c85b8.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=1845&size=79129&status=done&style=none&width=1845\" alt=\"image.png\"></p>\n<h3 id=\"13、使用-Chome-实时保存更改的-css-样式\"><a href=\"#13、使用-Chome-实时保存更改的-css-样式\" class=\"headerlink\" title=\"13、使用 Chome 实时保存更改的 css 样式\"></a>13、使用 Chome 实时保存更改的 css 样式</h3><ul>\n<li>选中 <code>Source &gt; Overrides</code> ，之后点击 <code>+</code>  选择一个本地文件夹用来保存更改后的样式，最后勾选 <code>Enable Local Overrides</code> 。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965107087-3d47d726-c4fb-4d0c-9d48-38c5422db524.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=1522&size=23539&status=done&style=none&width=1522\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965155644-099a9d4e-fec1-4433-9d24-55f52727ca22.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=114&originWidth=395&size=9886&status=done&style=none&width=395\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965811764-61b27e31-8e8f-4b23-b93f-46c0a52f8069.png#align=left&display=inline&height=417&margin=%5Bobject%20Object%5D&name=image.png&originHeight=417&originWidth=831&size=60690&status=done&style=none&width=831\" alt=\"image.png\"></p>\n<h3 id=\"14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比\"><a href=\"#14、使用-Chrome-查看使用-Overrides-更改后内容与之前内容的对比\" class=\"headerlink\" title=\"14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比\"></a>14、使用 Chrome 查看使用 Overrides 更改后内容与之前内容的对比</h3><ul>\n<li>输入 <code>Command + shift + p</code> ，搜索 <code>show changes</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965562313-e3ac2cd8-614a-457e-a0c6-912660c48270.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=519&size=7584&status=done&style=none&width=519\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965855015-feca9397-66d0-40ac-ab41-e349241c14e1.png#align=left&display=inline&height=651&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1136&size=118201&status=done&style=none&width=1136\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606965980764-b6e363ca-172d-4a63-b141-137b186f97e7.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=928&size=40226&status=done&style=none&width=928\" alt=\"image.png\"></p>\n<h3 id=\"15、查看-Chrome-请求是由谁发起的\"><a href=\"#15、查看-Chrome-请求是由谁发起的\" class=\"headerlink\" title=\"15、查看 Chrome 请求是由谁发起的\"></a>15、查看 Chrome 请求是由谁发起的</h3><ul>\n<li>选择 <code>NetWork &gt; Initialtor</code> ，不但可以查看调用位置，也可获取触发位置。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966265653-8fd5a74d-5486-4b50-951d-3ac4aa2dafb9.png#align=left&display=inline&height=650&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1077&size=93651&status=done&style=none&width=1077\" alt=\"image.png\"><br><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966315917-5db64699-69bd-4b64-b041-36e35a03bedc.png#align=left&display=inline&height=96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=96&originWidth=744&size=15715&status=done&style=none&width=744\" alt=\"image.png\"></p>\n<h3 id=\"16、Chrome-性能监测工具\"><a href=\"#16、Chrome-性能监测工具\" class=\"headerlink\" title=\"16、Chrome 性能监测工具\"></a>16、Chrome 性能监测工具</h3><ul>\n<li><code>Command + shift + p</code>  输入 <code>show performance monitor</code>  即可实时查看程序运行的性能。<ul>\n<li><code>CPU usage</code> ： <code>cpu</code> 的监听</li>\n<li><code>JS heap size</code> : 内存占用监听，如添加到 <code>window</code>  对象上的事件不回收会造成内存溢出。</li>\n<li><code>DOM Nodes</code>: 内存中所分配的 <code>dom</code> 节点的个数</li>\n<li><code>JS envnt listeners</code>: <code>js</code> 中已经绑定的事件个数</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606966748112-fdd53dde-e210-458e-992a-68429c28b334.png#align=left&display=inline&height=319&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1919&size=60517&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"17、使用-Chrome-做性能调优，迅速定位问题\"><a href=\"#17、使用-Chrome-做性能调优，迅速定位问题\" class=\"headerlink\" title=\"17、使用 Chrome 做性能调优，迅速定位问题\"></a>17、使用 Chrome 做性能调优，迅速定位问题</h3><ul>\n<li>选择 <code>performance</code>  点击录制按钮，可以查看从录制开始到停止时间内 <code>js</code> 代码运行的情况。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967325061-7ddbd154-20e4-4ff2-b903-ca2a8e05c378.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1919&size=111943&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率\"><a href=\"#18、使用-Chrome-动画检查器，检查修改-css-动画，提升效率\" class=\"headerlink\" title=\"18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率\"></a>18、使用 Chrome 动画检查器，检查修改 css 动画，提升效率</h3><ul>\n<li><code>Command + shift + p</code>  输入 <code>show animations</code>  打开动画的调试器。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1606967977814-c5fa0c33-8952-46b2-84d2-a1315a766658.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=1919&size=108889&status=done&style=none&width=1919\" alt=\"image.png\"></p>\n<h3 id=\"19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况\"><a href=\"#19、使用-Chrome-查看代码覆盖率，检查代码覆盖情况\" class=\"headerlink\" title=\"19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况\"></a>19、使用 Chrome 查看代码覆盖率，检查代码覆盖情况</h3><ul>\n<li><code>Command + shift +p</code>  输入 <code>show coverage</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1607172475188-07f61e49-f764-427e-8b1b-71a45b552b27.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1893&size=172193&status=done&style=none&width=1893\" alt=\"image.png\"></p>\n<h3 id=\"20、copy-复制控制台内容\"><a href=\"#20、copy-复制控制台内容\" class=\"headerlink\" title=\"20、copy() 复制控制台内容\"></a>20、copy() 复制控制台内容</h3><ul>\n<li>可以通过全局的方法  <code>copy()</code>  在  <code>console</code>  里  <code>copy</code>  任何你能拿到的资源，包括我们在后面[第六节]会提到的那些变量。例如  <code>copy($_)</code>  或  <code>copy($0)</code></li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278259306-ac7e6a27-9b73-424c-955c-9d60cde38aad.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1780049&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"21、-查看上一次程序执行结果\"><a href=\"#21、-查看上一次程序执行结果\" class=\"headerlink\" title=\"21、$_查看上一次程序执行结果\"></a>21、$_查看上一次程序执行结果</h3><ul>\n<li><code>$_</code>  是对上次执行的结果的 <strong>引用</strong></li>\n</ul>\n<p>**<br><strong><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608278776314-7be09c82-b10e-4760-9dc0-ecccb00e01c9.png#align=left&display=inline&height=184&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=1014&size=116869&status=done&style=none&width=507\" alt=\"image.png\"></strong></p>\n<h3 id=\"22、-i-配合-chrome-插件引入第三方包\"><a href=\"#22、-i-配合-chrome-插件引入第三方包\" class=\"headerlink\" title=\"22、$i 配合 chrome 插件引入第三方包\"></a>22、$i 配合 chrome 插件引入第三方包</h3><ul>\n<li>有时你只是想玩玩新出的 <code>npm</code> 包，现在不用再大费周章去建一个项目测试了，只需要在 <a href=\"https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related\">Chrome 插件:Console Importer</a> 的帮助之下，快速的在 <code>console</code> 中引入和测试一些 <code>npm</code> 库。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608278892044-9115b62e-c6ff-40ac-8330-253b84191be6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1817520&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"23、使用实时表达式\"><a href=\"#23、使用实时表达式\" class=\"headerlink\" title=\"23、使用实时表达式\"></a>23、使用实时表达式</h3><ul>\n<li><code>DevTools</code> 在 <code>Console</code> 面板中引入了一个非常漂亮的附加功能，这是一个名为 <code>Live expression</code> 的工具。只需按下 “眼睛” 符号，你就可以在那里定义任何 <code>JavaScript</code> 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281376215-967b1d31-4690-4f9d-a5f7-868365ce3f6a.gif#align=left&display=inline&height=716&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=716&originWidth=1102&size=2073027&status=done&style=none&width=1102\" alt=\"1.gif\"></p>\n<h3 id=\"24、通过-‘h’-来隐藏元素\"><a href=\"#24、通过-‘h’-来隐藏元素\" class=\"headerlink\" title=\"24、通过 ‘h’ 来隐藏元素\"></a>24、通过 ‘h’ 来隐藏元素</h3><ul>\n<li>按一下  <code>&#39;h&#39;</code>  就可以隐藏你在元素面板中选择的元素。再次按下 ‘<code>h</code>‘ 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281579251-0b47cee8-0d8d-4445-a858-2d409edd6e7c.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=802&originWidth=1332&size=1651328&status=done&style=none&width=1332\" alt=\"1.gif\"></p>\n<h3 id=\"25、拖动-amp-放置-元素\"><a href=\"#25、拖动-amp-放置-元素\" class=\"headerlink\" title=\"25、拖动 &amp; 放置 元素\"></a>25、拖动 &amp; 放置 元素</h3><ul>\n<li>当你想看看页面的某一部分在  <code>DOM</code>  树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281657769-7775b7d5-2c49-44e8-9f5f-0d52ced8ac17.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=2.gif&originHeight=642&originWidth=1066&size=891397&status=done&style=none&width=1066\" alt=\"2.gif\"></p>\n<h3 id=\"26、使用-control-按钮-来移动元素\"><a href=\"#26、使用-control-按钮-来移动元素\" class=\"headerlink\" title=\"26、使用 control (按钮) 来移动元素!\"></a>26、使用 <code>control</code> (按钮) 来移动元素!</h3><ul>\n<li>如果你只是想移动你当前选中的元素，在  <code>DOM</code>  结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用<code>[ctrl]</code> + <code>[⬆]</code> / <code>[ctrl]</code> + <code>[⬇]</code> (<code>[⌘]</code> + <code>[⬆]</code> / <code>[⌘]</code> + <code>[⬇]</code> on Mac).</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281716760-63613a96-c29f-488f-b7e9-f16994b0c2b6.gif#align=left&display=inline&height=802&margin=%5Bobject%20Object%5D&name=3.gif&originHeight=802&originWidth=1332&size=3046583&status=done&style=none&width=1332\" alt=\"3.gif\"></p>\n<h3 id=\"27、元素面板中类似于基础编辑器的操作\"><a href=\"#27、元素面板中类似于基础编辑器的操作\" class=\"headerlink\" title=\"27、元素面板中类似于基础编辑器的操作\"></a>27、元素面板中类似于基础编辑器的操作</h3><ul>\n<li><p>从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 <code>[ctrl]</code> + <code>[v]</code> 来粘贴)， 所以我们可以在元素面板里把 <code>HTML</code> 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？</p>\n</li>\n<li><p>使用<code>[ctrl]</code> + <code>[z]</code> (<code>[⌘]</code> + <code>[z]</code> on Mac)撤销我们的任何改动。 使用 <code>[ctrl]</code> + <code>[shift]</code> + <code>[z]</code>重新编辑我们的任何修改。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281829967-1a9d3db2-270a-4f23-9d25-52585c80aed7.gif#align=left&display=inline&height=642&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=642&originWidth=1066&size=5633497&status=done&style=none&width=1066\" alt=\"1.gif\"></p>\n<h3 id=\"28、Shadow-editor-阴影编辑器\"><a href=\"#28、Shadow-editor-阴影编辑器\" class=\"headerlink\" title=\"28、Shadow editor 阴影编辑器\"></a>28、<code>Shadow editor</code> 阴影编辑器</h3><ul>\n<li>你可以通过在  <code>Style</code>  面板中点击靠近  <code>box-shadow</code>  属性或者  <code>text-shadow</code>  属性的  <code>阴影方形符号</code>  来打开它：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281887248-eed208b7-7636-4172-b428-ba7a07bec474.gif#align=left&display=inline&height=718&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=718&originWidth=576&size=722085&status=done&style=none&width=576\" alt=\"1.gif\"></p>\n<h3 id=\"29、Timing-function-editor-定时函数编辑器\"><a href=\"#29、Timing-function-editor-定时函数编辑器\" class=\"headerlink\" title=\"29、Timing function editor 定时函数编辑器\"></a>29、Timing function editor 定时函数编辑器</h3><ul>\n<li><p>也称为 <code>Cubic bezier(贝塞尔)</code> 编辑器。贝塞尔曲线是一串用来定义 <code>CSS</code> 的动画速度在整个动画过程中如何变化的 <code>魔法数值</code> 。我们将其定义为 <code>transition-timing-function</code> 或者 <code>animation-timing-function</code> CSS 属性。</p>\n</li>\n<li><p>像之前说的 <code>Color picker</code> 和 <code>Shadow editor</code> 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：<code>trasition</code>， <code>animation</code> - 请注意：如果<code>timing</code> 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608281968319-1ce527ef-daf5-4eb7-8d8c-f3c2747bfa4d.gif#align=left&display=inline&height=590&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=590&originWidth=474&size=3886698&status=done&style=none&width=474\" alt=\"1.gif\"></p>\n<h3 id=\"30、插入样式规则的按钮\"><a href=\"#30、插入样式规则的按钮\" class=\"headerlink\" title=\"30、插入样式规则的按钮\"></a>30、插入样式规则的按钮</h3><p>当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 <code>Color</code> 和 <code>Shadow</code> 编辑器添加 <code>CSS</code> 属性的按钮：</p>\n<ul>\n<li><p><code>text-shadow</code></p>\n</li>\n<li><p><code>box-shadow</code></p>\n</li>\n<li><p><code>color</code></p>\n</li>\n<li><p><code>background-color</code></p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282091218-b368c609-f0ae-49c2-a1cf-fbc31424917e.gif#align=left&display=inline&height=558&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=558&originWidth=632&size=1958540&status=done&style=none&width=632\" alt=\"1.gif\"></p>\n<h3 id=\"31、在元素面板中展开所有的子节点\"><a href=\"#31、在元素面板中展开所有的子节点\" class=\"headerlink\" title=\"31、在元素面板中展开所有的子节点\"></a>31、在元素面板中展开所有的子节点</h3><ul>\n<li>一个一个的去点击级联的  <code>▶</code>  按钮太慢了，不如使用右击节点后的  <code>expand recursively</code>  命令：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282162863-1a2d16de-4444-497e-b927-0f85bfd59964.gif#align=left&display=inline&height=520&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=520&originWidth=760&size=7216217&status=done&style=none&width=760\" alt=\"1.gif\"></p>\n<h3 id=\"32、控制传感器\"><a href=\"#32、控制传感器\" class=\"headerlink\" title=\"32、控制传感器\"></a>32、控制传感器</h3><ul>\n<li><p>如果你正在你的应用中使用一些获取位置信息的 <code>API</code> 而且想要测试一下它，总不能开着车环绕世界吧，(其实也不是不行 😉)。</p>\n</li>\n<li><p><code>Drawer</code> 里的 <code>Sensors(传感器)</code> 面板可以让你模拟特定的位置: 支持从预定义的位置中进行选择，添加自己的位置，或者手动键入纬度/经度。选定的值将被 <code>navigator.geolocation.watchPosition</code>（或 <code>.getCurrentPosition</code> ）报告。</p>\n</li>\n<li><p>如果你的 <code>App</code> 使用加速计，传感器面板也可以模拟你设备在 3D 空间中的位置！</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1608282513575-bb313d74-b584-4f58-ac1b-f577ffe719c0.gif#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&name=1.gif&originHeight=728&originWidth=774&size=1259259&status=done&style=none&width=774\" alt=\"1.gif\"></p>\n"},{"title":"Vue2 文档","date":"2020-07-14T16:00:00.000Z","_content":"\n## 1. 父子组件传值\n\n- 父子： `props`\n- 子父： `this.$emit('事件名', 参数)`\n\n## 2. 获取 dom 节点\n\n> `this.$refs`， 可以获取组件的引用，同时可以获取组件的 `data，methods` 等\n\n## 3. 路由\n\n- 后端路由\n\n> 对于普通的网站，所有的超链接都是 `URL` 地址，所有的 `URL` 地址都对应服务器上的资源。\n\n- 前端路由\n\n> 对于单页面应用程序（`SPA`），主要通过 `URL` 的 `hash(#)` 来实现不同页面之间的切换；同时，`hash` 有一个特点，`http` 请求中不会包含 `hash` 相关的内容\n\n## 4. 命名视图 router-view\n\n```vue\n<template>\n  <div id=\"app\">\n    <router-view></router-view>\n    <router-view name=\"left\"></router-view>\n    <router-view name=\"main\"></router-view>\n  </div>\n</template>\n\n<script>\nvar header = {\n  template: \"<div>header</div>\"\n};\nvar leftBox = {\n  template: \"<div>left</div>\"\n};\nvar mainBox = {\n  template: \"<div>main</div>\"\n};\n\nvar router = new VueRouter({\n  routes: [\n    {\n      path: \"/\",\n      components: {\n        default: header,\n        left: leftBox,\n        main: mainBox\n      }\n    }\n  ]\n});\n\nvar vm = new Vue({\n  el: \"#app\",\n  router\n});\n</script>\n```\n\n## 5. watch\n\n```vue\n<template>\n  <input type=\"text\" v-model=\"msg\" />\n</template>\n\n<script>\ndata: {\n   msg: ''\n},\nwatch: {\n  msg(newVal, oldVal) {\n    console.log(newVal, oldVal)\n  },\n  \"$route.path\": (newVal, oldVal) => {\n    console.log(newVal, oldVal)\n  }\n}\n</script>\n```\n\n## 6. computed\n\n- 在 `computed` 中，可以定义一些属性（计算属性）；计算属性的本质就是一个方法。只不过在我们这些计算属性的时候，是直接把他们的名称当作属性来使用的，并不会把计算属性当作方法来调用。\n- 计算属性的求值结果，会被缓存起来，方便下次直接使用; 如果 `计算属性` 方法中，所依赖的所有数据，都没有发生变化，则不会重新对 `计算属性` 进行求值\n\n```vue\n<template>\n  <input type=\"text\" v-model=\"firstname\" />\n  <input type=\"text\" v-model=\"lastname\" />\n  <input type=\"text\" v-model=\"fullname\" />\n</template>\n\n<script>\ndata: {\n    firstname: '',\n    lastname: ''\n},\ncomputed: {\n    fullname() {\n        return this.firstname + '-' + this.lastname;\n    }\n}\n</script>\n```\n\n## 7. render\n\n- `createElements` 是一个方法，调用它，能够把指定的组件模板，渲染为 `html` 结构\n- 通常习惯性将 `createElements` 写成 `h`\n\n```vue\n<script>\nvar login = {\n  template: \"<h1>这是登陆组件</h1>\"\n};\n\nvar vm = new Vue({\n  el: \"#app\",\n  data: {},\n  render: function (createElements) {\n    return createElements(login);\n  }\n});\n</script>\n```\n\n## 8. 模块的导入与导出\n\n- `commenJs` 导入导出模块\n\n> 导入\n\n```javascript\nvar 名称 = require(\"模块标识符\");\n```\n\n> 导出\n\n```javascript\nmodule.exports = {};\n```\n\n- `import` 导入导出模块\n\n> 导入\n\n```javascript\ninport 名称A from '模块标识符'\ninport { 名称B } '标识路径'\n```\n\n> 导出\n\n```javascript\nexport default 名称A\nexport 名称B\n```\n\n> 重命名\n\n```javascript\nimport 名称A as newA from '模块标识符'\nimport { 名称B as newB } from '标示路径'\n```\n\n## 9. vuex\n\n### 介绍\n\n- `vuex` 是 `vue.js` 应用程序开发的状态管理模式（状态可以理解为数据），它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可检测的方式发生变化\n\n### props，data 和 vuex 的区别\n\n- `props`: 存放父组件传递过来的数据\n- `data`: 存放私有数据\n- `vuex`: 组件之间共享的数据\n\n### state，mutations，actions，getters，modules\n\n- `state`：类似于 `data`，用来存数据\n\n> 访问\n\n```javascript\nthis.$store.state.数据a\n\n...mapState\n```\n\n- `mutations`：类似于 `methods`，处理同步方法\n\n> 使用\n\n```javascript\nmutations: {\n    \"METHODS\": function(state, value) {\n        state.value = value;\n    }\n}\n```\n\n> 访问\n\n```javascript\nthis.$store.commit('方法名', '参数')\n\n...mapMutations\n```\n\n- `actions`：类似于 `methods`，处理异步方法\n\n> 使用\n\n```javascript\nactions: {\n    async methodsAsync({ commit }, value) {\n        try {\n            const result = await apiMethods()\n            if (result.code === 200) {\n                commit(\"SET_METHODS\", result.data)\n            }\n        } catch(err) {\n            throw new Error(err);\n        }\n    }\n}\n```\n\n> 访问\n\n```javascript\nthis.$store.dispatch('方法名', '参数')\n\n...mapActions\n```\n\n- `getters`：类似于 `computed` 和 `filter`，处理数据\n\n> 使用\n\n```javascript\ngetters: {\n    newData(state) {\n        return state.arr.filter(item => item.id === 1)\n    }\n}\n```\n\n> 访问\n\n```javascript\nthis.$store.getters('名称')\n\n...mapGetters\n```\n\n## 10. props 传递数据未更新\n\n> 解决方式：使用 `watch` 监听 `props`\n\n## 11. 生命周期\n\n### beforeCreate\n\n- 组件创建阶段\n\n> 此时，组件的 `data` 和 `methods` 以及页面 `DOM` 结构都还没有初始化\n\n### created\n\n- 组件创建阶段\n\n> 此时，组件的 `data` 和 `methods` 已经可用了，但是页面 `DOM` 结构还没有渲染出来；经常用来发起 `ajax` 请求\n> 注意，在 `ssr` 服务端渲染的时候，在此处发起 `ajax` 请求会有问题，推荐在 `mounted` 生命周期函数中来发起 `ajax` 请求。\n\n### beforeMount\n\n- 组件创建阶段\n\n> 此时内存中的模板结构还没有*真正渲染到页面上*；此时，页面上*看不到真实的数据*，此时用户看到的只是一个模板页面\n\n### Mounted\n\n- 组件创建阶段\n\n> 组件挂载完毕，可初始化插件\n\n### beforeUpdate\n\n> _数据肯定是最新的_，然而*页面呈现的数据还是旧的*\n\n### updated\n\n> 页面已经完成了更新。此时，`data` 和 `view` 上都是最新的数据\n\n### beforeDestroy\n\n- 组件销毁阶段\n\n> 此时没有真正开始销毁，组件还是正常可用的。同时，`data` 、`methods` 等数据或方法，依然可以被正常访问；\n\n### destroyed\n\n- 组件销毁阶段\n\n> 组件已经完成了销毁.`data` 和 `methods` 都不可用了\n\n## 12  vue 组件从创建到销毁的整个过程\n\n| 行为                                                               | 指向 | 作用                                                                                                                                                 |\n| ------------------------------------------------------------------ | ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `new Vue()`                                                        | ➡️   | 实例化 `Vue` 对象                                                                                                                                    |\n| `Init Events & Lifecycle`                                          | ➡️   | 初始化组件 `methods` 和 `生命周期函数`                                                                                                               |\n| `beforeCreate`                                                     | ➡️   | `data`，`methods` 未被初始化                                                                                                                         |\n| `Init injections & reactivity`                                     | ➡️   | 正在初始化 `data` 和 `methods` 中的数据以及方法                                                                                                      |\n| `created`                                                          | ➡️   | `data`，`methods` 可用，但 `Dom` 结构还未被渲染，常发起 `ajax` 请求                                                                                  |\n| ⬇️                                                                 | ➡️   | 判断是否有 `el`，`template` 属性                                                                                                                     |\n| ⬇️                                                                 | ➡️   | 用来编译模版结构，当所有指令解析完毕，则`模板页面就被渲染到内存中了`；当模板编译完成，模板页面还没有挂在到页面上，只是存在于内存中，用户看不到页面； |\n| `beforeMount`                                                      | ➡️   | 此时，页面上看不到 `真实数据`，此时用户看到的只是一个模板页面                                                                                        |\n| `Create vm.$el and replace \"el\" with it`                           | ➡️   | 正在把内存中渲染好的模板结构替换到页面上                                                                                                             |\n| `mounted`                                                          | ➡️   | 此时，页面渲染完毕                                                                                                                                   |\n| ⬇️(组件运行中的生命周期函数)                                       | ➡️   | 会根据 `data` 数据的变化，有选择行的触发 `0`次 或 `n`次                                                                                              |\n| `beforeUpdate`                                                     | ➡️   | 数据是新的，但页面呈现的数据仍是旧的                                                                                                                 |\n| `updated`                                                          | ➡️   | 页面已经完成了更新，此时，数据是最新的，同时页面上呈现的数据也是最新的                                                                               |\n| ⬇️(销毁阶段)                                                       |      |                                                                                                                                                      |\n| `beforeDestroy`                                                    | ➡️   | 组件即将被销毁，但是还没有真 正开始销毁，此时组件还是正常可用的。`data`，`methods` 仍可正常访问                                                      |\n| `Teardown watchers,child components and event listeners`(销毁过程) | ➡️   |                                                                                                                                                      |\n| `destroyed`                                                        | ➡️   | 组件已经完成了销毁，组件已经废了，`data` 和 `methods` 都不可用了                                                                                     |\n\n## 13. keep-alive\n\n### 新增生命周期\n\n> 被包含在  `<keep-alive>`  中创建的组件，会多两个生命周期: `activated`  与  `deactivated`\n\n- actived\n\n> 组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 `keep-alive` 激活时被调用。\n\n- deactivated\n\n> 组件被停用时调用。\n\n### 新增属性\n\n- include\n\n> 包含的组件缓存生效。对应 `.vue` 文件的 `name` 属性\n\n- exclude\n\n> 排除的组件不缓存，优先级大于 `include`。对应 `.vue` 文件的 `name` 属性\n\n## 14. `nextTick`\n\n### 背景\n\n> 在官方文档中说明 `Vue` 是异步执行 `DOM` 更新的，所以在某些场景下需要进行特殊处理才可正常执行某些逻辑。\n\n### 应用场景\n\n- 在 `Vue` 生命周期的 `created()` 钩子函数进行的 `DOM` 操作一定要放在 `Vue.nextTick()` 的回调函数中\n\n> 原因: 在 `created()` 钩子函数执行的时候 `DOM` 其实并未进行任何渲染，而此时进行 `DOM` 操作毫无意义，因此一定要将操作 `Dom` 部分的代码放入 `Vue.nextTick()` 的回调函数中。与之对应的就是 `mounted()` 钩子函数，因为该钩子函数执行时所有的`DOM` 挂载和渲染都已完成，此时在该钩子函数中进行任何 `DOM` 操作都不会有问题 。\n\n- 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 `DOM` 结构的时候，这个操作都应该放进 `Vue.nextTick()` 的回调函数中。\n\n### nextTick 源码浅析\n\n> `Vue.nextTick` 用于延迟执行一段代码，它接受 `2` 个参数（ `回调函数` 和 `执行回调函数的上下文环境`），如果没有提供回调函数，那么将返回 `promise` 对象。\n\n> 主要的实现方式为判断设备所支持的三种属性，依据各自支持的属性来进行异步操作。如果支持 `promise`，会使用 `Promise.then` 来做延迟调用函数。如果设备不支持 `Promise` 对象，再判断是否支持 `MutationObserver` 对象，如果支持该对象，就使用`MutationObserver` 来做延迟，最后如果上面两种都不支持的话，我们会使用 `setTimeout` 来做延迟操作。\n\n## 15. 自定义指令\n\n### 简介\n\n> 除了核心功能默认内置的指令 ( `v-model`  和  `v-show`)， `Vue`  也允许注册自定义指令。\n\n> 注意，在 `Vue2.0` 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 `DOM`  元素进行底层操作，这时候就会用到自定义指令。\n\n- 例\n\n> 当页面加载时，该元素将获得焦点 (注意： `autofocus`  在移动版 `Safari`  上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：\n\n```javascript\n// 注册一个全局自定义指令 `v-focus`\nVue.directive(\"focus\", {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus();\n  }\n});\n```\n\n> 如果想注册局部指令，组件中也接受一个 `directives`  的选项：\n\n```javascript\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n\n> 然后你可以在模板中任何元素上使用新的  `v-focus`   `property`，如下\n\n```html\n<input v-focus />\n```\n\n### 钩子函数\n\n> 一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n- `update`：所在组件的 `VNode` 更新时调用，但是可能发生在其子 `VNode` 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n- `componentUpdated`：指令所在组件的 `VNode` 及其子 `VNode` 全部更新后调用。\n- `unbind`：只调用一次，指令与元素解绑时调用。\n\n> 接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。\n\n### 钩子函数参数\n\n> 指令钩子函数会被传入以下参数：\n\n- `el`：指令所绑定的元素，可以用来直接操作 `DOM`。\n- `binding`：一个对象，包含以下 `property`：\n  - `name`：指令名，不包括 `v-` 前缀。\n  - `value`：指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 `2`。\n  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n  - `expression`：字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。\n  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`。\n  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\n- `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3) 来了解更多详情。\n- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n> 除了  `el`  之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的  [`dataset`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset)  来进行。\n\n- 例\n\n```html\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\n```\n\n```javascript\nVue.directive(\"demo\", {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify;\n    el.innerHTML =\n      \"name: \" +\n      s(binding.name) +\n      \"<br>\" +\n      \"value: \" +\n      s(binding.value) +\n      \"<br>\" +\n      \"expression: \" +\n      s(binding.expression) +\n      \"<br>\" +\n      \"argument: \" +\n      s(binding.arg) +\n      \"<br>\" +\n      \"modifiers: \" +\n      s(binding.modifiers) +\n      \"<br>\" +\n      \"vnode keys: \" +\n      Object.keys(vnode).join(\", \");\n  }\n});\n\nnew Vue({\n  el: \"#hook-arguments-example\",\n  data: {\n    message: \"hello!\"\n  }\n});\n```\n\n### 动态指令参数\n\n> 指令的参数可以是动态的。例如，在 `v-mydirective:[argument]=\"value\"` 中，`argument` 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。\n\n> 例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：\n\n```html\n<div id=\"baseexample\">\n  <p>Scroll down the page</p>\n  <p v-pin=\"200\">Stick me 200px from the top of the page</p>\n</div>\n```\n\n```javascript\nVue.directive(\"pin\", {\n  bind: function (el, binding, vnode) {\n    el.style.position = \"fixed\";\n    el.style.top = binding.value + \"px\";\n  }\n});\n\nnew Vue({\n  el: \"#baseexample\"\n});\n```\n\n> 这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。\n\n```html\n<div id=\"dynamicexample\">\n  <h3>Scroll down inside this section ↓</h3>\n  <p v-pin:[direction]=\"200\">I am pinned onto the page at 200px to the left.</p>\n</div>\n```\n\n```javascript\nVue.directive(\"pin\", {\n  bind: function (el, binding, vnode) {\n    el.style.position = \"fixed\";\n    var s = binding.arg == \"left\" ? \"left\" : \"top\";\n    el.style[s] = binding.value + \"px\";\n  }\n});\n\nnew Vue({\n  el: \"#dynamicexample\",\n  data: function () {\n    return {\n      direction: \"left\"\n    };\n  }\n});\n```\n\n### 函数简写\n\n> 在很多时候，你可能想在  `bind`  和  `update`  时触发相同行为，而不关心其它的钩子。比如这样写：\n\n```javascript\nVue.directive(\"color-swatch\", function (el, binding) {\n  el.style.backgroundColor = binding.value;\n});\n```\n\n### 对象字面量\n\n> 如果指令需要多个值，可以传入一个 `JavaScript` 对象字面量。记住，指令函数能够接受所有合法的 `JavaScript` 表达式。\n\n```html\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\n```\n\n```javascript\nVue.directive(\"demo\", function (el, binding) {\n  console.log(binding.value.color); // => \"white\"\n  console.log(binding.value.text); // => \"hello!\"\n});\n```\n\n## 15. vue 3.0 尝鲜\n\n[中文文档](https://www.liulongbin.top:8085/)\n","source":"_posts/前端/Vue2 文档.md","raw":"---\ntitle: Vue2 文档\ndate: 2020-07-15\ncategories: [前端, vue]\ntags:\n  - 文档\n---\n\n## 1. 父子组件传值\n\n- 父子： `props`\n- 子父： `this.$emit('事件名', 参数)`\n\n## 2. 获取 dom 节点\n\n> `this.$refs`， 可以获取组件的引用，同时可以获取组件的 `data，methods` 等\n\n## 3. 路由\n\n- 后端路由\n\n> 对于普通的网站，所有的超链接都是 `URL` 地址，所有的 `URL` 地址都对应服务器上的资源。\n\n- 前端路由\n\n> 对于单页面应用程序（`SPA`），主要通过 `URL` 的 `hash(#)` 来实现不同页面之间的切换；同时，`hash` 有一个特点，`http` 请求中不会包含 `hash` 相关的内容\n\n## 4. 命名视图 router-view\n\n```vue\n<template>\n  <div id=\"app\">\n    <router-view></router-view>\n    <router-view name=\"left\"></router-view>\n    <router-view name=\"main\"></router-view>\n  </div>\n</template>\n\n<script>\nvar header = {\n  template: \"<div>header</div>\"\n};\nvar leftBox = {\n  template: \"<div>left</div>\"\n};\nvar mainBox = {\n  template: \"<div>main</div>\"\n};\n\nvar router = new VueRouter({\n  routes: [\n    {\n      path: \"/\",\n      components: {\n        default: header,\n        left: leftBox,\n        main: mainBox\n      }\n    }\n  ]\n});\n\nvar vm = new Vue({\n  el: \"#app\",\n  router\n});\n</script>\n```\n\n## 5. watch\n\n```vue\n<template>\n  <input type=\"text\" v-model=\"msg\" />\n</template>\n\n<script>\ndata: {\n   msg: ''\n},\nwatch: {\n  msg(newVal, oldVal) {\n    console.log(newVal, oldVal)\n  },\n  \"$route.path\": (newVal, oldVal) => {\n    console.log(newVal, oldVal)\n  }\n}\n</script>\n```\n\n## 6. computed\n\n- 在 `computed` 中，可以定义一些属性（计算属性）；计算属性的本质就是一个方法。只不过在我们这些计算属性的时候，是直接把他们的名称当作属性来使用的，并不会把计算属性当作方法来调用。\n- 计算属性的求值结果，会被缓存起来，方便下次直接使用; 如果 `计算属性` 方法中，所依赖的所有数据，都没有发生变化，则不会重新对 `计算属性` 进行求值\n\n```vue\n<template>\n  <input type=\"text\" v-model=\"firstname\" />\n  <input type=\"text\" v-model=\"lastname\" />\n  <input type=\"text\" v-model=\"fullname\" />\n</template>\n\n<script>\ndata: {\n    firstname: '',\n    lastname: ''\n},\ncomputed: {\n    fullname() {\n        return this.firstname + '-' + this.lastname;\n    }\n}\n</script>\n```\n\n## 7. render\n\n- `createElements` 是一个方法，调用它，能够把指定的组件模板，渲染为 `html` 结构\n- 通常习惯性将 `createElements` 写成 `h`\n\n```vue\n<script>\nvar login = {\n  template: \"<h1>这是登陆组件</h1>\"\n};\n\nvar vm = new Vue({\n  el: \"#app\",\n  data: {},\n  render: function (createElements) {\n    return createElements(login);\n  }\n});\n</script>\n```\n\n## 8. 模块的导入与导出\n\n- `commenJs` 导入导出模块\n\n> 导入\n\n```javascript\nvar 名称 = require(\"模块标识符\");\n```\n\n> 导出\n\n```javascript\nmodule.exports = {};\n```\n\n- `import` 导入导出模块\n\n> 导入\n\n```javascript\ninport 名称A from '模块标识符'\ninport { 名称B } '标识路径'\n```\n\n> 导出\n\n```javascript\nexport default 名称A\nexport 名称B\n```\n\n> 重命名\n\n```javascript\nimport 名称A as newA from '模块标识符'\nimport { 名称B as newB } from '标示路径'\n```\n\n## 9. vuex\n\n### 介绍\n\n- `vuex` 是 `vue.js` 应用程序开发的状态管理模式（状态可以理解为数据），它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可检测的方式发生变化\n\n### props，data 和 vuex 的区别\n\n- `props`: 存放父组件传递过来的数据\n- `data`: 存放私有数据\n- `vuex`: 组件之间共享的数据\n\n### state，mutations，actions，getters，modules\n\n- `state`：类似于 `data`，用来存数据\n\n> 访问\n\n```javascript\nthis.$store.state.数据a\n\n...mapState\n```\n\n- `mutations`：类似于 `methods`，处理同步方法\n\n> 使用\n\n```javascript\nmutations: {\n    \"METHODS\": function(state, value) {\n        state.value = value;\n    }\n}\n```\n\n> 访问\n\n```javascript\nthis.$store.commit('方法名', '参数')\n\n...mapMutations\n```\n\n- `actions`：类似于 `methods`，处理异步方法\n\n> 使用\n\n```javascript\nactions: {\n    async methodsAsync({ commit }, value) {\n        try {\n            const result = await apiMethods()\n            if (result.code === 200) {\n                commit(\"SET_METHODS\", result.data)\n            }\n        } catch(err) {\n            throw new Error(err);\n        }\n    }\n}\n```\n\n> 访问\n\n```javascript\nthis.$store.dispatch('方法名', '参数')\n\n...mapActions\n```\n\n- `getters`：类似于 `computed` 和 `filter`，处理数据\n\n> 使用\n\n```javascript\ngetters: {\n    newData(state) {\n        return state.arr.filter(item => item.id === 1)\n    }\n}\n```\n\n> 访问\n\n```javascript\nthis.$store.getters('名称')\n\n...mapGetters\n```\n\n## 10. props 传递数据未更新\n\n> 解决方式：使用 `watch` 监听 `props`\n\n## 11. 生命周期\n\n### beforeCreate\n\n- 组件创建阶段\n\n> 此时，组件的 `data` 和 `methods` 以及页面 `DOM` 结构都还没有初始化\n\n### created\n\n- 组件创建阶段\n\n> 此时，组件的 `data` 和 `methods` 已经可用了，但是页面 `DOM` 结构还没有渲染出来；经常用来发起 `ajax` 请求\n> 注意，在 `ssr` 服务端渲染的时候，在此处发起 `ajax` 请求会有问题，推荐在 `mounted` 生命周期函数中来发起 `ajax` 请求。\n\n### beforeMount\n\n- 组件创建阶段\n\n> 此时内存中的模板结构还没有*真正渲染到页面上*；此时，页面上*看不到真实的数据*，此时用户看到的只是一个模板页面\n\n### Mounted\n\n- 组件创建阶段\n\n> 组件挂载完毕，可初始化插件\n\n### beforeUpdate\n\n> _数据肯定是最新的_，然而*页面呈现的数据还是旧的*\n\n### updated\n\n> 页面已经完成了更新。此时，`data` 和 `view` 上都是最新的数据\n\n### beforeDestroy\n\n- 组件销毁阶段\n\n> 此时没有真正开始销毁，组件还是正常可用的。同时，`data` 、`methods` 等数据或方法，依然可以被正常访问；\n\n### destroyed\n\n- 组件销毁阶段\n\n> 组件已经完成了销毁.`data` 和 `methods` 都不可用了\n\n## 12  vue 组件从创建到销毁的整个过程\n\n| 行为                                                               | 指向 | 作用                                                                                                                                                 |\n| ------------------------------------------------------------------ | ---- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `new Vue()`                                                        | ➡️   | 实例化 `Vue` 对象                                                                                                                                    |\n| `Init Events & Lifecycle`                                          | ➡️   | 初始化组件 `methods` 和 `生命周期函数`                                                                                                               |\n| `beforeCreate`                                                     | ➡️   | `data`，`methods` 未被初始化                                                                                                                         |\n| `Init injections & reactivity`                                     | ➡️   | 正在初始化 `data` 和 `methods` 中的数据以及方法                                                                                                      |\n| `created`                                                          | ➡️   | `data`，`methods` 可用，但 `Dom` 结构还未被渲染，常发起 `ajax` 请求                                                                                  |\n| ⬇️                                                                 | ➡️   | 判断是否有 `el`，`template` 属性                                                                                                                     |\n| ⬇️                                                                 | ➡️   | 用来编译模版结构，当所有指令解析完毕，则`模板页面就被渲染到内存中了`；当模板编译完成，模板页面还没有挂在到页面上，只是存在于内存中，用户看不到页面； |\n| `beforeMount`                                                      | ➡️   | 此时，页面上看不到 `真实数据`，此时用户看到的只是一个模板页面                                                                                        |\n| `Create vm.$el and replace \"el\" with it`                           | ➡️   | 正在把内存中渲染好的模板结构替换到页面上                                                                                                             |\n| `mounted`                                                          | ➡️   | 此时，页面渲染完毕                                                                                                                                   |\n| ⬇️(组件运行中的生命周期函数)                                       | ➡️   | 会根据 `data` 数据的变化，有选择行的触发 `0`次 或 `n`次                                                                                              |\n| `beforeUpdate`                                                     | ➡️   | 数据是新的，但页面呈现的数据仍是旧的                                                                                                                 |\n| `updated`                                                          | ➡️   | 页面已经完成了更新，此时，数据是最新的，同时页面上呈现的数据也是最新的                                                                               |\n| ⬇️(销毁阶段)                                                       |      |                                                                                                                                                      |\n| `beforeDestroy`                                                    | ➡️   | 组件即将被销毁，但是还没有真 正开始销毁，此时组件还是正常可用的。`data`，`methods` 仍可正常访问                                                      |\n| `Teardown watchers,child components and event listeners`(销毁过程) | ➡️   |                                                                                                                                                      |\n| `destroyed`                                                        | ➡️   | 组件已经完成了销毁，组件已经废了，`data` 和 `methods` 都不可用了                                                                                     |\n\n## 13. keep-alive\n\n### 新增生命周期\n\n> 被包含在  `<keep-alive>`  中创建的组件，会多两个生命周期: `activated`  与  `deactivated`\n\n- actived\n\n> 组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 `keep-alive` 激活时被调用。\n\n- deactivated\n\n> 组件被停用时调用。\n\n### 新增属性\n\n- include\n\n> 包含的组件缓存生效。对应 `.vue` 文件的 `name` 属性\n\n- exclude\n\n> 排除的组件不缓存，优先级大于 `include`。对应 `.vue` 文件的 `name` 属性\n\n## 14. `nextTick`\n\n### 背景\n\n> 在官方文档中说明 `Vue` 是异步执行 `DOM` 更新的，所以在某些场景下需要进行特殊处理才可正常执行某些逻辑。\n\n### 应用场景\n\n- 在 `Vue` 生命周期的 `created()` 钩子函数进行的 `DOM` 操作一定要放在 `Vue.nextTick()` 的回调函数中\n\n> 原因: 在 `created()` 钩子函数执行的时候 `DOM` 其实并未进行任何渲染，而此时进行 `DOM` 操作毫无意义，因此一定要将操作 `Dom` 部分的代码放入 `Vue.nextTick()` 的回调函数中。与之对应的就是 `mounted()` 钩子函数，因为该钩子函数执行时所有的`DOM` 挂载和渲染都已完成，此时在该钩子函数中进行任何 `DOM` 操作都不会有问题 。\n\n- 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 `DOM` 结构的时候，这个操作都应该放进 `Vue.nextTick()` 的回调函数中。\n\n### nextTick 源码浅析\n\n> `Vue.nextTick` 用于延迟执行一段代码，它接受 `2` 个参数（ `回调函数` 和 `执行回调函数的上下文环境`），如果没有提供回调函数，那么将返回 `promise` 对象。\n\n> 主要的实现方式为判断设备所支持的三种属性，依据各自支持的属性来进行异步操作。如果支持 `promise`，会使用 `Promise.then` 来做延迟调用函数。如果设备不支持 `Promise` 对象，再判断是否支持 `MutationObserver` 对象，如果支持该对象，就使用`MutationObserver` 来做延迟，最后如果上面两种都不支持的话，我们会使用 `setTimeout` 来做延迟操作。\n\n## 15. 自定义指令\n\n### 简介\n\n> 除了核心功能默认内置的指令 ( `v-model`  和  `v-show`)， `Vue`  也允许注册自定义指令。\n\n> 注意，在 `Vue2.0` 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 `DOM`  元素进行底层操作，这时候就会用到自定义指令。\n\n- 例\n\n> 当页面加载时，该元素将获得焦点 (注意： `autofocus`  在移动版 `Safari`  上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：\n\n```javascript\n// 注册一个全局自定义指令 `v-focus`\nVue.directive(\"focus\", {\n  // 当被绑定的元素插入到 DOM 中时……\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus();\n  }\n});\n```\n\n> 如果想注册局部指令，组件中也接受一个 `directives`  的选项：\n\n```javascript\ndirectives: {\n  focus: {\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n```\n\n> 然后你可以在模板中任何元素上使用新的  `v-focus`   `property`，如下\n\n```html\n<input v-focus />\n```\n\n### 钩子函数\n\n> 一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n\n- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n- `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n- `update`：所在组件的 `VNode` 更新时调用，但是可能发生在其子 `VNode` 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。\n- `componentUpdated`：指令所在组件的 `VNode` 及其子 `VNode` 全部更新后调用。\n- `unbind`：只调用一次，指令与元素解绑时调用。\n\n> 接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。\n\n### 钩子函数参数\n\n> 指令钩子函数会被传入以下参数：\n\n- `el`：指令所绑定的元素，可以用来直接操作 `DOM`。\n- `binding`：一个对象，包含以下 `property`：\n  - `name`：指令名，不包括 `v-` 前缀。\n  - `value`：指令的绑定值，例如：`v-my-directive=\"1 + 1\"` 中，绑定值为 `2`。\n  - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。\n  - `expression`：字符串形式的指令表达式。例如 `v-my-directive=\"1 + 1\"` 中，表达式为 `\"1 + 1\"`。\n  - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `\"foo\"`。\n  - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。\n- `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3) 来了解更多详情。\n- `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。\n\n> 除了  `el`  之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的  [`dataset`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset)  来进行。\n\n- 例\n\n```html\n<div id=\"hook-arguments-example\" v-demo:foo.a.b=\"message\"></div>\n```\n\n```javascript\nVue.directive(\"demo\", {\n  bind: function (el, binding, vnode) {\n    var s = JSON.stringify;\n    el.innerHTML =\n      \"name: \" +\n      s(binding.name) +\n      \"<br>\" +\n      \"value: \" +\n      s(binding.value) +\n      \"<br>\" +\n      \"expression: \" +\n      s(binding.expression) +\n      \"<br>\" +\n      \"argument: \" +\n      s(binding.arg) +\n      \"<br>\" +\n      \"modifiers: \" +\n      s(binding.modifiers) +\n      \"<br>\" +\n      \"vnode keys: \" +\n      Object.keys(vnode).join(\", \");\n  }\n});\n\nnew Vue({\n  el: \"#hook-arguments-example\",\n  data: {\n    message: \"hello!\"\n  }\n});\n```\n\n### 动态指令参数\n\n> 指令的参数可以是动态的。例如，在 `v-mydirective:[argument]=\"value\"` 中，`argument` 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。\n\n> 例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：\n\n```html\n<div id=\"baseexample\">\n  <p>Scroll down the page</p>\n  <p v-pin=\"200\">Stick me 200px from the top of the page</p>\n</div>\n```\n\n```javascript\nVue.directive(\"pin\", {\n  bind: function (el, binding, vnode) {\n    el.style.position = \"fixed\";\n    el.style.top = binding.value + \"px\";\n  }\n});\n\nnew Vue({\n  el: \"#baseexample\"\n});\n```\n\n> 这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。\n\n```html\n<div id=\"dynamicexample\">\n  <h3>Scroll down inside this section ↓</h3>\n  <p v-pin:[direction]=\"200\">I am pinned onto the page at 200px to the left.</p>\n</div>\n```\n\n```javascript\nVue.directive(\"pin\", {\n  bind: function (el, binding, vnode) {\n    el.style.position = \"fixed\";\n    var s = binding.arg == \"left\" ? \"left\" : \"top\";\n    el.style[s] = binding.value + \"px\";\n  }\n});\n\nnew Vue({\n  el: \"#dynamicexample\",\n  data: function () {\n    return {\n      direction: \"left\"\n    };\n  }\n});\n```\n\n### 函数简写\n\n> 在很多时候，你可能想在  `bind`  和  `update`  时触发相同行为，而不关心其它的钩子。比如这样写：\n\n```javascript\nVue.directive(\"color-swatch\", function (el, binding) {\n  el.style.backgroundColor = binding.value;\n});\n```\n\n### 对象字面量\n\n> 如果指令需要多个值，可以传入一个 `JavaScript` 对象字面量。记住，指令函数能够接受所有合法的 `JavaScript` 表达式。\n\n```html\n<div v-demo=\"{ color: 'white', text: 'hello!' }\"></div>\n```\n\n```javascript\nVue.directive(\"demo\", function (el, binding) {\n  console.log(binding.value.color); // => \"white\"\n  console.log(binding.value.text); // => \"hello!\"\n});\n```\n\n## 15. vue 3.0 尝鲜\n\n[中文文档](https://www.liulongbin.top:8085/)\n","slug":"前端/Vue2 文档","published":1,"updated":"2021-04-07T07:23:23.482Z","_id":"ckn7476al002qyx7y8i352o5l","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-父子组件传值\"><a href=\"#1-父子组件传值\" class=\"headerlink\" title=\"1. 父子组件传值\"></a>1. 父子组件传值</h2><ul>\n<li>父子： <code>props</code></li>\n<li>子父： <code>this.$emit(&#39;事件名&#39;, 参数)</code></li>\n</ul>\n<h2 id=\"2-获取-dom-节点\"><a href=\"#2-获取-dom-节点\" class=\"headerlink\" title=\"2. 获取 dom 节点\"></a>2. 获取 dom 节点</h2><blockquote>\n<p><code>this.$refs</code>， 可以获取组件的引用，同时可以获取组件的 <code>data，methods</code> 等</p>\n</blockquote>\n<h2 id=\"3-路由\"><a href=\"#3-路由\" class=\"headerlink\" title=\"3. 路由\"></a>3. 路由</h2><ul>\n<li>后端路由</li>\n</ul>\n<blockquote>\n<p>对于普通的网站，所有的超链接都是 <code>URL</code> 地址，所有的 <code>URL</code> 地址都对应服务器上的资源。</p>\n</blockquote>\n<ul>\n<li>前端路由</li>\n</ul>\n<blockquote>\n<p>对于单页面应用程序（<code>SPA</code>），主要通过 <code>URL</code> 的 <code>hash(#)</code> 来实现不同页面之间的切换；同时，<code>hash</code> 有一个特点，<code>http</code> 请求中不会包含 <code>hash</code> 相关的内容</p>\n</blockquote>\n<h2 id=\"4-命名视图-router-view\"><a href=\"#4-命名视图-router-view\" class=\"headerlink\" title=\"4. 命名视图 router-view\"></a>4. 命名视图 router-view</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;router-view name&#x3D;&quot;left&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;router-view name&#x3D;&quot;main&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var header &#x3D; &#123;</span><br><span class=\"line\">  template: &quot;&lt;div&gt;header&lt;&#x2F;div&gt;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var leftBox &#x3D; &#123;</span><br><span class=\"line\">  template: &quot;&lt;div&gt;left&lt;&#x2F;div&gt;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var mainBox &#x3D; &#123;</span><br><span class=\"line\">  template: &quot;&lt;div&gt;main&lt;&#x2F;div&gt;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &quot;&#x2F;&quot;,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        default: header,</span><br><span class=\"line\">        left: leftBox,</span><br><span class=\"line\">        main: mainBox</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &quot;#app&quot;,</span><br><span class=\"line\">  router</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-watch\"><a href=\"#5-watch\" class=\"headerlink\" title=\"5. watch\"></a>5. watch</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; &#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">   msg: &#39;&#39;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">watch: &#123;</span><br><span class=\"line\">  msg(newVal, oldVal) &#123;</span><br><span class=\"line\">    console.log(newVal, oldVal)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;$route.path&quot;: (newVal, oldVal) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(newVal, oldVal)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-computed\"><a href=\"#6-computed\" class=\"headerlink\" title=\"6. computed\"></a>6. computed</h2><ul>\n<li>在 <code>computed</code> 中，可以定义一些属性（计算属性）；计算属性的本质就是一个方法。只不过在我们这些计算属性的时候，是直接把他们的名称当作属性来使用的，并不会把计算属性当作方法来调用。</li>\n<li>计算属性的求值结果，会被缓存起来，方便下次直接使用; 如果 <code>计算属性</code> 方法中，所依赖的所有数据，都没有发生变化，则不会重新对 <code>计算属性</code> 进行求值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstname&quot; &#x2F;&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastname&quot; &#x2F;&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;fullname&quot; &#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    firstname: &#39;&#39;,</span><br><span class=\"line\">    lastname: &#39;&#39;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    fullname() &#123;</span><br><span class=\"line\">        return this.firstname + &#39;-&#39; + this.lastname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-render\"><a href=\"#7-render\" class=\"headerlink\" title=\"7. render\"></a>7. render</h2><ul>\n<li><code>createElements</code> 是一个方法，调用它，能够把指定的组件模板，渲染为 <code>html</code> 结构</li>\n<li>通常习惯性将 <code>createElements</code> 写成 <code>h</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var login &#x3D; &#123;</span><br><span class=\"line\">  template: &quot;&lt;h1&gt;这是登陆组件&lt;&#x2F;h1&gt;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &quot;#app&quot;,</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\">  render: function (createElements) &#123;</span><br><span class=\"line\">    return createElements(login);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-模块的导入与导出\"><a href=\"#8-模块的导入与导出\" class=\"headerlink\" title=\"8. 模块的导入与导出\"></a>8. 模块的导入与导出</h2><ul>\n<li><code>commenJs</code> 导入导出模块</li>\n</ul>\n<blockquote>\n<p>导入</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 名称 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;模块标识符&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>导出</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>import</code> 导入导出模块</li>\n</ul>\n<blockquote>\n<p>导入</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inport 名称A <span class=\"keyword\">from</span> <span class=\"string\">&#x27;模块标识符&#x27;</span></span><br><span class=\"line\">inport &#123; 名称B &#125; <span class=\"string\">&#x27;标识路径&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>导出</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> 名称A</span><br><span class=\"line\"><span class=\"keyword\">export</span> 名称B</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重命名</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> 名称A <span class=\"keyword\">as</span> newA <span class=\"keyword\">from</span> <span class=\"string\">&#x27;模块标识符&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; 名称B <span class=\"keyword\">as</span> newB &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;标示路径&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-vuex\"><a href=\"#9-vuex\" class=\"headerlink\" title=\"9. vuex\"></a>9. vuex</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><ul>\n<li><code>vuex</code> 是 <code>vue.js</code> 应用程序开发的状态管理模式（状态可以理解为数据），它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可检测的方式发生变化</li>\n</ul>\n<h3 id=\"props，data-和-vuex-的区别\"><a href=\"#props，data-和-vuex-的区别\" class=\"headerlink\" title=\"props，data 和 vuex 的区别\"></a>props，data 和 vuex 的区别</h3><ul>\n<li><code>props</code>: 存放父组件传递过来的数据</li>\n<li><code>data</code>: 存放私有数据</li>\n<li><code>vuex</code>: 组件之间共享的数据</li>\n</ul>\n<h3 id=\"state，mutations，actions，getters，modules\"><a href=\"#state，mutations，actions，getters，modules\" class=\"headerlink\" title=\"state，mutations，actions，getters，modules\"></a>state，mutations，actions，getters，modules</h3><ul>\n<li><code>state</code>：类似于 <code>data</code>，用来存数据</li>\n</ul>\n<blockquote>\n<p>访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.state.数据a</span><br><span class=\"line\"></span><br><span class=\"line\">...mapState</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>mutations</code>：类似于 <code>methods</code>，处理同步方法</li>\n</ul>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;METHODS&quot;</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state, value</span>) </span>&#123;</span><br><span class=\"line\">        state.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&#x27;方法名&#x27;</span>, <span class=\"string\">&#x27;参数&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">...mapMutations</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>actions</code>：类似于 <code>methods</code>，处理异步方法</li>\n</ul>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">methodsAsync</span>(<span class=\"params\">&#123; commit &#125;, value</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> apiMethods()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result.code === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                commit(<span class=\"string\">&quot;SET_METHODS&quot;</span>, result.data)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.dispatch(<span class=\"string\">&#x27;方法名&#x27;</span>, <span class=\"string\">&#x27;参数&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">...mapActions</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>getters</code>：类似于 <code>computed</code> 和 <code>filter</code>，处理数据</li>\n</ul>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">newData</span>(<span class=\"params\">state</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state.arr.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.getters(<span class=\"string\">&#x27;名称&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">...mapGetters</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-props-传递数据未更新\"><a href=\"#10-props-传递数据未更新\" class=\"headerlink\" title=\"10. props 传递数据未更新\"></a>10. props 传递数据未更新</h2><blockquote>\n<p>解决方式：使用 <code>watch</code> 监听 <code>props</code></p>\n</blockquote>\n<h2 id=\"11-生命周期\"><a href=\"#11-生命周期\" class=\"headerlink\" title=\"11. 生命周期\"></a>11. 生命周期</h2><h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li>组件创建阶段</li>\n</ul>\n<blockquote>\n<p>此时，组件的 <code>data</code> 和 <code>methods</code> 以及页面 <code>DOM</code> 结构都还没有初始化</p>\n</blockquote>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li>组件创建阶段</li>\n</ul>\n<blockquote>\n<p>此时，组件的 <code>data</code> 和 <code>methods</code> 已经可用了，但是页面 <code>DOM</code> 结构还没有渲染出来；经常用来发起 <code>ajax</code> 请求<br>注意，在 <code>ssr</code> 服务端渲染的时候，在此处发起 <code>ajax</code> 请求会有问题，推荐在 <code>mounted</code> 生命周期函数中来发起 <code>ajax</code> 请求。</p>\n</blockquote>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li>组件创建阶段</li>\n</ul>\n<blockquote>\n<p>此时内存中的模板结构还没有<em>真正渲染到页面上</em>；此时，页面上<em>看不到真实的数据</em>，此时用户看到的只是一个模板页面</p>\n</blockquote>\n<h3 id=\"Mounted\"><a href=\"#Mounted\" class=\"headerlink\" title=\"Mounted\"></a>Mounted</h3><ul>\n<li>组件创建阶段</li>\n</ul>\n<blockquote>\n<p>组件挂载完毕，可初始化插件</p>\n</blockquote>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><blockquote>\n<p>_数据肯定是最新的_，然而<em>页面呈现的数据还是旧的</em></p>\n</blockquote>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><blockquote>\n<p>页面已经完成了更新。此时，<code>data</code> 和 <code>view</code> 上都是最新的数据</p>\n</blockquote>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li>组件销毁阶段</li>\n</ul>\n<blockquote>\n<p>此时没有真正开始销毁，组件还是正常可用的。同时，<code>data</code> 、<code>methods</code> 等数据或方法，依然可以被正常访问；</p>\n</blockquote>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li>组件销毁阶段</li>\n</ul>\n<blockquote>\n<p>组件已经完成了销毁.<code>data</code> 和 <code>methods</code> 都不可用了</p>\n</blockquote>\n<h2 id=\"12-vue-组件从创建到销毁的整个过程\"><a href=\"#12-vue-组件从创建到销毁的整个过程\" class=\"headerlink\" title=\"12  vue 组件从创建到销毁的整个过程\"></a>12  vue 组件从创建到销毁的整个过程</h2><table>\n<thead>\n<tr>\n<th>行为</th>\n<th>指向</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>new Vue()</code></td>\n<td>➡️</td>\n<td>实例化 <code>Vue</code> 对象</td>\n</tr>\n<tr>\n<td><code>Init Events &amp; Lifecycle</code></td>\n<td>➡️</td>\n<td>初始化组件 <code>methods</code> 和 <code>生命周期函数</code></td>\n</tr>\n<tr>\n<td><code>beforeCreate</code></td>\n<td>➡️</td>\n<td><code>data</code>，<code>methods</code> 未被初始化</td>\n</tr>\n<tr>\n<td><code>Init injections &amp; reactivity</code></td>\n<td>➡️</td>\n<td>正在初始化 <code>data</code> 和 <code>methods</code> 中的数据以及方法</td>\n</tr>\n<tr>\n<td><code>created</code></td>\n<td>➡️</td>\n<td><code>data</code>，<code>methods</code> 可用，但 <code>Dom</code> 结构还未被渲染，常发起 <code>ajax</code> 请求</td>\n</tr>\n<tr>\n<td>⬇️</td>\n<td>➡️</td>\n<td>判断是否有 <code>el</code>，<code>template</code> 属性</td>\n</tr>\n<tr>\n<td>⬇️</td>\n<td>➡️</td>\n<td>用来编译模版结构，当所有指令解析完毕，则<code>模板页面就被渲染到内存中了</code>；当模板编译完成，模板页面还没有挂在到页面上，只是存在于内存中，用户看不到页面；</td>\n</tr>\n<tr>\n<td><code>beforeMount</code></td>\n<td>➡️</td>\n<td>此时，页面上看不到 <code>真实数据</code>，此时用户看到的只是一个模板页面</td>\n</tr>\n<tr>\n<td><code>Create vm.$el and replace &quot;el&quot; with it</code></td>\n<td>➡️</td>\n<td>正在把内存中渲染好的模板结构替换到页面上</td>\n</tr>\n<tr>\n<td><code>mounted</code></td>\n<td>➡️</td>\n<td>此时，页面渲染完毕</td>\n</tr>\n<tr>\n<td>⬇️(组件运行中的生命周期函数)</td>\n<td>➡️</td>\n<td>会根据 <code>data</code> 数据的变化，有选择行的触发 <code>0</code>次 或 <code>n</code>次</td>\n</tr>\n<tr>\n<td><code>beforeUpdate</code></td>\n<td>➡️</td>\n<td>数据是新的，但页面呈现的数据仍是旧的</td>\n</tr>\n<tr>\n<td><code>updated</code></td>\n<td>➡️</td>\n<td>页面已经完成了更新，此时，数据是最新的，同时页面上呈现的数据也是最新的</td>\n</tr>\n<tr>\n<td>⬇️(销毁阶段)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>beforeDestroy</code></td>\n<td>➡️</td>\n<td>组件即将被销毁，但是还没有真 正开始销毁，此时组件还是正常可用的。<code>data</code>，<code>methods</code> 仍可正常访问</td>\n</tr>\n<tr>\n<td><code>Teardown watchers,child components and event listeners</code>(销毁过程)</td>\n<td>➡️</td>\n<td></td>\n</tr>\n<tr>\n<td><code>destroyed</code></td>\n<td>➡️</td>\n<td>组件已经完成了销毁，组件已经废了，<code>data</code> 和 <code>methods</code> 都不可用了</td>\n</tr>\n</tbody></table>\n<h2 id=\"13-keep-alive\"><a href=\"#13-keep-alive\" class=\"headerlink\" title=\"13. keep-alive\"></a>13. keep-alive</h2><h3 id=\"新增生命周期\"><a href=\"#新增生命周期\" class=\"headerlink\" title=\"新增生命周期\"></a>新增生命周期</h3><blockquote>\n<p>被包含在  <code>&lt;keep-alive&gt;</code>  中创建的组件，会多两个生命周期: <code>activated</code>  与  <code>deactivated</code></p>\n</blockquote>\n<ul>\n<li>actived</li>\n</ul>\n<blockquote>\n<p>组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 <code>keep-alive</code> 激活时被调用。</p>\n</blockquote>\n<ul>\n<li>deactivated</li>\n</ul>\n<blockquote>\n<p>组件被停用时调用。</p>\n</blockquote>\n<h3 id=\"新增属性\"><a href=\"#新增属性\" class=\"headerlink\" title=\"新增属性\"></a>新增属性</h3><ul>\n<li>include</li>\n</ul>\n<blockquote>\n<p>包含的组件缓存生效。对应 <code>.vue</code> 文件的 <code>name</code> 属性</p>\n</blockquote>\n<ul>\n<li>exclude</li>\n</ul>\n<blockquote>\n<p>排除的组件不缓存，优先级大于 <code>include</code>。对应 <code>.vue</code> 文件的 <code>name</code> 属性</p>\n</blockquote>\n<h2 id=\"14-nextTick\"><a href=\"#14-nextTick\" class=\"headerlink\" title=\"14. nextTick\"></a>14. <code>nextTick</code></h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><blockquote>\n<p>在官方文档中说明 <code>Vue</code> 是异步执行 <code>DOM</code> 更新的，所以在某些场景下需要进行特殊处理才可正常执行某些逻辑。</p>\n</blockquote>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li>在 <code>Vue</code> 生命周期的 <code>created()</code> 钩子函数进行的 <code>DOM</code> 操作一定要放在 <code>Vue.nextTick()</code> 的回调函数中</li>\n</ul>\n<blockquote>\n<p>原因: 在 <code>created()</code> 钩子函数执行的时候 <code>DOM</code> 其实并未进行任何渲染，而此时进行 <code>DOM</code> 操作毫无意义，因此一定要将操作 <code>Dom</code> 部分的代码放入 <code>Vue.nextTick()</code> 的回调函数中。与之对应的就是 <code>mounted()</code> 钩子函数，因为该钩子函数执行时所有的<code>DOM</code> 挂载和渲染都已完成，此时在该钩子函数中进行任何 <code>DOM</code> 操作都不会有问题 。</p>\n</blockquote>\n<ul>\n<li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 <code>DOM</code> 结构的时候，这个操作都应该放进 <code>Vue.nextTick()</code> 的回调函数中。</li>\n</ul>\n<h3 id=\"nextTick-源码浅析\"><a href=\"#nextTick-源码浅析\" class=\"headerlink\" title=\"nextTick 源码浅析\"></a>nextTick 源码浅析</h3><blockquote>\n<p><code>Vue.nextTick</code> 用于延迟执行一段代码，它接受 <code>2</code> 个参数（ <code>回调函数</code> 和 <code>执行回调函数的上下文环境</code>），如果没有提供回调函数，那么将返回 <code>promise</code> 对象。</p>\n</blockquote>\n<blockquote>\n<p>主要的实现方式为判断设备所支持的三种属性，依据各自支持的属性来进行异步操作。如果支持 <code>promise</code>，会使用 <code>Promise.then</code> 来做延迟调用函数。如果设备不支持 <code>Promise</code> 对象，再判断是否支持 <code>MutationObserver</code> 对象，如果支持该对象，就使用<code>MutationObserver</code> 来做延迟，最后如果上面两种都不支持的话，我们会使用 <code>setTimeout</code> 来做延迟操作。</p>\n</blockquote>\n<h2 id=\"15-自定义指令\"><a href=\"#15-自定义指令\" class=\"headerlink\" title=\"15. 自定义指令\"></a>15. 自定义指令</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p>除了核心功能默认内置的指令 ( <code>v-model</code>  和  <code>v-show</code>)， <code>Vue</code>  也允许注册自定义指令。</p>\n</blockquote>\n<blockquote>\n<p>注意，在 <code>Vue2.0</code> 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 <code>DOM</code>  元素进行底层操作，这时候就会用到自定义指令。</p>\n</blockquote>\n<ul>\n<li>例</li>\n</ul>\n<blockquote>\n<p>当页面加载时，该元素将获得焦点 (注意： <code>autofocus</code>  在移动版 <code>Safari</code>  上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class=\"line\">Vue.directive(<span class=\"string\">&quot;focus&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class=\"line\">  inserted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 聚焦元素</span></span><br><span class=\"line\">    el.focus();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果想注册局部指令，组件中也接受一个 <code>directives</code>  的选项：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">directives: &#123;</span><br><span class=\"line\">  focus: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指令的定义</span></span><br><span class=\"line\">    inserted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">      el.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>然后你可以在模板中任何元素上使用新的  <code>v-focus</code>   <code>property</code>，如下</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-focus</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h3><blockquote>\n<p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>\n</blockquote>\n<ul>\n<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>\n<li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>\n<li><code>update</code>：所在组件的 <code>VNode</code> 更新时调用，但是可能发生在其子 <code>VNode</code> 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>\n<li><code>componentUpdated</code>：指令所在组件的 <code>VNode</code> 及其子 <code>VNode</code> 全部更新后调用。</li>\n<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li>\n</ul>\n<blockquote>\n<p>接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</p>\n</blockquote>\n<h3 id=\"钩子函数参数\"><a href=\"#钩子函数参数\" class=\"headerlink\" title=\"钩子函数参数\"></a>钩子函数参数</h3><blockquote>\n<p>指令钩子函数会被传入以下参数：</p>\n</blockquote>\n<ul>\n<li><code>el</code>：指令所绑定的元素，可以用来直接操作 <code>DOM</code>。</li>\n<li><code>binding</code>：一个对象，包含以下 <code>property</code>：<ul>\n<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>\n<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>\n<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>\n<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>\n<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>\n<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>\n</ul>\n</li>\n<li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href=\"https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3\">VNode API</a> 来了解更多详情。</li>\n<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>\n</ul>\n<blockquote>\n<p>除了  <code>el</code>  之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset\"><code>dataset</code></a>  来进行。</p>\n</blockquote>\n<ul>\n<li>例</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;hook-arguments-example&quot;</span> <span class=\"attr\">v-demo:foo.a.b</span>=<span class=\"string\">&quot;message&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;demo&quot;</span>, &#123;</span><br><span class=\"line\">  bind: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding, vnode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">JSON</span>.stringify;</span><br><span class=\"line\">    el.innerHTML =</span><br><span class=\"line\">      <span class=\"string\">&quot;name: &quot;</span> +</span><br><span class=\"line\">      s(binding.name) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;value: &quot;</span> +</span><br><span class=\"line\">      s(binding.value) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;expression: &quot;</span> +</span><br><span class=\"line\">      s(binding.expression) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;argument: &quot;</span> +</span><br><span class=\"line\">      s(binding.arg) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;modifiers: &quot;</span> +</span><br><span class=\"line\">      s(binding.modifiers) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;vnode keys: &quot;</span> +</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.keys(vnode).join(<span class=\"string\">&quot;, &quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&quot;#hook-arguments-example&quot;</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">&quot;hello!&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态指令参数\"><a href=\"#动态指令参数\" class=\"headerlink\" title=\"动态指令参数\"></a>动态指令参数</h3><blockquote>\n<p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。</p>\n</blockquote>\n<blockquote>\n<p>例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;baseexample&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Scroll down the page<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-pin</span>=<span class=\"string\">&quot;200&quot;</span>&gt;</span>Stick me 200px from the top of the page<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;pin&quot;</span>, &#123;</span><br><span class=\"line\">  bind: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding, vnode</span>) </span>&#123;</span><br><span class=\"line\">    el.style.position = <span class=\"string\">&quot;fixed&quot;</span>;</span><br><span class=\"line\">    el.style.top = binding.value + <span class=\"string\">&quot;px&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&quot;#baseexample&quot;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dynamicexample&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>Scroll down inside this section ↓<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-pin:</span>[<span class=\"attr\">direction</span>]=<span class=\"string\">&quot;200&quot;</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;pin&quot;</span>, &#123;</span><br><span class=\"line\">  bind: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding, vnode</span>) </span>&#123;</span><br><span class=\"line\">    el.style.position = <span class=\"string\">&quot;fixed&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = binding.arg == <span class=\"string\">&quot;left&quot;</span> ? <span class=\"string\">&quot;left&quot;</span> : <span class=\"string\">&quot;top&quot;</span>;</span><br><span class=\"line\">    el.style[s] = binding.value + <span class=\"string\">&quot;px&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&quot;#dynamicexample&quot;</span>,</span><br><span class=\"line\">  data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      direction: <span class=\"string\">&quot;left&quot;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数简写\"><a href=\"#函数简写\" class=\"headerlink\" title=\"函数简写\"></a>函数简写</h3><blockquote>\n<p>在很多时候，你可能想在  <code>bind</code>  和  <code>update</code>  时触发相同行为，而不关心其它的钩子。比如这样写：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;color-swatch&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding</span>) </span>&#123;</span><br><span class=\"line\">  el.style.backgroundColor = binding.value;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h3><blockquote>\n<p>如果指令需要多个值，可以传入一个 <code>JavaScript</code> 对象字面量。记住，指令函数能够接受所有合法的 <code>JavaScript</code> 表达式。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-demo</span>=<span class=\"string\">&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;demo&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(binding.value.color); <span class=\"comment\">// =&gt; &quot;white&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(binding.value.text); <span class=\"comment\">// =&gt; &quot;hello!&quot;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-vue-3-0-尝鲜\"><a href=\"#15-vue-3-0-尝鲜\" class=\"headerlink\" title=\"15. vue 3.0 尝鲜\"></a>15. vue 3.0 尝鲜</h2><p><a href=\"https://www.liulongbin.top:8085/\">中文文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-父子组件传值\"><a href=\"#1-父子组件传值\" class=\"headerlink\" title=\"1. 父子组件传值\"></a>1. 父子组件传值</h2><ul>\n<li>父子： <code>props</code></li>\n<li>子父： <code>this.$emit(&#39;事件名&#39;, 参数)</code></li>\n</ul>\n<h2 id=\"2-获取-dom-节点\"><a href=\"#2-获取-dom-节点\" class=\"headerlink\" title=\"2. 获取 dom 节点\"></a>2. 获取 dom 节点</h2><blockquote>\n<p><code>this.$refs</code>， 可以获取组件的引用，同时可以获取组件的 <code>data，methods</code> 等</p>\n</blockquote>\n<h2 id=\"3-路由\"><a href=\"#3-路由\" class=\"headerlink\" title=\"3. 路由\"></a>3. 路由</h2><ul>\n<li>后端路由</li>\n</ul>\n<blockquote>\n<p>对于普通的网站，所有的超链接都是 <code>URL</code> 地址，所有的 <code>URL</code> 地址都对应服务器上的资源。</p>\n</blockquote>\n<ul>\n<li>前端路由</li>\n</ul>\n<blockquote>\n<p>对于单页面应用程序（<code>SPA</code>），主要通过 <code>URL</code> 的 <code>hash(#)</code> 来实现不同页面之间的切换；同时，<code>hash</code> 有一个特点，<code>http</code> 请求中不会包含 <code>hash</code> 相关的内容</p>\n</blockquote>\n<h2 id=\"4-命名视图-router-view\"><a href=\"#4-命名视图-router-view\" class=\"headerlink\" title=\"4. 命名视图 router-view\"></a>4. 命名视图 router-view</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class=\"line\">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;router-view name&#x3D;&quot;left&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">    &lt;router-view name&#x3D;&quot;main&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var header &#x3D; &#123;</span><br><span class=\"line\">  template: &quot;&lt;div&gt;header&lt;&#x2F;div&gt;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var leftBox &#x3D; &#123;</span><br><span class=\"line\">  template: &quot;&lt;div&gt;left&lt;&#x2F;div&gt;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var mainBox &#x3D; &#123;</span><br><span class=\"line\">  template: &quot;&lt;div&gt;main&lt;&#x2F;div&gt;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var router &#x3D; new VueRouter(&#123;</span><br><span class=\"line\">  routes: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      path: &quot;&#x2F;&quot;,</span><br><span class=\"line\">      components: &#123;</span><br><span class=\"line\">        default: header,</span><br><span class=\"line\">        left: leftBox,</span><br><span class=\"line\">        main: mainBox</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &quot;#app&quot;,</span><br><span class=\"line\">  router</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-watch\"><a href=\"#5-watch\" class=\"headerlink\" title=\"5. watch\"></a>5. watch</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;msg&quot; &#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">   msg: &#39;&#39;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">watch: &#123;</span><br><span class=\"line\">  msg(newVal, oldVal) &#123;</span><br><span class=\"line\">    console.log(newVal, oldVal)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;$route.path&quot;: (newVal, oldVal) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(newVal, oldVal)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-computed\"><a href=\"#6-computed\" class=\"headerlink\" title=\"6. computed\"></a>6. computed</h2><ul>\n<li>在 <code>computed</code> 中，可以定义一些属性（计算属性）；计算属性的本质就是一个方法。只不过在我们这些计算属性的时候，是直接把他们的名称当作属性来使用的，并不会把计算属性当作方法来调用。</li>\n<li>计算属性的求值结果，会被缓存起来，方便下次直接使用; 如果 <code>计算属性</code> 方法中，所依赖的所有数据，都没有发生变化，则不会重新对 <code>计算属性</code> 进行求值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;firstname&quot; &#x2F;&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;lastname&quot; &#x2F;&gt;</span><br><span class=\"line\">  &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;fullname&quot; &#x2F;&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">data: &#123;</span><br><span class=\"line\">    firstname: &#39;&#39;,</span><br><span class=\"line\">    lastname: &#39;&#39;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\">    fullname() &#123;</span><br><span class=\"line\">        return this.firstname + &#39;-&#39; + this.lastname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-render\"><a href=\"#7-render\" class=\"headerlink\" title=\"7. render\"></a>7. render</h2><ul>\n<li><code>createElements</code> 是一个方法，调用它，能够把指定的组件模板，渲染为 <code>html</code> 结构</li>\n<li>通常习惯性将 <code>createElements</code> 写成 <code>h</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">var login &#x3D; &#123;</span><br><span class=\"line\">  template: &quot;&lt;h1&gt;这是登陆组件&lt;&#x2F;h1&gt;&quot;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var vm &#x3D; new Vue(&#123;</span><br><span class=\"line\">  el: &quot;#app&quot;,</span><br><span class=\"line\">  data: &#123;&#125;,</span><br><span class=\"line\">  render: function (createElements) &#123;</span><br><span class=\"line\">    return createElements(login);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-模块的导入与导出\"><a href=\"#8-模块的导入与导出\" class=\"headerlink\" title=\"8. 模块的导入与导出\"></a>8. 模块的导入与导出</h2><ul>\n<li><code>commenJs</code> 导入导出模块</li>\n</ul>\n<blockquote>\n<p>导入</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 名称 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;模块标识符&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>导出</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>import</code> 导入导出模块</li>\n</ul>\n<blockquote>\n<p>导入</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inport 名称A <span class=\"keyword\">from</span> <span class=\"string\">&#x27;模块标识符&#x27;</span></span><br><span class=\"line\">inport &#123; 名称B &#125; <span class=\"string\">&#x27;标识路径&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>导出</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> 名称A</span><br><span class=\"line\"><span class=\"keyword\">export</span> 名称B</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>重命名</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> 名称A <span class=\"keyword\">as</span> newA <span class=\"keyword\">from</span> <span class=\"string\">&#x27;模块标识符&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; 名称B <span class=\"keyword\">as</span> newB &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;标示路径&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-vuex\"><a href=\"#9-vuex\" class=\"headerlink\" title=\"9. vuex\"></a>9. vuex</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><ul>\n<li><code>vuex</code> 是 <code>vue.js</code> 应用程序开发的状态管理模式（状态可以理解为数据），它采用集中式存储，管理应用的所有组件的状态，并以相应的规则保证状态以一种可检测的方式发生变化</li>\n</ul>\n<h3 id=\"props，data-和-vuex-的区别\"><a href=\"#props，data-和-vuex-的区别\" class=\"headerlink\" title=\"props，data 和 vuex 的区别\"></a>props，data 和 vuex 的区别</h3><ul>\n<li><code>props</code>: 存放父组件传递过来的数据</li>\n<li><code>data</code>: 存放私有数据</li>\n<li><code>vuex</code>: 组件之间共享的数据</li>\n</ul>\n<h3 id=\"state，mutations，actions，getters，modules\"><a href=\"#state，mutations，actions，getters，modules\" class=\"headerlink\" title=\"state，mutations，actions，getters，modules\"></a>state，mutations，actions，getters，modules</h3><ul>\n<li><code>state</code>：类似于 <code>data</code>，用来存数据</li>\n</ul>\n<blockquote>\n<p>访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.state.数据a</span><br><span class=\"line\"></span><br><span class=\"line\">...mapState</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>mutations</code>：类似于 <code>methods</code>，处理同步方法</li>\n</ul>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;METHODS&quot;</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">state, value</span>) </span>&#123;</span><br><span class=\"line\">        state.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.commit(<span class=\"string\">&#x27;方法名&#x27;</span>, <span class=\"string\">&#x27;参数&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">...mapMutations</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>actions</code>：类似于 <code>methods</code>，处理异步方法</li>\n</ul>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">methodsAsync</span>(<span class=\"params\">&#123; commit &#125;, value</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> apiMethods()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result.code === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                commit(<span class=\"string\">&quot;SET_METHODS&quot;</span>, result.data)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span>(err) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(err);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.dispatch(<span class=\"string\">&#x27;方法名&#x27;</span>, <span class=\"string\">&#x27;参数&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">...mapActions</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>getters</code>：类似于 <code>computed</code> 和 <code>filter</code>，处理数据</li>\n</ul>\n<blockquote>\n<p>使用</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">newData</span>(<span class=\"params\">state</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state.arr.filter(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item.id === <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>访问</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.$store.getters(<span class=\"string\">&#x27;名称&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">...mapGetters</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-props-传递数据未更新\"><a href=\"#10-props-传递数据未更新\" class=\"headerlink\" title=\"10. props 传递数据未更新\"></a>10. props 传递数据未更新</h2><blockquote>\n<p>解决方式：使用 <code>watch</code> 监听 <code>props</code></p>\n</blockquote>\n<h2 id=\"11-生命周期\"><a href=\"#11-生命周期\" class=\"headerlink\" title=\"11. 生命周期\"></a>11. 生命周期</h2><h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><ul>\n<li>组件创建阶段</li>\n</ul>\n<blockquote>\n<p>此时，组件的 <code>data</code> 和 <code>methods</code> 以及页面 <code>DOM</code> 结构都还没有初始化</p>\n</blockquote>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><ul>\n<li>组件创建阶段</li>\n</ul>\n<blockquote>\n<p>此时，组件的 <code>data</code> 和 <code>methods</code> 已经可用了，但是页面 <code>DOM</code> 结构还没有渲染出来；经常用来发起 <code>ajax</code> 请求<br>注意，在 <code>ssr</code> 服务端渲染的时候，在此处发起 <code>ajax</code> 请求会有问题，推荐在 <code>mounted</code> 生命周期函数中来发起 <code>ajax</code> 请求。</p>\n</blockquote>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><ul>\n<li>组件创建阶段</li>\n</ul>\n<blockquote>\n<p>此时内存中的模板结构还没有<em>真正渲染到页面上</em>；此时，页面上<em>看不到真实的数据</em>，此时用户看到的只是一个模板页面</p>\n</blockquote>\n<h3 id=\"Mounted\"><a href=\"#Mounted\" class=\"headerlink\" title=\"Mounted\"></a>Mounted</h3><ul>\n<li>组件创建阶段</li>\n</ul>\n<blockquote>\n<p>组件挂载完毕，可初始化插件</p>\n</blockquote>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><blockquote>\n<p>_数据肯定是最新的_，然而<em>页面呈现的数据还是旧的</em></p>\n</blockquote>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><blockquote>\n<p>页面已经完成了更新。此时，<code>data</code> 和 <code>view</code> 上都是最新的数据</p>\n</blockquote>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><ul>\n<li>组件销毁阶段</li>\n</ul>\n<blockquote>\n<p>此时没有真正开始销毁，组件还是正常可用的。同时，<code>data</code> 、<code>methods</code> 等数据或方法，依然可以被正常访问；</p>\n</blockquote>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><ul>\n<li>组件销毁阶段</li>\n</ul>\n<blockquote>\n<p>组件已经完成了销毁.<code>data</code> 和 <code>methods</code> 都不可用了</p>\n</blockquote>\n<h2 id=\"12-vue-组件从创建到销毁的整个过程\"><a href=\"#12-vue-组件从创建到销毁的整个过程\" class=\"headerlink\" title=\"12  vue 组件从创建到销毁的整个过程\"></a>12  vue 组件从创建到销毁的整个过程</h2><table>\n<thead>\n<tr>\n<th>行为</th>\n<th>指向</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>new Vue()</code></td>\n<td>➡️</td>\n<td>实例化 <code>Vue</code> 对象</td>\n</tr>\n<tr>\n<td><code>Init Events &amp; Lifecycle</code></td>\n<td>➡️</td>\n<td>初始化组件 <code>methods</code> 和 <code>生命周期函数</code></td>\n</tr>\n<tr>\n<td><code>beforeCreate</code></td>\n<td>➡️</td>\n<td><code>data</code>，<code>methods</code> 未被初始化</td>\n</tr>\n<tr>\n<td><code>Init injections &amp; reactivity</code></td>\n<td>➡️</td>\n<td>正在初始化 <code>data</code> 和 <code>methods</code> 中的数据以及方法</td>\n</tr>\n<tr>\n<td><code>created</code></td>\n<td>➡️</td>\n<td><code>data</code>，<code>methods</code> 可用，但 <code>Dom</code> 结构还未被渲染，常发起 <code>ajax</code> 请求</td>\n</tr>\n<tr>\n<td>⬇️</td>\n<td>➡️</td>\n<td>判断是否有 <code>el</code>，<code>template</code> 属性</td>\n</tr>\n<tr>\n<td>⬇️</td>\n<td>➡️</td>\n<td>用来编译模版结构，当所有指令解析完毕，则<code>模板页面就被渲染到内存中了</code>；当模板编译完成，模板页面还没有挂在到页面上，只是存在于内存中，用户看不到页面；</td>\n</tr>\n<tr>\n<td><code>beforeMount</code></td>\n<td>➡️</td>\n<td>此时，页面上看不到 <code>真实数据</code>，此时用户看到的只是一个模板页面</td>\n</tr>\n<tr>\n<td><code>Create vm.$el and replace &quot;el&quot; with it</code></td>\n<td>➡️</td>\n<td>正在把内存中渲染好的模板结构替换到页面上</td>\n</tr>\n<tr>\n<td><code>mounted</code></td>\n<td>➡️</td>\n<td>此时，页面渲染完毕</td>\n</tr>\n<tr>\n<td>⬇️(组件运行中的生命周期函数)</td>\n<td>➡️</td>\n<td>会根据 <code>data</code> 数据的变化，有选择行的触发 <code>0</code>次 或 <code>n</code>次</td>\n</tr>\n<tr>\n<td><code>beforeUpdate</code></td>\n<td>➡️</td>\n<td>数据是新的，但页面呈现的数据仍是旧的</td>\n</tr>\n<tr>\n<td><code>updated</code></td>\n<td>➡️</td>\n<td>页面已经完成了更新，此时，数据是最新的，同时页面上呈现的数据也是最新的</td>\n</tr>\n<tr>\n<td>⬇️(销毁阶段)</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>beforeDestroy</code></td>\n<td>➡️</td>\n<td>组件即将被销毁，但是还没有真 正开始销毁，此时组件还是正常可用的。<code>data</code>，<code>methods</code> 仍可正常访问</td>\n</tr>\n<tr>\n<td><code>Teardown watchers,child components and event listeners</code>(销毁过程)</td>\n<td>➡️</td>\n<td></td>\n</tr>\n<tr>\n<td><code>destroyed</code></td>\n<td>➡️</td>\n<td>组件已经完成了销毁，组件已经废了，<code>data</code> 和 <code>methods</code> 都不可用了</td>\n</tr>\n</tbody></table>\n<h2 id=\"13-keep-alive\"><a href=\"#13-keep-alive\" class=\"headerlink\" title=\"13. keep-alive\"></a>13. keep-alive</h2><h3 id=\"新增生命周期\"><a href=\"#新增生命周期\" class=\"headerlink\" title=\"新增生命周期\"></a>新增生命周期</h3><blockquote>\n<p>被包含在  <code>&lt;keep-alive&gt;</code>  中创建的组件，会多两个生命周期: <code>activated</code>  与  <code>deactivated</code></p>\n</blockquote>\n<ul>\n<li>actived</li>\n</ul>\n<blockquote>\n<p>组件被激活时调用，在组件第一次渲染时也会被调用，之后每次 <code>keep-alive</code> 激活时被调用。</p>\n</blockquote>\n<ul>\n<li>deactivated</li>\n</ul>\n<blockquote>\n<p>组件被停用时调用。</p>\n</blockquote>\n<h3 id=\"新增属性\"><a href=\"#新增属性\" class=\"headerlink\" title=\"新增属性\"></a>新增属性</h3><ul>\n<li>include</li>\n</ul>\n<blockquote>\n<p>包含的组件缓存生效。对应 <code>.vue</code> 文件的 <code>name</code> 属性</p>\n</blockquote>\n<ul>\n<li>exclude</li>\n</ul>\n<blockquote>\n<p>排除的组件不缓存，优先级大于 <code>include</code>。对应 <code>.vue</code> 文件的 <code>name</code> 属性</p>\n</blockquote>\n<h2 id=\"14-nextTick\"><a href=\"#14-nextTick\" class=\"headerlink\" title=\"14. nextTick\"></a>14. <code>nextTick</code></h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><blockquote>\n<p>在官方文档中说明 <code>Vue</code> 是异步执行 <code>DOM</code> 更新的，所以在某些场景下需要进行特殊处理才可正常执行某些逻辑。</p>\n</blockquote>\n<h3 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><ul>\n<li>在 <code>Vue</code> 生命周期的 <code>created()</code> 钩子函数进行的 <code>DOM</code> 操作一定要放在 <code>Vue.nextTick()</code> 的回调函数中</li>\n</ul>\n<blockquote>\n<p>原因: 在 <code>created()</code> 钩子函数执行的时候 <code>DOM</code> 其实并未进行任何渲染，而此时进行 <code>DOM</code> 操作毫无意义，因此一定要将操作 <code>Dom</code> 部分的代码放入 <code>Vue.nextTick()</code> 的回调函数中。与之对应的就是 <code>mounted()</code> 钩子函数，因为该钩子函数执行时所有的<code>DOM</code> 挂载和渲染都已完成，此时在该钩子函数中进行任何 <code>DOM</code> 操作都不会有问题 。</p>\n</blockquote>\n<ul>\n<li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 <code>DOM</code> 结构的时候，这个操作都应该放进 <code>Vue.nextTick()</code> 的回调函数中。</li>\n</ul>\n<h3 id=\"nextTick-源码浅析\"><a href=\"#nextTick-源码浅析\" class=\"headerlink\" title=\"nextTick 源码浅析\"></a>nextTick 源码浅析</h3><blockquote>\n<p><code>Vue.nextTick</code> 用于延迟执行一段代码，它接受 <code>2</code> 个参数（ <code>回调函数</code> 和 <code>执行回调函数的上下文环境</code>），如果没有提供回调函数，那么将返回 <code>promise</code> 对象。</p>\n</blockquote>\n<blockquote>\n<p>主要的实现方式为判断设备所支持的三种属性，依据各自支持的属性来进行异步操作。如果支持 <code>promise</code>，会使用 <code>Promise.then</code> 来做延迟调用函数。如果设备不支持 <code>Promise</code> 对象，再判断是否支持 <code>MutationObserver</code> 对象，如果支持该对象，就使用<code>MutationObserver</code> 来做延迟，最后如果上面两种都不支持的话，我们会使用 <code>setTimeout</code> 来做延迟操作。</p>\n</blockquote>\n<h2 id=\"15-自定义指令\"><a href=\"#15-自定义指令\" class=\"headerlink\" title=\"15. 自定义指令\"></a>15. 自定义指令</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p>除了核心功能默认内置的指令 ( <code>v-model</code>  和  <code>v-show</code>)， <code>Vue</code>  也允许注册自定义指令。</p>\n</blockquote>\n<blockquote>\n<p>注意，在 <code>Vue2.0</code> 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 <code>DOM</code>  元素进行底层操作，这时候就会用到自定义指令。</p>\n</blockquote>\n<ul>\n<li>例</li>\n</ul>\n<blockquote>\n<p>当页面加载时，该元素将获得焦点 (注意： <code>autofocus</code>  在移动版 <code>Safari</code>  上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注册一个全局自定义指令 `v-focus`</span></span><br><span class=\"line\">Vue.directive(<span class=\"string\">&quot;focus&quot;</span>, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class=\"line\">  inserted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 聚焦元素</span></span><br><span class=\"line\">    el.focus();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果想注册局部指令，组件中也接受一个 <code>directives</code>  的选项：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">directives: &#123;</span><br><span class=\"line\">  focus: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指令的定义</span></span><br><span class=\"line\">    inserted: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">      el.focus()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>然后你可以在模板中任何元素上使用新的  <code>v-focus</code>   <code>property</code>，如下</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">v-focus</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"钩子函数\"><a href=\"#钩子函数\" class=\"headerlink\" title=\"钩子函数\"></a>钩子函数</h3><blockquote>\n<p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>\n</blockquote>\n<ul>\n<li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>\n<li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>\n<li><code>update</code>：所在组件的 <code>VNode</code> 更新时调用，但是可能发生在其子 <code>VNode</code> 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>\n<li><code>componentUpdated</code>：指令所在组件的 <code>VNode</code> 及其子 <code>VNode</code> 全部更新后调用。</li>\n<li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li>\n</ul>\n<blockquote>\n<p>接下来我们来看一下钩子函数的参数 (即 el、binding、vnode 和 oldVnode)。</p>\n</blockquote>\n<h3 id=\"钩子函数参数\"><a href=\"#钩子函数参数\" class=\"headerlink\" title=\"钩子函数参数\"></a>钩子函数参数</h3><blockquote>\n<p>指令钩子函数会被传入以下参数：</p>\n</blockquote>\n<ul>\n<li><code>el</code>：指令所绑定的元素，可以用来直接操作 <code>DOM</code>。</li>\n<li><code>binding</code>：一个对象，包含以下 <code>property</code>：<ul>\n<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>\n<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>\n<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>\n<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>\n<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>\n<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>\n</ul>\n</li>\n<li><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href=\"https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3\">VNode API</a> 来了解更多详情。</li>\n<li><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</li>\n</ul>\n<blockquote>\n<p>除了  <code>el</code>  之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset\"><code>dataset</code></a>  来进行。</p>\n</blockquote>\n<ul>\n<li>例</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;hook-arguments-example&quot;</span> <span class=\"attr\">v-demo:foo.a.b</span>=<span class=\"string\">&quot;message&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;demo&quot;</span>, &#123;</span><br><span class=\"line\">  bind: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding, vnode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"built_in\">JSON</span>.stringify;</span><br><span class=\"line\">    el.innerHTML =</span><br><span class=\"line\">      <span class=\"string\">&quot;name: &quot;</span> +</span><br><span class=\"line\">      s(binding.name) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;value: &quot;</span> +</span><br><span class=\"line\">      s(binding.value) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;expression: &quot;</span> +</span><br><span class=\"line\">      s(binding.expression) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;argument: &quot;</span> +</span><br><span class=\"line\">      s(binding.arg) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;modifiers: &quot;</span> +</span><br><span class=\"line\">      s(binding.modifiers) +</span><br><span class=\"line\">      <span class=\"string\">&quot;&lt;br&gt;&quot;</span> +</span><br><span class=\"line\">      <span class=\"string\">&quot;vnode keys: &quot;</span> +</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.keys(vnode).join(<span class=\"string\">&quot;, &quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&quot;#hook-arguments-example&quot;</span>,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: <span class=\"string\">&quot;hello!&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态指令参数\"><a href=\"#动态指令参数\" class=\"headerlink\" title=\"动态指令参数\"></a>动态指令参数</h3><blockquote>\n<p>指令的参数可以是动态的。例如，在 <code>v-mydirective:[argument]=&quot;value&quot;</code> 中，<code>argument</code> 参数可以根据组件实例数据进行更新！这使得自定义指令可以在应用中被灵活使用。</p>\n</blockquote>\n<blockquote>\n<p>例如你想要创建一个自定义指令，用来通过固定布局将元素固定在页面上。我们可以像这样创建一个通过指令值来更新竖直位置像素值的自定义指令：</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;baseexample&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Scroll down the page<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-pin</span>=<span class=\"string\">&quot;200&quot;</span>&gt;</span>Stick me 200px from the top of the page<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;pin&quot;</span>, &#123;</span><br><span class=\"line\">  bind: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding, vnode</span>) </span>&#123;</span><br><span class=\"line\">    el.style.position = <span class=\"string\">&quot;fixed&quot;</span>;</span><br><span class=\"line\">    el.style.top = binding.value + <span class=\"string\">&quot;px&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&quot;#baseexample&quot;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这会把该元素固定在距离页面顶部 200 像素的位置。但如果场景是我们需要把元素固定在左侧而不是顶部又该怎么办呢？这时使用动态参数就可以非常方便地根据每个组件实例来进行更新。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dynamicexample&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">h3</span>&gt;</span>Scroll down inside this section ↓<span class=\"tag\">&lt;/<span class=\"name\">h3</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">v-pin:</span>[<span class=\"attr\">direction</span>]=<span class=\"string\">&quot;200&quot;</span>&gt;</span>I am pinned onto the page at 200px to the left.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;pin&quot;</span>, &#123;</span><br><span class=\"line\">  bind: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding, vnode</span>) </span>&#123;</span><br><span class=\"line\">    el.style.position = <span class=\"string\">&quot;fixed&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = binding.arg == <span class=\"string\">&quot;left&quot;</span> ? <span class=\"string\">&quot;left&quot;</span> : <span class=\"string\">&quot;top&quot;</span>;</span><br><span class=\"line\">    el.style[s] = binding.value + <span class=\"string\">&quot;px&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">  el: <span class=\"string\">&quot;#dynamicexample&quot;</span>,</span><br><span class=\"line\">  data: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      direction: <span class=\"string\">&quot;left&quot;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数简写\"><a href=\"#函数简写\" class=\"headerlink\" title=\"函数简写\"></a>函数简写</h3><blockquote>\n<p>在很多时候，你可能想在  <code>bind</code>  和  <code>update</code>  时触发相同行为，而不关心其它的钩子。比如这样写：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;color-swatch&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding</span>) </span>&#123;</span><br><span class=\"line\">  el.style.backgroundColor = binding.value;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象字面量\"><a href=\"#对象字面量\" class=\"headerlink\" title=\"对象字面量\"></a>对象字面量</h3><blockquote>\n<p>如果指令需要多个值，可以传入一个 <code>JavaScript</code> 对象字面量。记住，指令函数能够接受所有合法的 <code>JavaScript</code> 表达式。</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">v-demo</span>=<span class=\"string\">&quot;&#123; color: &#x27;white&#x27;, text: &#x27;hello!&#x27; &#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.directive(<span class=\"string\">&quot;demo&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">el, binding</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(binding.value.color); <span class=\"comment\">// =&gt; &quot;white&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(binding.value.text); <span class=\"comment\">// =&gt; &quot;hello!&quot;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"15-vue-3-0-尝鲜\"><a href=\"#15-vue-3-0-尝鲜\" class=\"headerlink\" title=\"15. vue 3.0 尝鲜\"></a>15. vue 3.0 尝鲜</h2><p><a href=\"https://www.liulongbin.top:8085/\">中文文档</a></p>\n"},{"title":"从图片裁剪了解 js 二进制常用 api","date":"2020-11-19T16:00:00.000Z","_content":"\n## 需求分析\n\n### 二进制模块之间的关系\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1598083455644-f4308101-1403-4566-ae7d-09a0c4fa5ffe.png#align=left&display=inline&height=602&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=889&size=126895&status=done&style=none&width=889)\n\n### 步骤\n\n1. 获取文件并读取文件\n1. 获取裁剪坐标\n1. 裁剪图片\n1. 读取裁剪后的图片预览并上传\n\n接下来先了解下二进制相关的 `API`  以方便实现本需求。\n\n## FileReader\n\n> `HTML5`定义了`FileReader`作为文件`API`的重要成员用于读取文件，根据`W3C`的定义，`FileReader`接口提供了读取文件的方法和包含读取结果的事件模型。\n\n### 创建实例\n\n```javascript\nconst fileReader = new FileReader();\n```\n\n### 属性\n\n| 属性名                                                                                | 描述                                                                                                               |\n| ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |\n| [error](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/error)            | 一个[DOMException](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMException)，表示在读取文件时发生的错误  。  |\n| [readyState](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readyState)  | 一个数字，用来表示  [FileReader](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader) API 的三种可能状态。 |\n| [result](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result)          | 文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。                           |\n\n### 方法\n\n| 方法名             | 描述                                                  |\n| ------------------ | ----------------------------------------------------- |\n| abort              | 中止读取操作                                          |\n| readAsArrayBuffer  | 异步按字节读取文件内容，结果用  ArrayBuffer  对象表示 |\n| readAsBinaryString | 异步按字节读取文件内容，结果为文件的二进制串          |\n| readAsDataURL      | 异步读取文件内容，结果用  data:url  的字符串形式表示  |\n| readAsText         | 异步按字符读取文件内容，结果用字符串形式表示          |\n\n### 事件\n\n| 事件名      | 描述                           |\n| ----------- | ------------------------------ |\n| onabort     | 中断时触发                     |\n| onerror     | 出错时触发                     |\n| onload      | 文件读取成功完成时触发         |\n| onloadend   | 读取完成触发（无论成功或失败） |\n| onloadstart | 读取开始时触发                 |\n| onprogress  | 读取中                         |\n\n### 示例\n\n```jsx\n/**\n * @description 把一个文件的内容通过字符串的方式读取出来\n */\n<input type=\"file\" id=\"upload\" />\n\nconst upload = document.getElementById(\"upload\");\nupload.addEventListener(\"change\", function() {\n\tconst fileReader = new FileReader();\n  fileReader.onload = function() {\n  \tconst reult = fileReader.result;\n    console.log(result):\n  }\n}, false);\n```\n\n## ArrayBuffer / TypedArray / DataView\n\n### ArrayBuffer\n\n#### 功能\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1597991690421-351d07c1-8366-469f-8912-d094078e5986.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=1746&size=58281&status=done&style=none&width=873)\n\n#### 介绍\n\n`FileReader`  有个 `readAsArrayBuffer()`  方法，如果被读取的文件是二进制数据，那么用次方法读取将是最合适的方案，读取出来的数据将是一个 `ArrayBuffer`  对象。\n\n#### 定义\n\n> `ArrayBuffer`  对象用来表示通用的、固定长度的原始二进制数据缓冲区。`ArrayBuffer`  不能直接操作,而是要通过**类型数组对象**或  **`DataView`\\*\\***  对象\\*\\*来操作,它们会将缓冲区中的数据表示为特定的格式,并通过这些格式来读写缓冲区的内容.\n\n`ArrayBuffer`也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\n```javascript\nconst arrayBuffer = new ArrayBuffer(8);\n// ArrayBuffer 对象有实例属性 byteLength ，表示当前实例占用的内存字节长度（单位字节）\nconsole.log(arrayBuffer.byteLength);\n```\n\n#### 属性\n\n| 属性名                                                                                                                                      | 描述                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |\n| ArrayBuffer.length                                                                                                                          | ArrayBuffer  构造函数的 length  属性，其值为 1 。                                        |\n| [ArrayBuffer.prototype.byteLength](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/byteLength) | 只读属性，表示  ArrayBuffer  的 byte  的大小，在 ArrayBuffer  构造完成时生成，不可改变。 |\n\n> 由于无法对  `Arraybuffer`  直接进行操作,所以我们需要借助其他对象来操作. 所有就有了  **`TypedArray`\\*\\***(类型数组对象)**和  **`DataView`\\***\\*对象**。\n\n### DataView\n\n上方代码生成了一段 8 字节的内存区域。其中每个字节的默认值都是 0。\n\n为了读和写这段内容，需要为它指定视图。 `DataView`  视图的创建，需要提供 `ArrayBuffer` 对象实例作为参数。\n\n`DataView`  视图是一个可以从二进制 `ArrayBuffer`  对象中读写多种数值类型的底层接口。\n\n- `setInt8()`  从 `DataView`  起始位置以 `byte`  为计数的指定偏移量 `byteOffset`  处存储一个 `8-bit`  数(一个字节)。\n- `getInt8()`  从 `DataView`  起始位置以 `byte` 为计数的指定偏移量 `byteOffset` 处获取一个 `8-bit` 数(一个字节)。\n\n#### 调用\n\n```javascript\nnew DataView(buffer, [, byteOffset [, byteLength]])\n```\n\n#### 参数\n\n| 参数名            | 描述                                                                                                                                                                                                                                                                                     |\n| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| buffer            | 一个 已经存在的[ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)  或  [SharedArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)   对象，DataView  对象的数据源。 |\n| byteOffset (可选) | 此  DataView  对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始。                                                                                                                                                                                               |\n| byteLength (可选) | 此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度。                                                                                                                                                                                                             |\n\n#### 异常\n\n- [RangeError](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError)\n\n如果 `byteOffset` 或者 `byteLength `参数的值导致视图超出了 `buffer` 的结束位置就会抛出此异常。\n\n例如，假设 `buffer` （缓冲对象）是 `16` 字节长度，`byteOffset` 参数为 `8`，`byteLength` 参数为  `10`，这个错误就会抛出，这是因为结果视图试图超出 `buffer` 对象的总长度 `2` 个字节。\n\n#### 示例\n\n```javascript\nlet arrayBuffer = new ArrayBuffer();\nconsole.log(arrayBuffer.byteLength); // 2\nlet dataView = new DataView(buffer);\ndataView.setInt8(0, 1);\ndataView.setInt8(1, 2);\nconsole.log(dataView.getInt8(0)); // 1\nconsole.log(dataView.getInt8(1)); // 2\nconsole.log(dataView.getInt16(0)); // 258\n```\n\n### TypedArray\n\n另一种`TypedArray`视图，与`DataView`视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。\n\n`TypedArray`对象描述了一个底层的二进制数据缓存区（`binary data buffer`）的一个类数组视图（`view`）。但它本身不可以被实例化，甚至无法访问，你可以把它理解为接口，它有很多的实现。\n\n#### 实现方法\n\n| 类型        | 单个元素值的范围 | 大小（bytes） | 描述                  |\n| ----------- | ---------------- | ------------- | --------------------- |\n| Int8Array   | -128 to 127      | 1             | 8 位二进制有符号整数  |\n| Uint8Array  | 0 to 255         | 1             | 8 位无符号整数        |\n| Int16Array  | -32768 to 32767  | 2             | 16 位二进制有符号整数 |\n| Uint16Array | 0 to 65535       | 2             | 16 位无符号整数       |\n\n#### 示例\n\n```javascript\nconst arrayBuffer = new ArrayBuffer(8);\nconsole.log(arrayBuffer.byteLength); // 8\nconst int8Array = new Int8Array(arrayBuffer);\nconsole.log(int8Array.length); // 8\nconst int16Array = new Int16Array(arrayBuffer);\nconsole.log(int16Array.length); // 4\n```\n\n## Blob\n\n`Blob`  是用来支持文件操作的。简单的说：在 `JS`  中，有两个构造函数  `File`  和  `Blob`, 而 `File`  继承了所有 `Blob`  的属性。\n\n所以在我们看来， `File`  对象可以看作一种特殊的 `Blob`  对象。\n\n### 功能\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1598082428365-89545715-5ef7-45d9-8610-82d830059ebe.png#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=1728&size=143528&status=done&style=none&width=1728)\n\n### 构造函数\n\n```javascript\n/**\n * @description 返回一个创建的 Blob 对象，其内容由参数中给定的数组串联组成\n */\nBlob(blobParts[, options])\n```\n\n### 属性\n\n| 属性名                                                                        | 描述                                                                                   |\n| ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |\n| [Blob.size](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size)  只读 | Blob  对象中所包含数据的大小（字节）                                                   |\n| [Blob.type](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type)  只读 | 一个字符串，表明该  Blob  对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。 |\n\n### 方法\n\n| 方法名                                                                                                   | 描述                                                                                                            |\n| -------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |\n| [Blob.slice([start[, end[, contentType]]])](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice) | 返回一个新的  Blob  对象，包含了源  Blob  对象中指定范围内的数据。                                              |\n| [Blob.stream()](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream)                            | 返回一个能读取 blob 内容的  [ReadableStream](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)。 |\n\n| [Blob.text()](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text)\n| 返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的  [USVString](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString)。 |\n| [Blob.arrayBuffer()](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer) | 返回一个 promise 且包含 blob 所有内容的二进制格式的  [ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBuffer)  |\n\n## atob 和 btoa\n\n从 `IE10+`  浏览器开始，所有的浏览器就原生提供了 `Base64`  编解码的方法。\n\n### Base64 解码\n\n```javascript\nlet decodedData = window.atob(encodedData);\n```\n\n### Base64 编码\n\n```javascript\nlet encodedData = window.btoa(stringToEncode);\n```\n\n## Canvas 中的 ImageData 对象\n\n`ImageData`  对象中存储着 `canvas`  对象真实的像素数据，它包含以下几个只读属性：\n\n- `width` ：图片宽度，单位是像素\n- `height` ：图片高度，单位是像素\n- `data` ： `Uint8ClampedArray`  类型的一维数组，包含着 `RGBA`  格式的整型数据，范围在 `0`  至 `255`  之间（包括 `255`）。\n\n### 创建一个 ImageData 对象\n\n使用 `createImageData()` 方法去创建一个新的，空白的 `ImageData`  对象。\n\n```javascript\nlet myImageData = ctx.createImageData(width, height);\n```\n\n上面代码创建了一个新的具体特定尺寸的`ImageData`对象。所有像素被预设为透明黑。\n\n### 得到场景像素数据\n\n为了获得一个包含画布场景像素数据的 `ImageData`  对象，你可以用 `getImageData()`  方法：\n\n```javascript\nlet myImageData = ctx.getImageData(left, top, width, height);\n```\n\n### 在场景中写入像素数据\n\n你可以用 `putImageData()`  方法去对场景进行像素数据的写入。\n\n```javascript\nctx.putImageData(myImageData, dx, dy);\n```\n\n### 使用 toDataURL 将 canvas 转换为 data URI 格式\n\n- 创建一个 `<canvas>`  元素\n\n```html\n<canvas id=\"canvas\" width=\"5\" height=\"5\"></canvas>\n```\n\n- 获取一个 `data-URL`\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\nlet dataURL = canvas.toDataURL();\nconsole.log(dataURL);\n// \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby\n// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC\"\n```\n\n基本所需要的技术点已经全部列出，接下来我们将实现图片裁剪的需求\n\n## 实现图片裁剪\n\n### 最终效果\n\n![image.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1598084805698-72d41a26-6ec6-4e5f-88d3-2662e3f05326.gif#align=left&display=inline&height=866&margin=%5Bobject%20Object%5D&name=image.gif&originHeight=866&originWidth=2216&size=3680927&status=done&style=none&width=2216)\n\n### 代码\n\n```jsx\nimport React, { useState, useRef } from \"react\";\nimport { Input, Row, Col, Button } from \"antd\";\nimport { ScissorOutlined, PlusCircleOutlined, MinusCircleOutlined, UploadOutlined } from \"@ant-design/icons\";\n\nconst App = () => {\n  const imageRef = useRef(),\n    canvasRef = useRef(),\n    avatarRef = useRef(),\n    [state, setState] = useState({\n      file: null,\n      dataURL: \"\",\n      times: 1,\n      startX: 0,\n      startY: 0,\n      startDrag: false,\n      lastX: 0,\n      lastY: 0,\n      avatarDataUrl: \"\"\n    });\n\n  function drawImage(left = state.lastX, top = state.lastY) {\n    let image = imageRef.current;\n    let canvas = canvasRef.current;\n    let ctx = canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    let imageWidth = image.width;\n    let imageHeight = image.height;\n    if (imageWidth > imageHeight) {\n      let scale = canvas.width / canvas.height;\n      imageWidth = canvas.width * state.times;\n      imageHeight = imageHeight * scale * state.times;\n    } else {\n      let scale = canvas.height / canvas.width;\n      imageHeight = canvas.height * state.times;\n      imageWidth = imageWidth * scale * state.times;\n    }\n    ctx.drawImage(image, (canvas.width - imageWidth) / 2 + left, (canvas.height - imageHeight) / 2 + top, imageWidth, imageHeight);\n  }\n\n  function handleChange(event) {\n    let file = event.target.files[0];\n    let fileReader = new FileReader();\n    fileReader.onload = event => {\n      setState({\n        ...state,\n        file,\n        dataURL: event.target.result\n      });\n      imageRef.onload = () => drawImage();\n    };\n    fileReader.readAsDataURL(file);\n  }\n\n  function handleMouseDown(event) {\n    setState({\n      ...state,\n      startX: event.clientX,\n      startY: event.clientY,\n      startDrag: true\n    });\n  }\n\n  function handleMouseMove(event) {\n    if (state.startDrag) {\n      drawImage(event.clientX - state.startX + state.lastX, event.clientY - state.startY + state.lastY);\n    }\n  }\n\n  function handleMouseUp(event) {\n    setState({\n      ...state,\n      lastX: event.clientX - state.startX + state.lastX,\n      lastY: event.clientY - state.startY + state.lastY,\n      startDrag: false\n    });\n  }\n\n  function bigger() {\n    setState({\n      ...state,\n      times: state.times + 0.1\n    });\n    drawImage();\n  }\n\n  function smaller() {\n    setState({\n      ...state,\n      times: state.times - 0.1\n    });\n    drawImage();\n  }\n\n  function confirm() {\n    let canvas = canvasRef.current;\n    let ctx = canvas.getContext(\"2d\");\n    const imageData = ctx.getImageData(100, 100, 100, 100);\n    let avatarCanvas = document.createElement(\"canvas\");\n    avatarCanvas.width = 100;\n    avatarCanvas.height = 100;\n    let avatarCtx = avatarCanvas.getContext(\"2d\");\n    avatarCtx.putImageData(imageData, 0, 0);\n    let avatarDataUrl = avatarCanvas.toDataURL();\n    setState({ ...state, avatarDataUrl });\n    avatarRef.current.src = avatarDataUrl;\n  }\n\n  function upload(event) {\n    console.log(state.avatarDataUrl);\n    let bytes = atob(state.avatarDataUrl.split(\",\")[1]);\n    console.log(\"bytes\", bytes);\n    let arrayBuffer = new ArrayBuffer(bytes.length);\n    let uInt8Array = new Uint8Array();\n    for (let i = 0; i < bytes.length; i++) {\n      uInt8Array[i] = bytes.charCodeAt[i];\n    }\n    let blob = new Blob([arrayBuffer], { type: \"image/png\" });\n    let xhr = new XMLHttpRequest();\n    let formData = new FormData();\n    formData.append(\"avatar\", blob);\n    xhr.open(\"POST\", \"/upload\", true);\n    xhr.send(formData);\n  }\n\n  return (\n    <div style={{ padding: \"10px\" }}>\n      <h2>图片裁剪，预览以及上传</h2>\n      <Input type=\"file\" accept=\"image/*\" onChange={handleChange} style={{ width: \"200px\" }} />\n      <Row>\n        <Col>{state.file && <img ref={imageRef} src={state.dataURL} alt=\"\" style={{ border: \"2px dashed #79D281\", width: \"400px\" }} />}</Col>\n      </Row>\n      <div onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp}>\n        {state.file && (\n          <Row>\n            <Col style={{ position: \"relative\" }}>\n              <canvas ref={canvasRef} width=\"300\" height=\"300\" style={{ border: \"2px dashed #632B21\" }}></canvas>\n              <div\n                style={{\n                  width: 100,\n                  height: 100,\n                  backgroundColor: \"blue\",\n                  opacity: 0.3,\n                  position: \"absolute\",\n                  left: 100,\n                  top: 100\n                }}></div>\n            </Col>\n            <Col>\n              <Button icon={<PlusCircleOutlined />} onClick={bigger}>\n                变大\n              </Button>\n              <Button icon={<MinusCircleOutlined />} onClick={smaller}>\n                变小\n              </Button>\n              <Button icon={<ScissorOutlined />} onClick={confirm}>\n                剪切\n              </Button>\n            </Col>\n          </Row>\n        )}\n      </div>\n      <div>{state.file && <img ref={avatarRef} alt=\"\" style={{ border: \"2px solid #85D6C7\" }} />}</div>\n      <div>\n        {state.file && (\n          <Button type=\"primary\" icon={<UploadOutlined />} onClick={upload}>\n            上传\n          </Button>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n### 实现\n\n#### 一、获取文件并读取文件\n\n给 `input`  绑定事件\n\n```jsx\nimport React, { useState, useRef } from \"react\";\n\nconst App = () => {\n  const imgRef = useRef();\n  const canvasRef = useRef();\n  const [file, setFile] = useState();\n  const [dataURL, setDataURL] = useState();\n  const [startX, setStartX] = useState(0);\n  const [startY, setStartY] = useState(0);\n  const [lastX, setLastX] = useState(0);\n  const [lastY, setLastY] = useState(0);\n  const [startDrag, setStartDrag] = useState(false);\n\n  const handleChange = event => {\n    let file = event.target.files[0];\n    let fileReader = new FileReader();\n    fileReader.onload = event => {\n      setFile(file);\n      setDataURL(event.target.result);\n      imageRef.current.onload = () => drawImage();\n    };\n    fileReader.readAsDataURL(file);\n  };\n\n  return (\n    <>\n      <input type=\"file\" onChange={handleChange} />\n\n      <img src=\"xxx\" ref={imgRef} />\n    </>\n  );\n};\n```\n\n`HTML5`  支持从  `input[type=file]`  元素中直接获取文件信息，也可以读取文件内容。\n\n此处用到了 `FileReader` ，这个类专门用来读取本地文件。纯文本或者二进制都可以进行读取，但是本地文件必须是经过用户允许之后才能读取，也就是说，用户要在 `input[type=file]`  中选择了这个文件，你才可以读取到它。\n\n通过 `FileReader`  我们可以将图片文件转化为 `DataURL` ，就是以 `data:image/png;base64`  开头的一种 `URL` ，然后可以直接放在 `image.src`  里，此时本地图片就会被显示出来。\n\n#### 二、获取裁剪坐标\n\n- `mousedown`\n\n这里要记录鼠标按下时的坐标，即 `startX`  和 `startY` ，同时将标识位 `startDrag`  设为 `true` ，标识鼠标开始移动。\n\n```javascript\nconst handleMouseDown = event => {\n  setStartX(event.clientX);\n  setStartY(event.clientY);\n  setStartDrag(true);\n};\n```\n\n- `mousemove`\n\n判断 `startDrag`  为 `true`（即鼠标开始移动），然后记录对应移动的距离。\n\n```javascript\nconst handleMouseMove = event => {\n  if (startDrag) {\n    drawImage(event.clientX - startX + lastX, event.clientY - startY + lastY);\n  }\n};\n```\n\n- `mouseup`\n\n这里要记录下最终鼠标的落点坐标，对应就是 `lastX`  与 `lastY`。\n\n```javascript\nconst handleMouseUp = event => {\n  setLastX(event.clientX - startX + lastX);\n  setLastY(event.clientY - startY + lastY);\n  setStartDrag(false);\n};\n```\n\n#### 三、裁剪图片\n\n将图片放置入 `canvas`  时需要调用 `drawImage` :\n\n```javascript\ndrawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n```\n\n```javascript\nconst drawImage = (left = lastX, top = lastY) => {\n  let image = imgRef.current,\n    canvas = canvasRef.current,\n    ctx = canvas.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  let imageWidth = image.width,\n    imageHeight = image.height;\n  if (imageWidth > imageHeight) {\n    let scale = canvas.width / canvas.height;\n    imageWidth = canvas.width * times;\n    imageHeight = imageHeight * scale * times;\n  } else {\n    let scale = canvas.height / canvas.width;\n    imageHeight = canvas.height * times;\n    imageWidth = imageWidth * scale * times;\n  }\n  ctx.drawImage(image, (canvas.width - imageWidth) / 2 + left, (canvas.height - imageHeight) / 2 + top, imageWidth, imageHeight);\n};\n```\n\n加入了 `scale`，这个变量是用来实现图片放大、缩小效果的。同时会判断图片的宽、高的大小关系，从而实现图片在 `canvas`  中对应的适配。\n\n#### 四、读取裁剪后的图片并上传\n\n这时我们要获取 `canvas`  中图片的信息，用 `toDataURL`  就可以转换成上面用到的 `DataURL` 。\n\n```javascript\nconst confirm = () => {\n  let canvas = canvasRef.current;\n  let ctx = canvas.getContext(\"2d\");\n  const imageData = ctx.getImageData(100, 100, 100, 100);\n  let avatarCanvas = document.createElement(\"canvas\");\n  avatarCanvas.width = 100;\n  avatarCanvas.height = 100;\n  let avatarCtx = avatarCanvas.getContext(\"2d\");\n  avatarCtx.putImageData(imageData, 0, 0);\n  let avatarDataUrl = avatarCanvas.toDataURL();\n  setAvatarDataUrl(avatarDataUrl);\n  avatarRef.current.src = avatarDataUrl;\n};\n```\n\n然后取出其中 `base64`  信息，再用 `window.atob`  转换成由二进制字符串。但 `window.atob`  转换后的结果仍然是字符串，直接给 `Blob`  还是会出错。所以又要用 `Uint8Array`  转换一下。\n\n这时候裁剪后的文件就储存在 `blob`  里了,我们可以把它当作是普通文件一样，加入到 `FormData`  里，并上传至服务器了。\n\n```javascript\nconst upload = event => {\n  // console.log(\"文件url\", this.state.avatarDataUrl);\n  let bytes = atob(avatarDataUrl.split(\",\")[1]);\n  console.log(\"bytes\", bytes);\n  let arrayBuffer = new ArrayBuffer(bytes.length);\n  let uInt8Array = new Uint8Array();\n  for (let i = 0; i < bytes.length; i++) {\n    uInt8Array[i] = bytes.charCodeAt[i];\n  }\n  let blob = new Blob([arrayBuffer], { type: \"image/png\" });\n  let xhr = new XMLHttpRequest();\n  let formData = new FormData();\n  formData.append(\"avatar\", blob);\n  xhr.open(\"POST\", \"/upload\", true);\n  xhr.send(formData);\n};\n```\n","source":"_posts/前端/从图片裁剪了解 js 二进制常用 api.md","raw":"---\ntitle: 从图片裁剪了解 js 二进制常用 api\ndate: 2020-11-20\ncategories: [前端, js]\ntags: \n  - 二进制\n---\n\n## 需求分析\n\n### 二进制模块之间的关系\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1598083455644-f4308101-1403-4566-ae7d-09a0c4fa5ffe.png#align=left&display=inline&height=602&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=889&size=126895&status=done&style=none&width=889)\n\n### 步骤\n\n1. 获取文件并读取文件\n1. 获取裁剪坐标\n1. 裁剪图片\n1. 读取裁剪后的图片预览并上传\n\n接下来先了解下二进制相关的 `API`  以方便实现本需求。\n\n## FileReader\n\n> `HTML5`定义了`FileReader`作为文件`API`的重要成员用于读取文件，根据`W3C`的定义，`FileReader`接口提供了读取文件的方法和包含读取结果的事件模型。\n\n### 创建实例\n\n```javascript\nconst fileReader = new FileReader();\n```\n\n### 属性\n\n| 属性名                                                                                | 描述                                                                                                               |\n| ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |\n| [error](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/error)            | 一个[DOMException](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMException)，表示在读取文件时发生的错误  。  |\n| [readyState](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readyState)  | 一个数字，用来表示  [FileReader](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader) API 的三种可能状态。 |\n| [result](https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result)          | 文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。                           |\n\n### 方法\n\n| 方法名             | 描述                                                  |\n| ------------------ | ----------------------------------------------------- |\n| abort              | 中止读取操作                                          |\n| readAsArrayBuffer  | 异步按字节读取文件内容，结果用  ArrayBuffer  对象表示 |\n| readAsBinaryString | 异步按字节读取文件内容，结果为文件的二进制串          |\n| readAsDataURL      | 异步读取文件内容，结果用  data:url  的字符串形式表示  |\n| readAsText         | 异步按字符读取文件内容，结果用字符串形式表示          |\n\n### 事件\n\n| 事件名      | 描述                           |\n| ----------- | ------------------------------ |\n| onabort     | 中断时触发                     |\n| onerror     | 出错时触发                     |\n| onload      | 文件读取成功完成时触发         |\n| onloadend   | 读取完成触发（无论成功或失败） |\n| onloadstart | 读取开始时触发                 |\n| onprogress  | 读取中                         |\n\n### 示例\n\n```jsx\n/**\n * @description 把一个文件的内容通过字符串的方式读取出来\n */\n<input type=\"file\" id=\"upload\" />\n\nconst upload = document.getElementById(\"upload\");\nupload.addEventListener(\"change\", function() {\n\tconst fileReader = new FileReader();\n  fileReader.onload = function() {\n  \tconst reult = fileReader.result;\n    console.log(result):\n  }\n}, false);\n```\n\n## ArrayBuffer / TypedArray / DataView\n\n### ArrayBuffer\n\n#### 功能\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1597991690421-351d07c1-8366-469f-8912-d094078e5986.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=1746&size=58281&status=done&style=none&width=873)\n\n#### 介绍\n\n`FileReader`  有个 `readAsArrayBuffer()`  方法，如果被读取的文件是二进制数据，那么用次方法读取将是最合适的方案，读取出来的数据将是一个 `ArrayBuffer`  对象。\n\n#### 定义\n\n> `ArrayBuffer`  对象用来表示通用的、固定长度的原始二进制数据缓冲区。`ArrayBuffer`  不能直接操作,而是要通过**类型数组对象**或  **`DataView`\\*\\***  对象\\*\\*来操作,它们会将缓冲区中的数据表示为特定的格式,并通过这些格式来读写缓冲区的内容.\n\n`ArrayBuffer`也是一个构造函数，可以分配一段可以存放数据的连续内存区域。\n\n```javascript\nconst arrayBuffer = new ArrayBuffer(8);\n// ArrayBuffer 对象有实例属性 byteLength ，表示当前实例占用的内存字节长度（单位字节）\nconsole.log(arrayBuffer.byteLength);\n```\n\n#### 属性\n\n| 属性名                                                                                                                                      | 描述                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- |\n| ArrayBuffer.length                                                                                                                          | ArrayBuffer  构造函数的 length  属性，其值为 1 。                                        |\n| [ArrayBuffer.prototype.byteLength](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/byteLength) | 只读属性，表示  ArrayBuffer  的 byte  的大小，在 ArrayBuffer  构造完成时生成，不可改变。 |\n\n> 由于无法对  `Arraybuffer`  直接进行操作,所以我们需要借助其他对象来操作. 所有就有了  **`TypedArray`\\*\\***(类型数组对象)**和  **`DataView`\\***\\*对象**。\n\n### DataView\n\n上方代码生成了一段 8 字节的内存区域。其中每个字节的默认值都是 0。\n\n为了读和写这段内容，需要为它指定视图。 `DataView`  视图的创建，需要提供 `ArrayBuffer` 对象实例作为参数。\n\n`DataView`  视图是一个可以从二进制 `ArrayBuffer`  对象中读写多种数值类型的底层接口。\n\n- `setInt8()`  从 `DataView`  起始位置以 `byte`  为计数的指定偏移量 `byteOffset`  处存储一个 `8-bit`  数(一个字节)。\n- `getInt8()`  从 `DataView`  起始位置以 `byte` 为计数的指定偏移量 `byteOffset` 处获取一个 `8-bit` 数(一个字节)。\n\n#### 调用\n\n```javascript\nnew DataView(buffer, [, byteOffset [, byteLength]])\n```\n\n#### 参数\n\n| 参数名            | 描述                                                                                                                                                                                                                                                                                     |\n| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| buffer            | 一个 已经存在的[ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)  或  [SharedArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)   对象，DataView  对象的数据源。 |\n| byteOffset (可选) | 此  DataView  对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始。                                                                                                                                                                                               |\n| byteLength (可选) | 此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度。                                                                                                                                                                                                             |\n\n#### 异常\n\n- [RangeError](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError)\n\n如果 `byteOffset` 或者 `byteLength `参数的值导致视图超出了 `buffer` 的结束位置就会抛出此异常。\n\n例如，假设 `buffer` （缓冲对象）是 `16` 字节长度，`byteOffset` 参数为 `8`，`byteLength` 参数为  `10`，这个错误就会抛出，这是因为结果视图试图超出 `buffer` 对象的总长度 `2` 个字节。\n\n#### 示例\n\n```javascript\nlet arrayBuffer = new ArrayBuffer();\nconsole.log(arrayBuffer.byteLength); // 2\nlet dataView = new DataView(buffer);\ndataView.setInt8(0, 1);\ndataView.setInt8(1, 2);\nconsole.log(dataView.getInt8(0)); // 1\nconsole.log(dataView.getInt8(1)); // 2\nconsole.log(dataView.getInt16(0)); // 258\n```\n\n### TypedArray\n\n另一种`TypedArray`视图，与`DataView`视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。\n\n`TypedArray`对象描述了一个底层的二进制数据缓存区（`binary data buffer`）的一个类数组视图（`view`）。但它本身不可以被实例化，甚至无法访问，你可以把它理解为接口，它有很多的实现。\n\n#### 实现方法\n\n| 类型        | 单个元素值的范围 | 大小（bytes） | 描述                  |\n| ----------- | ---------------- | ------------- | --------------------- |\n| Int8Array   | -128 to 127      | 1             | 8 位二进制有符号整数  |\n| Uint8Array  | 0 to 255         | 1             | 8 位无符号整数        |\n| Int16Array  | -32768 to 32767  | 2             | 16 位二进制有符号整数 |\n| Uint16Array | 0 to 65535       | 2             | 16 位无符号整数       |\n\n#### 示例\n\n```javascript\nconst arrayBuffer = new ArrayBuffer(8);\nconsole.log(arrayBuffer.byteLength); // 8\nconst int8Array = new Int8Array(arrayBuffer);\nconsole.log(int8Array.length); // 8\nconst int16Array = new Int16Array(arrayBuffer);\nconsole.log(int16Array.length); // 4\n```\n\n## Blob\n\n`Blob`  是用来支持文件操作的。简单的说：在 `JS`  中，有两个构造函数  `File`  和  `Blob`, 而 `File`  继承了所有 `Blob`  的属性。\n\n所以在我们看来， `File`  对象可以看作一种特殊的 `Blob`  对象。\n\n### 功能\n\n![image.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1598082428365-89545715-5ef7-45d9-8610-82d830059ebe.png#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=1728&size=143528&status=done&style=none&width=1728)\n\n### 构造函数\n\n```javascript\n/**\n * @description 返回一个创建的 Blob 对象，其内容由参数中给定的数组串联组成\n */\nBlob(blobParts[, options])\n```\n\n### 属性\n\n| 属性名                                                                        | 描述                                                                                   |\n| ----------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |\n| [Blob.size](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size)  只读 | Blob  对象中所包含数据的大小（字节）                                                   |\n| [Blob.type](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type)  只读 | 一个字符串，表明该  Blob  对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。 |\n\n### 方法\n\n| 方法名                                                                                                   | 描述                                                                                                            |\n| -------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |\n| [Blob.slice([start[, end[, contentType]]])](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice) | 返回一个新的  Blob  对象，包含了源  Blob  对象中指定范围内的数据。                                              |\n| [Blob.stream()](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream)                            | 返回一个能读取 blob 内容的  [ReadableStream](https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream)。 |\n\n| [Blob.text()](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text)\n| 返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的  [USVString](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString)。 |\n| [Blob.arrayBuffer()](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer) | 返回一个 promise 且包含 blob 所有内容的二进制格式的  [ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBuffer)  |\n\n## atob 和 btoa\n\n从 `IE10+`  浏览器开始，所有的浏览器就原生提供了 `Base64`  编解码的方法。\n\n### Base64 解码\n\n```javascript\nlet decodedData = window.atob(encodedData);\n```\n\n### Base64 编码\n\n```javascript\nlet encodedData = window.btoa(stringToEncode);\n```\n\n## Canvas 中的 ImageData 对象\n\n`ImageData`  对象中存储着 `canvas`  对象真实的像素数据，它包含以下几个只读属性：\n\n- `width` ：图片宽度，单位是像素\n- `height` ：图片高度，单位是像素\n- `data` ： `Uint8ClampedArray`  类型的一维数组，包含着 `RGBA`  格式的整型数据，范围在 `0`  至 `255`  之间（包括 `255`）。\n\n### 创建一个 ImageData 对象\n\n使用 `createImageData()` 方法去创建一个新的，空白的 `ImageData`  对象。\n\n```javascript\nlet myImageData = ctx.createImageData(width, height);\n```\n\n上面代码创建了一个新的具体特定尺寸的`ImageData`对象。所有像素被预设为透明黑。\n\n### 得到场景像素数据\n\n为了获得一个包含画布场景像素数据的 `ImageData`  对象，你可以用 `getImageData()`  方法：\n\n```javascript\nlet myImageData = ctx.getImageData(left, top, width, height);\n```\n\n### 在场景中写入像素数据\n\n你可以用 `putImageData()`  方法去对场景进行像素数据的写入。\n\n```javascript\nctx.putImageData(myImageData, dx, dy);\n```\n\n### 使用 toDataURL 将 canvas 转换为 data URI 格式\n\n- 创建一个 `<canvas>`  元素\n\n```html\n<canvas id=\"canvas\" width=\"5\" height=\"5\"></canvas>\n```\n\n- 获取一个 `data-URL`\n\n```javascript\nlet canvas = document.getElementById(\"canvas\");\nlet dataURL = canvas.toDataURL();\nconsole.log(dataURL);\n// \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby\n// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC\"\n```\n\n基本所需要的技术点已经全部列出，接下来我们将实现图片裁剪的需求\n\n## 实现图片裁剪\n\n### 最终效果\n\n![image.gif](https://cdn.nlark.com/yuque/0/2020/gif/732231/1598084805698-72d41a26-6ec6-4e5f-88d3-2662e3f05326.gif#align=left&display=inline&height=866&margin=%5Bobject%20Object%5D&name=image.gif&originHeight=866&originWidth=2216&size=3680927&status=done&style=none&width=2216)\n\n### 代码\n\n```jsx\nimport React, { useState, useRef } from \"react\";\nimport { Input, Row, Col, Button } from \"antd\";\nimport { ScissorOutlined, PlusCircleOutlined, MinusCircleOutlined, UploadOutlined } from \"@ant-design/icons\";\n\nconst App = () => {\n  const imageRef = useRef(),\n    canvasRef = useRef(),\n    avatarRef = useRef(),\n    [state, setState] = useState({\n      file: null,\n      dataURL: \"\",\n      times: 1,\n      startX: 0,\n      startY: 0,\n      startDrag: false,\n      lastX: 0,\n      lastY: 0,\n      avatarDataUrl: \"\"\n    });\n\n  function drawImage(left = state.lastX, top = state.lastY) {\n    let image = imageRef.current;\n    let canvas = canvasRef.current;\n    let ctx = canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    let imageWidth = image.width;\n    let imageHeight = image.height;\n    if (imageWidth > imageHeight) {\n      let scale = canvas.width / canvas.height;\n      imageWidth = canvas.width * state.times;\n      imageHeight = imageHeight * scale * state.times;\n    } else {\n      let scale = canvas.height / canvas.width;\n      imageHeight = canvas.height * state.times;\n      imageWidth = imageWidth * scale * state.times;\n    }\n    ctx.drawImage(image, (canvas.width - imageWidth) / 2 + left, (canvas.height - imageHeight) / 2 + top, imageWidth, imageHeight);\n  }\n\n  function handleChange(event) {\n    let file = event.target.files[0];\n    let fileReader = new FileReader();\n    fileReader.onload = event => {\n      setState({\n        ...state,\n        file,\n        dataURL: event.target.result\n      });\n      imageRef.onload = () => drawImage();\n    };\n    fileReader.readAsDataURL(file);\n  }\n\n  function handleMouseDown(event) {\n    setState({\n      ...state,\n      startX: event.clientX,\n      startY: event.clientY,\n      startDrag: true\n    });\n  }\n\n  function handleMouseMove(event) {\n    if (state.startDrag) {\n      drawImage(event.clientX - state.startX + state.lastX, event.clientY - state.startY + state.lastY);\n    }\n  }\n\n  function handleMouseUp(event) {\n    setState({\n      ...state,\n      lastX: event.clientX - state.startX + state.lastX,\n      lastY: event.clientY - state.startY + state.lastY,\n      startDrag: false\n    });\n  }\n\n  function bigger() {\n    setState({\n      ...state,\n      times: state.times + 0.1\n    });\n    drawImage();\n  }\n\n  function smaller() {\n    setState({\n      ...state,\n      times: state.times - 0.1\n    });\n    drawImage();\n  }\n\n  function confirm() {\n    let canvas = canvasRef.current;\n    let ctx = canvas.getContext(\"2d\");\n    const imageData = ctx.getImageData(100, 100, 100, 100);\n    let avatarCanvas = document.createElement(\"canvas\");\n    avatarCanvas.width = 100;\n    avatarCanvas.height = 100;\n    let avatarCtx = avatarCanvas.getContext(\"2d\");\n    avatarCtx.putImageData(imageData, 0, 0);\n    let avatarDataUrl = avatarCanvas.toDataURL();\n    setState({ ...state, avatarDataUrl });\n    avatarRef.current.src = avatarDataUrl;\n  }\n\n  function upload(event) {\n    console.log(state.avatarDataUrl);\n    let bytes = atob(state.avatarDataUrl.split(\",\")[1]);\n    console.log(\"bytes\", bytes);\n    let arrayBuffer = new ArrayBuffer(bytes.length);\n    let uInt8Array = new Uint8Array();\n    for (let i = 0; i < bytes.length; i++) {\n      uInt8Array[i] = bytes.charCodeAt[i];\n    }\n    let blob = new Blob([arrayBuffer], { type: \"image/png\" });\n    let xhr = new XMLHttpRequest();\n    let formData = new FormData();\n    formData.append(\"avatar\", blob);\n    xhr.open(\"POST\", \"/upload\", true);\n    xhr.send(formData);\n  }\n\n  return (\n    <div style={{ padding: \"10px\" }}>\n      <h2>图片裁剪，预览以及上传</h2>\n      <Input type=\"file\" accept=\"image/*\" onChange={handleChange} style={{ width: \"200px\" }} />\n      <Row>\n        <Col>{state.file && <img ref={imageRef} src={state.dataURL} alt=\"\" style={{ border: \"2px dashed #79D281\", width: \"400px\" }} />}</Col>\n      </Row>\n      <div onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp}>\n        {state.file && (\n          <Row>\n            <Col style={{ position: \"relative\" }}>\n              <canvas ref={canvasRef} width=\"300\" height=\"300\" style={{ border: \"2px dashed #632B21\" }}></canvas>\n              <div\n                style={{\n                  width: 100,\n                  height: 100,\n                  backgroundColor: \"blue\",\n                  opacity: 0.3,\n                  position: \"absolute\",\n                  left: 100,\n                  top: 100\n                }}></div>\n            </Col>\n            <Col>\n              <Button icon={<PlusCircleOutlined />} onClick={bigger}>\n                变大\n              </Button>\n              <Button icon={<MinusCircleOutlined />} onClick={smaller}>\n                变小\n              </Button>\n              <Button icon={<ScissorOutlined />} onClick={confirm}>\n                剪切\n              </Button>\n            </Col>\n          </Row>\n        )}\n      </div>\n      <div>{state.file && <img ref={avatarRef} alt=\"\" style={{ border: \"2px solid #85D6C7\" }} />}</div>\n      <div>\n        {state.file && (\n          <Button type=\"primary\" icon={<UploadOutlined />} onClick={upload}>\n            上传\n          </Button>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n```\n\n### 实现\n\n#### 一、获取文件并读取文件\n\n给 `input`  绑定事件\n\n```jsx\nimport React, { useState, useRef } from \"react\";\n\nconst App = () => {\n  const imgRef = useRef();\n  const canvasRef = useRef();\n  const [file, setFile] = useState();\n  const [dataURL, setDataURL] = useState();\n  const [startX, setStartX] = useState(0);\n  const [startY, setStartY] = useState(0);\n  const [lastX, setLastX] = useState(0);\n  const [lastY, setLastY] = useState(0);\n  const [startDrag, setStartDrag] = useState(false);\n\n  const handleChange = event => {\n    let file = event.target.files[0];\n    let fileReader = new FileReader();\n    fileReader.onload = event => {\n      setFile(file);\n      setDataURL(event.target.result);\n      imageRef.current.onload = () => drawImage();\n    };\n    fileReader.readAsDataURL(file);\n  };\n\n  return (\n    <>\n      <input type=\"file\" onChange={handleChange} />\n\n      <img src=\"xxx\" ref={imgRef} />\n    </>\n  );\n};\n```\n\n`HTML5`  支持从  `input[type=file]`  元素中直接获取文件信息，也可以读取文件内容。\n\n此处用到了 `FileReader` ，这个类专门用来读取本地文件。纯文本或者二进制都可以进行读取，但是本地文件必须是经过用户允许之后才能读取，也就是说，用户要在 `input[type=file]`  中选择了这个文件，你才可以读取到它。\n\n通过 `FileReader`  我们可以将图片文件转化为 `DataURL` ，就是以 `data:image/png;base64`  开头的一种 `URL` ，然后可以直接放在 `image.src`  里，此时本地图片就会被显示出来。\n\n#### 二、获取裁剪坐标\n\n- `mousedown`\n\n这里要记录鼠标按下时的坐标，即 `startX`  和 `startY` ，同时将标识位 `startDrag`  设为 `true` ，标识鼠标开始移动。\n\n```javascript\nconst handleMouseDown = event => {\n  setStartX(event.clientX);\n  setStartY(event.clientY);\n  setStartDrag(true);\n};\n```\n\n- `mousemove`\n\n判断 `startDrag`  为 `true`（即鼠标开始移动），然后记录对应移动的距离。\n\n```javascript\nconst handleMouseMove = event => {\n  if (startDrag) {\n    drawImage(event.clientX - startX + lastX, event.clientY - startY + lastY);\n  }\n};\n```\n\n- `mouseup`\n\n这里要记录下最终鼠标的落点坐标，对应就是 `lastX`  与 `lastY`。\n\n```javascript\nconst handleMouseUp = event => {\n  setLastX(event.clientX - startX + lastX);\n  setLastY(event.clientY - startY + lastY);\n  setStartDrag(false);\n};\n```\n\n#### 三、裁剪图片\n\n将图片放置入 `canvas`  时需要调用 `drawImage` :\n\n```javascript\ndrawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n```\n\n```javascript\nconst drawImage = (left = lastX, top = lastY) => {\n  let image = imgRef.current,\n    canvas = canvasRef.current,\n    ctx = canvas.getContext(\"2d\");\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  let imageWidth = image.width,\n    imageHeight = image.height;\n  if (imageWidth > imageHeight) {\n    let scale = canvas.width / canvas.height;\n    imageWidth = canvas.width * times;\n    imageHeight = imageHeight * scale * times;\n  } else {\n    let scale = canvas.height / canvas.width;\n    imageHeight = canvas.height * times;\n    imageWidth = imageWidth * scale * times;\n  }\n  ctx.drawImage(image, (canvas.width - imageWidth) / 2 + left, (canvas.height - imageHeight) / 2 + top, imageWidth, imageHeight);\n};\n```\n\n加入了 `scale`，这个变量是用来实现图片放大、缩小效果的。同时会判断图片的宽、高的大小关系，从而实现图片在 `canvas`  中对应的适配。\n\n#### 四、读取裁剪后的图片并上传\n\n这时我们要获取 `canvas`  中图片的信息，用 `toDataURL`  就可以转换成上面用到的 `DataURL` 。\n\n```javascript\nconst confirm = () => {\n  let canvas = canvasRef.current;\n  let ctx = canvas.getContext(\"2d\");\n  const imageData = ctx.getImageData(100, 100, 100, 100);\n  let avatarCanvas = document.createElement(\"canvas\");\n  avatarCanvas.width = 100;\n  avatarCanvas.height = 100;\n  let avatarCtx = avatarCanvas.getContext(\"2d\");\n  avatarCtx.putImageData(imageData, 0, 0);\n  let avatarDataUrl = avatarCanvas.toDataURL();\n  setAvatarDataUrl(avatarDataUrl);\n  avatarRef.current.src = avatarDataUrl;\n};\n```\n\n然后取出其中 `base64`  信息，再用 `window.atob`  转换成由二进制字符串。但 `window.atob`  转换后的结果仍然是字符串，直接给 `Blob`  还是会出错。所以又要用 `Uint8Array`  转换一下。\n\n这时候裁剪后的文件就储存在 `blob`  里了,我们可以把它当作是普通文件一样，加入到 `FormData`  里，并上传至服务器了。\n\n```javascript\nconst upload = event => {\n  // console.log(\"文件url\", this.state.avatarDataUrl);\n  let bytes = atob(avatarDataUrl.split(\",\")[1]);\n  console.log(\"bytes\", bytes);\n  let arrayBuffer = new ArrayBuffer(bytes.length);\n  let uInt8Array = new Uint8Array();\n  for (let i = 0; i < bytes.length; i++) {\n    uInt8Array[i] = bytes.charCodeAt[i];\n  }\n  let blob = new Blob([arrayBuffer], { type: \"image/png\" });\n  let xhr = new XMLHttpRequest();\n  let formData = new FormData();\n  formData.append(\"avatar\", blob);\n  xhr.open(\"POST\", \"/upload\", true);\n  xhr.send(formData);\n};\n```\n","slug":"前端/从图片裁剪了解 js 二进制常用 api","published":1,"updated":"2021-04-07T07:27:29.657Z","_id":"ckn7476am002tyx7ybva35va3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><h3 id=\"二进制模块之间的关系\"><a href=\"#二进制模块之间的关系\" class=\"headerlink\" title=\"二进制模块之间的关系\"></a>二进制模块之间的关系</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1598083455644-f4308101-1403-4566-ae7d-09a0c4fa5ffe.png#align=left&display=inline&height=602&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=889&size=126895&status=done&style=none&width=889\" alt=\"image.png\"></p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ol>\n<li>获取文件并读取文件</li>\n<li>获取裁剪坐标</li>\n<li>裁剪图片</li>\n<li>读取裁剪后的图片预览并上传</li>\n</ol>\n<p>接下来先了解下二进制相关的 <code>API</code>  以方便实现本需求。</p>\n<h2 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h2><blockquote>\n<p><code>HTML5</code>定义了<code>FileReader</code>作为文件<code>API</code>的重要成员用于读取文件，根据<code>W3C</code>的定义，<code>FileReader</code>接口提供了读取文件的方法和包含读取结果的事件模型。</p>\n</blockquote>\n<h3 id=\"创建实例\"><a href=\"#创建实例\" class=\"headerlink\" title=\"创建实例\"></a>创建实例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/error\">error</a></td>\n<td>一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DOMException\">DOMException</a>，表示在读取文件时发生的错误  。</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readyState\">readyState</a></td>\n<td>一个数字，用来表示  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\">FileReader</a> API 的三种可能状态。</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result\">result</a></td>\n<td>文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。</td>\n</tr>\n</tbody></table>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>abort</td>\n<td>中止读取操作</td>\n</tr>\n<tr>\n<td>readAsArrayBuffer</td>\n<td>异步按字节读取文件内容，结果用  ArrayBuffer  对象表示</td>\n</tr>\n<tr>\n<td>readAsBinaryString</td>\n<td>异步按字节读取文件内容，结果为文件的二进制串</td>\n</tr>\n<tr>\n<td>readAsDataURL</td>\n<td>异步读取文件内容，结果用  data:url  的字符串形式表示</td>\n</tr>\n<tr>\n<td>readAsText</td>\n<td>异步按字符读取文件内容，结果用字符串形式表示</td>\n</tr>\n</tbody></table>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><table>\n<thead>\n<tr>\n<th>事件名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onabort</td>\n<td>中断时触发</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td>出错时触发</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>文件读取成功完成时触发</td>\n</tr>\n<tr>\n<td>onloadend</td>\n<td>读取完成触发（无论成功或失败）</td>\n</tr>\n<tr>\n<td>onloadstart</td>\n<td>读取开始时触发</td>\n</tr>\n<tr>\n<td>onprogress</td>\n<td>读取中</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description </span>把一个文件的内容通过字符串的方式读取出来</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;file&quot;</span> id=<span class=\"string\">&quot;upload&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> upload = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;upload&quot;</span>);</span><br><span class=\"line\">upload.addEventListener(<span class=\"string\">&quot;change&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">  fileReader.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">const</span> reult = fileReader.result;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result):</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ArrayBuffer-TypedArray-DataView\"><a href=\"#ArrayBuffer-TypedArray-DataView\" class=\"headerlink\" title=\"ArrayBuffer / TypedArray / DataView\"></a>ArrayBuffer / TypedArray / DataView</h2><h3 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h3><h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1597991690421-351d07c1-8366-469f-8912-d094078e5986.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=1746&size=58281&status=done&style=none&width=873\" alt=\"image.png\"></p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p><code>FileReader</code>  有个 <code>readAsArrayBuffer()</code>  方法，如果被读取的文件是二进制数据，那么用次方法读取将是最合适的方案，读取出来的数据将是一个 <code>ArrayBuffer</code>  对象。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><blockquote>\n<p><code>ArrayBuffer</code>  对象用来表示通用的、固定长度的原始二进制数据缓冲区。<code>ArrayBuffer</code>  不能直接操作,而是要通过<strong>类型数组对象</strong>或  <strong><code>DataView</code>**</strong>  对象**来操作,它们会将缓冲区中的数据表示为特定的格式,并通过这些格式来读写缓冲区的内容.</p>\n</blockquote>\n<p><code>ArrayBuffer</code>也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">// ArrayBuffer 对象有实例属性 byteLength ，表示当前实例占用的内存字节长度（单位字节）</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayBuffer.byteLength);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayBuffer.length</td>\n<td>ArrayBuffer  构造函数的 length  属性，其值为 1 。</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/byteLength\">ArrayBuffer.prototype.byteLength</a></td>\n<td>只读属性，表示  ArrayBuffer  的 byte  的大小，在 ArrayBuffer  构造完成时生成，不可改变。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>由于无法对  <code>Arraybuffer</code>  直接进行操作,所以我们需要借助其他对象来操作. 所有就有了  <strong><code>TypedArray</code>**</strong>(类型数组对象)<strong>和  <strong><code>DataView</code>*</strong>*对象</strong>。</p>\n</blockquote>\n<h3 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h3><p>上方代码生成了一段 8 字节的内存区域。其中每个字节的默认值都是 0。</p>\n<p>为了读和写这段内容，需要为它指定视图。 <code>DataView</code>  视图的创建，需要提供 <code>ArrayBuffer</code> 对象实例作为参数。</p>\n<p><code>DataView</code>  视图是一个可以从二进制 <code>ArrayBuffer</code>  对象中读写多种数值类型的底层接口。</p>\n<ul>\n<li><code>setInt8()</code>  从 <code>DataView</code>  起始位置以 <code>byte</code>  为计数的指定偏移量 <code>byteOffset</code>  处存储一个 <code>8-bit</code>  数(一个字节)。</li>\n<li><code>getInt8()</code>  从 <code>DataView</code>  起始位置以 <code>byte</code> 为计数的指定偏移量 <code>byteOffset</code> 处获取一个 <code>8-bit</code> 数(一个字节)。</li>\n</ul>\n<h4 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer, [, byteOffset [, byteLength]])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>buffer</td>\n<td>一个 已经存在的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\">ArrayBuffer</a>  或  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\">SharedArrayBuffer</a>   对象，DataView  对象的数据源。</td>\n</tr>\n<tr>\n<td>byteOffset (可选)</td>\n<td>此  DataView  对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始。</td>\n</tr>\n<tr>\n<td>byteLength (可选)</td>\n<td>此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度。</td>\n</tr>\n</tbody></table>\n<h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError\">RangeError</a></li>\n</ul>\n<p>如果 <code>byteOffset</code> 或者 <code>byteLength </code>参数的值导致视图超出了 <code>buffer</code> 的结束位置就会抛出此异常。</p>\n<p>例如，假设 <code>buffer</code> （缓冲对象）是 <code>16</code> 字节长度，<code>byteOffset</code> 参数为 <code>8</code>，<code>byteLength</code> 参数为  <code>10</code>，这个错误就会抛出，这是因为结果视图试图超出 <code>buffer</code> 对象的总长度 <code>2</code> 个字节。</p>\n<h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayBuffer.byteLength); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dataView = <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer);</span><br><span class=\"line\">dataView.setInt8(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">dataView.setInt8(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dataView.getInt8(<span class=\"number\">0</span>)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dataView.getInt8(<span class=\"number\">1</span>)); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dataView.getInt16(<span class=\"number\">0</span>)); <span class=\"comment\">// 258</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h3><p>另一种<code>TypedArray</code>视图，与<code>DataView</code>视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。</p>\n<p><code>TypedArray</code>对象描述了一个底层的二进制数据缓存区（<code>binary data buffer</code>）的一个类数组视图（<code>view</code>）。但它本身不可以被实例化，甚至无法访问，你可以把它理解为接口，它有很多的实现。</p>\n<h4 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>单个元素值的范围</th>\n<th>大小（bytes）</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Int8Array</td>\n<td>-128 to 127</td>\n<td>1</td>\n<td>8 位二进制有符号整数</td>\n</tr>\n<tr>\n<td>Uint8Array</td>\n<td>0 to 255</td>\n<td>1</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Int16Array</td>\n<td>-32768 to 32767</td>\n<td>2</td>\n<td>16 位二进制有符号整数</td>\n</tr>\n<tr>\n<td>Uint16Array</td>\n<td>0 to 65535</td>\n<td>2</td>\n<td>16 位无符号整数</td>\n</tr>\n</tbody></table>\n<h4 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayBuffer.byteLength); <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> int8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Int8Array</span>(arrayBuffer);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int8Array.length); <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> int16Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(arrayBuffer);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int16Array.length); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h2><p><code>Blob</code>  是用来支持文件操作的。简单的说：在 <code>JS</code>  中，有两个构造函数  <code>File</code>  和  <code>Blob</code>, 而 <code>File</code>  继承了所有 <code>Blob</code>  的属性。</p>\n<p>所以在我们看来， <code>File</code>  对象可以看作一种特殊的 <code>Blob</code>  对象。</p>\n<h3 id=\"功能-1\"><a href=\"#功能-1\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1598082428365-89545715-5ef7-45d9-8610-82d830059ebe.png#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=1728&size=143528&status=done&style=none&width=1728\" alt=\"image.png\"></p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description </span>返回一个创建的 Blob 对象，其内容由参数中给定的数组串联组成</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Blob(blobParts[, options])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h3><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size\">Blob.size</a>  只读</td>\n<td>Blob  对象中所包含数据的大小（字节）</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type\">Blob.type</a>  只读</td>\n<td>一个字符串，表明该  Blob  对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</td>\n</tr>\n</tbody></table>\n<h3 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h3><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[Blob.slice([start[, end[, contentType]]])](<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice\">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice</a>)</td>\n<td>返回一个新的  Blob  对象，包含了源  Blob  对象中指定范围内的数据。</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream\">Blob.stream()</a></td>\n<td>返回一个能读取 blob 内容的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream\">ReadableStream</a>。</td>\n</tr>\n</tbody></table>\n<p>| <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text\">Blob.text()</a><br>| 返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/USVString\">USVString</a>。 |<br>| <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer\">Blob.arrayBuffer()</a> | 返回一个 promise 且包含 blob 所有内容的二进制格式的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBuffer\">ArrayBuffer</a>  |</p>\n<h2 id=\"atob-和-btoa\"><a href=\"#atob-和-btoa\" class=\"headerlink\" title=\"atob 和 btoa\"></a>atob 和 btoa</h2><p>从 <code>IE10+</code>  浏览器开始，所有的浏览器就原生提供了 <code>Base64</code>  编解码的方法。</p>\n<h3 id=\"Base64-解码\"><a href=\"#Base64-解码\" class=\"headerlink\" title=\"Base64 解码\"></a>Base64 解码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decodedData = <span class=\"built_in\">window</span>.atob(encodedData);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Base64-编码\"><a href=\"#Base64-编码\" class=\"headerlink\" title=\"Base64 编码\"></a>Base64 编码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> encodedData = <span class=\"built_in\">window</span>.btoa(stringToEncode);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Canvas-中的-ImageData-对象\"><a href=\"#Canvas-中的-ImageData-对象\" class=\"headerlink\" title=\"Canvas 中的 ImageData 对象\"></a>Canvas 中的 ImageData 对象</h2><p><code>ImageData</code>  对象中存储着 <code>canvas</code>  对象真实的像素数据，它包含以下几个只读属性：</p>\n<ul>\n<li><code>width</code> ：图片宽度，单位是像素</li>\n<li><code>height</code> ：图片高度，单位是像素</li>\n<li><code>data</code> ： <code>Uint8ClampedArray</code>  类型的一维数组，包含着 <code>RGBA</code>  格式的整型数据，范围在 <code>0</code>  至 <code>255</code>  之间（包括 <code>255</code>）。</li>\n</ul>\n<h3 id=\"创建一个-ImageData-对象\"><a href=\"#创建一个-ImageData-对象\" class=\"headerlink\" title=\"创建一个 ImageData 对象\"></a>创建一个 ImageData 对象</h3><p>使用 <code>createImageData()</code> 方法去创建一个新的，空白的 <code>ImageData</code>  对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myImageData = ctx.createImageData(width, height);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码创建了一个新的具体特定尺寸的<code>ImageData</code>对象。所有像素被预设为透明黑。</p>\n<h3 id=\"得到场景像素数据\"><a href=\"#得到场景像素数据\" class=\"headerlink\" title=\"得到场景像素数据\"></a>得到场景像素数据</h3><p>为了获得一个包含画布场景像素数据的 <code>ImageData</code>  对象，你可以用 <code>getImageData()</code>  方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myImageData = ctx.getImageData(left, top, width, height);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在场景中写入像素数据\"><a href=\"#在场景中写入像素数据\" class=\"headerlink\" title=\"在场景中写入像素数据\"></a>在场景中写入像素数据</h3><p>你可以用 <code>putImageData()</code>  方法去对场景进行像素数据的写入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.putImageData(myImageData, dx, dy);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-toDataURL-将-canvas-转换为-data-URI-格式\"><a href=\"#使用-toDataURL-将-canvas-转换为-data-URI-格式\" class=\"headerlink\" title=\"使用 toDataURL 将 canvas 转换为 data URI 格式\"></a>使用 toDataURL 将 canvas 转换为 data URI 格式</h3><ul>\n<li>创建一个 <code>&lt;canvas&gt;</code>  元素</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;canvas&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;5&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获取一个 <code>data-URL</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;canvas&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> dataURL = canvas.toDataURL();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dataURL);</span><br><span class=\"line\"><span class=\"comment\">// &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby</span></span><br><span class=\"line\"><span class=\"comment\">// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>基本所需要的技术点已经全部列出，接下来我们将实现图片裁剪的需求</p>\n<h2 id=\"实现图片裁剪\"><a href=\"#实现图片裁剪\" class=\"headerlink\" title=\"实现图片裁剪\"></a>实现图片裁剪</h2><h3 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1598084805698-72d41a26-6ec6-4e5f-88d3-2662e3f05326.gif#align=left&display=inline&height=866&margin=%5Bobject%20Object%5D&name=image.gif&originHeight=866&originWidth=2216&size=3680927&status=done&style=none&width=2216\" alt=\"image.gif\"></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useRef &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Input, Row, Col, Button &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;antd&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ScissorOutlined, PlusCircleOutlined, MinusCircleOutlined, UploadOutlined &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@ant-design/icons&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> imageRef = useRef(),</span><br><span class=\"line\">    canvasRef = useRef(),</span><br><span class=\"line\">    avatarRef = useRef(),</span><br><span class=\"line\">    [state, setState] = useState(&#123;</span><br><span class=\"line\">      file: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      dataURL: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">      times: <span class=\"number\">1</span>,</span><br><span class=\"line\">      startX: <span class=\"number\">0</span>,</span><br><span class=\"line\">      startY: <span class=\"number\">0</span>,</span><br><span class=\"line\">      startDrag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      lastX: <span class=\"number\">0</span>,</span><br><span class=\"line\">      lastY: <span class=\"number\">0</span>,</span><br><span class=\"line\">      avatarDataUrl: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawImage</span>(<span class=\"params\">left = state.lastX, top = state.lastY</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> image = imageRef.current;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> canvas = canvasRef.current;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ctx = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">    ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, canvas.width, canvas.height);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> imageWidth = image.width;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> imageHeight = image.height;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (imageWidth &gt; imageHeight) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> scale = canvas.width / canvas.height;</span><br><span class=\"line\">      imageWidth = canvas.width * state.times;</span><br><span class=\"line\">      imageHeight = imageHeight * scale * state.times;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> scale = canvas.height / canvas.width;</span><br><span class=\"line\">      imageHeight = canvas.height * state.times;</span><br><span class=\"line\">      imageWidth = imageWidth * scale * state.times;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.drawImage(image, (canvas.width - imageWidth) / <span class=\"number\">2</span> + left, (canvas.height - imageHeight) / <span class=\"number\">2</span> + top, imageWidth, imageHeight);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleChange</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = event.target.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">    fileReader.onload = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">      setState(&#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        file,</span><br><span class=\"line\">        dataURL: event.target.result</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      imageRef.onload = <span class=\"function\">() =&gt;</span> drawImage();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    fileReader.readAsDataURL(file);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMouseDown</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    setState(&#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      startX: event.clientX,</span><br><span class=\"line\">      startY: event.clientY,</span><br><span class=\"line\">      startDrag: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMouseMove</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state.startDrag) &#123;</span><br><span class=\"line\">      drawImage(event.clientX - state.startX + state.lastX, event.clientY - state.startY + state.lastY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMouseUp</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    setState(&#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      lastX: event.clientX - state.startX + state.lastX,</span><br><span class=\"line\">      lastY: event.clientY - state.startY + state.lastY,</span><br><span class=\"line\">      startDrag: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bigger</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setState(&#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      times: state.times + <span class=\"number\">0.1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    drawImage();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">smaller</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setState(&#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      times: state.times - <span class=\"number\">0.1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    drawImage();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">confirm</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> canvas = canvasRef.current;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ctx = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> imageData = ctx.getImageData(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> avatarCanvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;canvas&quot;</span>);</span><br><span class=\"line\">    avatarCanvas.width = <span class=\"number\">100</span>;</span><br><span class=\"line\">    avatarCanvas.height = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> avatarCtx = avatarCanvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">    avatarCtx.putImageData(imageData, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> avatarDataUrl = avatarCanvas.toDataURL();</span><br><span class=\"line\">    setState(&#123; ...state, avatarDataUrl &#125;);</span><br><span class=\"line\">    avatarRef.current.src = avatarDataUrl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(state.avatarDataUrl);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bytes = atob(state.avatarDataUrl.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;bytes&quot;</span>, bytes);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(bytes.length);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> uInt8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class=\"line\">      uInt8Array[i] = bytes.charCodeAt[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([arrayBuffer], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;image/png&quot;</span> &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">    formData.append(<span class=\"string\">&quot;avatar&quot;</span>, blob);</span><br><span class=\"line\">    xhr.open(<span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;/upload&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    xhr.send(formData);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div style=&#123;&#123; <span class=\"attr\">padding</span>: <span class=\"string\">&quot;10px&quot;</span> &#125;&#125;&gt;</span><br><span class=\"line\">      &lt;h2&gt;图片裁剪，预览以及上传&lt;/h2&gt;</span><br><span class=\"line\">      &lt;Input type=<span class=\"string\">&quot;file&quot;</span> accept=<span class=\"string\">&quot;image/*&quot;</span> onChange=&#123;handleChange&#125; style=&#123;&#123; <span class=\"attr\">width</span>: <span class=\"string\">&quot;200px&quot;</span> &#125;&#125; /&gt;</span><br><span class=\"line\">      &lt;Row&gt;</span><br><span class=\"line\">        &lt;Col&gt;&#123;state.file &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;imageRef&#125;</span> <span class=\"attr\">src</span>=<span class=\"string\">&#123;state.dataURL&#125;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">border:</span> &quot;<span class=\"attr\">2px</span> <span class=\"attr\">dashed</span> #<span class=\"attr\">79D281</span>&quot;, <span class=\"attr\">width:</span> &quot;<span class=\"attr\">400px</span>&quot; &#125;&#125; /&gt;</span></span>&#125;&lt;/Col&gt;</span><br><span class=\"line\">      &lt;/Row&gt;</span><br><span class=\"line\">      &lt;div onMouseDown=&#123;handleMouseDown&#125; onMouseMove=&#123;handleMouseMove&#125; onMouseUp=&#123;handleMouseUp&#125;&gt;</span><br><span class=\"line\">        &#123;state.file &amp;&amp; (</span><br><span class=\"line\">          &lt;Row&gt;</span><br><span class=\"line\">            &lt;Col style=&#123;&#123; <span class=\"attr\">position</span>: <span class=\"string\">&quot;relative&quot;</span> &#125;&#125;&gt;</span><br><span class=\"line\">              &lt;canvas ref=&#123;canvasRef&#125; width=<span class=\"string\">&quot;300&quot;</span> height=<span class=\"string\">&quot;300&quot;</span> style=&#123;&#123; <span class=\"attr\">border</span>: <span class=\"string\">&quot;2px dashed #632B21&quot;</span> &#125;&#125;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">              &lt;div</span><br><span class=\"line\">                style=&#123;&#123;</span><br><span class=\"line\">                  width: <span class=\"number\">100</span>,</span><br><span class=\"line\">                  height: <span class=\"number\">100</span>,</span><br><span class=\"line\">                  backgroundColor: <span class=\"string\">&quot;blue&quot;</span>,</span><br><span class=\"line\">                  opacity: <span class=\"number\">0.3</span>,</span><br><span class=\"line\">                  position: <span class=\"string\">&quot;absolute&quot;</span>,</span><br><span class=\"line\">                  left: <span class=\"number\">100</span>,</span><br><span class=\"line\">                  top: <span class=\"number\">100</span></span><br><span class=\"line\">                &#125;&#125;&gt;&lt;/div&gt;</span><br><span class=\"line\">            &lt;/Col&gt;</span><br><span class=\"line\">            &lt;Col&gt;</span><br><span class=\"line\">              &lt;Button icon=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">PlusCircleOutlined</span> /&gt;</span></span>&#125; onClick=&#123;bigger&#125;&gt;</span><br><span class=\"line\">                变大</span><br><span class=\"line\">              &lt;/Button&gt;</span><br><span class=\"line\">              &lt;Button icon=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">MinusCircleOutlined</span> /&gt;</span></span>&#125; onClick=&#123;smaller&#125;&gt;</span><br><span class=\"line\">                变小</span><br><span class=\"line\">              &lt;/Button&gt;</span><br><span class=\"line\">              &lt;Button icon=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ScissorOutlined</span> /&gt;</span></span>&#125; onClick=&#123;confirm&#125;&gt;</span><br><span class=\"line\">                剪切</span><br><span class=\"line\">              &lt;/Button&gt;</span><br><span class=\"line\">            &lt;/Col&gt;</span><br><span class=\"line\">          &lt;/Row&gt;</span><br><span class=\"line\">        )&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;div&gt;&#123;state.file &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;avatarRef&#125;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">border:</span> &quot;<span class=\"attr\">2px</span> <span class=\"attr\">solid</span> #<span class=\"attr\">85D6C7</span>&quot; &#125;&#125; /&gt;</span></span>&#125;&lt;/div&gt;</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;state.file &amp;&amp; (</span><br><span class=\"line\">          &lt;Button type=<span class=\"string\">&quot;primary&quot;</span> icon=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UploadOutlined</span> /&gt;</span></span>&#125; onClick=&#123;upload&#125;&gt;</span><br><span class=\"line\">            上传</span><br><span class=\"line\">          &lt;/Button&gt;</span><br><span class=\"line\">        )&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><h4 id=\"一、获取文件并读取文件\"><a href=\"#一、获取文件并读取文件\" class=\"headerlink\" title=\"一、获取文件并读取文件\"></a>一、获取文件并读取文件</h4><p>给 <code>input</code>  绑定事件</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useRef &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> imgRef = useRef();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> canvasRef = useRef();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [file, setFile] = useState();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [dataURL, setDataURL] = useState();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [startX, setStartX] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [startY, setStartY] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [lastX, setLastX] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [lastY, setLastY] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [startDrag, setStartDrag] = useState(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> handleChange = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = event.target.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">    fileReader.onload = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">      setFile(file);</span><br><span class=\"line\">      setDataURL(event.target.result);</span><br><span class=\"line\">      imageRef.current.onload = <span class=\"function\">() =&gt;</span> drawImage();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    fileReader.readAsDataURL(file);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input type=<span class=\"string\">&quot;file&quot;</span> onChange=&#123;handleChange&#125; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;img src=<span class=\"string\">&quot;xxx&quot;</span> ref=&#123;imgRef&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>HTML5</code>  支持从  <code>input[type=file]</code>  元素中直接获取文件信息，也可以读取文件内容。</p>\n<p>此处用到了 <code>FileReader</code> ，这个类专门用来读取本地文件。纯文本或者二进制都可以进行读取，但是本地文件必须是经过用户允许之后才能读取，也就是说，用户要在 <code>input[type=file]</code>  中选择了这个文件，你才可以读取到它。</p>\n<p>通过 <code>FileReader</code>  我们可以将图片文件转化为 <code>DataURL</code> ，就是以 <code>data:image/png;base64</code>  开头的一种 <code>URL</code> ，然后可以直接放在 <code>image.src</code>  里，此时本地图片就会被显示出来。</p>\n<h4 id=\"二、获取裁剪坐标\"><a href=\"#二、获取裁剪坐标\" class=\"headerlink\" title=\"二、获取裁剪坐标\"></a>二、获取裁剪坐标</h4><ul>\n<li><code>mousedown</code></li>\n</ul>\n<p>这里要记录鼠标按下时的坐标，即 <code>startX</code>  和 <code>startY</code> ，同时将标识位 <code>startDrag</code>  设为 <code>true</code> ，标识鼠标开始移动。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handleMouseDown = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  setStartX(event.clientX);</span><br><span class=\"line\">  setStartY(event.clientY);</span><br><span class=\"line\">  setStartDrag(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>mousemove</code></li>\n</ul>\n<p>判断 <code>startDrag</code>  为 <code>true</code>（即鼠标开始移动），然后记录对应移动的距离。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handleMouseMove = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (startDrag) &#123;</span><br><span class=\"line\">    drawImage(event.clientX - startX + lastX, event.clientY - startY + lastY);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>mouseup</code></li>\n</ul>\n<p>这里要记录下最终鼠标的落点坐标，对应就是 <code>lastX</code>  与 <code>lastY</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handleMouseUp = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  setLastX(event.clientX - startX + lastX);</span><br><span class=\"line\">  setLastY(event.clientY - startY + lastY);</span><br><span class=\"line\">  setStartDrag(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"三、裁剪图片\"><a href=\"#三、裁剪图片\" class=\"headerlink\" title=\"三、裁剪图片\"></a>三、裁剪图片</h4><p>将图片放置入 <code>canvas</code>  时需要调用 <code>drawImage</code> :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> drawImage = <span class=\"function\">(<span class=\"params\">left = lastX, top = lastY</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> image = imgRef.current,</span><br><span class=\"line\">    canvas = canvasRef.current,</span><br><span class=\"line\">    ctx = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">  ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, canvas.width, canvas.height);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> imageWidth = image.width,</span><br><span class=\"line\">    imageHeight = image.height;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (imageWidth &gt; imageHeight) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> scale = canvas.width / canvas.height;</span><br><span class=\"line\">    imageWidth = canvas.width * times;</span><br><span class=\"line\">    imageHeight = imageHeight * scale * times;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> scale = canvas.height / canvas.width;</span><br><span class=\"line\">    imageHeight = canvas.height * times;</span><br><span class=\"line\">    imageWidth = imageWidth * scale * times;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ctx.drawImage(image, (canvas.width - imageWidth) / <span class=\"number\">2</span> + left, (canvas.height - imageHeight) / <span class=\"number\">2</span> + top, imageWidth, imageHeight);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>加入了 <code>scale</code>，这个变量是用来实现图片放大、缩小效果的。同时会判断图片的宽、高的大小关系，从而实现图片在 <code>canvas</code>  中对应的适配。</p>\n<h4 id=\"四、读取裁剪后的图片并上传\"><a href=\"#四、读取裁剪后的图片并上传\" class=\"headerlink\" title=\"四、读取裁剪后的图片并上传\"></a>四、读取裁剪后的图片并上传</h4><p>这时我们要获取 <code>canvas</code>  中图片的信息，用 <code>toDataURL</code>  就可以转换成上面用到的 <code>DataURL</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> confirm = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> canvas = canvasRef.current;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ctx = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> imageData = ctx.getImageData(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> avatarCanvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;canvas&quot;</span>);</span><br><span class=\"line\">  avatarCanvas.width = <span class=\"number\">100</span>;</span><br><span class=\"line\">  avatarCanvas.height = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> avatarCtx = avatarCanvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">  avatarCtx.putImageData(imageData, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> avatarDataUrl = avatarCanvas.toDataURL();</span><br><span class=\"line\">  setAvatarDataUrl(avatarDataUrl);</span><br><span class=\"line\">  avatarRef.current.src = avatarDataUrl;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后取出其中 <code>base64</code>  信息，再用 <code>window.atob</code>  转换成由二进制字符串。但 <code>window.atob</code>  转换后的结果仍然是字符串，直接给 <code>Blob</code>  还是会出错。所以又要用 <code>Uint8Array</code>  转换一下。</p>\n<p>这时候裁剪后的文件就储存在 <code>blob</code>  里了,我们可以把它当作是普通文件一样，加入到 <code>FormData</code>  里，并上传至服务器了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> upload = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(&quot;文件url&quot;, this.state.avatarDataUrl);</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> bytes = atob(avatarDataUrl.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;bytes&quot;</span>, bytes);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(bytes.length);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> uInt8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class=\"line\">    uInt8Array[i] = bytes.charCodeAt[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([arrayBuffer], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;image/png&quot;</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">  formData.append(<span class=\"string\">&quot;avatar&quot;</span>, blob);</span><br><span class=\"line\">  xhr.open(<span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;/upload&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  xhr.send(formData);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><h3 id=\"二进制模块之间的关系\"><a href=\"#二进制模块之间的关系\" class=\"headerlink\" title=\"二进制模块之间的关系\"></a>二进制模块之间的关系</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1598083455644-f4308101-1403-4566-ae7d-09a0c4fa5ffe.png#align=left&display=inline&height=602&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=889&size=126895&status=done&style=none&width=889\" alt=\"image.png\"></p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><ol>\n<li>获取文件并读取文件</li>\n<li>获取裁剪坐标</li>\n<li>裁剪图片</li>\n<li>读取裁剪后的图片预览并上传</li>\n</ol>\n<p>接下来先了解下二进制相关的 <code>API</code>  以方便实现本需求。</p>\n<h2 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h2><blockquote>\n<p><code>HTML5</code>定义了<code>FileReader</code>作为文件<code>API</code>的重要成员用于读取文件，根据<code>W3C</code>的定义，<code>FileReader</code>接口提供了读取文件的方法和包含读取结果的事件模型。</p>\n</blockquote>\n<h3 id=\"创建实例\"><a href=\"#创建实例\" class=\"headerlink\" title=\"创建实例\"></a>创建实例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/error\">error</a></td>\n<td>一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DOMException\">DOMException</a>，表示在读取文件时发生的错误  。</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/readyState\">readyState</a></td>\n<td>一个数字，用来表示  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\">FileReader</a> API 的三种可能状态。</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result\">result</a></td>\n<td>文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。</td>\n</tr>\n</tbody></table>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h3><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>abort</td>\n<td>中止读取操作</td>\n</tr>\n<tr>\n<td>readAsArrayBuffer</td>\n<td>异步按字节读取文件内容，结果用  ArrayBuffer  对象表示</td>\n</tr>\n<tr>\n<td>readAsBinaryString</td>\n<td>异步按字节读取文件内容，结果为文件的二进制串</td>\n</tr>\n<tr>\n<td>readAsDataURL</td>\n<td>异步读取文件内容，结果用  data:url  的字符串形式表示</td>\n</tr>\n<tr>\n<td>readAsText</td>\n<td>异步按字符读取文件内容，结果用字符串形式表示</td>\n</tr>\n</tbody></table>\n<h3 id=\"事件\"><a href=\"#事件\" class=\"headerlink\" title=\"事件\"></a>事件</h3><table>\n<thead>\n<tr>\n<th>事件名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onabort</td>\n<td>中断时触发</td>\n</tr>\n<tr>\n<td>onerror</td>\n<td>出错时触发</td>\n</tr>\n<tr>\n<td>onload</td>\n<td>文件读取成功完成时触发</td>\n</tr>\n<tr>\n<td>onloadend</td>\n<td>读取完成触发（无论成功或失败）</td>\n</tr>\n<tr>\n<td>onloadstart</td>\n<td>读取开始时触发</td>\n</tr>\n<tr>\n<td>onprogress</td>\n<td>读取中</td>\n</tr>\n</tbody></table>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description </span>把一个文件的内容通过字符串的方式读取出来</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;file&quot;</span> id=<span class=\"string\">&quot;upload&quot;</span> /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> upload = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;upload&quot;</span>);</span><br><span class=\"line\">upload.addEventListener(<span class=\"string\">&quot;change&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">const</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">  fileReader.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t<span class=\"keyword\">const</span> reult = fileReader.result;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result):</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ArrayBuffer-TypedArray-DataView\"><a href=\"#ArrayBuffer-TypedArray-DataView\" class=\"headerlink\" title=\"ArrayBuffer / TypedArray / DataView\"></a>ArrayBuffer / TypedArray / DataView</h2><h3 id=\"ArrayBuffer\"><a href=\"#ArrayBuffer\" class=\"headerlink\" title=\"ArrayBuffer\"></a>ArrayBuffer</h3><h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1597991690421-351d07c1-8366-469f-8912-d094078e5986.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=1746&size=58281&status=done&style=none&width=873\" alt=\"image.png\"></p>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p><code>FileReader</code>  有个 <code>readAsArrayBuffer()</code>  方法，如果被读取的文件是二进制数据，那么用次方法读取将是最合适的方案，读取出来的数据将是一个 <code>ArrayBuffer</code>  对象。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><blockquote>\n<p><code>ArrayBuffer</code>  对象用来表示通用的、固定长度的原始二进制数据缓冲区。<code>ArrayBuffer</code>  不能直接操作,而是要通过<strong>类型数组对象</strong>或  <strong><code>DataView</code>**</strong>  对象**来操作,它们会将缓冲区中的数据表示为特定的格式,并通过这些格式来读写缓冲区的内容.</p>\n</blockquote>\n<p><code>ArrayBuffer</code>也是一个构造函数，可以分配一段可以存放数据的连续内存区域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">// ArrayBuffer 对象有实例属性 byteLength ，表示当前实例占用的内存字节长度（单位字节）</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayBuffer.byteLength);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayBuffer.length</td>\n<td>ArrayBuffer  构造函数的 length  属性，其值为 1 。</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/byteLength\">ArrayBuffer.prototype.byteLength</a></td>\n<td>只读属性，表示  ArrayBuffer  的 byte  的大小，在 ArrayBuffer  构造完成时生成，不可改变。</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>由于无法对  <code>Arraybuffer</code>  直接进行操作,所以我们需要借助其他对象来操作. 所有就有了  <strong><code>TypedArray</code>**</strong>(类型数组对象)<strong>和  <strong><code>DataView</code>*</strong>*对象</strong>。</p>\n</blockquote>\n<h3 id=\"DataView\"><a href=\"#DataView\" class=\"headerlink\" title=\"DataView\"></a>DataView</h3><p>上方代码生成了一段 8 字节的内存区域。其中每个字节的默认值都是 0。</p>\n<p>为了读和写这段内容，需要为它指定视图。 <code>DataView</code>  视图的创建，需要提供 <code>ArrayBuffer</code> 对象实例作为参数。</p>\n<p><code>DataView</code>  视图是一个可以从二进制 <code>ArrayBuffer</code>  对象中读写多种数值类型的底层接口。</p>\n<ul>\n<li><code>setInt8()</code>  从 <code>DataView</code>  起始位置以 <code>byte</code>  为计数的指定偏移量 <code>byteOffset</code>  处存储一个 <code>8-bit</code>  数(一个字节)。</li>\n<li><code>getInt8()</code>  从 <code>DataView</code>  起始位置以 <code>byte</code> 为计数的指定偏移量 <code>byteOffset</code> 处获取一个 <code>8-bit</code> 数(一个字节)。</li>\n</ul>\n<h4 id=\"调用\"><a href=\"#调用\" class=\"headerlink\" title=\"调用\"></a>调用</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer, [, byteOffset [, byteLength]])</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>buffer</td>\n<td>一个 已经存在的<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\">ArrayBuffer</a>  或  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer\">SharedArrayBuffer</a>   对象，DataView  对象的数据源。</td>\n</tr>\n<tr>\n<td>byteOffset (可选)</td>\n<td>此  DataView  对象的第一个字节在 buffer 中的字节偏移。如果未指定，则默认从第一个字节开始。</td>\n</tr>\n<tr>\n<td>byteLength (可选)</td>\n<td>此 DataView 对象的字节长度。如果未指定，这个视图的长度将匹配 buffer 的长度。</td>\n</tr>\n</tbody></table>\n<h4 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h4><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError\">RangeError</a></li>\n</ul>\n<p>如果 <code>byteOffset</code> 或者 <code>byteLength </code>参数的值导致视图超出了 <code>buffer</code> 的结束位置就会抛出此异常。</p>\n<p>例如，假设 <code>buffer</code> （缓冲对象）是 <code>16</code> 字节长度，<code>byteOffset</code> 参数为 <code>8</code>，<code>byteLength</code> 参数为  <code>10</code>，这个错误就会抛出，这是因为结果视图试图超出 <code>buffer</code> 对象的总长度 <code>2</code> 个字节。</p>\n<h4 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayBuffer.byteLength); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dataView = <span class=\"keyword\">new</span> <span class=\"built_in\">DataView</span>(buffer);</span><br><span class=\"line\">dataView.setInt8(<span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">dataView.setInt8(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dataView.getInt8(<span class=\"number\">0</span>)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dataView.getInt8(<span class=\"number\">1</span>)); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dataView.getInt16(<span class=\"number\">0</span>)); <span class=\"comment\">// 258</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"TypedArray\"><a href=\"#TypedArray\" class=\"headerlink\" title=\"TypedArray\"></a>TypedArray</h3><p>另一种<code>TypedArray</code>视图，与<code>DataView</code>视图的一个区别是，它不是一个构造函数，而是一组构造函数，代表不同的数据格式。</p>\n<p><code>TypedArray</code>对象描述了一个底层的二进制数据缓存区（<code>binary data buffer</code>）的一个类数组视图（<code>view</code>）。但它本身不可以被实例化，甚至无法访问，你可以把它理解为接口，它有很多的实现。</p>\n<h4 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h4><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>单个元素值的范围</th>\n<th>大小（bytes）</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Int8Array</td>\n<td>-128 to 127</td>\n<td>1</td>\n<td>8 位二进制有符号整数</td>\n</tr>\n<tr>\n<td>Uint8Array</td>\n<td>0 to 255</td>\n<td>1</td>\n<td>8 位无符号整数</td>\n</tr>\n<tr>\n<td>Int16Array</td>\n<td>-32768 to 32767</td>\n<td>2</td>\n<td>16 位二进制有符号整数</td>\n</tr>\n<tr>\n<td>Uint16Array</td>\n<td>0 to 65535</td>\n<td>2</td>\n<td>16 位无符号整数</td>\n</tr>\n</tbody></table>\n<h4 id=\"示例-2\"><a href=\"#示例-2\" class=\"headerlink\" title=\"示例\"></a>示例</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayBuffer.byteLength); <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> int8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Int8Array</span>(arrayBuffer);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int8Array.length); <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> int16Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Int16Array</span>(arrayBuffer);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(int16Array.length); <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Blob\"><a href=\"#Blob\" class=\"headerlink\" title=\"Blob\"></a>Blob</h2><p><code>Blob</code>  是用来支持文件操作的。简单的说：在 <code>JS</code>  中，有两个构造函数  <code>File</code>  和  <code>Blob</code>, 而 <code>File</code>  继承了所有 <code>Blob</code>  的属性。</p>\n<p>所以在我们看来， <code>File</code>  对象可以看作一种特殊的 <code>Blob</code>  对象。</p>\n<h3 id=\"功能-1\"><a href=\"#功能-1\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1598082428365-89545715-5ef7-45d9-8610-82d830059ebe.png#align=left&display=inline&height=730&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=1728&size=143528&status=done&style=none&width=1728\" alt=\"image.png\"></p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@description </span>返回一个创建的 Blob 对象，其内容由参数中给定的数组串联组成</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Blob(blobParts[, options])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h3><table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/size\">Blob.size</a>  只读</td>\n<td>Blob  对象中所包含数据的大小（字节）</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/type\">Blob.type</a>  只读</td>\n<td>一个字符串，表明该  Blob  对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。</td>\n</tr>\n</tbody></table>\n<h3 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h3><table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>[Blob.slice([start[, end[, contentType]]])](<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice\">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/slice</a>)</td>\n<td>返回一个新的  Blob  对象，包含了源  Blob  对象中指定范围内的数据。</td>\n</tr>\n<tr>\n<td><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/stream\">Blob.stream()</a></td>\n<td>返回一个能读取 blob 内容的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ReadableStream\">ReadableStream</a>。</td>\n</tr>\n</tbody></table>\n<p>| <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/text\">Blob.text()</a><br>| 返回一个 promise 且包含 blob 所有内容的 UTF-8 格式的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/USVString\">USVString</a>。 |<br>| <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Blob/arrayBuffer\">Blob.arrayBuffer()</a> | 返回一个 promise 且包含 blob 所有内容的二进制格式的  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/ArrayBuffer\">ArrayBuffer</a>  |</p>\n<h2 id=\"atob-和-btoa\"><a href=\"#atob-和-btoa\" class=\"headerlink\" title=\"atob 和 btoa\"></a>atob 和 btoa</h2><p>从 <code>IE10+</code>  浏览器开始，所有的浏览器就原生提供了 <code>Base64</code>  编解码的方法。</p>\n<h3 id=\"Base64-解码\"><a href=\"#Base64-解码\" class=\"headerlink\" title=\"Base64 解码\"></a>Base64 解码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decodedData = <span class=\"built_in\">window</span>.atob(encodedData);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Base64-编码\"><a href=\"#Base64-编码\" class=\"headerlink\" title=\"Base64 编码\"></a>Base64 编码</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> encodedData = <span class=\"built_in\">window</span>.btoa(stringToEncode);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Canvas-中的-ImageData-对象\"><a href=\"#Canvas-中的-ImageData-对象\" class=\"headerlink\" title=\"Canvas 中的 ImageData 对象\"></a>Canvas 中的 ImageData 对象</h2><p><code>ImageData</code>  对象中存储着 <code>canvas</code>  对象真实的像素数据，它包含以下几个只读属性：</p>\n<ul>\n<li><code>width</code> ：图片宽度，单位是像素</li>\n<li><code>height</code> ：图片高度，单位是像素</li>\n<li><code>data</code> ： <code>Uint8ClampedArray</code>  类型的一维数组，包含着 <code>RGBA</code>  格式的整型数据，范围在 <code>0</code>  至 <code>255</code>  之间（包括 <code>255</code>）。</li>\n</ul>\n<h3 id=\"创建一个-ImageData-对象\"><a href=\"#创建一个-ImageData-对象\" class=\"headerlink\" title=\"创建一个 ImageData 对象\"></a>创建一个 ImageData 对象</h3><p>使用 <code>createImageData()</code> 方法去创建一个新的，空白的 <code>ImageData</code>  对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myImageData = ctx.createImageData(width, height);</span><br></pre></td></tr></table></figure>\n\n<p>上面代码创建了一个新的具体特定尺寸的<code>ImageData</code>对象。所有像素被预设为透明黑。</p>\n<h3 id=\"得到场景像素数据\"><a href=\"#得到场景像素数据\" class=\"headerlink\" title=\"得到场景像素数据\"></a>得到场景像素数据</h3><p>为了获得一个包含画布场景像素数据的 <code>ImageData</code>  对象，你可以用 <code>getImageData()</code>  方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myImageData = ctx.getImageData(left, top, width, height);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在场景中写入像素数据\"><a href=\"#在场景中写入像素数据\" class=\"headerlink\" title=\"在场景中写入像素数据\"></a>在场景中写入像素数据</h3><p>你可以用 <code>putImageData()</code>  方法去对场景进行像素数据的写入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.putImageData(myImageData, dx, dy);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-toDataURL-将-canvas-转换为-data-URI-格式\"><a href=\"#使用-toDataURL-将-canvas-转换为-data-URI-格式\" class=\"headerlink\" title=\"使用 toDataURL 将 canvas 转换为 data URI 格式\"></a>使用 toDataURL 将 canvas 转换为 data URI 格式</h3><ul>\n<li>创建一个 <code>&lt;canvas&gt;</code>  元素</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;canvas&quot;</span> <span class=\"attr\">width</span>=<span class=\"string\">&quot;5&quot;</span> <span class=\"attr\">height</span>=<span class=\"string\">&quot;5&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>获取一个 <code>data-URL</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;canvas&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> dataURL = canvas.toDataURL();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(dataURL);</span><br><span class=\"line\"><span class=\"comment\">// &quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNby</span></span><br><span class=\"line\"><span class=\"comment\">// blAAAADElEQVQImWNgoBMAAABpAAFEI8ARAAAAAElFTkSuQmCC&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>基本所需要的技术点已经全部列出，接下来我们将实现图片裁剪的需求</p>\n<h2 id=\"实现图片裁剪\"><a href=\"#实现图片裁剪\" class=\"headerlink\" title=\"实现图片裁剪\"></a>实现图片裁剪</h2><h3 id=\"最终效果\"><a href=\"#最终效果\" class=\"headerlink\" title=\"最终效果\"></a>最终效果</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2020/gif/732231/1598084805698-72d41a26-6ec6-4e5f-88d3-2662e3f05326.gif#align=left&display=inline&height=866&margin=%5Bobject%20Object%5D&name=image.gif&originHeight=866&originWidth=2216&size=3680927&status=done&style=none&width=2216\" alt=\"image.gif\"></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useRef &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Input, Row, Col, Button &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;antd&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ScissorOutlined, PlusCircleOutlined, MinusCircleOutlined, UploadOutlined &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@ant-design/icons&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> imageRef = useRef(),</span><br><span class=\"line\">    canvasRef = useRef(),</span><br><span class=\"line\">    avatarRef = useRef(),</span><br><span class=\"line\">    [state, setState] = useState(&#123;</span><br><span class=\"line\">      file: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      dataURL: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">      times: <span class=\"number\">1</span>,</span><br><span class=\"line\">      startX: <span class=\"number\">0</span>,</span><br><span class=\"line\">      startY: <span class=\"number\">0</span>,</span><br><span class=\"line\">      startDrag: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      lastX: <span class=\"number\">0</span>,</span><br><span class=\"line\">      lastY: <span class=\"number\">0</span>,</span><br><span class=\"line\">      avatarDataUrl: <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawImage</span>(<span class=\"params\">left = state.lastX, top = state.lastY</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> image = imageRef.current;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> canvas = canvasRef.current;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ctx = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">    ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, canvas.width, canvas.height);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> imageWidth = image.width;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> imageHeight = image.height;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (imageWidth &gt; imageHeight) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> scale = canvas.width / canvas.height;</span><br><span class=\"line\">      imageWidth = canvas.width * state.times;</span><br><span class=\"line\">      imageHeight = imageHeight * scale * state.times;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> scale = canvas.height / canvas.width;</span><br><span class=\"line\">      imageHeight = canvas.height * state.times;</span><br><span class=\"line\">      imageWidth = imageWidth * scale * state.times;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ctx.drawImage(image, (canvas.width - imageWidth) / <span class=\"number\">2</span> + left, (canvas.height - imageHeight) / <span class=\"number\">2</span> + top, imageWidth, imageHeight);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleChange</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = event.target.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">    fileReader.onload = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">      setState(&#123;</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        file,</span><br><span class=\"line\">        dataURL: event.target.result</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      imageRef.onload = <span class=\"function\">() =&gt;</span> drawImage();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    fileReader.readAsDataURL(file);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMouseDown</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    setState(&#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      startX: event.clientX,</span><br><span class=\"line\">      startY: event.clientY,</span><br><span class=\"line\">      startDrag: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMouseMove</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state.startDrag) &#123;</span><br><span class=\"line\">      drawImage(event.clientX - state.startX + state.lastX, event.clientY - state.startY + state.lastY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleMouseUp</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    setState(&#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      lastX: event.clientX - state.startX + state.lastX,</span><br><span class=\"line\">      lastY: event.clientY - state.startY + state.lastY,</span><br><span class=\"line\">      startDrag: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bigger</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setState(&#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      times: state.times + <span class=\"number\">0.1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    drawImage();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">smaller</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    setState(&#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      times: state.times - <span class=\"number\">0.1</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    drawImage();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">confirm</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> canvas = canvasRef.current;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ctx = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> imageData = ctx.getImageData(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> avatarCanvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;canvas&quot;</span>);</span><br><span class=\"line\">    avatarCanvas.width = <span class=\"number\">100</span>;</span><br><span class=\"line\">    avatarCanvas.height = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> avatarCtx = avatarCanvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">    avatarCtx.putImageData(imageData, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> avatarDataUrl = avatarCanvas.toDataURL();</span><br><span class=\"line\">    setState(&#123; ...state, avatarDataUrl &#125;);</span><br><span class=\"line\">    avatarRef.current.src = avatarDataUrl;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upload</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(state.avatarDataUrl);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> bytes = atob(state.avatarDataUrl.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;bytes&quot;</span>, bytes);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(bytes.length);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> uInt8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class=\"line\">      uInt8Array[i] = bytes.charCodeAt[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([arrayBuffer], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;image/png&quot;</span> &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    <span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">    formData.append(<span class=\"string\">&quot;avatar&quot;</span>, blob);</span><br><span class=\"line\">    xhr.open(<span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;/upload&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    xhr.send(formData);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div style=&#123;&#123; <span class=\"attr\">padding</span>: <span class=\"string\">&quot;10px&quot;</span> &#125;&#125;&gt;</span><br><span class=\"line\">      &lt;h2&gt;图片裁剪，预览以及上传&lt;/h2&gt;</span><br><span class=\"line\">      &lt;Input type=<span class=\"string\">&quot;file&quot;</span> accept=<span class=\"string\">&quot;image/*&quot;</span> onChange=&#123;handleChange&#125; style=&#123;&#123; <span class=\"attr\">width</span>: <span class=\"string\">&quot;200px&quot;</span> &#125;&#125; /&gt;</span><br><span class=\"line\">      &lt;Row&gt;</span><br><span class=\"line\">        &lt;Col&gt;&#123;state.file &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;imageRef&#125;</span> <span class=\"attr\">src</span>=<span class=\"string\">&#123;state.dataURL&#125;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">border:</span> &quot;<span class=\"attr\">2px</span> <span class=\"attr\">dashed</span> #<span class=\"attr\">79D281</span>&quot;, <span class=\"attr\">width:</span> &quot;<span class=\"attr\">400px</span>&quot; &#125;&#125; /&gt;</span></span>&#125;&lt;/Col&gt;</span><br><span class=\"line\">      &lt;/Row&gt;</span><br><span class=\"line\">      &lt;div onMouseDown=&#123;handleMouseDown&#125; onMouseMove=&#123;handleMouseMove&#125; onMouseUp=&#123;handleMouseUp&#125;&gt;</span><br><span class=\"line\">        &#123;state.file &amp;&amp; (</span><br><span class=\"line\">          &lt;Row&gt;</span><br><span class=\"line\">            &lt;Col style=&#123;&#123; <span class=\"attr\">position</span>: <span class=\"string\">&quot;relative&quot;</span> &#125;&#125;&gt;</span><br><span class=\"line\">              &lt;canvas ref=&#123;canvasRef&#125; width=<span class=\"string\">&quot;300&quot;</span> height=<span class=\"string\">&quot;300&quot;</span> style=&#123;&#123; <span class=\"attr\">border</span>: <span class=\"string\">&quot;2px dashed #632B21&quot;</span> &#125;&#125;&gt;&lt;/canvas&gt;</span><br><span class=\"line\">              &lt;div</span><br><span class=\"line\">                style=&#123;&#123;</span><br><span class=\"line\">                  width: <span class=\"number\">100</span>,</span><br><span class=\"line\">                  height: <span class=\"number\">100</span>,</span><br><span class=\"line\">                  backgroundColor: <span class=\"string\">&quot;blue&quot;</span>,</span><br><span class=\"line\">                  opacity: <span class=\"number\">0.3</span>,</span><br><span class=\"line\">                  position: <span class=\"string\">&quot;absolute&quot;</span>,</span><br><span class=\"line\">                  left: <span class=\"number\">100</span>,</span><br><span class=\"line\">                  top: <span class=\"number\">100</span></span><br><span class=\"line\">                &#125;&#125;&gt;&lt;/div&gt;</span><br><span class=\"line\">            &lt;/Col&gt;</span><br><span class=\"line\">            &lt;Col&gt;</span><br><span class=\"line\">              &lt;Button icon=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">PlusCircleOutlined</span> /&gt;</span></span>&#125; onClick=&#123;bigger&#125;&gt;</span><br><span class=\"line\">                变大</span><br><span class=\"line\">              &lt;/Button&gt;</span><br><span class=\"line\">              &lt;Button icon=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">MinusCircleOutlined</span> /&gt;</span></span>&#125; onClick=&#123;smaller&#125;&gt;</span><br><span class=\"line\">                变小</span><br><span class=\"line\">              &lt;/Button&gt;</span><br><span class=\"line\">              &lt;Button icon=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ScissorOutlined</span> /&gt;</span></span>&#125; onClick=&#123;confirm&#125;&gt;</span><br><span class=\"line\">                剪切</span><br><span class=\"line\">              &lt;/Button&gt;</span><br><span class=\"line\">            &lt;/Col&gt;</span><br><span class=\"line\">          &lt;/Row&gt;</span><br><span class=\"line\">        )&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">      &lt;div&gt;&#123;state.file &amp;&amp; <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;avatarRef&#125;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;&quot;</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">border:</span> &quot;<span class=\"attr\">2px</span> <span class=\"attr\">solid</span> #<span class=\"attr\">85D6C7</span>&quot; &#125;&#125; /&gt;</span></span>&#125;&lt;/div&gt;</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;state.file &amp;&amp; (</span><br><span class=\"line\">          &lt;Button type=<span class=\"string\">&quot;primary&quot;</span> icon=&#123;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">UploadOutlined</span> /&gt;</span></span>&#125; onClick=&#123;upload&#125;&gt;</span><br><span class=\"line\">            上传</span><br><span class=\"line\">          &lt;/Button&gt;</span><br><span class=\"line\">        )&#125;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> App;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><h4 id=\"一、获取文件并读取文件\"><a href=\"#一、获取文件并读取文件\" class=\"headerlink\" title=\"一、获取文件并读取文件\"></a>一、获取文件并读取文件</h4><p>给 <code>input</code>  绑定事件</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useRef &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> imgRef = useRef();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> canvasRef = useRef();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [file, setFile] = useState();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [dataURL, setDataURL] = useState();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [startX, setStartX] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [startY, setStartY] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [lastX, setLastX] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [lastY, setLastY] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [startDrag, setStartDrag] = useState(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> handleChange = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> file = event.target.files[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> fileReader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">    fileReader.onload = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">      setFile(file);</span><br><span class=\"line\">      setDataURL(event.target.result);</span><br><span class=\"line\">      imageRef.current.onload = <span class=\"function\">() =&gt;</span> drawImage();</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    fileReader.readAsDataURL(file);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;input type=<span class=\"string\">&quot;file&quot;</span> onChange=&#123;handleChange&#125; /&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">      &lt;img src=<span class=\"string\">&quot;xxx&quot;</span> ref=&#123;imgRef&#125; /&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>HTML5</code>  支持从  <code>input[type=file]</code>  元素中直接获取文件信息，也可以读取文件内容。</p>\n<p>此处用到了 <code>FileReader</code> ，这个类专门用来读取本地文件。纯文本或者二进制都可以进行读取，但是本地文件必须是经过用户允许之后才能读取，也就是说，用户要在 <code>input[type=file]</code>  中选择了这个文件，你才可以读取到它。</p>\n<p>通过 <code>FileReader</code>  我们可以将图片文件转化为 <code>DataURL</code> ，就是以 <code>data:image/png;base64</code>  开头的一种 <code>URL</code> ，然后可以直接放在 <code>image.src</code>  里，此时本地图片就会被显示出来。</p>\n<h4 id=\"二、获取裁剪坐标\"><a href=\"#二、获取裁剪坐标\" class=\"headerlink\" title=\"二、获取裁剪坐标\"></a>二、获取裁剪坐标</h4><ul>\n<li><code>mousedown</code></li>\n</ul>\n<p>这里要记录鼠标按下时的坐标，即 <code>startX</code>  和 <code>startY</code> ，同时将标识位 <code>startDrag</code>  设为 <code>true</code> ，标识鼠标开始移动。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handleMouseDown = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  setStartX(event.clientX);</span><br><span class=\"line\">  setStartY(event.clientY);</span><br><span class=\"line\">  setStartDrag(<span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>mousemove</code></li>\n</ul>\n<p>判断 <code>startDrag</code>  为 <code>true</code>（即鼠标开始移动），然后记录对应移动的距离。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handleMouseMove = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (startDrag) &#123;</span><br><span class=\"line\">    drawImage(event.clientX - startX + lastX, event.clientY - startY + lastY);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>mouseup</code></li>\n</ul>\n<p>这里要记录下最终鼠标的落点坐标，对应就是 <code>lastX</code>  与 <code>lastY</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handleMouseUp = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  setLastX(event.clientX - startX + lastX);</span><br><span class=\"line\">  setLastY(event.clientY - startY + lastY);</span><br><span class=\"line\">  setStartDrag(<span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"三、裁剪图片\"><a href=\"#三、裁剪图片\" class=\"headerlink\" title=\"三、裁剪图片\"></a>三、裁剪图片</h4><p>将图片放置入 <code>canvas</code>  时需要调用 <code>drawImage</code> :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> drawImage = <span class=\"function\">(<span class=\"params\">left = lastX, top = lastY</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> image = imgRef.current,</span><br><span class=\"line\">    canvas = canvasRef.current,</span><br><span class=\"line\">    ctx = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">  ctx.clearRect(<span class=\"number\">0</span>, <span class=\"number\">0</span>, canvas.width, canvas.height);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> imageWidth = image.width,</span><br><span class=\"line\">    imageHeight = image.height;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (imageWidth &gt; imageHeight) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> scale = canvas.width / canvas.height;</span><br><span class=\"line\">    imageWidth = canvas.width * times;</span><br><span class=\"line\">    imageHeight = imageHeight * scale * times;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> scale = canvas.height / canvas.width;</span><br><span class=\"line\">    imageHeight = canvas.height * times;</span><br><span class=\"line\">    imageWidth = imageWidth * scale * times;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ctx.drawImage(image, (canvas.width - imageWidth) / <span class=\"number\">2</span> + left, (canvas.height - imageHeight) / <span class=\"number\">2</span> + top, imageWidth, imageHeight);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>加入了 <code>scale</code>，这个变量是用来实现图片放大、缩小效果的。同时会判断图片的宽、高的大小关系，从而实现图片在 <code>canvas</code>  中对应的适配。</p>\n<h4 id=\"四、读取裁剪后的图片并上传\"><a href=\"#四、读取裁剪后的图片并上传\" class=\"headerlink\" title=\"四、读取裁剪后的图片并上传\"></a>四、读取裁剪后的图片并上传</h4><p>这时我们要获取 <code>canvas</code>  中图片的信息，用 <code>toDataURL</code>  就可以转换成上面用到的 <code>DataURL</code> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> confirm = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> canvas = canvasRef.current;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ctx = canvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> imageData = ctx.getImageData(<span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> avatarCanvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;canvas&quot;</span>);</span><br><span class=\"line\">  avatarCanvas.width = <span class=\"number\">100</span>;</span><br><span class=\"line\">  avatarCanvas.height = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> avatarCtx = avatarCanvas.getContext(<span class=\"string\">&quot;2d&quot;</span>);</span><br><span class=\"line\">  avatarCtx.putImageData(imageData, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> avatarDataUrl = avatarCanvas.toDataURL();</span><br><span class=\"line\">  setAvatarDataUrl(avatarDataUrl);</span><br><span class=\"line\">  avatarRef.current.src = avatarDataUrl;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>然后取出其中 <code>base64</code>  信息，再用 <code>window.atob</code>  转换成由二进制字符串。但 <code>window.atob</code>  转换后的结果仍然是字符串，直接给 <code>Blob</code>  还是会出错。所以又要用 <code>Uint8Array</code>  转换一下。</p>\n<p>这时候裁剪后的文件就储存在 <code>blob</code>  里了,我们可以把它当作是普通文件一样，加入到 <code>FormData</code>  里，并上传至服务器了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> upload = <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(&quot;文件url&quot;, this.state.avatarDataUrl);</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> bytes = atob(avatarDataUrl.split(<span class=\"string\">&quot;,&quot;</span>)[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;bytes&quot;</span>, bytes);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arrayBuffer = <span class=\"keyword\">new</span> <span class=\"built_in\">ArrayBuffer</span>(bytes.length);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> uInt8Array = <span class=\"keyword\">new</span> <span class=\"built_in\">Uint8Array</span>();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class=\"line\">    uInt8Array[i] = bytes.charCodeAt[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> blob = <span class=\"keyword\">new</span> Blob([arrayBuffer], &#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;image/png&quot;</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">  <span class=\"keyword\">let</span> formData = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">  formData.append(<span class=\"string\">&quot;avatar&quot;</span>, blob);</span><br><span class=\"line\">  xhr.open(<span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;/upload&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">  xhr.send(formData);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"React16 文档","date":"2020-08-14T16:00:00.000Z","_content":"\n## 1. React 中的核心概念\n\n### 虚拟 DOM\n\n1. DOM 的本质是什么？\n\n> 浏览器中的概念，用`js`对象来表示页面上的元素，并提供了操作 `DOM` 对象的 API；\n\n2. 什么是 React 中的 虚拟 DOM？（ 虚拟 DOM 的本质）：\n\n> 用`js`对象来模拟 页面上的`DOM和DOM嵌套`\n\n3. 为什么要实现 虚拟 DOM ？（ 虚拟 DOM 的目的）：\n\n> 为了实现页面中，`DOM`元素的高效更新\n\n4. DOM 和 虚拟 DOM 的区别：\n\n- `DOM`：浏览器中，提供的概念；用`js`对象，表示页面上的元素，并提供了操作元素的 `API`；\n- `虚拟DOM`：是框架中的概念；是开发框架的人员，手动用`js`对象来模拟`DOM`元素和嵌套关系；\n\n5. DOM 树的概念：\n\n> 一个网页的呈现过程：\n>\n> 1. 浏览器请求服务器获取页面的 `html` 代码；\n> 2. 浏览器要先在内存中，解析 `DOM` 结构，并在浏览器内存中，渲染出一棵 `DOM` 树；\n> 3. 浏览器把 `DOM` 树，呈现到页面上；\n\n### Diff 算法\n\n1. tree diff：\n\n> 新旧两棵 `DOM` 树，逐层对比的过程，就是`tree diff`；\n> 当整棵`DOM`逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到；\n\n2. component diff：\n\n> 在进行 `tree diff` 的时候，每一层中，组件级别的对比，叫做 `component diff`；\n> 如果对比前后，组件的类型相同，则**暂时**认为此组件不许要被更新；\n> 如果对比前后，组件的类型不同，则需要移除旧组件，创建新组件，并追加到页面上；\n\n3. element diff：\n\n> 在进行组件对比的时候，如果两个组件的类型相同，则需要进行元素级别的对比，这叫做`element diff`；\n\n## 2. React 中创建组件\n\n### 使用构造函数来创建组件\n\n> 1、在组件中，必须要向外`return`一个合法的`jsx`创建的`虚拟DOM`元素；\n> 2、如果要接收外界传递的数据，需要在`构造函数`的参数列表中使用`props`来接收；\n> 3、无论是`vue`还是`react`，组件中的`props`永远都是只读`read-only`的，不能被重新赋值；\n> 4、组件的名称`首字母`必须是`大写`的\n> 5、省略 `.jsx` 文件名\n\n> 打开 `webpack.config.js`，并在导出的配置对象中，新增以下几个节点：\n\n```javascript\nresolve: {\n  extensions: [\".js\", \".jsx\", \".json\"];\n}\n```\n\n> 如果在一个组件中 `return` 一个 `null`，则表示此组件是空的，什么都不会渲染\n\n```jsx\nfunction Hello(props) {\n  return (\n    <div>\n      这是Hello组件 -- {props.name} -- {props.age} -- {props.gender}\n    </div>\n  );\n}\n\nconst user = {\n  name: \"大黄\",\n  age: 3,\n  gender: \"雄性\"\n};\n\nReactDOM.render(\n  <div>\n    <Hello {...user} />\n  </div>,\n  document.getElementById(\"#app\")\n);\n```\n\n### 使用 class 关键字来创建组件\n\n> `public`: 所有成员都可访问\n> `private`: 只有当前类可访问\n> `protected`: 只有当前类和其子类可访问，外部成员无法访问\n\n> `es6`中的`class关键字`，是实现`面向对象编程`的新形式，也叫做`语法糖`\n\n- constructor 构造器中的 super 函数\n\n> 在子类中， `this` 只能放到 `super` 之后使用\n> 子类中的 `super`，其实就是父类中，`contructor`构造器的一个引用\n\n- 最基本的组件结构\n\n> `render`函数的作用：渲染当前组件所对应的`虚拟DOM` 元素\n\n```jsx\nimport React from \"react\";\nclass 组件名称 extends React.Component {\n  render() {\n    return <div>这是 class 创建的组件</div>;\n  }\n}\n```\n\n- this.props 和 this.state\n\n> 1. `this.props` 接收外界传递的参数，`this.state` 设置私有数据\n> 2. 在 `class` 关键字创建的组件中，直接使用 `this.props` 访问传递过来的数据\n> 3. `props` 是只读的\n\n```jsx\nclass Movie extends React.Component {\n  constructor() {\n    super();\n    // 这里的 this.state = {}，就相当于 Vue中的data() { return {} }\n    this.state = {\n      msg: \"这是Movie组件的私有数据\"\n    };\n  }\n  render() {\n    {\n      /* 注意：在 class 组件内容，this 表示当前组件的实例对象 */\n    }\n    return <div>这是Movie组件 -- {this.props.name}</div>;\n  }\n}\nconst user = {\n  name: \"大黄\",\n  age: 3,\n  gender: \"雄性\"\n};\n\nReactDOM.render(\n  <div>\n    <Movie {...user} />\n    <h3>{this.state.msg}</h3>\n  </div>,\n  document.getElementById(\"#app\")\n);\n```\n\n### 两种创建组件的方式的对比\n\n> 使用 `class` 关键字创建的组件，有自己的 `私有数据(this.state)` 和 `生命周期`\n> 使用 `function` 创建的组件，只有 `props`，没有自己的 `私有数据` 和 `生命周期`\n> 有状态组件和无状态组件之间的 `本质区别`：有无 `state` 属性和 `生命周期函数`\n\n## 3. React 中 style 处理方式\n\n### 内联\n\n```jsx\nstyle = {{ color: red }}\n```\n\n### css\n\n> 1、如果直接导入 `css` 样式表，默认则是在全局上，整个项目都会生效\n> 2、css 模块化，只针对 `class` 选择器 和 `id` 选择器生效\n> 引用：`import style from './style.css'`\n\n## 4. React 中事件绑定\n\n1. 事件的名称都是 `React` 所提供的，因此名称的首字母必须大写`onClick`，`onMouseOver`\n2. 为事件提供的处理函数，必须是以下格式：\n\n```javascript\nonClick = { function };\n```\n\n3. 用的最多的事件绑定形式为：\n\n```jsx\n<button onClick={() => this.show(\"传参\")}>按钮</button>;\n\n// 事件的处理函数，需要定义为 一个箭头函数，然后赋值给 函数名称\nshow = arg1 => {\n  console.log(\"show方法\" + arg1);\n};\n```\n\n4. 在 `React` 中，如果想要修改 `state` 中的数据，推荐使用 `this.setState({ })`\n\n> 1、在`setState`中，只会把对应的 `state`状态更新，而不会覆盖其它的 `state`状态。\n> 2、`this.setState` 方法的执行时 `异步的`。\n> 3、如果在调用完 `this.setState`之后，又想立即拿到最新的`state`的值，需要使用 `this.setState({}, callback)`，第二个参数【回调函数】中获取。\n\n## 5. 单向数据流(状态变化 => 自动更新页面)\n\n> 1、`React` 中，默认是 `单向数据流`，只能把 `state` 上的数据绑定到页面，无法把页面中数据的变化，自动同步回 `state`；如果需要把页面上数据的变化，保存到 `state`，需要手动监听`onChange` 事件，拿到最新的数据，手动调用 `this.setState({ })` 更改。\n> 2、当为文本框绑定 `value` 值以后，要么同时给标签提供一个 `readOnly` 属性，要么提供一个 `onChange` 事件处理函数。\n\n```jsx\n// 方案一：通过事件参数 e 来获取DOM元素的引用\n<input type=\"text\" value={this.state.msg} onChange={e => this.textChanged(e)} />;\n\ntextChanged = e => {\n  console.log(e.target.value);\n};\n\n// 方案二：通过ref 来获取DOM元素的引用  this.refs.引用名称\n<input type=\"text\" value={this.state.msg} onChange={() => this.textChanged()} ref=\"txt\" />;\n\ntextChanged = () => {\n  console.log(this.refs.txt.value);\n};\n```\n\n## 6. 生命周期\n\n- 生命周期介绍\n\n> 每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会触发一系列事件，这些事件就叫做组件的生命周期\n\n- React 的生命周期分为三个部分\n\n1. 组件创建阶段\n\n> 只执行一次\n\n> 1. `componentWillMount` => `挂载之前`\n> 2. `render` => `正在渲染，虚拟DOM创建到了内存中，还未挂载到页面上`\n> 3. `componentDidMount` => `挂载结束，需要操作DOM节点的初始化操作放在这里`\n\n2. 组件运行阶段：\n\n> 根据 `props` 属性或者 `state` 状态的改变，有选择性的执行 `0` 到 `多次`\n\n> 1. `props` 改变之后\n> 2. `componentWillReceiveProps` => 当一个挂载的组件接收到新的 `props` 的时候被调用\n> 3. `state` 改变之后\n> 4. `shouldComponentUpdate（nextprops, nextState）` => 当组件做出是否要更新 `DOM` 的决定的时候被调用，在改变状态的时候可以选择通过( `return true` )或者不通过( `return false`)\n> 5. `componentWillUpdate` => 在更新发生之前被调用\n> 6. `render` => 数据是新的，页面是旧的\n>\n> 7.`componentDidUpdate` => 数据是新的，页面已经变成了最新的\n\n3. 组件销毁阶段\n\n> 只执行一次\n\n> `componentWillUnmount` => 组件移除或者销毁的时候被调用\n\n## 7. 验证数据类型\n\n```javascript\nimport { ProtoTypes } from \"prop-types\";\n\n// 定义组件需要传入的参数\nMyCompo.protoTypes = {\n  a: ProtoTypes.string.isRequired,\n  b: ProtoTypes.string.isRequired,\n  c: ProtoTypes.number.isRequired\n};\n```\n\n## 8. flux\n\n### 简介\n\n> 传统的 `MVC` 和 `MVVM` 架构设计模式有一个致命的缺点：当项目越来越大、逻辑越来越复杂的时候，数据流动就越显得混乱。\n\n> `Flux` 是致力于解决数据有序传输问题的架构设计模式，来自 `Facebook`。`Flux` 中最大的哲学：数据是 `单向流动` 的。\n\n> [官方手册](https://github.com/facebook/flux/tree/master/examples/flux-concepts)\n\n> `Flux` 中最重要的四个概念：`Dispatcher`、`Store`、`View`、`Action`。\n\n![flux.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703835856-e1263bac-124a-40da-ae3c-b45a4c8081ae.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&name=flux.png&originHeight=393&originWidth=1300&size=26132&status=done&style=none&width=1300)\n\n### 基本概念\n\n1. 概述\n   - `flux` 是一个管理 `App` 中数据流动的模式。\n   - 最关键的概念：`数据的流动是单向的`。\n2. Dispatcher 调度者\n   - `Dispatcher` 接受 `action`，并且要把这些 `action` 分派给已经注册到 `Dispatcher` 的 `store` 上\n   - 所有的 `store` 都将接收所有的 `action`\n   - 在每个 `App` 中，应该确保只有一个 `Dispatcher` 的实例\n3. store 仓库\n   - `store` 是在 `App` 中持有数据的仓库\n   - 所有的 `store` 要在 `App` 的 `Dispatcher` 上注册，确保它们可以接收 `action`\n   - `store` 中的数据只能被 `action` 改变。\n   - `store` 中不能够有公共的 `setter`，只能有 `getter`\n   - `store` 决定了它们愿意响应哪些 `actions`\n   - 无论何时，`store` 中的数据发生改变，就会触发一个 `change` 事件\n   - 同一个 `App` 中可能有很多 `store`\n4. Action 行为\n   - `Action` 定义了 `App` 内部的 `API`\n   - 它们捕获所有可能改变 `App` 的途径和方法\n   - 它们是简单的`对象`，并且要有 `type属性` 和 `其他的一些数据属性`\n   - `Action` 应该有一个具有语义的、直观的表示它是做什么的名字\n   - 所有的`store`都将接收同一个`action`，并且通过这个 `action`，`store` 会知道它们要清除、更新哪些数据\n5. Views 视图\n   - `store` 中的数据被展示在了`view`上\n   - `View` 层可以使用任何框架\n   - 当一个视图想要获取 `store` 中的数据，它必须 `subscribe 订阅` 一下该 `store` 的`change` 事件\n   - 当 `store` 触发了 `change` 事件，此时 `view` 就能得到新的数据并且重新渲染\n   - 如果一个组件要使用 `store`，但是没有订阅这个 `store`，此时就会出错\n   - `Action` 最常见的产生原因是：在 `App` 中的某一个部分，因为用户的交互行为，而被此`view` `dispatch`出来了\n\n### redux\n\n- 简介\n  - [官网](https://redux.js.org/)\n  - Redux 就是 Flux 思想在 React 中的实现\n  - Redux 是一个可预测状态的 Js app 容器\n  - [`通过例子来学习redux`](https://github.com/reactjs/redux/tree/master/examples)\n- Redux 创建的步骤\n  - 设置一个 `reducer`；\n  - 创建一个`store`，`Redux.createStore(reducer)`\n  - 创建 `render` 函数\n  - 注册 `render`，`store.subscribe(render)`\n  - 监听，此时要记得 `store.dispatch(action)`，不是直接修改`store`\n\n### React-Redux\n\n- 简介\n  - 将 `react` 和 `redux` 合并起来，可以让任何组件在任何地方看见 `store`\n  - [官方文档](https://github.com/reactjs/react-redux/tree/master/docs)\n  - `React-Redux` 给我们提供了：`Provider组件`，`connect函数`\n- Provider 组件\n\n> 1、使用 `react-redux` 提供的 `Provider` 组件传递 `store` 上下文之后，`包裹在其中的所有组件` 全都可以识别这个上下文\n\n> 2、在 `Provider` 组件内部的自定义组件可以使用 `connect()` 函数，但是在其外部的不可使用\n\n- connect 函数\n\n> 1、将 `React组件` 和 `Redux` 的 `store` 进行连接\n> 2、`connect` 提供了一个很方便的 `API` 能够适应绝大多数工作\n> 3、它没有更改你传进来的类，反而会返回一个已经连接好的新类\n> 4、提供了两个参数：`mapStateToProps`, `mapDispatchToProps`\n\n- mapStateToProps\n\n> 1、如果传入`mapStateToProps`，此时这个组件将订阅 `Redux` 中 `store` 的更新信息；\n> 2、这意味着无论任何时候 `store` 被更改了，`mapStateToProps` 函数都将会被调用，`mapStateToProps` 的返回值必须是一个 `Object`；\n> 3、这个 `Object` 将与组件的 `props` 融合，也就是说，这个返回的 `Object` 中的 `key` 将自动成为组件的 `props` 中的成员\n> 4、如果不想订阅 `store` 的更新，此时可以不传递这个参数，采用 `null` 占位\n\n- mapDispatchToProps\n\n> 如果向 `connect` 函数中传入了第二个参数，并且是一个 `函数`，那么这个函数将获得`dispatch` 方法，该方法可以通过 `emit action`，间接的导致 `state` 的改变\n> 可以使用 `bindActionCreators()` 方法轻松的将 `Action creator`(返回 `action` 的函数)接口和 `dispatch` 进行绑定\n\n- 书写规则\n\n> index.js\n\n```jsx\nimport React from \"react\";\nimport { render } from \"react-dom\";\nimport { createStore } from \"redux\";\nimport { Provider } from \"react-redux\";\nimport App from \"./containers/App\";\nimport reducer from \"./reducers\";\n\nconst store = createStore(reducer);\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n```\n\n> App.js\n\n```jsx\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport * as actions from \"./actions\";\n\nclass App extends React.Component {\n  constructor(props) {\n    super();\n    console.log(props);\n    // props: { r: 0, g: 0, b: 0, actions: 许多方法 }\n  }\n  render() {\n    return <div>这是App组件</div>;\n  }\n}\nconst mapStateToProps = state => {\n  return {\n    r: state.r,\n    g: state.g,\n    b: state.b\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    actions: bindActionCreators(actions, dispatch)\n  };\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\n> reducer.js\n\n```jsx\nexport default (state, action) => {\n  if (state == undefined) {\n    state = { r: 0, g: 0, b: 0 };\n  }\n  if (action.type == \"ADD\") {\n    return {\n      ...state,\n      r: state.r + 1\n    };\n  }\n  return state;\n};\n```\n\n> actions.js\n\n```jsx\nexport const ADD = () => { \"type\": \"ADD\" }\n```\n\n### 组件内部的 state 和全局的 state\n\n> 组件的数据三兄弟：`state`, `props`, `context` 不管是谁发生改变，都会引发 `render()` 执行，视图会被重绘。但是，构造函数不会被重新执行。所以不管基于什么理由，都不需要将全局的状态，用自己组件的 `state` 接收，而仅需要用`connect`连接一下全局`store`，然后使用`this.props.**`即可。\n\n### reducer 模块化\n\n```javascript\nimport { combineReducers } from \"redux\";\nimport todoReducers from \"./todoReducer.js\"; // 标准reducer\n\nexport default combineReducers({\n  todoReducers\n});\n```\n\n### redux-logger\n\n> 打印 redux log\n\n```javascript\nimport { createStore, applyMiddleware } from \"redux\";\nimport { createLogger } from \"redux-logger\";\nimport reducer from \"./reducers/index.js\";\nlet store = createStore(reducer, applyMiddleware(createLogger()));\n```\n\n### redux-thunk\n\n> 解决异步问题\n\n> `redux-thunk`帮助我们在所有的组件的 `props` 中添加了一个 `dispatch` 方法。\n\n> 当然，这个组件一定要被 `connect` 函数进行处理\n\n> 注意，如果使用 `thunk`，则 `connect` 函数不能传入第二个参数，否则会导致无法获取 `this.props.dispatch()`\n\n```javascript\n// 入口文件\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nlet store = createStore(reducer, applyMiddleware(thunk))\n\n/** 组件中 */\n/** 第一种写法，并没有将actions进行抽离 */\n$.get('/shu.txt', data => {\n    var number = Number(data);\n    this.props.dispatch({\n        \"type\": \"ADD\",\n        number\n    })\n})\n/** 第二种写法:常用 */\n// 可枚举\nimport * as actions from './actions/actions.js'\n\nclass ** extends React.Component {\n    ...\n    add() {\n        this.props.dispatch(actions.add())\n        this.props.dispatch(actions.minus())\n    }\n    ...\n}\n/** 现在，一般不会再写第二个参数了，就是说省略掉mapDispatchToProps */\nexport default connect(\n (state) => {\n    return {\n        state: state\n    }\n })(**)\n// actions.js\n/* 现在，异步的Action Creator不要直接返回 Action，而是返回一个携带 dispatch 的函数；这个函数相当于“延长”了dispatch的持续时间。*/\nexport const add = () => (dispatch, getState) => {\n    console.log(getState()) // getState可以获取全局数据\n    $.get('/shu.txt', data => {\n        var number = Number(data);\n        dispatch({\"type\": \"MINUS\", number})\n    })\n}\nexport const minus = () => { \"type\": \"MINUS\" }\n// reducer.js\nexport default (state = 0, action) => {\n    switch(action.type) {\n        case \"ADD\":\n            return state + action.number\n        case \"MINUS\":\n            return state - 1\n    }\n    return state;\n}\n```\n\n## 9. react-router4.x\n\n### 介绍\n\n- [官网](https://reacttraining.com/react-router)\n- 安装：`npm install react-router-dom`\n\n### demo\n\n> `exact`表示严格匹配，如果路径为 `path=\"/\"` 的 `Route` 不设置该属性，则会自动向下匹配路由，即都会显示出来\n\n```jsx\nimport React from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\n\nfunction Index() {\n  return <h2>Home</h2>;\n}\n\nfunction About() {\n  return <h2>About</h2>;\n}\n\nfunction Users() {\n  return <h2>Users</h2>;\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <ul>\n            <li>\n              <Link to=\"/\">Home</Link>\n            </li>\n            <li>\n              <Link to=\"/about/\">About</Link>\n            </li>\n            <li>\n              <Link to=\"/users/\">Users</Link>\n            </li>\n          </ul>\n        </nav>\n\n        <Route path=\"/\" exact component={Index} />\n        <Route path=\"/about/\" component={About} />\n        <Route path=\"/users/\" component={Users} />\n      </div>\n    </Router>\n  );\n}\nexport default AppRouter;\n```\n\n### 动态路由\n\n```jsx\n// App.js 定义动态路由\n<Route path=\"/content/:aid\"></Route>\n// news.js 跳转\n<Link to={`/content/${value.aid}`}></Link>\n// Content.js 跳在生命周期函数中获取动态路由参数\nclass Content extends Component {\n    /* ... */\n      componentDidMount() {\n          const { match } = this.props\n          // 获取到传递的动态路由参数\n          console.log(match.params.aid)\n      }\n    /* ... */\n}\n```\n\n### get 传值\n\n```jsx\n// App.js 定义动态路由\n<Route path=\"/content\"></Route>\n// news.js 跳转\n<Link to={`/content?aid=${value.aid}`}></Link>\n// Content.js 跳在生命周期函数中获取动态路由参数\nclass Content extends Component {\n    ...\n      componentDidMount() {\n          const { location } = this.props\n          // 获取到传递的动态路由参数\n          console.log(location.search)\n      }\n    ...\n}\n```\n\n### js 控制跳转\n\n1. 引入 `Redirect` 组件\n2. 定义一个 `flag`\n\n```javascript\nthis.state = {\n  loginFlag: false\n};\n```\n\n3. 在 `Render` 中判断 `flag`，从而来决定是否进行跳转\n\n```jsx\nif (this.state.loginFlag) {\n  return <Redirect to={{ pathname: \"/\" }} />;\n}\n```\n\n4. 执行 `js` 跳转，通过 `js` 改变 `loginFlag` 的状态，改变以后，就可以从新的 `render` 中通过 `Redirect` 自己进行跳转\n\n### 模块化路由\n\n> router.js\n\n```jsx\nimport Home from \"./components/Home/\";\nimport About from \"./components/About/\";\nimport User from \"./components/User/\";\nimport UserList from \"./User/UserList\";\nimport UserInfo from \"./User/UserInfo\";\n\nlet router = [\n  {\n    path: \"/\",\n    component: Home,\n    exact: true\n  },\n  {\n    path: \"/about\",\n    component: About\n  },\n  {\n    path: \"/User\",\n    component: User,\n    routes: [\n      // 嵌套路由设置\n      {\n        path: \"/user/\",\n        component: UserList\n      },\n      {\n        path: \"/user/info\",\n        component: UserInfo\n      }\n    ]\n  }\n];\nexport default router;\n```\n\n> App.js 入口文件\n\n```jsx\nimport React, { Component } from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nimport router from \"./router.js\";\n\nclass App extends Component {\n  render() {\n    return (\n      <Router>\n        <div>\n          {router.map((route, key) => {\n            if (route.exact) {\n              return (\n                <Route\n                  exact\n                  key={key}\n                  path={route.path}\n                  render={props => (\n                    // 向子组件传递子路由\n                    <route.component {...props} routes={route.routes} />\n                  )}\n                />\n              );\n            } else {\n              return (\n                <Route\n                  key={key}\n                  path={route.path}\n                  render={props => (\n                    // 向子组件传递子路由\n                    <route.component {...props} routes={route.routes} />\n                  )}\n                />\n              );\n            }\n          })}\n        </div>\n      </Router>\n    );\n  }\n}\n```\n\n> User.js\n\n```jsx\nimport React, { Component } from \"react\";\nimport { Route, Link } from \"react-router-dom\";\n\nclass User extends Component {\n  componentWillMount() {\n    console.log(this.props.routes);\n  }\n  render() {\n    return (\n      <div>\n        <div className=\"contenr\">\n          <div className=\"left\">\n            <Link />\n          </div>\n          <div className=\"right\">\n            {this.props.routes.map((route, key) => {\n              return <Route exact key={key} path={route.path} component={route.component} />;\n            })}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\nexport default User;\n```\n\n### 常用路由组件\n\n- _BrowserRouter_：使用 `HTML5` 历史记录 `API` (`pushState`，`replaceState` 和`popstate` 事件)的 `<Router>` 来保持 `UI` 与 `URL` 的同步\n- _HashRouter_：使用 `URL` 的哈希部分(即 `window.location.hash` )的<路由器>可以保持您的 `UI` 与 `URL` 同步。注意：哈希历史记录不支持 `location.key` 或 `location.state`。 在以前的版本中，我们试图缓和行为，但是有一些边缘案例我们无法解决。 任何需要此行为的代码或插件将无法正常工作。 由于此技术仅用于支持旧版浏览器，因此我们建议您将服务器配置为使用`<BrowserHistory>`\n- _Link_：渲染成 `a` 标签\n- _NavLink_：一种特殊版本的 `<Link>`，当与当前 `URL` 匹配时，将向渲染元素添加样式属性。\n- _Redirect_：重定向\n- _Route_：在位置与路线的路径匹配时呈现一些 `UI`。\n- _Switch_：只渲染命中的第一个 `<Route>` 或 `<Redirect>` 。\n\n```jsx\n// Switch的用法\nimport { Switch, Route } from \"react-router\";\n<Switch>\n  <Route exact path=\"/\" component={Home} />\n  <Route path=\"/about\" component={About} />\n  <Route path=\"/:user\" component={User} />\n  <Route component={NoMatch} />\n</Switch>;\n```\n\n## 10. context\n\n- 介绍\n\n> 在一个典型的 `React` 应用中，数据是通过 `props` 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，`UI` 主题），这些属性是应用程序中许多组件都需要的。`Context` 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 `props`。\n\n- 繁琐的 `props` 方式\n\n```jsx\nclass App extends React.Component {\n  render() {\n    return <Toolbar theme=\"dark\" />;\n  }\n}\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemeButton theme={props.theme} />\n    </div>\n  );\n}\nclass ThemeButton extends React.Component {\n  render() {\n    <Button theme={this.props.theme}>按钮</Button>;\n  }\n}\n```\n\n- 使用 `context`\n\n```jsx\n// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。\n// 为当前的 theme 创建一个 context（“light”为默认值）。\nconst ThemeContext = React.createContext(\"light\");\n\nclass App extends React.Component {\n  render() {\n    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n    // 无论多深，任何组件都能读取这个值。\n    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n    return (\n      <ThemeContext.Provider value=\"dark\">\n        <Toolbar />\n      </ThemeContext.Provider>\n    );\n  }\n}\nfunction ToolBar() {\n  return (\n    <div>\n      <ThemeButton />\n    </div>\n  );\n}\nclass ThemeButton extends React.Component {\n  // 指定 contextType 读取当前的 theme context。\n  // React 会往上找到最近的 theme Provider，然后使用它的值。\n  // 在这个例子中，当前的 theme 值为 “dark”。\n  static contextType = ThemeContext;\n  render() {\n    return <Button theme={this.context}>按钮</Button>;\n  }\n}\n```\n\n## 11. react-hooks\n\n> `Hook` 是 `React 16.8` 的新增特性。它可以让你在不编写 `class` 的情况下使用 `state` 以及其他的 `React` 特性。\n\n### 11.1 State Hook\n\n> `useState` 就是一个 `Hook`，类似 `class` 组件的 `this.setState`，但是它不会把新的 `state` 和旧的 `state` 进行合并。`useState` 会返回一对值：_当前状态_ 和一个让你 _更新它的函数_，你可以在事件处理函数中或其他一些地方调用这个函数。\n\n- 计数器\n\n```jsx\nimport React, { useState } from \"react\";\n\nfunction Example() {\n  // 声明一个叫 “count” 的 state 变量。\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n\n// 等价的 class 示例\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Click me</button>\n      </div>\n    );\n  }\n}\n```\n\n- 声明多个 `state` 变量\n\n```jsx\nfunction ExampleWithManyStates() {\n  // 声明多个 state 变量！\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState(\"banana\");\n  const [todos, setTodos] = useState([{ text: \"Learn Hooks\" }]);\n  // ...\n}\n```\n\n- 什么是 `Hook`\n\n> `Hook` 是一些可以让你在函数组件里“钩入” `React state` 及生命周期等特性的函数。`Hook` 不能在 `class` 组件中使用 —— 这使得你不使用 `class` 也能使用 `React`。\n\n- 惰性 state\n\n```jsx\nconst [state, setState] = useState(() => {\n  const initialState = someExpensiveComputation(props);\n  return initialState;\n});\n```\n\n### 11.2 Effect Hook\n\n> `Effect Hook` 可以让你在函数组件中执行副作用操作\n\n#### (1) 无需清除的 `Effect`\n\n> 有时候，我们只想在 `React` 更新 `DOM` 之后运行一些额外的代码。比如发送网络请求，手动变更 `DOM`，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。\n\n- 使用 `class` 的示例\n\n```jsx\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Click me</button>\n      </div>\n    );\n  }\n}\n```\n\n- 使用 `Hook` 的示例\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n```\n\n> `useEffect` 做了什么？ 通过使用这个 `Hook`，你可以告诉 `React` 组件需要在渲染后执行某些操作。`React` 会保存你传递的函数（我们将它称之为 “`effect`”），并且在执行 `DOM` 更新之后调用它。在这个 `effect` 中，我们设置了 `document` 的 `title` 属性，不过我们也可以执行数据获取或调用其他命令式的 API。\n\n> 为什么在组件内部调用 `useEffect`？ 将 `useEffect` 放在组件内部让我们可以在 `effect` 中直接访问 `count` `state` 变量（或其他 `props`）。我们不需要特殊的 `API` 来读取它 —— 它已经保存在函数作用域中。`Hook` 使用了 `JavaScript` 的闭包机制，而不用在 `JavaScript` 已经提供了解决方案的情况下，还引入特定的 React API。\n\n> `useEffect` 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 `effect` 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。`React` 保证了每次运行 `effect` 的同时，`DOM` 都已经更新完毕。\n\n{% note warning, 与 `componentDidMount` 或 `componentDidUpdate` 不同，使用 `useEffect` 调度的 `effect` 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，`effect` 不需要同步地执行。在个别情况下（例如测量布局），有单独的 `useLayoutEffect Hook` 供你使用，其 `API` 与 `useEffect` 相同。 %}\n\n#### (2) 需要清除的 `Effect`\n\n> 之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！现在让我们来比较一下如何用 `Class` 和 `Hook` 来实现。\n\n- 使用 `class` 的示例\n\n```jsx\nclass FriendStatus extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(this.props.friend.id, this.handleStatusChange);\n  }\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(this.props.friend.id, this.handleStatusChange);\n  }\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n\n  render() {\n    if (this.state.isOnline === null) {\n      return \"Loading...\";\n    }\n    return this.state.isOnline ? \"Online\" : \"Offline\";\n  }\n}\n```\n\n- 使用 `Hook` 的示例\n\n{% note warning, 眼尖的读者可能已经注意到了，这个示例还需要编写 componentDidUpdate 方法才能保证完全正确。我们先暂时忽略这一点，本章节中后续部分会介绍它。 %}\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // Specify how to clean up after this effect:\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return \"Loading...\";\n  }\n  return isOnline ? \"Online\" : \"Offline\";\n}\n```\n\n> 为什么要在 `effect` 中返回一个函数？ 这是 `effect` 可选的清除机制。每个 `effect` 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 `effect` 的一部分。\n\n> `React` 何时清除 `effect`？ `React` 会在组件卸载的时候执行清除操作。正如之前学到的，`effect` 在每次渲染的时候都会执行。这就是为什么 `React` 会在执行当前 `effect` 之前对上一个 `effect` 进行清除。我们稍后将讨论为什么这将助于避免 `bug` 以及如何在遇到性能问题时跳过此行为。\n\n{% note warning, 并不是必须为 `effect` 中返回的函数命名。这里我们将其命名为 `cleanup` 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。 %}\n\n### 11.3 Hook 规则\n\n#### (1) 只在最顶层使用 `Hook`\n\n> 不要在循环，条件或嵌套函数中调用 `Hook`， 确保总是在你的 `React` 函数的最顶层调用他们。遵守这条规则，你就能确保 `Hook` 在每一次渲染中都按照同样的顺序被调用。这让 `React` 能够在多次的 `useState` 和 `useEffect` 调用之间保持 `hook` 状态的正确。\n\n#### (2) 只在 `React` 函数中调用 `Hook`\n\n> 不要在普通的 `JavaScript` 函数中调用 `Hook`。你可以：\n\n- ✅ 在 `React` 的函数组件中调用 `Hook`\n- ✅ 在自定义 `Hook` 中调用其他 `Hook`\n\n### 11.4 自定义 Hook\n\n> 通过自定义 `Hook`，可以将组件逻辑提取到可重用的函数中。\n\n#### (1) 提取自定义 `Hook`\n\n> 当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 `Hook` 都是函数，所以也同样适用这种方式。\n\n> 自定义 `Hook` 是一个函数，其名称以 “`use`” 开头，函数内部可以调用其他的 `Hook`。 例如，下面的 `useFriendStatus` 是我们第一个自定义的 `Hook`:\n\n```jsx\nimport { useState, useEffect } from \"react\";\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}\n```\n\n#### (2) 使用自定义 `Hook`\n\n```jsx\nfunction FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return \"Loading...\";\n  }\n  return isOnline ? \"Online\" : \"Offline\";\n}\n\nfunction FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  return <li style={{ color: isOnline ? \"green\" : \"black\" }}>{props.friend.name}</li>;\n}\n```\n\n### 11.5 Hook API 索引\n\n> 参见 [Hook API](https://react.docschina.org/docs/hooks-reference.html)\n\n#### 11.5.1 基础 Hook\n\n##### useState\n\n> [点击跳转](#linkUseState)\n\n##### useEffect\n\n> [点击跳转](#linkUseEffect)\n\n##### useContext\n\n> 订阅 `context` 的变化，感觉就是对于获取 `context` 的值换了一种写法而已。相对于之前的写法，在函数组件中添加 `context` 更加简单。\n\n```jsx\nconst context = React.createContext({})\nconst { Provider, Consumer  } = context;\n\n// hooks的写法\nclass App extends React.Component {\n    return (\n        <Provider value={{ name: 'li' }}>\n            <Hello/>\n        </Provider>\n    </div>\n}\nfunction Hello () {\n    const value = useContext(context);\n    return <h1>value: {value.name}</h1>\n}\n\n// 原本的写法\nfunction Hello (props) {\n    function render ({name}) {\n      return <h1>value: {value.name}</h1>\n    }\n    return (\n      <Consumer>\n        {render}\n      </Consumer>\n    )\n}\n```\n\n#### 11.5.2 额外的 Hook\n\n##### useReducer\n\n> 类似于 `redux` 那样的状态更新方案。使用场景（基本上就是 `redux` 的应用场景），管理的状态值是对象，并且键值较多。`state` 每个 `key` 修改的逻辑比较复杂，需要单独放到一个文件里面管理。\n\n```jsx\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"increment\":\n      return { count: state.count + 1 };\n    case \"decrement\":\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: \"increment\" })}>+</button>\n      <button onClick={() => dispatch({ type: \"decrement\" })}>-</button>\n    </>\n  );\n}\n```\n\n##### useCallback\n\n> 仅在指定的依赖项发生变化时，会返回一个新的函数引用，函数体并没有发生变化。\n\n```jsx\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n```\n\n> 这样使用的好处：不会在每次组件 `render` 的时候，重新生成一个函数，节省开销。例如\n\n```jsx\nfunction f() {\n  const cacheCallback = useCallback(() => {\n    doSomething(a, b);\n  }, [a, b]);\n  // 和下面这样的形式相比, 每次组件渲染的时候，都会重新创建一个 doSometing 函数\n  function doSometing(a, b) {}\n}\n```\n\n> 可以保持函数的引用保持不变。我们都知道在类组件，事件处理函数基本上都是通过 `this.method` 的方式绑定的，这样做的方式有一个好处，对方法的引用一直保持不变。 那么在函数组件就可以通过使用 `useCallback` 来实现。\n\n> 可以实现在子组件把该回调作为依赖处理。\n\n```jsx\nfunction Parent({ a, b }) {\n  const cacheCallback = useCallback(() => {\n    doSometing(a, b);\n  }, [a, b]);\n  return <Child handler={cacheCallback} />;\n}\n\nfunction Child({ handler }) {\n  useEffect(() => {\n    handler();\n  }, [handler]);\n}\n```\n\n##### useMemo\n\n> 类似于 `vue` 的 `computed`，在依赖发生变化的时候重新计算缓存值。其实自己实现起来也很容易，和 `vue` 的计算属性不同的是，`vue` 的计算属性是自动收集依赖的，而使用 `useMeno` 需要手动在数组种传入依赖项。\n\n```jsx\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n```\n\n> `useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`\n\n##### useRef\n\n> 故名思义，该 `hook` 主要是用来获取组件实例或者或者 `dom` 节点。 但是它更有用的地方，是可以返回一个在组件生命周期内，引用不变的对象。\n\n```jsx\nfunction f() {\n  const elRef = uesRef(null);\n  return <div ref={elRef}></div>;\n}\n```\n\n> 用来存储数据的话，考虑下面的场景。\n\n```jsx\nlet handler = () => {}; // 事件处理函数\n// 不使用 useRef, 可以使用函数外部的一个变量来存储数据\nfunction f() {\n  useEffect(() => {\n    window.addEventListener(\"scroll\", handler);\n  }, []);\n\n  const moveScroll = useCallback(() => {\n    window.removeEventListener(\"scorll\", handler);\n  }, []);\n\n  return (\n    <div onClick={moveScroll} ref={elRef}>\n      移除scroll监听\n    </div>\n  );\n}\n\n// 使用useRef的版本，可以使代码更加内聚。但是前提是必须要理解useRef这个hooks。\nfunction f() {\n  const handler = useRef(null);\n  handler.current = () => {}; // 事件处理\n\n  useEffect(() => {\n    window.addEventListener(\"scroll\", handler.current);\n  }, []);\n\n  const moveScroll = useCallback(() => {\n    window.removeEventListener(\"scorll\", handler.current);\n  }, []);\n\n  return (\n    <div onClick={moveScroll} ref={elRef}>\n      移除scroll监听\n    </div>\n  );\n}\n```\n\n##### useImperativeHandle\n\n> `useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。\n\n```jsx\nconst Fancy = React.forwardRef((props, ref) => {\n  return (\n    <div>\n      <input type=\"text\" ref={ref} />\n    </div>\n  );\n});\n\nfunction Hello() {\n  const ref = useRef(null);\n\n  useEffect(() => {\n    console.log(\"current\", ref); // { current: Input }\n  }, []);\n\n  return <Fancy ref={ref} />;\n}\n```\n\n##### useLayoutEffect\n\n> 函数签名和 `useEffect` 是一样的， 可以使用它来读取 `DOM` 布局并 `同步` 触发重渲染。\n\n##### useDebugValue\n\n> 用来给 `hooks` 添加上打印信息。\n","source":"_posts/前端/React16 文档.md","raw":"---\ntitle: React16 文档\ndate: 2020-08-15\ncategories: [前端, react]\ntags:\n  - 文档\n---\n\n## 1. React 中的核心概念\n\n### 虚拟 DOM\n\n1. DOM 的本质是什么？\n\n> 浏览器中的概念，用`js`对象来表示页面上的元素，并提供了操作 `DOM` 对象的 API；\n\n2. 什么是 React 中的 虚拟 DOM？（ 虚拟 DOM 的本质）：\n\n> 用`js`对象来模拟 页面上的`DOM和DOM嵌套`\n\n3. 为什么要实现 虚拟 DOM ？（ 虚拟 DOM 的目的）：\n\n> 为了实现页面中，`DOM`元素的高效更新\n\n4. DOM 和 虚拟 DOM 的区别：\n\n- `DOM`：浏览器中，提供的概念；用`js`对象，表示页面上的元素，并提供了操作元素的 `API`；\n- `虚拟DOM`：是框架中的概念；是开发框架的人员，手动用`js`对象来模拟`DOM`元素和嵌套关系；\n\n5. DOM 树的概念：\n\n> 一个网页的呈现过程：\n>\n> 1. 浏览器请求服务器获取页面的 `html` 代码；\n> 2. 浏览器要先在内存中，解析 `DOM` 结构，并在浏览器内存中，渲染出一棵 `DOM` 树；\n> 3. 浏览器把 `DOM` 树，呈现到页面上；\n\n### Diff 算法\n\n1. tree diff：\n\n> 新旧两棵 `DOM` 树，逐层对比的过程，就是`tree diff`；\n> 当整棵`DOM`逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到；\n\n2. component diff：\n\n> 在进行 `tree diff` 的时候，每一层中，组件级别的对比，叫做 `component diff`；\n> 如果对比前后，组件的类型相同，则**暂时**认为此组件不许要被更新；\n> 如果对比前后，组件的类型不同，则需要移除旧组件，创建新组件，并追加到页面上；\n\n3. element diff：\n\n> 在进行组件对比的时候，如果两个组件的类型相同，则需要进行元素级别的对比，这叫做`element diff`；\n\n## 2. React 中创建组件\n\n### 使用构造函数来创建组件\n\n> 1、在组件中，必须要向外`return`一个合法的`jsx`创建的`虚拟DOM`元素；\n> 2、如果要接收外界传递的数据，需要在`构造函数`的参数列表中使用`props`来接收；\n> 3、无论是`vue`还是`react`，组件中的`props`永远都是只读`read-only`的，不能被重新赋值；\n> 4、组件的名称`首字母`必须是`大写`的\n> 5、省略 `.jsx` 文件名\n\n> 打开 `webpack.config.js`，并在导出的配置对象中，新增以下几个节点：\n\n```javascript\nresolve: {\n  extensions: [\".js\", \".jsx\", \".json\"];\n}\n```\n\n> 如果在一个组件中 `return` 一个 `null`，则表示此组件是空的，什么都不会渲染\n\n```jsx\nfunction Hello(props) {\n  return (\n    <div>\n      这是Hello组件 -- {props.name} -- {props.age} -- {props.gender}\n    </div>\n  );\n}\n\nconst user = {\n  name: \"大黄\",\n  age: 3,\n  gender: \"雄性\"\n};\n\nReactDOM.render(\n  <div>\n    <Hello {...user} />\n  </div>,\n  document.getElementById(\"#app\")\n);\n```\n\n### 使用 class 关键字来创建组件\n\n> `public`: 所有成员都可访问\n> `private`: 只有当前类可访问\n> `protected`: 只有当前类和其子类可访问，外部成员无法访问\n\n> `es6`中的`class关键字`，是实现`面向对象编程`的新形式，也叫做`语法糖`\n\n- constructor 构造器中的 super 函数\n\n> 在子类中， `this` 只能放到 `super` 之后使用\n> 子类中的 `super`，其实就是父类中，`contructor`构造器的一个引用\n\n- 最基本的组件结构\n\n> `render`函数的作用：渲染当前组件所对应的`虚拟DOM` 元素\n\n```jsx\nimport React from \"react\";\nclass 组件名称 extends React.Component {\n  render() {\n    return <div>这是 class 创建的组件</div>;\n  }\n}\n```\n\n- this.props 和 this.state\n\n> 1. `this.props` 接收外界传递的参数，`this.state` 设置私有数据\n> 2. 在 `class` 关键字创建的组件中，直接使用 `this.props` 访问传递过来的数据\n> 3. `props` 是只读的\n\n```jsx\nclass Movie extends React.Component {\n  constructor() {\n    super();\n    // 这里的 this.state = {}，就相当于 Vue中的data() { return {} }\n    this.state = {\n      msg: \"这是Movie组件的私有数据\"\n    };\n  }\n  render() {\n    {\n      /* 注意：在 class 组件内容，this 表示当前组件的实例对象 */\n    }\n    return <div>这是Movie组件 -- {this.props.name}</div>;\n  }\n}\nconst user = {\n  name: \"大黄\",\n  age: 3,\n  gender: \"雄性\"\n};\n\nReactDOM.render(\n  <div>\n    <Movie {...user} />\n    <h3>{this.state.msg}</h3>\n  </div>,\n  document.getElementById(\"#app\")\n);\n```\n\n### 两种创建组件的方式的对比\n\n> 使用 `class` 关键字创建的组件，有自己的 `私有数据(this.state)` 和 `生命周期`\n> 使用 `function` 创建的组件，只有 `props`，没有自己的 `私有数据` 和 `生命周期`\n> 有状态组件和无状态组件之间的 `本质区别`：有无 `state` 属性和 `生命周期函数`\n\n## 3. React 中 style 处理方式\n\n### 内联\n\n```jsx\nstyle = {{ color: red }}\n```\n\n### css\n\n> 1、如果直接导入 `css` 样式表，默认则是在全局上，整个项目都会生效\n> 2、css 模块化，只针对 `class` 选择器 和 `id` 选择器生效\n> 引用：`import style from './style.css'`\n\n## 4. React 中事件绑定\n\n1. 事件的名称都是 `React` 所提供的，因此名称的首字母必须大写`onClick`，`onMouseOver`\n2. 为事件提供的处理函数，必须是以下格式：\n\n```javascript\nonClick = { function };\n```\n\n3. 用的最多的事件绑定形式为：\n\n```jsx\n<button onClick={() => this.show(\"传参\")}>按钮</button>;\n\n// 事件的处理函数，需要定义为 一个箭头函数，然后赋值给 函数名称\nshow = arg1 => {\n  console.log(\"show方法\" + arg1);\n};\n```\n\n4. 在 `React` 中，如果想要修改 `state` 中的数据，推荐使用 `this.setState({ })`\n\n> 1、在`setState`中，只会把对应的 `state`状态更新，而不会覆盖其它的 `state`状态。\n> 2、`this.setState` 方法的执行时 `异步的`。\n> 3、如果在调用完 `this.setState`之后，又想立即拿到最新的`state`的值，需要使用 `this.setState({}, callback)`，第二个参数【回调函数】中获取。\n\n## 5. 单向数据流(状态变化 => 自动更新页面)\n\n> 1、`React` 中，默认是 `单向数据流`，只能把 `state` 上的数据绑定到页面，无法把页面中数据的变化，自动同步回 `state`；如果需要把页面上数据的变化，保存到 `state`，需要手动监听`onChange` 事件，拿到最新的数据，手动调用 `this.setState({ })` 更改。\n> 2、当为文本框绑定 `value` 值以后，要么同时给标签提供一个 `readOnly` 属性，要么提供一个 `onChange` 事件处理函数。\n\n```jsx\n// 方案一：通过事件参数 e 来获取DOM元素的引用\n<input type=\"text\" value={this.state.msg} onChange={e => this.textChanged(e)} />;\n\ntextChanged = e => {\n  console.log(e.target.value);\n};\n\n// 方案二：通过ref 来获取DOM元素的引用  this.refs.引用名称\n<input type=\"text\" value={this.state.msg} onChange={() => this.textChanged()} ref=\"txt\" />;\n\ntextChanged = () => {\n  console.log(this.refs.txt.value);\n};\n```\n\n## 6. 生命周期\n\n- 生命周期介绍\n\n> 每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会触发一系列事件，这些事件就叫做组件的生命周期\n\n- React 的生命周期分为三个部分\n\n1. 组件创建阶段\n\n> 只执行一次\n\n> 1. `componentWillMount` => `挂载之前`\n> 2. `render` => `正在渲染，虚拟DOM创建到了内存中，还未挂载到页面上`\n> 3. `componentDidMount` => `挂载结束，需要操作DOM节点的初始化操作放在这里`\n\n2. 组件运行阶段：\n\n> 根据 `props` 属性或者 `state` 状态的改变，有选择性的执行 `0` 到 `多次`\n\n> 1. `props` 改变之后\n> 2. `componentWillReceiveProps` => 当一个挂载的组件接收到新的 `props` 的时候被调用\n> 3. `state` 改变之后\n> 4. `shouldComponentUpdate（nextprops, nextState）` => 当组件做出是否要更新 `DOM` 的决定的时候被调用，在改变状态的时候可以选择通过( `return true` )或者不通过( `return false`)\n> 5. `componentWillUpdate` => 在更新发生之前被调用\n> 6. `render` => 数据是新的，页面是旧的\n>\n> 7.`componentDidUpdate` => 数据是新的，页面已经变成了最新的\n\n3. 组件销毁阶段\n\n> 只执行一次\n\n> `componentWillUnmount` => 组件移除或者销毁的时候被调用\n\n## 7. 验证数据类型\n\n```javascript\nimport { ProtoTypes } from \"prop-types\";\n\n// 定义组件需要传入的参数\nMyCompo.protoTypes = {\n  a: ProtoTypes.string.isRequired,\n  b: ProtoTypes.string.isRequired,\n  c: ProtoTypes.number.isRequired\n};\n```\n\n## 8. flux\n\n### 简介\n\n> 传统的 `MVC` 和 `MVVM` 架构设计模式有一个致命的缺点：当项目越来越大、逻辑越来越复杂的时候，数据流动就越显得混乱。\n\n> `Flux` 是致力于解决数据有序传输问题的架构设计模式，来自 `Facebook`。`Flux` 中最大的哲学：数据是 `单向流动` 的。\n\n> [官方手册](https://github.com/facebook/flux/tree/master/examples/flux-concepts)\n\n> `Flux` 中最重要的四个概念：`Dispatcher`、`Store`、`View`、`Action`。\n\n![flux.png](https://cdn.nlark.com/yuque/0/2020/png/732231/1608703835856-e1263bac-124a-40da-ae3c-b45a4c8081ae.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&name=flux.png&originHeight=393&originWidth=1300&size=26132&status=done&style=none&width=1300)\n\n### 基本概念\n\n1. 概述\n   - `flux` 是一个管理 `App` 中数据流动的模式。\n   - 最关键的概念：`数据的流动是单向的`。\n2. Dispatcher 调度者\n   - `Dispatcher` 接受 `action`，并且要把这些 `action` 分派给已经注册到 `Dispatcher` 的 `store` 上\n   - 所有的 `store` 都将接收所有的 `action`\n   - 在每个 `App` 中，应该确保只有一个 `Dispatcher` 的实例\n3. store 仓库\n   - `store` 是在 `App` 中持有数据的仓库\n   - 所有的 `store` 要在 `App` 的 `Dispatcher` 上注册，确保它们可以接收 `action`\n   - `store` 中的数据只能被 `action` 改变。\n   - `store` 中不能够有公共的 `setter`，只能有 `getter`\n   - `store` 决定了它们愿意响应哪些 `actions`\n   - 无论何时，`store` 中的数据发生改变，就会触发一个 `change` 事件\n   - 同一个 `App` 中可能有很多 `store`\n4. Action 行为\n   - `Action` 定义了 `App` 内部的 `API`\n   - 它们捕获所有可能改变 `App` 的途径和方法\n   - 它们是简单的`对象`，并且要有 `type属性` 和 `其他的一些数据属性`\n   - `Action` 应该有一个具有语义的、直观的表示它是做什么的名字\n   - 所有的`store`都将接收同一个`action`，并且通过这个 `action`，`store` 会知道它们要清除、更新哪些数据\n5. Views 视图\n   - `store` 中的数据被展示在了`view`上\n   - `View` 层可以使用任何框架\n   - 当一个视图想要获取 `store` 中的数据，它必须 `subscribe 订阅` 一下该 `store` 的`change` 事件\n   - 当 `store` 触发了 `change` 事件，此时 `view` 就能得到新的数据并且重新渲染\n   - 如果一个组件要使用 `store`，但是没有订阅这个 `store`，此时就会出错\n   - `Action` 最常见的产生原因是：在 `App` 中的某一个部分，因为用户的交互行为，而被此`view` `dispatch`出来了\n\n### redux\n\n- 简介\n  - [官网](https://redux.js.org/)\n  - Redux 就是 Flux 思想在 React 中的实现\n  - Redux 是一个可预测状态的 Js app 容器\n  - [`通过例子来学习redux`](https://github.com/reactjs/redux/tree/master/examples)\n- Redux 创建的步骤\n  - 设置一个 `reducer`；\n  - 创建一个`store`，`Redux.createStore(reducer)`\n  - 创建 `render` 函数\n  - 注册 `render`，`store.subscribe(render)`\n  - 监听，此时要记得 `store.dispatch(action)`，不是直接修改`store`\n\n### React-Redux\n\n- 简介\n  - 将 `react` 和 `redux` 合并起来，可以让任何组件在任何地方看见 `store`\n  - [官方文档](https://github.com/reactjs/react-redux/tree/master/docs)\n  - `React-Redux` 给我们提供了：`Provider组件`，`connect函数`\n- Provider 组件\n\n> 1、使用 `react-redux` 提供的 `Provider` 组件传递 `store` 上下文之后，`包裹在其中的所有组件` 全都可以识别这个上下文\n\n> 2、在 `Provider` 组件内部的自定义组件可以使用 `connect()` 函数，但是在其外部的不可使用\n\n- connect 函数\n\n> 1、将 `React组件` 和 `Redux` 的 `store` 进行连接\n> 2、`connect` 提供了一个很方便的 `API` 能够适应绝大多数工作\n> 3、它没有更改你传进来的类，反而会返回一个已经连接好的新类\n> 4、提供了两个参数：`mapStateToProps`, `mapDispatchToProps`\n\n- mapStateToProps\n\n> 1、如果传入`mapStateToProps`，此时这个组件将订阅 `Redux` 中 `store` 的更新信息；\n> 2、这意味着无论任何时候 `store` 被更改了，`mapStateToProps` 函数都将会被调用，`mapStateToProps` 的返回值必须是一个 `Object`；\n> 3、这个 `Object` 将与组件的 `props` 融合，也就是说，这个返回的 `Object` 中的 `key` 将自动成为组件的 `props` 中的成员\n> 4、如果不想订阅 `store` 的更新，此时可以不传递这个参数，采用 `null` 占位\n\n- mapDispatchToProps\n\n> 如果向 `connect` 函数中传入了第二个参数，并且是一个 `函数`，那么这个函数将获得`dispatch` 方法，该方法可以通过 `emit action`，间接的导致 `state` 的改变\n> 可以使用 `bindActionCreators()` 方法轻松的将 `Action creator`(返回 `action` 的函数)接口和 `dispatch` 进行绑定\n\n- 书写规则\n\n> index.js\n\n```jsx\nimport React from \"react\";\nimport { render } from \"react-dom\";\nimport { createStore } from \"redux\";\nimport { Provider } from \"react-redux\";\nimport App from \"./containers/App\";\nimport reducer from \"./reducers\";\n\nconst store = createStore(reducer);\nrender(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById(\"root\")\n);\n```\n\n> App.js\n\n```jsx\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport * as actions from \"./actions\";\n\nclass App extends React.Component {\n  constructor(props) {\n    super();\n    console.log(props);\n    // props: { r: 0, g: 0, b: 0, actions: 许多方法 }\n  }\n  render() {\n    return <div>这是App组件</div>;\n  }\n}\nconst mapStateToProps = state => {\n  return {\n    r: state.r,\n    g: state.g,\n    b: state.b\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    actions: bindActionCreators(actions, dispatch)\n  };\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n```\n\n> reducer.js\n\n```jsx\nexport default (state, action) => {\n  if (state == undefined) {\n    state = { r: 0, g: 0, b: 0 };\n  }\n  if (action.type == \"ADD\") {\n    return {\n      ...state,\n      r: state.r + 1\n    };\n  }\n  return state;\n};\n```\n\n> actions.js\n\n```jsx\nexport const ADD = () => { \"type\": \"ADD\" }\n```\n\n### 组件内部的 state 和全局的 state\n\n> 组件的数据三兄弟：`state`, `props`, `context` 不管是谁发生改变，都会引发 `render()` 执行，视图会被重绘。但是，构造函数不会被重新执行。所以不管基于什么理由，都不需要将全局的状态，用自己组件的 `state` 接收，而仅需要用`connect`连接一下全局`store`，然后使用`this.props.**`即可。\n\n### reducer 模块化\n\n```javascript\nimport { combineReducers } from \"redux\";\nimport todoReducers from \"./todoReducer.js\"; // 标准reducer\n\nexport default combineReducers({\n  todoReducers\n});\n```\n\n### redux-logger\n\n> 打印 redux log\n\n```javascript\nimport { createStore, applyMiddleware } from \"redux\";\nimport { createLogger } from \"redux-logger\";\nimport reducer from \"./reducers/index.js\";\nlet store = createStore(reducer, applyMiddleware(createLogger()));\n```\n\n### redux-thunk\n\n> 解决异步问题\n\n> `redux-thunk`帮助我们在所有的组件的 `props` 中添加了一个 `dispatch` 方法。\n\n> 当然，这个组件一定要被 `connect` 函数进行处理\n\n> 注意，如果使用 `thunk`，则 `connect` 函数不能传入第二个参数，否则会导致无法获取 `this.props.dispatch()`\n\n```javascript\n// 入口文件\nimport { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nlet store = createStore(reducer, applyMiddleware(thunk))\n\n/** 组件中 */\n/** 第一种写法，并没有将actions进行抽离 */\n$.get('/shu.txt', data => {\n    var number = Number(data);\n    this.props.dispatch({\n        \"type\": \"ADD\",\n        number\n    })\n})\n/** 第二种写法:常用 */\n// 可枚举\nimport * as actions from './actions/actions.js'\n\nclass ** extends React.Component {\n    ...\n    add() {\n        this.props.dispatch(actions.add())\n        this.props.dispatch(actions.minus())\n    }\n    ...\n}\n/** 现在，一般不会再写第二个参数了，就是说省略掉mapDispatchToProps */\nexport default connect(\n (state) => {\n    return {\n        state: state\n    }\n })(**)\n// actions.js\n/* 现在，异步的Action Creator不要直接返回 Action，而是返回一个携带 dispatch 的函数；这个函数相当于“延长”了dispatch的持续时间。*/\nexport const add = () => (dispatch, getState) => {\n    console.log(getState()) // getState可以获取全局数据\n    $.get('/shu.txt', data => {\n        var number = Number(data);\n        dispatch({\"type\": \"MINUS\", number})\n    })\n}\nexport const minus = () => { \"type\": \"MINUS\" }\n// reducer.js\nexport default (state = 0, action) => {\n    switch(action.type) {\n        case \"ADD\":\n            return state + action.number\n        case \"MINUS\":\n            return state - 1\n    }\n    return state;\n}\n```\n\n## 9. react-router4.x\n\n### 介绍\n\n- [官网](https://reacttraining.com/react-router)\n- 安装：`npm install react-router-dom`\n\n### demo\n\n> `exact`表示严格匹配，如果路径为 `path=\"/\"` 的 `Route` 不设置该属性，则会自动向下匹配路由，即都会显示出来\n\n```jsx\nimport React from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\n\nfunction Index() {\n  return <h2>Home</h2>;\n}\n\nfunction About() {\n  return <h2>About</h2>;\n}\n\nfunction Users() {\n  return <h2>Users</h2>;\n}\n\nfunction AppRouter() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <ul>\n            <li>\n              <Link to=\"/\">Home</Link>\n            </li>\n            <li>\n              <Link to=\"/about/\">About</Link>\n            </li>\n            <li>\n              <Link to=\"/users/\">Users</Link>\n            </li>\n          </ul>\n        </nav>\n\n        <Route path=\"/\" exact component={Index} />\n        <Route path=\"/about/\" component={About} />\n        <Route path=\"/users/\" component={Users} />\n      </div>\n    </Router>\n  );\n}\nexport default AppRouter;\n```\n\n### 动态路由\n\n```jsx\n// App.js 定义动态路由\n<Route path=\"/content/:aid\"></Route>\n// news.js 跳转\n<Link to={`/content/${value.aid}`}></Link>\n// Content.js 跳在生命周期函数中获取动态路由参数\nclass Content extends Component {\n    /* ... */\n      componentDidMount() {\n          const { match } = this.props\n          // 获取到传递的动态路由参数\n          console.log(match.params.aid)\n      }\n    /* ... */\n}\n```\n\n### get 传值\n\n```jsx\n// App.js 定义动态路由\n<Route path=\"/content\"></Route>\n// news.js 跳转\n<Link to={`/content?aid=${value.aid}`}></Link>\n// Content.js 跳在生命周期函数中获取动态路由参数\nclass Content extends Component {\n    ...\n      componentDidMount() {\n          const { location } = this.props\n          // 获取到传递的动态路由参数\n          console.log(location.search)\n      }\n    ...\n}\n```\n\n### js 控制跳转\n\n1. 引入 `Redirect` 组件\n2. 定义一个 `flag`\n\n```javascript\nthis.state = {\n  loginFlag: false\n};\n```\n\n3. 在 `Render` 中判断 `flag`，从而来决定是否进行跳转\n\n```jsx\nif (this.state.loginFlag) {\n  return <Redirect to={{ pathname: \"/\" }} />;\n}\n```\n\n4. 执行 `js` 跳转，通过 `js` 改变 `loginFlag` 的状态，改变以后，就可以从新的 `render` 中通过 `Redirect` 自己进行跳转\n\n### 模块化路由\n\n> router.js\n\n```jsx\nimport Home from \"./components/Home/\";\nimport About from \"./components/About/\";\nimport User from \"./components/User/\";\nimport UserList from \"./User/UserList\";\nimport UserInfo from \"./User/UserInfo\";\n\nlet router = [\n  {\n    path: \"/\",\n    component: Home,\n    exact: true\n  },\n  {\n    path: \"/about\",\n    component: About\n  },\n  {\n    path: \"/User\",\n    component: User,\n    routes: [\n      // 嵌套路由设置\n      {\n        path: \"/user/\",\n        component: UserList\n      },\n      {\n        path: \"/user/info\",\n        component: UserInfo\n      }\n    ]\n  }\n];\nexport default router;\n```\n\n> App.js 入口文件\n\n```jsx\nimport React, { Component } from \"react\";\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\nimport router from \"./router.js\";\n\nclass App extends Component {\n  render() {\n    return (\n      <Router>\n        <div>\n          {router.map((route, key) => {\n            if (route.exact) {\n              return (\n                <Route\n                  exact\n                  key={key}\n                  path={route.path}\n                  render={props => (\n                    // 向子组件传递子路由\n                    <route.component {...props} routes={route.routes} />\n                  )}\n                />\n              );\n            } else {\n              return (\n                <Route\n                  key={key}\n                  path={route.path}\n                  render={props => (\n                    // 向子组件传递子路由\n                    <route.component {...props} routes={route.routes} />\n                  )}\n                />\n              );\n            }\n          })}\n        </div>\n      </Router>\n    );\n  }\n}\n```\n\n> User.js\n\n```jsx\nimport React, { Component } from \"react\";\nimport { Route, Link } from \"react-router-dom\";\n\nclass User extends Component {\n  componentWillMount() {\n    console.log(this.props.routes);\n  }\n  render() {\n    return (\n      <div>\n        <div className=\"contenr\">\n          <div className=\"left\">\n            <Link />\n          </div>\n          <div className=\"right\">\n            {this.props.routes.map((route, key) => {\n              return <Route exact key={key} path={route.path} component={route.component} />;\n            })}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\nexport default User;\n```\n\n### 常用路由组件\n\n- _BrowserRouter_：使用 `HTML5` 历史记录 `API` (`pushState`，`replaceState` 和`popstate` 事件)的 `<Router>` 来保持 `UI` 与 `URL` 的同步\n- _HashRouter_：使用 `URL` 的哈希部分(即 `window.location.hash` )的<路由器>可以保持您的 `UI` 与 `URL` 同步。注意：哈希历史记录不支持 `location.key` 或 `location.state`。 在以前的版本中，我们试图缓和行为，但是有一些边缘案例我们无法解决。 任何需要此行为的代码或插件将无法正常工作。 由于此技术仅用于支持旧版浏览器，因此我们建议您将服务器配置为使用`<BrowserHistory>`\n- _Link_：渲染成 `a` 标签\n- _NavLink_：一种特殊版本的 `<Link>`，当与当前 `URL` 匹配时，将向渲染元素添加样式属性。\n- _Redirect_：重定向\n- _Route_：在位置与路线的路径匹配时呈现一些 `UI`。\n- _Switch_：只渲染命中的第一个 `<Route>` 或 `<Redirect>` 。\n\n```jsx\n// Switch的用法\nimport { Switch, Route } from \"react-router\";\n<Switch>\n  <Route exact path=\"/\" component={Home} />\n  <Route path=\"/about\" component={About} />\n  <Route path=\"/:user\" component={User} />\n  <Route component={NoMatch} />\n</Switch>;\n```\n\n## 10. context\n\n- 介绍\n\n> 在一个典型的 `React` 应用中，数据是通过 `props` 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，`UI` 主题），这些属性是应用程序中许多组件都需要的。`Context` 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 `props`。\n\n- 繁琐的 `props` 方式\n\n```jsx\nclass App extends React.Component {\n  render() {\n    return <Toolbar theme=\"dark\" />;\n  }\n}\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemeButton theme={props.theme} />\n    </div>\n  );\n}\nclass ThemeButton extends React.Component {\n  render() {\n    <Button theme={this.props.theme}>按钮</Button>;\n  }\n}\n```\n\n- 使用 `context`\n\n```jsx\n// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。\n// 为当前的 theme 创建一个 context（“light”为默认值）。\nconst ThemeContext = React.createContext(\"light\");\n\nclass App extends React.Component {\n  render() {\n    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。\n    // 无论多深，任何组件都能读取这个值。\n    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。\n    return (\n      <ThemeContext.Provider value=\"dark\">\n        <Toolbar />\n      </ThemeContext.Provider>\n    );\n  }\n}\nfunction ToolBar() {\n  return (\n    <div>\n      <ThemeButton />\n    </div>\n  );\n}\nclass ThemeButton extends React.Component {\n  // 指定 contextType 读取当前的 theme context。\n  // React 会往上找到最近的 theme Provider，然后使用它的值。\n  // 在这个例子中，当前的 theme 值为 “dark”。\n  static contextType = ThemeContext;\n  render() {\n    return <Button theme={this.context}>按钮</Button>;\n  }\n}\n```\n\n## 11. react-hooks\n\n> `Hook` 是 `React 16.8` 的新增特性。它可以让你在不编写 `class` 的情况下使用 `state` 以及其他的 `React` 特性。\n\n### 11.1 State Hook\n\n> `useState` 就是一个 `Hook`，类似 `class` 组件的 `this.setState`，但是它不会把新的 `state` 和旧的 `state` 进行合并。`useState` 会返回一对值：_当前状态_ 和一个让你 _更新它的函数_，你可以在事件处理函数中或其他一些地方调用这个函数。\n\n- 计数器\n\n```jsx\nimport React, { useState } from \"react\";\n\nfunction Example() {\n  // 声明一个叫 “count” 的 state 变量。\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n\n// 等价的 class 示例\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Click me</button>\n      </div>\n    );\n  }\n}\n```\n\n- 声明多个 `state` 变量\n\n```jsx\nfunction ExampleWithManyStates() {\n  // 声明多个 state 变量！\n  const [age, setAge] = useState(42);\n  const [fruit, setFruit] = useState(\"banana\");\n  const [todos, setTodos] = useState([{ text: \"Learn Hooks\" }]);\n  // ...\n}\n```\n\n- 什么是 `Hook`\n\n> `Hook` 是一些可以让你在函数组件里“钩入” `React state` 及生命周期等特性的函数。`Hook` 不能在 `class` 组件中使用 —— 这使得你不使用 `class` 也能使用 `React`。\n\n- 惰性 state\n\n```jsx\nconst [state, setState] = useState(() => {\n  const initialState = someExpensiveComputation(props);\n  return initialState;\n});\n```\n\n### 11.2 Effect Hook\n\n> `Effect Hook` 可以让你在函数组件中执行副作用操作\n\n#### (1) 无需清除的 `Effect`\n\n> 有时候，我们只想在 `React` 更新 `DOM` 之后运行一些额外的代码。比如发送网络请求，手动变更 `DOM`，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。\n\n- 使用 `class` 的示例\n\n```jsx\nclass Example extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  }\n\n  componentDidMount() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n  componentDidUpdate() {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n\n  render() {\n    return (\n      <div>\n        <p>You clicked {this.state.count} times</p>\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>Click me</button>\n      </div>\n    );\n  }\n}\n```\n\n- 使用 `Hook` 的示例\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n```\n\n> `useEffect` 做了什么？ 通过使用这个 `Hook`，你可以告诉 `React` 组件需要在渲染后执行某些操作。`React` 会保存你传递的函数（我们将它称之为 “`effect`”），并且在执行 `DOM` 更新之后调用它。在这个 `effect` 中，我们设置了 `document` 的 `title` 属性，不过我们也可以执行数据获取或调用其他命令式的 API。\n\n> 为什么在组件内部调用 `useEffect`？ 将 `useEffect` 放在组件内部让我们可以在 `effect` 中直接访问 `count` `state` 变量（或其他 `props`）。我们不需要特殊的 `API` 来读取它 —— 它已经保存在函数作用域中。`Hook` 使用了 `JavaScript` 的闭包机制，而不用在 `JavaScript` 已经提供了解决方案的情况下，还引入特定的 React API。\n\n> `useEffect` 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 `effect` 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。`React` 保证了每次运行 `effect` 的同时，`DOM` 都已经更新完毕。\n\n{% note warning, 与 `componentDidMount` 或 `componentDidUpdate` 不同，使用 `useEffect` 调度的 `effect` 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，`effect` 不需要同步地执行。在个别情况下（例如测量布局），有单独的 `useLayoutEffect Hook` 供你使用，其 `API` 与 `useEffect` 相同。 %}\n\n#### (2) 需要清除的 `Effect`\n\n> 之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！现在让我们来比较一下如何用 `Class` 和 `Hook` 来实现。\n\n- 使用 `class` 的示例\n\n```jsx\nclass FriendStatus extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOnline: null };\n    this.handleStatusChange = this.handleStatusChange.bind(this);\n  }\n\n  componentDidMount() {\n    ChatAPI.subscribeToFriendStatus(this.props.friend.id, this.handleStatusChange);\n  }\n  componentWillUnmount() {\n    ChatAPI.unsubscribeFromFriendStatus(this.props.friend.id, this.handleStatusChange);\n  }\n  handleStatusChange(status) {\n    this.setState({\n      isOnline: status.isOnline\n    });\n  }\n\n  render() {\n    if (this.state.isOnline === null) {\n      return \"Loading...\";\n    }\n    return this.state.isOnline ? \"Online\" : \"Offline\";\n  }\n}\n```\n\n- 使用 `Hook` 的示例\n\n{% note warning, 眼尖的读者可能已经注意到了，这个示例还需要编写 componentDidUpdate 方法才能保证完全正确。我们先暂时忽略这一点，本章节中后续部分会介绍它。 %}\n\n```jsx\nimport React, { useState, useEffect } from \"react\";\n\nfunction FriendStatus(props) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    // Specify how to clean up after this effect:\n    return function cleanup() {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n\n  if (isOnline === null) {\n    return \"Loading...\";\n  }\n  return isOnline ? \"Online\" : \"Offline\";\n}\n```\n\n> 为什么要在 `effect` 中返回一个函数？ 这是 `effect` 可选的清除机制。每个 `effect` 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 `effect` 的一部分。\n\n> `React` 何时清除 `effect`？ `React` 会在组件卸载的时候执行清除操作。正如之前学到的，`effect` 在每次渲染的时候都会执行。这就是为什么 `React` 会在执行当前 `effect` 之前对上一个 `effect` 进行清除。我们稍后将讨论为什么这将助于避免 `bug` 以及如何在遇到性能问题时跳过此行为。\n\n{% note warning, 并不是必须为 `effect` 中返回的函数命名。这里我们将其命名为 `cleanup` 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。 %}\n\n### 11.3 Hook 规则\n\n#### (1) 只在最顶层使用 `Hook`\n\n> 不要在循环，条件或嵌套函数中调用 `Hook`， 确保总是在你的 `React` 函数的最顶层调用他们。遵守这条规则，你就能确保 `Hook` 在每一次渲染中都按照同样的顺序被调用。这让 `React` 能够在多次的 `useState` 和 `useEffect` 调用之间保持 `hook` 状态的正确。\n\n#### (2) 只在 `React` 函数中调用 `Hook`\n\n> 不要在普通的 `JavaScript` 函数中调用 `Hook`。你可以：\n\n- ✅ 在 `React` 的函数组件中调用 `Hook`\n- ✅ 在自定义 `Hook` 中调用其他 `Hook`\n\n### 11.4 自定义 Hook\n\n> 通过自定义 `Hook`，可以将组件逻辑提取到可重用的函数中。\n\n#### (1) 提取自定义 `Hook`\n\n> 当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 `Hook` 都是函数，所以也同样适用这种方式。\n\n> 自定义 `Hook` 是一个函数，其名称以 “`use`” 开头，函数内部可以调用其他的 `Hook`。 例如，下面的 `useFriendStatus` 是我们第一个自定义的 `Hook`:\n\n```jsx\nimport { useState, useEffect } from \"react\";\n\nfunction useFriendStatus(friendID) {\n  const [isOnline, setIsOnline] = useState(null);\n\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n    };\n  });\n\n  return isOnline;\n}\n```\n\n#### (2) 使用自定义 `Hook`\n\n```jsx\nfunction FriendStatus(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  if (isOnline === null) {\n    return \"Loading...\";\n  }\n  return isOnline ? \"Online\" : \"Offline\";\n}\n\nfunction FriendListItem(props) {\n  const isOnline = useFriendStatus(props.friend.id);\n\n  return <li style={{ color: isOnline ? \"green\" : \"black\" }}>{props.friend.name}</li>;\n}\n```\n\n### 11.5 Hook API 索引\n\n> 参见 [Hook API](https://react.docschina.org/docs/hooks-reference.html)\n\n#### 11.5.1 基础 Hook\n\n##### useState\n\n> [点击跳转](#linkUseState)\n\n##### useEffect\n\n> [点击跳转](#linkUseEffect)\n\n##### useContext\n\n> 订阅 `context` 的变化，感觉就是对于获取 `context` 的值换了一种写法而已。相对于之前的写法，在函数组件中添加 `context` 更加简单。\n\n```jsx\nconst context = React.createContext({})\nconst { Provider, Consumer  } = context;\n\n// hooks的写法\nclass App extends React.Component {\n    return (\n        <Provider value={{ name: 'li' }}>\n            <Hello/>\n        </Provider>\n    </div>\n}\nfunction Hello () {\n    const value = useContext(context);\n    return <h1>value: {value.name}</h1>\n}\n\n// 原本的写法\nfunction Hello (props) {\n    function render ({name}) {\n      return <h1>value: {value.name}</h1>\n    }\n    return (\n      <Consumer>\n        {render}\n      </Consumer>\n    )\n}\n```\n\n#### 11.5.2 额外的 Hook\n\n##### useReducer\n\n> 类似于 `redux` 那样的状态更新方案。使用场景（基本上就是 `redux` 的应用场景），管理的状态值是对象，并且键值较多。`state` 每个 `key` 修改的逻辑比较复杂，需要单独放到一个文件里面管理。\n\n```jsx\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"increment\":\n      return { count: state.count + 1 };\n    case \"decrement\":\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    <>\n      Count: {state.count}\n      <button onClick={() => dispatch({ type: \"increment\" })}>+</button>\n      <button onClick={() => dispatch({ type: \"decrement\" })}>-</button>\n    </>\n  );\n}\n```\n\n##### useCallback\n\n> 仅在指定的依赖项发生变化时，会返回一个新的函数引用，函数体并没有发生变化。\n\n```jsx\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n```\n\n> 这样使用的好处：不会在每次组件 `render` 的时候，重新生成一个函数，节省开销。例如\n\n```jsx\nfunction f() {\n  const cacheCallback = useCallback(() => {\n    doSomething(a, b);\n  }, [a, b]);\n  // 和下面这样的形式相比, 每次组件渲染的时候，都会重新创建一个 doSometing 函数\n  function doSometing(a, b) {}\n}\n```\n\n> 可以保持函数的引用保持不变。我们都知道在类组件，事件处理函数基本上都是通过 `this.method` 的方式绑定的，这样做的方式有一个好处，对方法的引用一直保持不变。 那么在函数组件就可以通过使用 `useCallback` 来实现。\n\n> 可以实现在子组件把该回调作为依赖处理。\n\n```jsx\nfunction Parent({ a, b }) {\n  const cacheCallback = useCallback(() => {\n    doSometing(a, b);\n  }, [a, b]);\n  return <Child handler={cacheCallback} />;\n}\n\nfunction Child({ handler }) {\n  useEffect(() => {\n    handler();\n  }, [handler]);\n}\n```\n\n##### useMemo\n\n> 类似于 `vue` 的 `computed`，在依赖发生变化的时候重新计算缓存值。其实自己实现起来也很容易，和 `vue` 的计算属性不同的是，`vue` 的计算属性是自动收集依赖的，而使用 `useMeno` 需要手动在数组种传入依赖项。\n\n```jsx\nconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n```\n\n> `useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`\n\n##### useRef\n\n> 故名思义，该 `hook` 主要是用来获取组件实例或者或者 `dom` 节点。 但是它更有用的地方，是可以返回一个在组件生命周期内，引用不变的对象。\n\n```jsx\nfunction f() {\n  const elRef = uesRef(null);\n  return <div ref={elRef}></div>;\n}\n```\n\n> 用来存储数据的话，考虑下面的场景。\n\n```jsx\nlet handler = () => {}; // 事件处理函数\n// 不使用 useRef, 可以使用函数外部的一个变量来存储数据\nfunction f() {\n  useEffect(() => {\n    window.addEventListener(\"scroll\", handler);\n  }, []);\n\n  const moveScroll = useCallback(() => {\n    window.removeEventListener(\"scorll\", handler);\n  }, []);\n\n  return (\n    <div onClick={moveScroll} ref={elRef}>\n      移除scroll监听\n    </div>\n  );\n}\n\n// 使用useRef的版本，可以使代码更加内聚。但是前提是必须要理解useRef这个hooks。\nfunction f() {\n  const handler = useRef(null);\n  handler.current = () => {}; // 事件处理\n\n  useEffect(() => {\n    window.addEventListener(\"scroll\", handler.current);\n  }, []);\n\n  const moveScroll = useCallback(() => {\n    window.removeEventListener(\"scorll\", handler.current);\n  }, []);\n\n  return (\n    <div onClick={moveScroll} ref={elRef}>\n      移除scroll监听\n    </div>\n  );\n}\n```\n\n##### useImperativeHandle\n\n> `useImperativeHandle` 可以让你在使用 `ref` 时自定义暴露给父组件的实例值。\n\n```jsx\nconst Fancy = React.forwardRef((props, ref) => {\n  return (\n    <div>\n      <input type=\"text\" ref={ref} />\n    </div>\n  );\n});\n\nfunction Hello() {\n  const ref = useRef(null);\n\n  useEffect(() => {\n    console.log(\"current\", ref); // { current: Input }\n  }, []);\n\n  return <Fancy ref={ref} />;\n}\n```\n\n##### useLayoutEffect\n\n> 函数签名和 `useEffect` 是一样的， 可以使用它来读取 `DOM` 布局并 `同步` 触发重渲染。\n\n##### useDebugValue\n\n> 用来给 `hooks` 添加上打印信息。\n","slug":"前端/React16 文档","published":1,"updated":"2021-04-07T07:29:46.117Z","_id":"ckn7476au0037yx7y3aac6bor","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-React-中的核心概念\"><a href=\"#1-React-中的核心概念\" class=\"headerlink\" title=\"1. React 中的核心概念\"></a>1. React 中的核心概念</h2><h3 id=\"虚拟-DOM\"><a href=\"#虚拟-DOM\" class=\"headerlink\" title=\"虚拟 DOM\"></a>虚拟 DOM</h3><ol>\n<li>DOM 的本质是什么？</li>\n</ol>\n<blockquote>\n<p>浏览器中的概念，用<code>js</code>对象来表示页面上的元素，并提供了操作 <code>DOM</code> 对象的 API；</p>\n</blockquote>\n<ol start=\"2\">\n<li>什么是 React 中的 虚拟 DOM？（ 虚拟 DOM 的本质）：</li>\n</ol>\n<blockquote>\n<p>用<code>js</code>对象来模拟 页面上的<code>DOM和DOM嵌套</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>为什么要实现 虚拟 DOM ？（ 虚拟 DOM 的目的）：</li>\n</ol>\n<blockquote>\n<p>为了实现页面中，<code>DOM</code>元素的高效更新</p>\n</blockquote>\n<ol start=\"4\">\n<li>DOM 和 虚拟 DOM 的区别：</li>\n</ol>\n<ul>\n<li><code>DOM</code>：浏览器中，提供的概念；用<code>js</code>对象，表示页面上的元素，并提供了操作元素的 <code>API</code>；</li>\n<li><code>虚拟DOM</code>：是框架中的概念；是开发框架的人员，手动用<code>js</code>对象来模拟<code>DOM</code>元素和嵌套关系；</li>\n</ul>\n<ol start=\"5\">\n<li>DOM 树的概念：</li>\n</ol>\n<blockquote>\n<p>一个网页的呈现过程：</p>\n<ol>\n<li>浏览器请求服务器获取页面的 <code>html</code> 代码；</li>\n<li>浏览器要先在内存中，解析 <code>DOM</code> 结构，并在浏览器内存中，渲染出一棵 <code>DOM</code> 树；</li>\n<li>浏览器把 <code>DOM</code> 树，呈现到页面上；</li>\n</ol>\n</blockquote>\n<h3 id=\"Diff-算法\"><a href=\"#Diff-算法\" class=\"headerlink\" title=\"Diff 算法\"></a>Diff 算法</h3><ol>\n<li>tree diff：</li>\n</ol>\n<blockquote>\n<p>新旧两棵 <code>DOM</code> 树，逐层对比的过程，就是<code>tree diff</code>；<br>当整棵<code>DOM</code>逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到；</p>\n</blockquote>\n<ol start=\"2\">\n<li>component diff：</li>\n</ol>\n<blockquote>\n<p>在进行 <code>tree diff</code> 的时候，每一层中，组件级别的对比，叫做 <code>component diff</code>；<br>如果对比前后，组件的类型相同，则<strong>暂时</strong>认为此组件不许要被更新；<br>如果对比前后，组件的类型不同，则需要移除旧组件，创建新组件，并追加到页面上；</p>\n</blockquote>\n<ol start=\"3\">\n<li>element diff：</li>\n</ol>\n<blockquote>\n<p>在进行组件对比的时候，如果两个组件的类型相同，则需要进行元素级别的对比，这叫做<code>element diff</code>；</p>\n</blockquote>\n<h2 id=\"2-React-中创建组件\"><a href=\"#2-React-中创建组件\" class=\"headerlink\" title=\"2. React 中创建组件\"></a>2. React 中创建组件</h2><h3 id=\"使用构造函数来创建组件\"><a href=\"#使用构造函数来创建组件\" class=\"headerlink\" title=\"使用构造函数来创建组件\"></a>使用构造函数来创建组件</h3><blockquote>\n<p>1、在组件中，必须要向外<code>return</code>一个合法的<code>jsx</code>创建的<code>虚拟DOM</code>元素；<br>2、如果要接收外界传递的数据，需要在<code>构造函数</code>的参数列表中使用<code>props</code>来接收；<br>3、无论是<code>vue</code>还是<code>react</code>，组件中的<code>props</code>永远都是只读<code>read-only</code>的，不能被重新赋值；<br>4、组件的名称<code>首字母</code>必须是<code>大写</code>的<br>5、省略 <code>.jsx</code> 文件名</p>\n</blockquote>\n<blockquote>\n<p>打开 <code>webpack.config.js</code>，并在导出的配置对象中，新增以下几个节点：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">  extensions: [<span class=\"string\">&quot;.js&quot;</span>, <span class=\"string\">&quot;.jsx&quot;</span>, <span class=\"string\">&quot;.json&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果在一个组件中 <code>return</code> 一个 <code>null</code>，则表示此组件是空的，什么都不会渲染</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      这是Hello组件 -- &#123;props.name&#125; -- &#123;props.age&#125; -- &#123;props.gender&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;大黄&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">3</span>,</span><br><span class=\"line\">  gender: <span class=\"string\">&quot;雄性&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;Hello &#123;...user&#125; /&gt;</span><br><span class=\"line\">  &lt;/div&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;#app&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-class-关键字来创建组件\"><a href=\"#使用-class-关键字来创建组件\" class=\"headerlink\" title=\"使用 class 关键字来创建组件\"></a>使用 class 关键字来创建组件</h3><blockquote>\n<p><code>public</code>: 所有成员都可访问<br><code>private</code>: 只有当前类可访问<br><code>protected</code>: 只有当前类和其子类可访问，外部成员无法访问</p>\n</blockquote>\n<blockquote>\n<p><code>es6</code>中的<code>class关键字</code>，是实现<code>面向对象编程</code>的新形式，也叫做<code>语法糖</code></p>\n</blockquote>\n<ul>\n<li>constructor 构造器中的 super 函数</li>\n</ul>\n<blockquote>\n<p>在子类中， <code>this</code> 只能放到 <code>super</code> 之后使用<br>子类中的 <code>super</code>，其实就是父类中，<code>contructor</code>构造器的一个引用</p>\n</blockquote>\n<ul>\n<li>最基本的组件结构</li>\n</ul>\n<blockquote>\n<p><code>render</code>函数的作用：渲染当前组件所对应的<code>虚拟DOM</code> 元素</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 组件名称 <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>这是 class 创建的组件<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>this.props 和 this.state</li>\n</ul>\n<blockquote>\n<ol>\n<li><code>this.props</code> 接收外界传递的参数，<code>this.state</code> 设置私有数据</li>\n<li>在 <code>class</code> 关键字创建的组件中，直接使用 <code>this.props</code> 访问传递过来的数据</li>\n<li><code>props</code> 是只读的</li>\n</ol>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Movie</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 这里的 this.state = &#123;&#125;，就相当于 Vue中的data() &#123; return &#123;&#125; &#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">      msg: <span class=\"string\">&quot;这是Movie组件的私有数据&quot;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 注意：在 class 组件内容，this 表示当前组件的实例对象 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>这是Movie组件 -- &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;大黄&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">3</span>,</span><br><span class=\"line\">  gender: <span class=\"string\">&quot;雄性&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;Movie &#123;...user&#125; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;<span class=\"built_in\">this</span>.state.msg&#125;&lt;/h3&gt;</span><br><span class=\"line\">  &lt;/div&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;#app&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"两种创建组件的方式的对比\"><a href=\"#两种创建组件的方式的对比\" class=\"headerlink\" title=\"两种创建组件的方式的对比\"></a>两种创建组件的方式的对比</h3><blockquote>\n<p>使用 <code>class</code> 关键字创建的组件，有自己的 <code>私有数据(this.state)</code> 和 <code>生命周期</code><br>使用 <code>function</code> 创建的组件，只有 <code>props</code>，没有自己的 <code>私有数据</code> 和 <code>生命周期</code><br>有状态组件和无状态组件之间的 <code>本质区别</code>：有无 <code>state</code> 属性和 <code>生命周期函数</code></p>\n</blockquote>\n<h2 id=\"3-React-中-style-处理方式\"><a href=\"#3-React-中-style-处理方式\" class=\"headerlink\" title=\"3. React 中 style 处理方式\"></a>3. React 中 style 处理方式</h2><h3 id=\"内联\"><a href=\"#内联\" class=\"headerlink\" title=\"内联\"></a>内联</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style = &#123;&#123; <span class=\"attr\">color</span>: red &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><blockquote>\n<p>1、如果直接导入 <code>css</code> 样式表，默认则是在全局上，整个项目都会生效<br>2、css 模块化，只针对 <code>class</code> 选择器 和 <code>id</code> 选择器生效<br>引用：<code>import style from &#39;./style.css&#39;</code></p>\n</blockquote>\n<h2 id=\"4-React-中事件绑定\"><a href=\"#4-React-中事件绑定\" class=\"headerlink\" title=\"4. React 中事件绑定\"></a>4. React 中事件绑定</h2><ol>\n<li>事件的名称都是 <code>React</code> 所提供的，因此名称的首字母必须大写<code>onClick</code>，<code>onMouseOver</code></li>\n<li>为事件提供的处理函数，必须是以下格式：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onClick = &#123; <span class=\"function\"><span class=\"keyword\">function</span> &#125;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>用的最多的事件绑定形式为：</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.show(<span class=\"string\">&quot;传参&quot;</span>)&#125;&gt;按钮&lt;/button&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 事件的处理函数，需要定义为 一个箭头函数，然后赋值给 函数名称</span></span><br><span class=\"line\">show = <span class=\"function\"><span class=\"params\">arg1</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;show方法&quot;</span> + arg1);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>在 <code>React</code> 中，如果想要修改 <code>state</code> 中的数据，推荐使用 <code>this.setState(&#123; &#125;)</code></li>\n</ol>\n<blockquote>\n<p>1、在<code>setState</code>中，只会把对应的 <code>state</code>状态更新，而不会覆盖其它的 <code>state</code>状态。<br>2、<code>this.setState</code> 方法的执行时 <code>异步的</code>。<br>3、如果在调用完 <code>this.setState</code>之后，又想立即拿到最新的<code>state</code>的值，需要使用 <code>this.setState(&#123;&#125;, callback)</code>，第二个参数【回调函数】中获取。</p>\n</blockquote>\n<h2 id=\"5-单向数据流-状态变化-gt-自动更新页面\"><a href=\"#5-单向数据流-状态变化-gt-自动更新页面\" class=\"headerlink\" title=\"5. 单向数据流(状态变化 =&gt; 自动更新页面)\"></a>5. 单向数据流(状态变化 =&gt; 自动更新页面)</h2><blockquote>\n<p>1、<code>React</code> 中，默认是 <code>单向数据流</code>，只能把 <code>state</code> 上的数据绑定到页面，无法把页面中数据的变化，自动同步回 <code>state</code>；如果需要把页面上数据的变化，保存到 <code>state</code>，需要手动监听<code>onChange</code> 事件，拿到最新的数据，手动调用 <code>this.setState(&#123; &#125;)</code> 更改。<br>2、当为文本框绑定 <code>value</code> 值以后，要么同时给标签提供一个 <code>readOnly</code> 属性，要么提供一个 <code>onChange</code> 事件处理函数。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案一：通过事件参数 e 来获取DOM元素的引用</span></span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;text&quot;</span> value=&#123;<span class=\"built_in\">this</span>.state.msg&#125; onChange=&#123;<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">this</span>.textChanged(e)&#125; /&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">textChanged = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.target.value);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方案二：通过ref 来获取DOM元素的引用  this.refs.引用名称</span></span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;text&quot;</span> value=&#123;<span class=\"built_in\">this</span>.state.msg&#125; onChange=&#123;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.textChanged()&#125; ref=<span class=\"string\">&quot;txt&quot;</span> /&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">textChanged = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.refs.txt.value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-生命周期\"><a href=\"#6-生命周期\" class=\"headerlink\" title=\"6. 生命周期\"></a>6. 生命周期</h2><ul>\n<li>生命周期介绍</li>\n</ul>\n<blockquote>\n<p>每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会触发一系列事件，这些事件就叫做组件的生命周期</p>\n</blockquote>\n<ul>\n<li>React 的生命周期分为三个部分</li>\n</ul>\n<ol>\n<li>组件创建阶段</li>\n</ol>\n<blockquote>\n<p>只执行一次</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>componentWillMount</code> =&gt; <code>挂载之前</code></li>\n<li><code>render</code> =&gt; <code>正在渲染，虚拟DOM创建到了内存中，还未挂载到页面上</code></li>\n<li><code>componentDidMount</code> =&gt; <code>挂载结束，需要操作DOM节点的初始化操作放在这里</code></li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>组件运行阶段：</li>\n</ol>\n<blockquote>\n<p>根据 <code>props</code> 属性或者 <code>state</code> 状态的改变，有选择性的执行 <code>0</code> 到 <code>多次</code></p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>props</code> 改变之后</li>\n<li><code>componentWillReceiveProps</code> =&gt; 当一个挂载的组件接收到新的 <code>props</code> 的时候被调用</li>\n<li><code>state</code> 改变之后</li>\n<li><code>shouldComponentUpdate（nextprops, nextState）</code> =&gt; 当组件做出是否要更新 <code>DOM</code> 的决定的时候被调用，在改变状态的时候可以选择通过( <code>return true</code> )或者不通过( <code>return false</code>)</li>\n<li><code>componentWillUpdate</code> =&gt; 在更新发生之前被调用</li>\n<li><code>render</code> =&gt; 数据是新的，页面是旧的</li>\n</ol>\n<p>7.<code>componentDidUpdate</code> =&gt; 数据是新的，页面已经变成了最新的</p>\n</blockquote>\n<ol start=\"3\">\n<li>组件销毁阶段</li>\n</ol>\n<blockquote>\n<p>只执行一次</p>\n</blockquote>\n<blockquote>\n<p><code>componentWillUnmount</code> =&gt; 组件移除或者销毁的时候被调用</p>\n</blockquote>\n<h2 id=\"7-验证数据类型\"><a href=\"#7-验证数据类型\" class=\"headerlink\" title=\"7. 验证数据类型\"></a>7. 验证数据类型</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ProtoTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义组件需要传入的参数</span></span><br><span class=\"line\">MyCompo.protoTypes = &#123;</span><br><span class=\"line\">  a: ProtoTypes.string.isRequired,</span><br><span class=\"line\">  b: ProtoTypes.string.isRequired,</span><br><span class=\"line\">  c: ProtoTypes.number.isRequired</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-flux\"><a href=\"#8-flux\" class=\"headerlink\" title=\"8. flux\"></a>8. flux</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p>传统的 <code>MVC</code> 和 <code>MVVM</code> 架构设计模式有一个致命的缺点：当项目越来越大、逻辑越来越复杂的时候，数据流动就越显得混乱。</p>\n</blockquote>\n<blockquote>\n<p><code>Flux</code> 是致力于解决数据有序传输问题的架构设计模式，来自 <code>Facebook</code>。<code>Flux</code> 中最大的哲学：数据是 <code>单向流动</code> 的。</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/facebook/flux/tree/master/examples/flux-concepts\">官方手册</a></p>\n</blockquote>\n<blockquote>\n<p><code>Flux</code> 中最重要的四个概念：<code>Dispatcher</code>、<code>Store</code>、<code>View</code>、<code>Action</code>。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703835856-e1263bac-124a-40da-ae3c-b45a4c8081ae.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&name=flux.png&originHeight=393&originWidth=1300&size=26132&status=done&style=none&width=1300\" alt=\"flux.png\"></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ol>\n<li>概述<ul>\n<li><code>flux</code> 是一个管理 <code>App</code> 中数据流动的模式。</li>\n<li>最关键的概念：<code>数据的流动是单向的</code>。</li>\n</ul>\n</li>\n<li>Dispatcher 调度者<ul>\n<li><code>Dispatcher</code> 接受 <code>action</code>，并且要把这些 <code>action</code> 分派给已经注册到 <code>Dispatcher</code> 的 <code>store</code> 上</li>\n<li>所有的 <code>store</code> 都将接收所有的 <code>action</code></li>\n<li>在每个 <code>App</code> 中，应该确保只有一个 <code>Dispatcher</code> 的实例</li>\n</ul>\n</li>\n<li>store 仓库<ul>\n<li><code>store</code> 是在 <code>App</code> 中持有数据的仓库</li>\n<li>所有的 <code>store</code> 要在 <code>App</code> 的 <code>Dispatcher</code> 上注册，确保它们可以接收 <code>action</code></li>\n<li><code>store</code> 中的数据只能被 <code>action</code> 改变。</li>\n<li><code>store</code> 中不能够有公共的 <code>setter</code>，只能有 <code>getter</code></li>\n<li><code>store</code> 决定了它们愿意响应哪些 <code>actions</code></li>\n<li>无论何时，<code>store</code> 中的数据发生改变，就会触发一个 <code>change</code> 事件</li>\n<li>同一个 <code>App</code> 中可能有很多 <code>store</code></li>\n</ul>\n</li>\n<li>Action 行为<ul>\n<li><code>Action</code> 定义了 <code>App</code> 内部的 <code>API</code></li>\n<li>它们捕获所有可能改变 <code>App</code> 的途径和方法</li>\n<li>它们是简单的<code>对象</code>，并且要有 <code>type属性</code> 和 <code>其他的一些数据属性</code></li>\n<li><code>Action</code> 应该有一个具有语义的、直观的表示它是做什么的名字</li>\n<li>所有的<code>store</code>都将接收同一个<code>action</code>，并且通过这个 <code>action</code>，<code>store</code> 会知道它们要清除、更新哪些数据</li>\n</ul>\n</li>\n<li>Views 视图<ul>\n<li><code>store</code> 中的数据被展示在了<code>view</code>上</li>\n<li><code>View</code> 层可以使用任何框架</li>\n<li>当一个视图想要获取 <code>store</code> 中的数据，它必须 <code>subscribe 订阅</code> 一下该 <code>store</code> 的<code>change</code> 事件</li>\n<li>当 <code>store</code> 触发了 <code>change</code> 事件，此时 <code>view</code> 就能得到新的数据并且重新渲染</li>\n<li>如果一个组件要使用 <code>store</code>，但是没有订阅这个 <code>store</code>，此时就会出错</li>\n<li><code>Action</code> 最常见的产生原因是：在 <code>App</code> 中的某一个部分，因为用户的交互行为，而被此<code>view</code> <code>dispatch</code>出来了</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h3><ul>\n<li>简介<ul>\n<li><a href=\"https://redux.js.org/\">官网</a></li>\n<li>Redux 就是 Flux 思想在 React 中的实现</li>\n<li>Redux 是一个可预测状态的 Js app 容器</li>\n<li><a href=\"https://github.com/reactjs/redux/tree/master/examples\"><code>通过例子来学习redux</code></a></li>\n</ul>\n</li>\n<li>Redux 创建的步骤<ul>\n<li>设置一个 <code>reducer</code>；</li>\n<li>创建一个<code>store</code>，<code>Redux.createStore(reducer)</code></li>\n<li>创建 <code>render</code> 函数</li>\n<li>注册 <code>render</code>，<code>store.subscribe(render)</code></li>\n<li>监听，此时要记得 <code>store.dispatch(action)</code>，不是直接修改<code>store</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"React-Redux\"><a href=\"#React-Redux\" class=\"headerlink\" title=\"React-Redux\"></a>React-Redux</h3><ul>\n<li>简介<ul>\n<li>将 <code>react</code> 和 <code>redux</code> 合并起来，可以让任何组件在任何地方看见 <code>store</code></li>\n<li><a href=\"https://github.com/reactjs/react-redux/tree/master/docs\">官方文档</a></li>\n<li><code>React-Redux</code> 给我们提供了：<code>Provider组件</code>，<code>connect函数</code></li>\n</ul>\n</li>\n<li>Provider 组件</li>\n</ul>\n<blockquote>\n<p>1、使用 <code>react-redux</code> 提供的 <code>Provider</code> 组件传递 <code>store</code> 上下文之后，<code>包裹在其中的所有组件</code> 全都可以识别这个上下文</p>\n</blockquote>\n<blockquote>\n<p>2、在 <code>Provider</code> 组件内部的自定义组件可以使用 <code>connect()</code> 函数，但是在其外部的不可使用</p>\n</blockquote>\n<ul>\n<li>connect 函数</li>\n</ul>\n<blockquote>\n<p>1、将 <code>React组件</code> 和 <code>Redux</code> 的 <code>store</code> 进行连接<br>2、<code>connect</code> 提供了一个很方便的 <code>API</code> 能够适应绝大多数工作<br>3、它没有更改你传进来的类，反而会返回一个已经连接好的新类<br>4、提供了两个参数：<code>mapStateToProps</code>, <code>mapDispatchToProps</code></p>\n</blockquote>\n<ul>\n<li>mapStateToProps</li>\n</ul>\n<blockquote>\n<p>1、如果传入<code>mapStateToProps</code>，此时这个组件将订阅 <code>Redux</code> 中 <code>store</code> 的更新信息；<br>2、这意味着无论任何时候 <code>store</code> 被更改了，<code>mapStateToProps</code> 函数都将会被调用，<code>mapStateToProps</code> 的返回值必须是一个 <code>Object</code>；<br>3、这个 <code>Object</code> 将与组件的 <code>props</code> 融合，也就是说，这个返回的 <code>Object</code> 中的 <code>key</code> 将自动成为组件的 <code>props</code> 中的成员<br>4、如果不想订阅 <code>store</code> 的更新，此时可以不传递这个参数，采用 <code>null</code> 占位</p>\n</blockquote>\n<ul>\n<li>mapDispatchToProps</li>\n</ul>\n<blockquote>\n<p>如果向 <code>connect</code> 函数中传入了第二个参数，并且是一个 <code>函数</code>，那么这个函数将获得<code>dispatch</code> 方法，该方法可以通过 <code>emit action</code>，间接的导致 <code>state</code> 的改变<br>可以使用 <code>bindActionCreators()</code> 方法轻松的将 <code>Action creator</code>(返回 <code>action</code> 的函数)接口和 <code>dispatch</code> 进行绑定</p>\n</blockquote>\n<ul>\n<li>书写规则</li>\n</ul>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;./containers/App&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">&quot;./reducers&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>App.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">&quot;./actions&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(props);</span><br><span class=\"line\">    <span class=\"comment\">// props: &#123; r: 0, g: 0, b: 0, actions: 许多方法 &#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>这是App组件<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    r: state.r,</span><br><span class=\"line\">    g: state.g,</span><br><span class=\"line\">    b: state.b</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    actions: bindActionCreators(actions, dispatch)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(App);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>reducer.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (state, action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state == <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    state = &#123; <span class=\"attr\">r</span>: <span class=\"number\">0</span>, <span class=\"attr\">g</span>: <span class=\"number\">0</span>, <span class=\"attr\">b</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type == <span class=\"string\">&quot;ADD&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      r: state.r + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>actions.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD = <span class=\"function\">() =&gt;</span> &#123; <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;ADD&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件内部的-state-和全局的-state\"><a href=\"#组件内部的-state-和全局的-state\" class=\"headerlink\" title=\"组件内部的 state 和全局的 state\"></a>组件内部的 state 和全局的 state</h3><blockquote>\n<p>组件的数据三兄弟：<code>state</code>, <code>props</code>, <code>context</code> 不管是谁发生改变，都会引发 <code>render()</code> 执行，视图会被重绘。但是，构造函数不会被重新执行。所以不管基于什么理由，都不需要将全局的状态，用自己组件的 <code>state</code> 接收，而仅需要用<code>connect</code>连接一下全局<code>store</code>，然后使用<code>this.props.**</code>即可。</p>\n</blockquote>\n<h3 id=\"reducer-模块化\"><a href=\"#reducer-模块化\" class=\"headerlink\" title=\"reducer 模块化\"></a>reducer 模块化</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todoReducers <span class=\"keyword\">from</span> <span class=\"string\">&quot;./todoReducer.js&quot;</span>; <span class=\"comment\">// 标准reducer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">  todoReducers</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"redux-logger\"><a href=\"#redux-logger\" class=\"headerlink\" title=\"redux-logger\"></a>redux-logger</h3><blockquote>\n<p>打印 redux log</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createLogger &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux-logger&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">&quot;./reducers/index.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer, applyMiddleware(createLogger()));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"redux-thunk\"><a href=\"#redux-thunk\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h3><blockquote>\n<p>解决异步问题</p>\n</blockquote>\n<blockquote>\n<p><code>redux-thunk</code>帮助我们在所有的组件的 <code>props</code> 中添加了一个 <code>dispatch</code> 方法。</p>\n</blockquote>\n<blockquote>\n<p>当然，这个组件一定要被 <code>connect</code> 函数进行处理</p>\n</blockquote>\n<blockquote>\n<p>注意，如果使用 <code>thunk</code>，则 <code>connect</code> 函数不能传入第二个参数，否则会导致无法获取 <code>this.props.dispatch()</code></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入口文件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux-thunk&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer, applyMiddleware(thunk))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 组件中 */</span></span><br><span class=\"line\"><span class=\"comment\">/** 第一种写法，并没有将actions进行抽离 */</span></span><br><span class=\"line\">$.get(<span class=\"string\">&#x27;/shu.txt&#x27;</span>, <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> number = <span class=\"built_in\">Number</span>(data);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.props.dispatch(&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;ADD&quot;</span>,</span><br><span class=\"line\">        number</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">/** 第二种写法:常用 */</span></span><br><span class=\"line\"><span class=\"comment\">// 可枚举</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./actions/actions.js&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> ** <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.props.dispatch(actions.add())</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.props.dispatch(actions.minus())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** 现在，一般不会再写第二个参数了，就是说省略掉mapDispatchToProps */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</span><br><span class=\"line\"> (state) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        state: state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;)(**)</span><br><span class=\"line\"><span class=\"comment\">// actions.js</span></span><br><span class=\"line\"><span class=\"comment\">/* 现在，异步的Action Creator不要直接返回 Action，而是返回一个携带 dispatch 的函数；这个函数相当于“延长”了dispatch的持续时间。*/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> add = <span class=\"function\">() =&gt;</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(getState()) <span class=\"comment\">// getState可以获取全局数据</span></span><br><span class=\"line\">    $.get(<span class=\"string\">&#x27;/shu.txt&#x27;</span>, <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> number = <span class=\"built_in\">Number</span>(data);</span><br><span class=\"line\">        dispatch(&#123;<span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;MINUS&quot;</span>, number&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> minus = <span class=\"function\">() =&gt;</span> &#123; <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;MINUS&quot;</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// reducer.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (state = <span class=\"number\">0</span>, action) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;ADD&quot;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state + action.number</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;MINUS&quot;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-react-router4-x\"><a href=\"#9-react-router4-x\" class=\"headerlink\" title=\"9. react-router4.x\"></a>9. react-router4.x</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><ul>\n<li><a href=\"https://reacttraining.com/react-router\">官网</a></li>\n<li>安装：<code>npm install react-router-dom</code></li>\n</ul>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><blockquote>\n<p><code>exact</code>表示严格匹配，如果路径为 <code>path=&quot;/&quot;</code> 的 <code>Route</code> 不设置该属性，则会自动向下匹配路由，即都会显示出来</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter <span class=\"keyword\">as</span> Router, Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router-dom&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Index</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">About</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Users</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Users<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">AppRouter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Router&gt;</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;nav&gt;</span><br><span class=\"line\">          &lt;ul&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">              &lt;Link to=<span class=\"string\">&quot;/&quot;</span>&gt;Home&lt;/Link&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">              &lt;Link to=<span class=\"string\">&quot;/about/&quot;</span>&gt;About&lt;/Link&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">              &lt;Link to=<span class=\"string\">&quot;/users/&quot;</span>&gt;Users&lt;/Link&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">          &lt;/ul&gt;</span><br><span class=\"line\">        &lt;/nav&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;Route path=<span class=\"string\">&quot;/&quot;</span> exact component=&#123;Index&#125; /&gt;</span><br><span class=\"line\">        &lt;Route path=<span class=\"string\">&quot;/about/&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class=\"line\">        &lt;Route path=<span class=\"string\">&quot;/users/&quot;</span> component=&#123;Users&#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/Router&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> AppRouter;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态路由\"><a href=\"#动态路由\" class=\"headerlink\" title=\"动态路由\"></a>动态路由</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.js 定义动态路由</span></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">&quot;/content/:aid&quot;</span>&gt;&lt;/Route&gt;</span><br><span class=\"line\"><span class=\"comment\">// news.js 跳转</span></span><br><span class=\"line\">&lt;Link to=&#123;<span class=\"string\">`/content/<span class=\"subst\">$&#123;value.aid&#125;</span>`</span>&#125;&gt;&lt;/Link&gt;</span><br><span class=\"line\"><span class=\"comment\">// Content.js 跳在生命周期函数中获取动态路由参数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Content</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> &#123; match &#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">          <span class=\"comment\">// 获取到传递的动态路由参数</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(match.params.aid)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-传值\"><a href=\"#get-传值\" class=\"headerlink\" title=\"get 传值\"></a>get 传值</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.js 定义动态路由</span></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">&quot;/content&quot;</span>&gt;&lt;/Route&gt;</span><br><span class=\"line\"><span class=\"comment\">// news.js 跳转</span></span><br><span class=\"line\">&lt;Link to=&#123;<span class=\"string\">`/content?aid=<span class=\"subst\">$&#123;value.aid&#125;</span>`</span>&#125;&gt;&lt;/Link&gt;</span><br><span class=\"line\"><span class=\"comment\">// Content.js 跳在生命周期函数中获取动态路由参数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Content</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">      <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> &#123; location &#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">          <span class=\"comment\">// 获取到传递的动态路由参数</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(location.search)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"js-控制跳转\"><a href=\"#js-控制跳转\" class=\"headerlink\" title=\"js 控制跳转\"></a>js 控制跳转</h3><ol>\n<li>引入 <code>Redirect</code> 组件</li>\n<li>定义一个 <code>flag</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">  loginFlag: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在 <code>Render</code> 中判断 <code>flag</code>，从而来决定是否进行跳转</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.state.loginFlag) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Redirect</span> <span class=\"attr\">to</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">pathname:</span> &quot;/&quot; &#125;&#125; /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>执行 <code>js</code> 跳转，通过 <code>js</code> 改变 <code>loginFlag</code> 的状态，改变以后，就可以从新的 <code>render</code> 中通过 <code>Redirect</code> 自己进行跳转</li>\n</ol>\n<h3 id=\"模块化路由\"><a href=\"#模块化路由\" class=\"headerlink\" title=\"模块化路由\"></a>模块化路由</h3><blockquote>\n<p>router.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Home <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/Home/&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> About <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/About/&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> User <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/User/&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> UserList <span class=\"keyword\">from</span> <span class=\"string\">&quot;./User/UserList&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> UserInfo <span class=\"keyword\">from</span> <span class=\"string\">&quot;./User/UserInfo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> router = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: <span class=\"string\">&quot;/&quot;</span>,</span><br><span class=\"line\">    component: Home,</span><br><span class=\"line\">    exact: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: <span class=\"string\">&quot;/about&quot;</span>,</span><br><span class=\"line\">    component: About</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: <span class=\"string\">&quot;/User&quot;</span>,</span><br><span class=\"line\">    component: User,</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      <span class=\"comment\">// 嵌套路由设置</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: <span class=\"string\">&quot;/user/&quot;</span>,</span><br><span class=\"line\">        component: UserList</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: <span class=\"string\">&quot;/user/info&quot;</span>,</span><br><span class=\"line\">        component: UserInfo</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> router;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>App.js 入口文件</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter <span class=\"keyword\">as</span> Router, Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">&quot;./router.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Router&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;router.map(<span class=\"function\">(<span class=\"params\">route, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (route.exact) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;Route</span><br><span class=\"line\">                  exact</span><br><span class=\"line\">                  key=&#123;key&#125;</span><br><span class=\"line\">                  path=&#123;route.path&#125;</span><br><span class=\"line\">                  render=&#123;<span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">                    <span class=\"comment\">// 向子组件传递子路由</span></span><br><span class=\"line\">                    &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt;</span><br><span class=\"line\">                  )&#125;</span><br><span class=\"line\">                /&gt;</span><br><span class=\"line\">              );</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;Route</span><br><span class=\"line\">                  key=&#123;key&#125;</span><br><span class=\"line\">                  path=&#123;route.path&#125;</span><br><span class=\"line\">                  render=&#123;<span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">                    <span class=\"comment\">// 向子组件传递子路由</span></span><br><span class=\"line\">                    &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt;</span><br><span class=\"line\">                  )&#125;</span><br><span class=\"line\">                /&gt;</span><br><span class=\"line\">              );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)&#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/Router&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>User.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router-dom&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentWillMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.props.routes);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">&quot;contenr&quot;</span>&gt;</span><br><span class=\"line\">          &lt;div className=<span class=\"string\">&quot;left&quot;</span>&gt;</span><br><span class=\"line\">            &lt;Link /&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">          &lt;div className=<span class=\"string\">&quot;right&quot;</span>&gt;</span><br><span class=\"line\">            &#123;<span class=\"built_in\">this</span>.props.routes.map(<span class=\"function\">(<span class=\"params\">route, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">exact</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;key&#125;</span> <span class=\"attr\">path</span>=<span class=\"string\">&#123;route.path&#125;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;route.component&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">            &#125;)&#125;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> User;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用路由组件\"><a href=\"#常用路由组件\" class=\"headerlink\" title=\"常用路由组件\"></a>常用路由组件</h3><ul>\n<li>_BrowserRouter_：使用 <code>HTML5</code> 历史记录 <code>API</code> (<code>pushState</code>，<code>replaceState</code> 和<code>popstate</code> 事件)的 <code>&lt;Router&gt;</code> 来保持 <code>UI</code> 与 <code>URL</code> 的同步</li>\n<li>_HashRouter_：使用 <code>URL</code> 的哈希部分(即 <code>window.location.hash</code> )的&lt;路由器&gt;可以保持您的 <code>UI</code> 与 <code>URL</code> 同步。注意：哈希历史记录不支持 <code>location.key</code> 或 <code>location.state</code>。 在以前的版本中，我们试图缓和行为，但是有一些边缘案例我们无法解决。 任何需要此行为的代码或插件将无法正常工作。 由于此技术仅用于支持旧版浏览器，因此我们建议您将服务器配置为使用<code>&lt;BrowserHistory&gt;</code></li>\n<li>_Link_：渲染成 <code>a</code> 标签</li>\n<li>_NavLink_：一种特殊版本的 <code>&lt;Link&gt;</code>，当与当前 <code>URL</code> 匹配时，将向渲染元素添加样式属性。</li>\n<li>_Redirect_：重定向</li>\n<li>_Route_：在位置与路线的路径匹配时呈现一些 <code>UI</code>。</li>\n<li>_Switch_：只渲染命中的第一个 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code> 。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Switch的用法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Switch, Route &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router&quot;</span>;</span><br><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">  &lt;Route exact path=<span class=\"string\">&quot;/&quot;</span> component=&#123;Home&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">&quot;/about&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">&quot;/:user&quot;</span> component=&#123;User&#125; /&gt;</span><br><span class=\"line\">  &lt;Route component=&#123;NoMatch&#125; /&gt;</span><br><span class=\"line\">&lt;/Switch&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-context\"><a href=\"#10-context\" class=\"headerlink\" title=\"10. context\"></a>10. context</h2><ul>\n<li>介绍</li>\n</ul>\n<blockquote>\n<p>在一个典型的 <code>React</code> 应用中，数据是通过 <code>props</code> 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，<code>UI</code> 主题），这些属性是应用程序中许多组件都需要的。<code>Context</code> 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 <code>props</code>。</p>\n</blockquote>\n<ul>\n<li>繁琐的 <code>props</code> 方式</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Toolbar</span> <span class=\"attr\">theme</span>=<span class=\"string\">&quot;dark&quot;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Toolbar</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;ThemeButton theme=&#123;props.theme&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThemeButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    &lt;Button theme=&#123;<span class=\"built_in\">this</span>.props.theme&#125;&gt;按钮&lt;/Button&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>context</code></li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span></span><br><span class=\"line\"><span class=\"comment\">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ThemeContext = React.createContext(<span class=\"string\">&quot;light&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class=\"line\">    <span class=\"comment\">// 无论多深，任何组件都能读取这个值。</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ThemeContext.Provider value=<span class=\"string\">&quot;dark&quot;</span>&gt;</span><br><span class=\"line\">        &lt;Toolbar /&gt;</span><br><span class=\"line\">      &lt;/ThemeContext.Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ToolBar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;ThemeButton /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThemeButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 指定 contextType 读取当前的 theme context。</span></span><br><span class=\"line\">  <span class=\"comment\">// React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class=\"line\">  <span class=\"comment\">// 在这个例子中，当前的 theme 值为 “dark”。</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> contextType = ThemeContext;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">theme</span>=<span class=\"string\">&#123;this.context&#125;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-react-hooks\"><a href=\"#11-react-hooks\" class=\"headerlink\" title=\"11. react-hooks\"></a>11. react-hooks</h2><blockquote>\n<p><code>Hook</code> 是 <code>React 16.8</code> 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性。</p>\n</blockquote>\n<h3 id=\"11-1-State-Hook\"><a href=\"#11-1-State-Hook\" class=\"headerlink\" title=\"11.1 State Hook\"></a>11.1 State Hook</h3><blockquote>\n<p><code>useState</code> 就是一个 <code>Hook</code>，类似 <code>class</code> 组件的 <code>this.setState</code>，但是它不会把新的 <code>state</code> 和旧的 <code>state</code> 进行合并。<code>useState</code> 会返回一对值：<em>当前状态</em> 和一个让你 _更新它的函数_，你可以在事件处理函数中或其他一些地方调用这个函数。</p>\n</blockquote>\n<ul>\n<li>计数器</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个叫 “count” 的 state 变量。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> setCount(count + <span class=\"number\">1</span>)&#125;&gt;Click me&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价的 class 示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;You clicked &#123;<span class=\"built_in\">this</span>.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.setState(&#123; <span class=\"attr\">count</span>: <span class=\"built_in\">this</span>.state.count + <span class=\"number\">1</span> &#125;)&#125;&gt;Click me&lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>声明多个 <code>state</code> 变量</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ExampleWithManyStates</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明多个 state 变量！</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [age, setAge] = useState(<span class=\"number\">42</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [fruit, setFruit] = useState(<span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [todos, setTodos] = useState([&#123; <span class=\"attr\">text</span>: <span class=\"string\">&quot;Learn Hooks&quot;</span> &#125;]);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>什么是 <code>Hook</code></li>\n</ul>\n<blockquote>\n<p><code>Hook</code> 是一些可以让你在函数组件里“钩入” <code>React state</code> 及生命周期等特性的函数。<code>Hook</code> 不能在 <code>class</code> 组件中使用 —— 这使得你不使用 <code>class</code> 也能使用 <code>React</code>。</p>\n</blockquote>\n<ul>\n<li>惰性 state</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [state, setState] = useState(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> initialState = someExpensiveComputation(props);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> initialState;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-2-Effect-Hook\"><a href=\"#11-2-Effect-Hook\" class=\"headerlink\" title=\"11.2 Effect Hook\"></a>11.2 Effect Hook</h3><blockquote>\n<p><code>Effect Hook</code> 可以让你在函数组件中执行副作用操作</p>\n</blockquote>\n<h4 id=\"1-无需清除的-Effect\"><a href=\"#1-无需清除的-Effect\" class=\"headerlink\" title=\"(1) 无需清除的 Effect\"></a>(1) 无需清除的 <code>Effect</code></h4><blockquote>\n<p>有时候，我们只想在 <code>React</code> 更新 <code>DOM</code> 之后运行一些额外的代码。比如发送网络请求，手动变更 <code>DOM</code>，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p>\n</blockquote>\n<ul>\n<li>使用 <code>class</code> 的示例</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.title = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.state.count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidUpdate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.title = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.state.count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;You clicked &#123;<span class=\"built_in\">this</span>.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.setState(&#123; <span class=\"attr\">count</span>: <span class=\"built_in\">this</span>.state.count + <span class=\"number\">1</span> &#125;)&#125;&gt;Click me&lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>Hook</code> 的示例</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.title = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> setCount(count + <span class=\"number\">1</span>)&#125;&gt;Click me&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>useEffect</code> 做了什么？ 通过使用这个 <code>Hook</code>，你可以告诉 <code>React</code> 组件需要在渲染后执行某些操作。<code>React</code> 会保存你传递的函数（我们将它称之为 “<code>effect</code>”），并且在执行 <code>DOM</code> 更新之后调用它。在这个 <code>effect</code> 中，我们设置了 <code>document</code> 的 <code>title</code> 属性，不过我们也可以执行数据获取或调用其他命令式的 API。</p>\n</blockquote>\n<blockquote>\n<p>为什么在组件内部调用 <code>useEffect</code>？ 将 <code>useEffect</code> 放在组件内部让我们可以在 <code>effect</code> 中直接访问 <code>count</code> <code>state</code> 变量（或其他 <code>props</code>）。我们不需要特殊的 <code>API</code> 来读取它 —— 它已经保存在函数作用域中。<code>Hook</code> 使用了 <code>JavaScript</code> 的闭包机制，而不用在 <code>JavaScript</code> 已经提供了解决方案的情况下，还引入特定的 React API。</p>\n</blockquote>\n<blockquote>\n<p><code>useEffect</code> 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 <code>effect</code> 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。<code>React</code> 保证了每次运行 <code>effect</code> 的同时，<code>DOM</code> 都已经更新完毕。</p>\n</blockquote>\n<div class=\"tag-plugin note\"><div class=\"title\"><strong>warning,</strong></div><div class=\"body\"><p>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 <code>effect</code> 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，<code>effect</code> 不需要同步地执行。在个别情况下（例如测量布局），有单独的 <code>useLayoutEffect Hook</code> 供你使用，其 <code>API</code> 与 <code>useEffect</code> 相同。</p></div></div>\n\n<h4 id=\"2-需要清除的-Effect\"><a href=\"#2-需要清除的-Effect\" class=\"headerlink\" title=\"(2) 需要清除的 Effect\"></a>(2) 需要清除的 <code>Effect</code></h4><blockquote>\n<p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！现在让我们来比较一下如何用 <code>Class</code> 和 <code>Hook</code> 来实现。</p>\n</blockquote>\n<ul>\n<li>使用 <code>class</code> 的示例</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendStatus</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123; <span class=\"attr\">isOnline</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.handleStatusChange = <span class=\"built_in\">this</span>.handleStatusChange.bind(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(<span class=\"built_in\">this</span>.props.friend.id, <span class=\"built_in\">this</span>.handleStatusChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentWillUnmount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    ChatAPI.unsubscribeFromFriendStatus(<span class=\"built_in\">this</span>.props.friend.id, <span class=\"built_in\">this</span>.handleStatusChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">handleStatusChange</span>(<span class=\"params\">status</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(&#123;</span><br><span class=\"line\">      isOnline: status.isOnline</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.state.isOnline === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;Loading...&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.state.isOnline ? <span class=\"string\">&quot;Online&quot;</span> : <span class=\"string\">&quot;Offline&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>Hook</code> 的示例</li>\n</ul>\n<div class=\"tag-plugin note\"><div class=\"title\"><strong>warning,</strong></div><div class=\"body\"><p>眼尖的读者可能已经注意到了，这个示例还需要编写 componentDidUpdate 方法才能保证完全正确。我们先暂时忽略这一点，本章节中后续部分会介绍它。</p></div></div>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FriendStatus</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [isOnline, setIsOnline] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleStatusChange</span>(<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">      setIsOnline(status.isOnline);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    <span class=\"comment\">// Specify how to clean up after this effect:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cleanup</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isOnline === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Loading...&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isOnline ? <span class=\"string\">&quot;Online&quot;</span> : <span class=\"string\">&quot;Offline&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为什么要在 <code>effect</code> 中返回一个函数？ 这是 <code>effect</code> 可选的清除机制。每个 <code>effect</code> 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 <code>effect</code> 的一部分。</p>\n</blockquote>\n<blockquote>\n<p><code>React</code> 何时清除 <code>effect</code>？ <code>React</code> 会在组件卸载的时候执行清除操作。正如之前学到的，<code>effect</code> 在每次渲染的时候都会执行。这就是为什么 <code>React</code> 会在执行当前 <code>effect</code> 之前对上一个 <code>effect</code> 进行清除。我们稍后将讨论为什么这将助于避免 <code>bug</code> 以及如何在遇到性能问题时跳过此行为。</p>\n</blockquote>\n<div class=\"tag-plugin note\"><div class=\"title\"><strong>warning,</strong></div><div class=\"body\"><p>并不是必须为 <code>effect</code> 中返回的函数命名。这里我们将其命名为 <code>cleanup</code> 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。</p></div></div>\n\n<h3 id=\"11-3-Hook-规则\"><a href=\"#11-3-Hook-规则\" class=\"headerlink\" title=\"11.3 Hook 规则\"></a>11.3 Hook 规则</h3><h4 id=\"1-只在最顶层使用-Hook\"><a href=\"#1-只在最顶层使用-Hook\" class=\"headerlink\" title=\"(1) 只在最顶层使用 Hook\"></a>(1) 只在最顶层使用 <code>Hook</code></h4><blockquote>\n<p>不要在循环，条件或嵌套函数中调用 <code>Hook</code>， 确保总是在你的 <code>React</code> 函数的最顶层调用他们。遵守这条规则，你就能确保 <code>Hook</code> 在每一次渲染中都按照同样的顺序被调用。这让 <code>React</code> 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 <code>hook</code> 状态的正确。</p>\n</blockquote>\n<h4 id=\"2-只在-React-函数中调用-Hook\"><a href=\"#2-只在-React-函数中调用-Hook\" class=\"headerlink\" title=\"(2) 只在 React 函数中调用 Hook\"></a>(2) 只在 <code>React</code> 函数中调用 <code>Hook</code></h4><blockquote>\n<p>不要在普通的 <code>JavaScript</code> 函数中调用 <code>Hook</code>。你可以：</p>\n</blockquote>\n<ul>\n<li>✅ 在 <code>React</code> 的函数组件中调用 <code>Hook</code></li>\n<li>✅ 在自定义 <code>Hook</code> 中调用其他 <code>Hook</code></li>\n</ul>\n<h3 id=\"11-4-自定义-Hook\"><a href=\"#11-4-自定义-Hook\" class=\"headerlink\" title=\"11.4 自定义 Hook\"></a>11.4 自定义 Hook</h3><blockquote>\n<p>通过自定义 <code>Hook</code>，可以将组件逻辑提取到可重用的函数中。</p>\n</blockquote>\n<h4 id=\"1-提取自定义-Hook\"><a href=\"#1-提取自定义-Hook\" class=\"headerlink\" title=\"(1) 提取自定义 Hook\"></a>(1) 提取自定义 <code>Hook</code></h4><blockquote>\n<p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 <code>Hook</code> 都是函数，所以也同样适用这种方式。</p>\n</blockquote>\n<blockquote>\n<p>自定义 <code>Hook</code> 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 <code>Hook</code>。 例如，下面的 <code>useFriendStatus</code> 是我们第一个自定义的 <code>Hook</code>:</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFriendStatus</span>(<span class=\"params\">friendID</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [isOnline, setIsOnline] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleStatusChange</span>(<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">      setIsOnline(status.isOnline);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> isOnline;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用自定义-Hook\"><a href=\"#2-使用自定义-Hook\" class=\"headerlink\" title=\"(2) 使用自定义 Hook\"></a>(2) 使用自定义 <code>Hook</code></h4><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FriendStatus</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isOnline === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Loading...&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isOnline ? <span class=\"string\">&quot;Online&quot;</span> : <span class=\"string\">&quot;Offline&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FriendListItem</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">color:</span> <span class=\"attr\">isOnline</span> ? &quot;<span class=\"attr\">green</span>&quot; <span class=\"attr\">:</span> &quot;<span class=\"attr\">black</span>&quot; &#125;&#125;&gt;</span>&#123;props.friend.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-5-Hook-API-索引\"><a href=\"#11-5-Hook-API-索引\" class=\"headerlink\" title=\"11.5 Hook API 索引\"></a>11.5 Hook API 索引</h3><blockquote>\n<p>参见 <a href=\"https://react.docschina.org/docs/hooks-reference.html\">Hook API</a></p>\n</blockquote>\n<h4 id=\"11-5-1-基础-Hook\"><a href=\"#11-5-1-基础-Hook\" class=\"headerlink\" title=\"11.5.1 基础 Hook\"></a>11.5.1 基础 Hook</h4><h5 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h5><blockquote>\n<p><a href=\"#linkUseState\">点击跳转</a></p>\n</blockquote>\n<h5 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h5><blockquote>\n<p><a href=\"#linkUseEffect\">点击跳转</a></p>\n</blockquote>\n<h5 id=\"useContext\"><a href=\"#useContext\" class=\"headerlink\" title=\"useContext\"></a>useContext</h5><blockquote>\n<p>订阅 <code>context</code> 的变化，感觉就是对于获取 <code>context</code> 的值换了一种写法而已。相对于之前的写法，在函数组件中添加 <code>context</code> 更加简单。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> context = React.createContext(&#123;&#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; Provider, Consumer  &#125; = context;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// hooks的写法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Provider value=&#123;&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;li&#x27;</span> &#125;&#125;&gt;</span><br><span class=\"line\">            &lt;Hello/&gt;</span><br><span class=\"line\">        &lt;/Provider&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = useContext(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>value: &#123;value.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原本的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span> (<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span> (<span class=\"params\">&#123;name&#125;</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>value: &#123;value.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Consumer&gt;</span><br><span class=\"line\">        &#123;render&#125;</span><br><span class=\"line\">      &lt;/Consumer&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-5-2-额外的-Hook\"><a href=\"#11-5-2-额外的-Hook\" class=\"headerlink\" title=\"11.5.2 额外的 Hook\"></a>11.5.2 额外的 Hook</h4><h5 id=\"useReducer\"><a href=\"#useReducer\" class=\"headerlink\" title=\"useReducer\"></a>useReducer</h5><blockquote>\n<p>类似于 <code>redux</code> 那样的状态更新方案。使用场景（基本上就是 <code>redux</code> 的应用场景），管理的状态值是对象，并且键值较多。<code>state</code> 每个 <code>key</code> 修改的逻辑比较复杂，需要单独放到一个文件里面管理。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;increment&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; <span class=\"attr\">count</span>: state.count + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;decrement&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; <span class=\"attr\">count</span>: state.count - <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      Count: &#123;state.count&#125;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;increment&quot;</span> &#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;decrement&quot;</span> &#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"useCallback\"><a href=\"#useCallback\" class=\"headerlink\" title=\"useCallback\"></a>useCallback</h5><blockquote>\n<p>仅在指定的依赖项发生变化时，会返回一个新的函数引用，函数体并没有发生变化。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoizedCallback = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  doSomething(a, b);</span><br><span class=\"line\">&#125;, [a, b]);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这样使用的好处：不会在每次组件 <code>render</code> 的时候，重新生成一个函数，节省开销。例如</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cacheCallback = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    doSomething(a, b);</span><br><span class=\"line\">  &#125;, [a, b]);</span><br><span class=\"line\">  <span class=\"comment\">// 和下面这样的形式相比, 每次组件渲染的时候，都会重新创建一个 doSometing 函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSometing</span>(<span class=\"params\">a, b</span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以保持函数的引用保持不变。我们都知道在类组件，事件处理函数基本上都是通过 <code>this.method</code> 的方式绑定的，这样做的方式有一个好处，对方法的引用一直保持不变。 那么在函数组件就可以通过使用 <code>useCallback</code> 来实现。</p>\n</blockquote>\n<blockquote>\n<p>可以实现在子组件把该回调作为依赖处理。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cacheCallback = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    doSometing(a, b);</span><br><span class=\"line\">  &#125;, [a, b]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">handler</span>=<span class=\"string\">&#123;cacheCallback&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">&#123; handler &#125;</span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    handler();</span><br><span class=\"line\">  &#125;, [handler]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h5><blockquote>\n<p>类似于 <code>vue</code> 的 <code>computed</code>，在依赖发生变化的时候重新计算缓存值。其实自己实现起来也很容易，和 <code>vue</code> 的计算属性不同的是，<code>vue</code> 的计算属性是自动收集依赖的，而使用 <code>useMeno</code> 需要手动在数组种传入依赖项。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoizedValue = useMemo(<span class=\"function\">() =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></p>\n</blockquote>\n<h5 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h5><blockquote>\n<p>故名思义，该 <code>hook</code> 主要是用来获取组件实例或者或者 <code>dom</code> 节点。 但是它更有用的地方，是可以返回一个在组件生命周期内，引用不变的对象。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elRef = uesRef(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;elRef&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>用来存储数据的话，考虑下面的场景。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> handler = <span class=\"function\">() =&gt;</span> &#123;&#125;; <span class=\"comment\">// 事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\">// 不使用 useRef, 可以使用函数外部的一个变量来存储数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, handler);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> moveScroll = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">&quot;scorll&quot;</span>, handler);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div onClick=&#123;moveScroll&#125; ref=&#123;elRef&#125;&gt;</span><br><span class=\"line\">      移除scroll监听</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用useRef的版本，可以使代码更加内聚。但是前提是必须要理解useRef这个hooks。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = useRef(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  handler.current = <span class=\"function\">() =&gt;</span> &#123;&#125;; <span class=\"comment\">// 事件处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, handler.current);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> moveScroll = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">&quot;scorll&quot;</span>, handler.current);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div onClick=&#123;moveScroll&#125; ref=&#123;elRef&#125;&gt;</span><br><span class=\"line\">      移除scroll监听</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"useImperativeHandle\"><a href=\"#useImperativeHandle\" class=\"headerlink\" title=\"useImperativeHandle\"></a>useImperativeHandle</h5><blockquote>\n<p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Fancy = React.forwardRef(<span class=\"function\">(<span class=\"params\">props, ref</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;input type=<span class=\"string\">&quot;text&quot;</span> ref=&#123;ref&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ref = useRef(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current&quot;</span>, ref); <span class=\"comment\">// &#123; current: Input &#125;</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Fancy</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"useLayoutEffect\"><a href=\"#useLayoutEffect\" class=\"headerlink\" title=\"useLayoutEffect\"></a>useLayoutEffect</h5><blockquote>\n<p>函数签名和 <code>useEffect</code> 是一样的， 可以使用它来读取 <code>DOM</code> 布局并 <code>同步</code> 触发重渲染。</p>\n</blockquote>\n<h5 id=\"useDebugValue\"><a href=\"#useDebugValue\" class=\"headerlink\" title=\"useDebugValue\"></a>useDebugValue</h5><blockquote>\n<p>用来给 <code>hooks</code> 添加上打印信息。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-React-中的核心概念\"><a href=\"#1-React-中的核心概念\" class=\"headerlink\" title=\"1. React 中的核心概念\"></a>1. React 中的核心概念</h2><h3 id=\"虚拟-DOM\"><a href=\"#虚拟-DOM\" class=\"headerlink\" title=\"虚拟 DOM\"></a>虚拟 DOM</h3><ol>\n<li>DOM 的本质是什么？</li>\n</ol>\n<blockquote>\n<p>浏览器中的概念，用<code>js</code>对象来表示页面上的元素，并提供了操作 <code>DOM</code> 对象的 API；</p>\n</blockquote>\n<ol start=\"2\">\n<li>什么是 React 中的 虚拟 DOM？（ 虚拟 DOM 的本质）：</li>\n</ol>\n<blockquote>\n<p>用<code>js</code>对象来模拟 页面上的<code>DOM和DOM嵌套</code></p>\n</blockquote>\n<ol start=\"3\">\n<li>为什么要实现 虚拟 DOM ？（ 虚拟 DOM 的目的）：</li>\n</ol>\n<blockquote>\n<p>为了实现页面中，<code>DOM</code>元素的高效更新</p>\n</blockquote>\n<ol start=\"4\">\n<li>DOM 和 虚拟 DOM 的区别：</li>\n</ol>\n<ul>\n<li><code>DOM</code>：浏览器中，提供的概念；用<code>js</code>对象，表示页面上的元素，并提供了操作元素的 <code>API</code>；</li>\n<li><code>虚拟DOM</code>：是框架中的概念；是开发框架的人员，手动用<code>js</code>对象来模拟<code>DOM</code>元素和嵌套关系；</li>\n</ul>\n<ol start=\"5\">\n<li>DOM 树的概念：</li>\n</ol>\n<blockquote>\n<p>一个网页的呈现过程：</p>\n<ol>\n<li>浏览器请求服务器获取页面的 <code>html</code> 代码；</li>\n<li>浏览器要先在内存中，解析 <code>DOM</code> 结构，并在浏览器内存中，渲染出一棵 <code>DOM</code> 树；</li>\n<li>浏览器把 <code>DOM</code> 树，呈现到页面上；</li>\n</ol>\n</blockquote>\n<h3 id=\"Diff-算法\"><a href=\"#Diff-算法\" class=\"headerlink\" title=\"Diff 算法\"></a>Diff 算法</h3><ol>\n<li>tree diff：</li>\n</ol>\n<blockquote>\n<p>新旧两棵 <code>DOM</code> 树，逐层对比的过程，就是<code>tree diff</code>；<br>当整棵<code>DOM</code>逐层对比完毕，则所有需要被按需更新的元素，必然能够被找到；</p>\n</blockquote>\n<ol start=\"2\">\n<li>component diff：</li>\n</ol>\n<blockquote>\n<p>在进行 <code>tree diff</code> 的时候，每一层中，组件级别的对比，叫做 <code>component diff</code>；<br>如果对比前后，组件的类型相同，则<strong>暂时</strong>认为此组件不许要被更新；<br>如果对比前后，组件的类型不同，则需要移除旧组件，创建新组件，并追加到页面上；</p>\n</blockquote>\n<ol start=\"3\">\n<li>element diff：</li>\n</ol>\n<blockquote>\n<p>在进行组件对比的时候，如果两个组件的类型相同，则需要进行元素级别的对比，这叫做<code>element diff</code>；</p>\n</blockquote>\n<h2 id=\"2-React-中创建组件\"><a href=\"#2-React-中创建组件\" class=\"headerlink\" title=\"2. React 中创建组件\"></a>2. React 中创建组件</h2><h3 id=\"使用构造函数来创建组件\"><a href=\"#使用构造函数来创建组件\" class=\"headerlink\" title=\"使用构造函数来创建组件\"></a>使用构造函数来创建组件</h3><blockquote>\n<p>1、在组件中，必须要向外<code>return</code>一个合法的<code>jsx</code>创建的<code>虚拟DOM</code>元素；<br>2、如果要接收外界传递的数据，需要在<code>构造函数</code>的参数列表中使用<code>props</code>来接收；<br>3、无论是<code>vue</code>还是<code>react</code>，组件中的<code>props</code>永远都是只读<code>read-only</code>的，不能被重新赋值；<br>4、组件的名称<code>首字母</code>必须是<code>大写</code>的<br>5、省略 <code>.jsx</code> 文件名</p>\n</blockquote>\n<blockquote>\n<p>打开 <code>webpack.config.js</code>，并在导出的配置对象中，新增以下几个节点：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">  extensions: [<span class=\"string\">&quot;.js&quot;</span>, <span class=\"string\">&quot;.jsx&quot;</span>, <span class=\"string\">&quot;.json&quot;</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果在一个组件中 <code>return</code> 一个 <code>null</code>，则表示此组件是空的，什么都不会渲染</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      这是Hello组件 -- &#123;props.name&#125; -- &#123;props.age&#125; -- &#123;props.gender&#125;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;大黄&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">3</span>,</span><br><span class=\"line\">  gender: <span class=\"string\">&quot;雄性&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;Hello &#123;...user&#125; /&gt;</span><br><span class=\"line\">  &lt;/div&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;#app&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-class-关键字来创建组件\"><a href=\"#使用-class-关键字来创建组件\" class=\"headerlink\" title=\"使用 class 关键字来创建组件\"></a>使用 class 关键字来创建组件</h3><blockquote>\n<p><code>public</code>: 所有成员都可访问<br><code>private</code>: 只有当前类可访问<br><code>protected</code>: 只有当前类和其子类可访问，外部成员无法访问</p>\n</blockquote>\n<blockquote>\n<p><code>es6</code>中的<code>class关键字</code>，是实现<code>面向对象编程</code>的新形式，也叫做<code>语法糖</code></p>\n</blockquote>\n<ul>\n<li>constructor 构造器中的 super 函数</li>\n</ul>\n<blockquote>\n<p>在子类中， <code>this</code> 只能放到 <code>super</code> 之后使用<br>子类中的 <code>super</code>，其实就是父类中，<code>contructor</code>构造器的一个引用</p>\n</blockquote>\n<ul>\n<li>最基本的组件结构</li>\n</ul>\n<blockquote>\n<p><code>render</code>函数的作用：渲染当前组件所对应的<code>虚拟DOM</code> 元素</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> 组件名称 <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>这是 class 创建的组件<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>this.props 和 this.state</li>\n</ul>\n<blockquote>\n<ol>\n<li><code>this.props</code> 接收外界传递的参数，<code>this.state</code> 设置私有数据</li>\n<li>在 <code>class</code> 关键字创建的组件中，直接使用 <code>this.props</code> 访问传递过来的数据</li>\n<li><code>props</code> 是只读的</li>\n</ol>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Movie</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    <span class=\"comment\">// 这里的 this.state = &#123;&#125;，就相当于 Vue中的data() &#123; return &#123;&#125; &#125;</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">      msg: <span class=\"string\">&quot;这是Movie组件的私有数据&quot;</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 注意：在 class 组件内容，this 表示当前组件的实例对象 */</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>这是Movie组件 -- &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> user = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;大黄&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">3</span>,</span><br><span class=\"line\">  gender: <span class=\"string\">&quot;雄性&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;Movie &#123;...user&#125; /&gt;</span><br><span class=\"line\">    &lt;h3&gt;&#123;<span class=\"built_in\">this</span>.state.msg&#125;&lt;/h3&gt;</span><br><span class=\"line\">  &lt;/div&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;#app&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"两种创建组件的方式的对比\"><a href=\"#两种创建组件的方式的对比\" class=\"headerlink\" title=\"两种创建组件的方式的对比\"></a>两种创建组件的方式的对比</h3><blockquote>\n<p>使用 <code>class</code> 关键字创建的组件，有自己的 <code>私有数据(this.state)</code> 和 <code>生命周期</code><br>使用 <code>function</code> 创建的组件，只有 <code>props</code>，没有自己的 <code>私有数据</code> 和 <code>生命周期</code><br>有状态组件和无状态组件之间的 <code>本质区别</code>：有无 <code>state</code> 属性和 <code>生命周期函数</code></p>\n</blockquote>\n<h2 id=\"3-React-中-style-处理方式\"><a href=\"#3-React-中-style-处理方式\" class=\"headerlink\" title=\"3. React 中 style 处理方式\"></a>3. React 中 style 处理方式</h2><h3 id=\"内联\"><a href=\"#内联\" class=\"headerlink\" title=\"内联\"></a>内联</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">style = &#123;&#123; <span class=\"attr\">color</span>: red &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><blockquote>\n<p>1、如果直接导入 <code>css</code> 样式表，默认则是在全局上，整个项目都会生效<br>2、css 模块化，只针对 <code>class</code> 选择器 和 <code>id</code> 选择器生效<br>引用：<code>import style from &#39;./style.css&#39;</code></p>\n</blockquote>\n<h2 id=\"4-React-中事件绑定\"><a href=\"#4-React-中事件绑定\" class=\"headerlink\" title=\"4. React 中事件绑定\"></a>4. React 中事件绑定</h2><ol>\n<li>事件的名称都是 <code>React</code> 所提供的，因此名称的首字母必须大写<code>onClick</code>，<code>onMouseOver</code></li>\n<li>为事件提供的处理函数，必须是以下格式：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">onClick = &#123; <span class=\"function\"><span class=\"keyword\">function</span> &#125;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>用的最多的事件绑定形式为：</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.show(<span class=\"string\">&quot;传参&quot;</span>)&#125;&gt;按钮&lt;/button&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 事件的处理函数，需要定义为 一个箭头函数，然后赋值给 函数名称</span></span><br><span class=\"line\">show = <span class=\"function\"><span class=\"params\">arg1</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;show方法&quot;</span> + arg1);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>在 <code>React</code> 中，如果想要修改 <code>state</code> 中的数据，推荐使用 <code>this.setState(&#123; &#125;)</code></li>\n</ol>\n<blockquote>\n<p>1、在<code>setState</code>中，只会把对应的 <code>state</code>状态更新，而不会覆盖其它的 <code>state</code>状态。<br>2、<code>this.setState</code> 方法的执行时 <code>异步的</code>。<br>3、如果在调用完 <code>this.setState</code>之后，又想立即拿到最新的<code>state</code>的值，需要使用 <code>this.setState(&#123;&#125;, callback)</code>，第二个参数【回调函数】中获取。</p>\n</blockquote>\n<h2 id=\"5-单向数据流-状态变化-gt-自动更新页面\"><a href=\"#5-单向数据流-状态变化-gt-自动更新页面\" class=\"headerlink\" title=\"5. 单向数据流(状态变化 =&gt; 自动更新页面)\"></a>5. 单向数据流(状态变化 =&gt; 自动更新页面)</h2><blockquote>\n<p>1、<code>React</code> 中，默认是 <code>单向数据流</code>，只能把 <code>state</code> 上的数据绑定到页面，无法把页面中数据的变化，自动同步回 <code>state</code>；如果需要把页面上数据的变化，保存到 <code>state</code>，需要手动监听<code>onChange</code> 事件，拿到最新的数据，手动调用 <code>this.setState(&#123; &#125;)</code> 更改。<br>2、当为文本框绑定 <code>value</code> 值以后，要么同时给标签提供一个 <code>readOnly</code> 属性，要么提供一个 <code>onChange</code> 事件处理函数。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 方案一：通过事件参数 e 来获取DOM元素的引用</span></span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;text&quot;</span> value=&#123;<span class=\"built_in\">this</span>.state.msg&#125; onChange=&#123;<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">this</span>.textChanged(e)&#125; /&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">textChanged = <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.target.value);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方案二：通过ref 来获取DOM元素的引用  this.refs.引用名称</span></span><br><span class=\"line\">&lt;input type=<span class=\"string\">&quot;text&quot;</span> value=&#123;<span class=\"built_in\">this</span>.state.msg&#125; onChange=&#123;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.textChanged()&#125; ref=<span class=\"string\">&quot;txt&quot;</span> /&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">textChanged = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.refs.txt.value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-生命周期\"><a href=\"#6-生命周期\" class=\"headerlink\" title=\"6. 生命周期\"></a>6. 生命周期</h2><ul>\n<li>生命周期介绍</li>\n</ul>\n<blockquote>\n<p>每个组件的实例，从创建、到运行、直到销毁，在这个过程中，会触发一系列事件，这些事件就叫做组件的生命周期</p>\n</blockquote>\n<ul>\n<li>React 的生命周期分为三个部分</li>\n</ul>\n<ol>\n<li>组件创建阶段</li>\n</ol>\n<blockquote>\n<p>只执行一次</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>componentWillMount</code> =&gt; <code>挂载之前</code></li>\n<li><code>render</code> =&gt; <code>正在渲染，虚拟DOM创建到了内存中，还未挂载到页面上</code></li>\n<li><code>componentDidMount</code> =&gt; <code>挂载结束，需要操作DOM节点的初始化操作放在这里</code></li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>组件运行阶段：</li>\n</ol>\n<blockquote>\n<p>根据 <code>props</code> 属性或者 <code>state</code> 状态的改变，有选择性的执行 <code>0</code> 到 <code>多次</code></p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>props</code> 改变之后</li>\n<li><code>componentWillReceiveProps</code> =&gt; 当一个挂载的组件接收到新的 <code>props</code> 的时候被调用</li>\n<li><code>state</code> 改变之后</li>\n<li><code>shouldComponentUpdate（nextprops, nextState）</code> =&gt; 当组件做出是否要更新 <code>DOM</code> 的决定的时候被调用，在改变状态的时候可以选择通过( <code>return true</code> )或者不通过( <code>return false</code>)</li>\n<li><code>componentWillUpdate</code> =&gt; 在更新发生之前被调用</li>\n<li><code>render</code> =&gt; 数据是新的，页面是旧的</li>\n</ol>\n<p>7.<code>componentDidUpdate</code> =&gt; 数据是新的，页面已经变成了最新的</p>\n</blockquote>\n<ol start=\"3\">\n<li>组件销毁阶段</li>\n</ol>\n<blockquote>\n<p>只执行一次</p>\n</blockquote>\n<blockquote>\n<p><code>componentWillUnmount</code> =&gt; 组件移除或者销毁的时候被调用</p>\n</blockquote>\n<h2 id=\"7-验证数据类型\"><a href=\"#7-验证数据类型\" class=\"headerlink\" title=\"7. 验证数据类型\"></a>7. 验证数据类型</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ProtoTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;prop-types&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义组件需要传入的参数</span></span><br><span class=\"line\">MyCompo.protoTypes = &#123;</span><br><span class=\"line\">  a: ProtoTypes.string.isRequired,</span><br><span class=\"line\">  b: ProtoTypes.string.isRequired,</span><br><span class=\"line\">  c: ProtoTypes.number.isRequired</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-flux\"><a href=\"#8-flux\" class=\"headerlink\" title=\"8. flux\"></a>8. flux</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><blockquote>\n<p>传统的 <code>MVC</code> 和 <code>MVVM</code> 架构设计模式有一个致命的缺点：当项目越来越大、逻辑越来越复杂的时候，数据流动就越显得混乱。</p>\n</blockquote>\n<blockquote>\n<p><code>Flux</code> 是致力于解决数据有序传输问题的架构设计模式，来自 <code>Facebook</code>。<code>Flux</code> 中最大的哲学：数据是 <code>单向流动</code> 的。</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://github.com/facebook/flux/tree/master/examples/flux-concepts\">官方手册</a></p>\n</blockquote>\n<blockquote>\n<p><code>Flux</code> 中最重要的四个概念：<code>Dispatcher</code>、<code>Store</code>、<code>View</code>、<code>Action</code>。</p>\n</blockquote>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2020/png/732231/1608703835856-e1263bac-124a-40da-ae3c-b45a4c8081ae.png#align=left&display=inline&height=393&margin=%5Bobject%20Object%5D&name=flux.png&originHeight=393&originWidth=1300&size=26132&status=done&style=none&width=1300\" alt=\"flux.png\"></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ol>\n<li>概述<ul>\n<li><code>flux</code> 是一个管理 <code>App</code> 中数据流动的模式。</li>\n<li>最关键的概念：<code>数据的流动是单向的</code>。</li>\n</ul>\n</li>\n<li>Dispatcher 调度者<ul>\n<li><code>Dispatcher</code> 接受 <code>action</code>，并且要把这些 <code>action</code> 分派给已经注册到 <code>Dispatcher</code> 的 <code>store</code> 上</li>\n<li>所有的 <code>store</code> 都将接收所有的 <code>action</code></li>\n<li>在每个 <code>App</code> 中，应该确保只有一个 <code>Dispatcher</code> 的实例</li>\n</ul>\n</li>\n<li>store 仓库<ul>\n<li><code>store</code> 是在 <code>App</code> 中持有数据的仓库</li>\n<li>所有的 <code>store</code> 要在 <code>App</code> 的 <code>Dispatcher</code> 上注册，确保它们可以接收 <code>action</code></li>\n<li><code>store</code> 中的数据只能被 <code>action</code> 改变。</li>\n<li><code>store</code> 中不能够有公共的 <code>setter</code>，只能有 <code>getter</code></li>\n<li><code>store</code> 决定了它们愿意响应哪些 <code>actions</code></li>\n<li>无论何时，<code>store</code> 中的数据发生改变，就会触发一个 <code>change</code> 事件</li>\n<li>同一个 <code>App</code> 中可能有很多 <code>store</code></li>\n</ul>\n</li>\n<li>Action 行为<ul>\n<li><code>Action</code> 定义了 <code>App</code> 内部的 <code>API</code></li>\n<li>它们捕获所有可能改变 <code>App</code> 的途径和方法</li>\n<li>它们是简单的<code>对象</code>，并且要有 <code>type属性</code> 和 <code>其他的一些数据属性</code></li>\n<li><code>Action</code> 应该有一个具有语义的、直观的表示它是做什么的名字</li>\n<li>所有的<code>store</code>都将接收同一个<code>action</code>，并且通过这个 <code>action</code>，<code>store</code> 会知道它们要清除、更新哪些数据</li>\n</ul>\n</li>\n<li>Views 视图<ul>\n<li><code>store</code> 中的数据被展示在了<code>view</code>上</li>\n<li><code>View</code> 层可以使用任何框架</li>\n<li>当一个视图想要获取 <code>store</code> 中的数据，它必须 <code>subscribe 订阅</code> 一下该 <code>store</code> 的<code>change</code> 事件</li>\n<li>当 <code>store</code> 触发了 <code>change</code> 事件，此时 <code>view</code> 就能得到新的数据并且重新渲染</li>\n<li>如果一个组件要使用 <code>store</code>，但是没有订阅这个 <code>store</code>，此时就会出错</li>\n<li><code>Action</code> 最常见的产生原因是：在 <code>App</code> 中的某一个部分，因为用户的交互行为，而被此<code>view</code> <code>dispatch</code>出来了</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"redux\"><a href=\"#redux\" class=\"headerlink\" title=\"redux\"></a>redux</h3><ul>\n<li>简介<ul>\n<li><a href=\"https://redux.js.org/\">官网</a></li>\n<li>Redux 就是 Flux 思想在 React 中的实现</li>\n<li>Redux 是一个可预测状态的 Js app 容器</li>\n<li><a href=\"https://github.com/reactjs/redux/tree/master/examples\"><code>通过例子来学习redux</code></a></li>\n</ul>\n</li>\n<li>Redux 创建的步骤<ul>\n<li>设置一个 <code>reducer</code>；</li>\n<li>创建一个<code>store</code>，<code>Redux.createStore(reducer)</code></li>\n<li>创建 <code>render</code> 函数</li>\n<li>注册 <code>render</code>，<code>store.subscribe(render)</code></li>\n<li>监听，此时要记得 <code>store.dispatch(action)</code>，不是直接修改<code>store</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"React-Redux\"><a href=\"#React-Redux\" class=\"headerlink\" title=\"React-Redux\"></a>React-Redux</h3><ul>\n<li>简介<ul>\n<li>将 <code>react</code> 和 <code>redux</code> 合并起来，可以让任何组件在任何地方看见 <code>store</code></li>\n<li><a href=\"https://github.com/reactjs/react-redux/tree/master/docs\">官方文档</a></li>\n<li><code>React-Redux</code> 给我们提供了：<code>Provider组件</code>，<code>connect函数</code></li>\n</ul>\n</li>\n<li>Provider 组件</li>\n</ul>\n<blockquote>\n<p>1、使用 <code>react-redux</code> 提供的 <code>Provider</code> 组件传递 <code>store</code> 上下文之后，<code>包裹在其中的所有组件</code> 全都可以识别这个上下文</p>\n</blockquote>\n<blockquote>\n<p>2、在 <code>Provider</code> 组件内部的自定义组件可以使用 <code>connect()</code> 函数，但是在其外部的不可使用</p>\n</blockquote>\n<ul>\n<li>connect 函数</li>\n</ul>\n<blockquote>\n<p>1、将 <code>React组件</code> 和 <code>Redux</code> 的 <code>store</code> 进行连接<br>2、<code>connect</code> 提供了一个很方便的 <code>API</code> 能够适应绝大多数工作<br>3、它没有更改你传进来的类，反而会返回一个已经连接好的新类<br>4、提供了两个参数：<code>mapStateToProps</code>, <code>mapDispatchToProps</code></p>\n</blockquote>\n<ul>\n<li>mapStateToProps</li>\n</ul>\n<blockquote>\n<p>1、如果传入<code>mapStateToProps</code>，此时这个组件将订阅 <code>Redux</code> 中 <code>store</code> 的更新信息；<br>2、这意味着无论任何时候 <code>store</code> 被更改了，<code>mapStateToProps</code> 函数都将会被调用，<code>mapStateToProps</code> 的返回值必须是一个 <code>Object</code>；<br>3、这个 <code>Object</code> 将与组件的 <code>props</code> 融合，也就是说，这个返回的 <code>Object</code> 中的 <code>key</code> 将自动成为组件的 <code>props</code> 中的成员<br>4、如果不想订阅 <code>store</code> 的更新，此时可以不传递这个参数，采用 <code>null</code> 占位</p>\n</blockquote>\n<ul>\n<li>mapDispatchToProps</li>\n</ul>\n<blockquote>\n<p>如果向 <code>connect</code> 函数中传入了第二个参数，并且是一个 <code>函数</code>，那么这个函数将获得<code>dispatch</code> 方法，该方法可以通过 <code>emit action</code>，间接的导致 <code>state</code> 的改变<br>可以使用 <code>bindActionCreators()</code> 方法轻松的将 <code>Action creator</code>(返回 <code>action</code> 的函数)接口和 <code>dispatch</code> 进行绑定</p>\n</blockquote>\n<ul>\n<li>书写规则</li>\n</ul>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;./containers/App&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">&quot;./reducers&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer);</span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;root&quot;</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>App.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">&quot;./actions&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(props);</span><br><span class=\"line\">    <span class=\"comment\">// props: &#123; r: 0, g: 0, b: 0, actions: 许多方法 &#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>这是App组件<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    r: state.r,</span><br><span class=\"line\">    g: state.g,</span><br><span class=\"line\">    b: state.b</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    actions: bindActionCreators(actions, dispatch)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(App);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>reducer.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (state, action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (state == <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    state = &#123; <span class=\"attr\">r</span>: <span class=\"number\">0</span>, <span class=\"attr\">g</span>: <span class=\"number\">0</span>, <span class=\"attr\">b</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (action.type == <span class=\"string\">&quot;ADD&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...state,</span><br><span class=\"line\">      r: state.r + <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>actions.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD = <span class=\"function\">() =&gt;</span> &#123; <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;ADD&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件内部的-state-和全局的-state\"><a href=\"#组件内部的-state-和全局的-state\" class=\"headerlink\" title=\"组件内部的 state 和全局的 state\"></a>组件内部的 state 和全局的 state</h3><blockquote>\n<p>组件的数据三兄弟：<code>state</code>, <code>props</code>, <code>context</code> 不管是谁发生改变，都会引发 <code>render()</code> 执行，视图会被重绘。但是，构造函数不会被重新执行。所以不管基于什么理由，都不需要将全局的状态，用自己组件的 <code>state</code> 接收，而仅需要用<code>connect</code>连接一下全局<code>store</code>，然后使用<code>this.props.**</code>即可。</p>\n</blockquote>\n<h3 id=\"reducer-模块化\"><a href=\"#reducer-模块化\" class=\"headerlink\" title=\"reducer 模块化\"></a>reducer 模块化</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todoReducers <span class=\"keyword\">from</span> <span class=\"string\">&quot;./todoReducer.js&quot;</span>; <span class=\"comment\">// 标准reducer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">  todoReducers</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"redux-logger\"><a href=\"#redux-logger\" class=\"headerlink\" title=\"redux-logger\"></a>redux-logger</h3><blockquote>\n<p>打印 redux log</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createLogger &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;redux-logger&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">&quot;./reducers/index.js&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer, applyMiddleware(createLogger()));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"redux-thunk\"><a href=\"#redux-thunk\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h3><blockquote>\n<p>解决异步问题</p>\n</blockquote>\n<blockquote>\n<p><code>redux-thunk</code>帮助我们在所有的组件的 <code>props</code> 中添加了一个 <code>dispatch</code> 方法。</p>\n</blockquote>\n<blockquote>\n<p>当然，这个组件一定要被 <code>connect</code> 函数进行处理</p>\n</blockquote>\n<blockquote>\n<p>注意，如果使用 <code>thunk</code>，则 <code>connect</code> 函数不能传入第二个参数，否则会导致无法获取 <code>this.props.dispatch()</code></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 入口文件</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">&#x27;redux-thunk&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer, applyMiddleware(thunk))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** 组件中 */</span></span><br><span class=\"line\"><span class=\"comment\">/** 第一种写法，并没有将actions进行抽离 */</span></span><br><span class=\"line\">$.get(<span class=\"string\">&#x27;/shu.txt&#x27;</span>, <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> number = <span class=\"built_in\">Number</span>(data);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.props.dispatch(&#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;ADD&quot;</span>,</span><br><span class=\"line\">        number</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">/** 第二种写法:常用 */</span></span><br><span class=\"line\"><span class=\"comment\">// 可枚举</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actions <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./actions/actions.js&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> ** <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.props.dispatch(actions.add())</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.props.dispatch(actions.minus())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/** 现在，一般不会再写第二个参数了，就是说省略掉mapDispatchToProps */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</span><br><span class=\"line\"> (state) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        state: state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> &#125;)(**)</span><br><span class=\"line\"><span class=\"comment\">// actions.js</span></span><br><span class=\"line\"><span class=\"comment\">/* 现在，异步的Action Creator不要直接返回 Action，而是返回一个携带 dispatch 的函数；这个函数相当于“延长”了dispatch的持续时间。*/</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> add = <span class=\"function\">() =&gt;</span> <span class=\"function\">(<span class=\"params\">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(getState()) <span class=\"comment\">// getState可以获取全局数据</span></span><br><span class=\"line\">    $.get(<span class=\"string\">&#x27;/shu.txt&#x27;</span>, <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> number = <span class=\"built_in\">Number</span>(data);</span><br><span class=\"line\">        dispatch(&#123;<span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;MINUS&quot;</span>, number&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> minus = <span class=\"function\">() =&gt;</span> &#123; <span class=\"string\">&quot;type&quot;</span>: <span class=\"string\">&quot;MINUS&quot;</span> &#125;</span><br><span class=\"line\"><span class=\"comment\">// reducer.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (state = <span class=\"number\">0</span>, action) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;ADD&quot;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state + action.number</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&quot;MINUS&quot;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-react-router4-x\"><a href=\"#9-react-router4-x\" class=\"headerlink\" title=\"9. react-router4.x\"></a>9. react-router4.x</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><ul>\n<li><a href=\"https://reacttraining.com/react-router\">官网</a></li>\n<li>安装：<code>npm install react-router-dom</code></li>\n</ul>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><blockquote>\n<p><code>exact</code>表示严格匹配，如果路径为 <code>path=&quot;/&quot;</code> 的 <code>Route</code> 不设置该属性，则会自动向下匹配路由，即都会显示出来</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter <span class=\"keyword\">as</span> Router, Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router-dom&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Index</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Home<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">About</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>About<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Users</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h2</span>&gt;</span>Users<span class=\"tag\">&lt;/<span class=\"name\">h2</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">AppRouter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;Router&gt;</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;nav&gt;</span><br><span class=\"line\">          &lt;ul&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">              &lt;Link to=<span class=\"string\">&quot;/&quot;</span>&gt;Home&lt;/Link&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">              &lt;Link to=<span class=\"string\">&quot;/about/&quot;</span>&gt;About&lt;/Link&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">            &lt;li&gt;</span><br><span class=\"line\">              &lt;Link to=<span class=\"string\">&quot;/users/&quot;</span>&gt;Users&lt;/Link&gt;</span><br><span class=\"line\">            &lt;/li&gt;</span><br><span class=\"line\">          &lt;/ul&gt;</span><br><span class=\"line\">        &lt;/nav&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;Route path=<span class=\"string\">&quot;/&quot;</span> exact component=&#123;Index&#125; /&gt;</span><br><span class=\"line\">        &lt;Route path=<span class=\"string\">&quot;/about/&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class=\"line\">        &lt;Route path=<span class=\"string\">&quot;/users/&quot;</span> component=&#123;Users&#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    &lt;/Router&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> AppRouter;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"动态路由\"><a href=\"#动态路由\" class=\"headerlink\" title=\"动态路由\"></a>动态路由</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.js 定义动态路由</span></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">&quot;/content/:aid&quot;</span>&gt;&lt;/Route&gt;</span><br><span class=\"line\"><span class=\"comment\">// news.js 跳转</span></span><br><span class=\"line\">&lt;Link to=&#123;<span class=\"string\">`/content/<span class=\"subst\">$&#123;value.aid&#125;</span>`</span>&#125;&gt;&lt;/Link&gt;</span><br><span class=\"line\"><span class=\"comment\">// Content.js 跳在生命周期函数中获取动态路由参数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Content</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> &#123; match &#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">          <span class=\"comment\">// 获取到传递的动态路由参数</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(match.params.aid)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-传值\"><a href=\"#get-传值\" class=\"headerlink\" title=\"get 传值\"></a>get 传值</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.js 定义动态路由</span></span><br><span class=\"line\">&lt;Route path=<span class=\"string\">&quot;/content&quot;</span>&gt;&lt;/Route&gt;</span><br><span class=\"line\"><span class=\"comment\">// news.js 跳转</span></span><br><span class=\"line\">&lt;Link to=&#123;<span class=\"string\">`/content?aid=<span class=\"subst\">$&#123;value.aid&#125;</span>`</span>&#125;&gt;&lt;/Link&gt;</span><br><span class=\"line\"><span class=\"comment\">// Content.js 跳在生命周期函数中获取动态路由参数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Content</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">      <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> &#123; location &#125; = <span class=\"built_in\">this</span>.props</span><br><span class=\"line\">          <span class=\"comment\">// 获取到传递的动态路由参数</span></span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(location.search)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"js-控制跳转\"><a href=\"#js-控制跳转\" class=\"headerlink\" title=\"js 控制跳转\"></a>js 控制跳转</h3><ol>\n<li>引入 <code>Redirect</code> 组件</li>\n<li>定义一个 <code>flag</code></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">  loginFlag: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在 <code>Render</code> 中判断 <code>flag</code>，从而来决定是否进行跳转</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.state.loginFlag) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Redirect</span> <span class=\"attr\">to</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">pathname:</span> &quot;/&quot; &#125;&#125; /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>执行 <code>js</code> 跳转，通过 <code>js</code> 改变 <code>loginFlag</code> 的状态，改变以后，就可以从新的 <code>render</code> 中通过 <code>Redirect</code> 自己进行跳转</li>\n</ol>\n<h3 id=\"模块化路由\"><a href=\"#模块化路由\" class=\"headerlink\" title=\"模块化路由\"></a>模块化路由</h3><blockquote>\n<p>router.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Home <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/Home/&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> About <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/About/&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> User <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/User/&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> UserList <span class=\"keyword\">from</span> <span class=\"string\">&quot;./User/UserList&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> UserInfo <span class=\"keyword\">from</span> <span class=\"string\">&quot;./User/UserInfo&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> router = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: <span class=\"string\">&quot;/&quot;</span>,</span><br><span class=\"line\">    component: Home,</span><br><span class=\"line\">    exact: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: <span class=\"string\">&quot;/about&quot;</span>,</span><br><span class=\"line\">    component: About</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    path: <span class=\"string\">&quot;/User&quot;</span>,</span><br><span class=\"line\">    component: User,</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      <span class=\"comment\">// 嵌套路由设置</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: <span class=\"string\">&quot;/user/&quot;</span>,</span><br><span class=\"line\">        component: UserList</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        path: <span class=\"string\">&quot;/user/info&quot;</span>,</span><br><span class=\"line\">        component: UserInfo</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> router;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>App.js 入口文件</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter <span class=\"keyword\">as</span> Router, Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> router <span class=\"keyword\">from</span> <span class=\"string\">&quot;./router.js&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Router&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;router.map(<span class=\"function\">(<span class=\"params\">route, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (route.exact) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;Route</span><br><span class=\"line\">                  exact</span><br><span class=\"line\">                  key=&#123;key&#125;</span><br><span class=\"line\">                  path=&#123;route.path&#125;</span><br><span class=\"line\">                  render=&#123;<span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">                    <span class=\"comment\">// 向子组件传递子路由</span></span><br><span class=\"line\">                    &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt;</span><br><span class=\"line\">                  )&#125;</span><br><span class=\"line\">                /&gt;</span><br><span class=\"line\">              );</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> (</span><br><span class=\"line\">                &lt;Route</span><br><span class=\"line\">                  key=&#123;key&#125;</span><br><span class=\"line\">                  path=&#123;route.path&#125;</span><br><span class=\"line\">                  render=&#123;<span class=\"function\"><span class=\"params\">props</span> =&gt;</span> (</span><br><span class=\"line\">                    <span class=\"comment\">// 向子组件传递子路由</span></span><br><span class=\"line\">                    &lt;route.component &#123;...props&#125; routes=&#123;route.routes&#125; /&gt;</span><br><span class=\"line\">                  )&#125;</span><br><span class=\"line\">                /&gt;</span><br><span class=\"line\">              );</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)&#125;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/Router&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>User.js</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Route, Link &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router-dom&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentWillMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.props.routes);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div className=<span class=\"string\">&quot;contenr&quot;</span>&gt;</span><br><span class=\"line\">          &lt;div className=<span class=\"string\">&quot;left&quot;</span>&gt;</span><br><span class=\"line\">            &lt;Link /&gt;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">          &lt;div className=<span class=\"string\">&quot;right&quot;</span>&gt;</span><br><span class=\"line\">            &#123;<span class=\"built_in\">this</span>.props.routes.map(<span class=\"function\">(<span class=\"params\">route, key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Route</span> <span class=\"attr\">exact</span> <span class=\"attr\">key</span>=<span class=\"string\">&#123;key&#125;</span> <span class=\"attr\">path</span>=<span class=\"string\">&#123;route.path&#125;</span> <span class=\"attr\">component</span>=<span class=\"string\">&#123;route.component&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">            &#125;)&#125;</span><br><span class=\"line\">          &lt;/div&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> User;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用路由组件\"><a href=\"#常用路由组件\" class=\"headerlink\" title=\"常用路由组件\"></a>常用路由组件</h3><ul>\n<li>_BrowserRouter_：使用 <code>HTML5</code> 历史记录 <code>API</code> (<code>pushState</code>，<code>replaceState</code> 和<code>popstate</code> 事件)的 <code>&lt;Router&gt;</code> 来保持 <code>UI</code> 与 <code>URL</code> 的同步</li>\n<li>_HashRouter_：使用 <code>URL</code> 的哈希部分(即 <code>window.location.hash</code> )的&lt;路由器&gt;可以保持您的 <code>UI</code> 与 <code>URL</code> 同步。注意：哈希历史记录不支持 <code>location.key</code> 或 <code>location.state</code>。 在以前的版本中，我们试图缓和行为，但是有一些边缘案例我们无法解决。 任何需要此行为的代码或插件将无法正常工作。 由于此技术仅用于支持旧版浏览器，因此我们建议您将服务器配置为使用<code>&lt;BrowserHistory&gt;</code></li>\n<li>_Link_：渲染成 <code>a</code> 标签</li>\n<li>_NavLink_：一种特殊版本的 <code>&lt;Link&gt;</code>，当与当前 <code>URL</code> 匹配时，将向渲染元素添加样式属性。</li>\n<li>_Redirect_：重定向</li>\n<li>_Route_：在位置与路线的路径匹配时呈现一些 <code>UI</code>。</li>\n<li>_Switch_：只渲染命中的第一个 <code>&lt;Route&gt;</code> 或 <code>&lt;Redirect&gt;</code> 。</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Switch的用法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Switch, Route &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-router&quot;</span>;</span><br><span class=\"line\">&lt;Switch&gt;</span><br><span class=\"line\">  &lt;Route exact path=<span class=\"string\">&quot;/&quot;</span> component=&#123;Home&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">&quot;/about&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class=\"line\">  &lt;Route path=<span class=\"string\">&quot;/:user&quot;</span> component=&#123;User&#125; /&gt;</span><br><span class=\"line\">  &lt;Route component=&#123;NoMatch&#125; /&gt;</span><br><span class=\"line\">&lt;/Switch&gt;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-context\"><a href=\"#10-context\" class=\"headerlink\" title=\"10. context\"></a>10. context</h2><ul>\n<li>介绍</li>\n</ul>\n<blockquote>\n<p>在一个典型的 <code>React</code> 应用中，数据是通过 <code>props</code> 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，<code>UI</code> 主题），这些属性是应用程序中许多组件都需要的。<code>Context</code> 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 <code>props</code>。</p>\n</blockquote>\n<ul>\n<li>繁琐的 <code>props</code> 方式</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Toolbar</span> <span class=\"attr\">theme</span>=<span class=\"string\">&quot;dark&quot;</span> /&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Toolbar</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;ThemeButton theme=&#123;props.theme&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThemeButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    &lt;Button theme=&#123;<span class=\"built_in\">this</span>.props.theme&#125;&gt;按钮&lt;/Button&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>context</code></li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span></span><br><span class=\"line\"><span class=\"comment\">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ThemeContext = React.createContext(<span class=\"string\">&quot;light&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class=\"line\">    <span class=\"comment\">// 无论多深，任何组件都能读取这个值。</span></span><br><span class=\"line\">    <span class=\"comment\">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ThemeContext.Provider value=<span class=\"string\">&quot;dark&quot;</span>&gt;</span><br><span class=\"line\">        &lt;Toolbar /&gt;</span><br><span class=\"line\">      &lt;/ThemeContext.Provider&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ToolBar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;ThemeButton /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThemeButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 指定 contextType 读取当前的 theme context。</span></span><br><span class=\"line\">  <span class=\"comment\">// React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class=\"line\">  <span class=\"comment\">// 在这个例子中，当前的 theme 值为 “dark”。</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> contextType = ThemeContext;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Button</span> <span class=\"attr\">theme</span>=<span class=\"string\">&#123;this.context&#125;</span>&gt;</span>按钮<span class=\"tag\">&lt;/<span class=\"name\">Button</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-react-hooks\"><a href=\"#11-react-hooks\" class=\"headerlink\" title=\"11. react-hooks\"></a>11. react-hooks</h2><blockquote>\n<p><code>Hook</code> 是 <code>React 16.8</code> 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性。</p>\n</blockquote>\n<h3 id=\"11-1-State-Hook\"><a href=\"#11-1-State-Hook\" class=\"headerlink\" title=\"11.1 State Hook\"></a>11.1 State Hook</h3><blockquote>\n<p><code>useState</code> 就是一个 <code>Hook</code>，类似 <code>class</code> 组件的 <code>this.setState</code>，但是它不会把新的 <code>state</code> 和旧的 <code>state</code> 进行合并。<code>useState</code> 会返回一对值：<em>当前状态</em> 和一个让你 _更新它的函数_，你可以在事件处理函数中或其他一些地方调用这个函数。</p>\n</blockquote>\n<ul>\n<li>计数器</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明一个叫 “count” 的 state 变量。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> setCount(count + <span class=\"number\">1</span>)&#125;&gt;Click me&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价的 class 示例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;You clicked &#123;<span class=\"built_in\">this</span>.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.setState(&#123; <span class=\"attr\">count</span>: <span class=\"built_in\">this</span>.state.count + <span class=\"number\">1</span> &#125;)&#125;&gt;Click me&lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>声明多个 <code>state</code> 变量</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ExampleWithManyStates</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明多个 state 变量！</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [age, setAge] = useState(<span class=\"number\">42</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [fruit, setFruit] = useState(<span class=\"string\">&quot;banana&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [todos, setTodos] = useState([&#123; <span class=\"attr\">text</span>: <span class=\"string\">&quot;Learn Hooks&quot;</span> &#125;]);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>什么是 <code>Hook</code></li>\n</ul>\n<blockquote>\n<p><code>Hook</code> 是一些可以让你在函数组件里“钩入” <code>React state</code> 及生命周期等特性的函数。<code>Hook</code> 不能在 <code>class</code> 组件中使用 —— 这使得你不使用 <code>class</code> 也能使用 <code>React</code>。</p>\n</blockquote>\n<ul>\n<li>惰性 state</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [state, setState] = useState(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> initialState = someExpensiveComputation(props);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> initialState;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-2-Effect-Hook\"><a href=\"#11-2-Effect-Hook\" class=\"headerlink\" title=\"11.2 Effect Hook\"></a>11.2 Effect Hook</h3><blockquote>\n<p><code>Effect Hook</code> 可以让你在函数组件中执行副作用操作</p>\n</blockquote>\n<h4 id=\"1-无需清除的-Effect\"><a href=\"#1-无需清除的-Effect\" class=\"headerlink\" title=\"(1) 无需清除的 Effect\"></a>(1) 无需清除的 <code>Effect</code></h4><blockquote>\n<p>有时候，我们只想在 <code>React</code> 更新 <code>DOM</code> 之后运行一些额外的代码。比如发送网络请求，手动变更 <code>DOM</code>，记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p>\n</blockquote>\n<ul>\n<li>使用 <code>class</code> 的示例</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.title = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.state.count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidUpdate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.title = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.state.count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;p&gt;You clicked &#123;<span class=\"built_in\">this</span>.state.count&#125; times&lt;/p&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">this</span>.setState(&#123; <span class=\"attr\">count</span>: <span class=\"built_in\">this</span>.state.count + <span class=\"number\">1</span> &#125;)&#125;&gt;Click me&lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>Hook</code> 的示例</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.title = <span class=\"string\">`You clicked <span class=\"subst\">$&#123;count&#125;</span> times`</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> setCount(count + <span class=\"number\">1</span>)&#125;&gt;Click me&lt;/button&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>useEffect</code> 做了什么？ 通过使用这个 <code>Hook</code>，你可以告诉 <code>React</code> 组件需要在渲染后执行某些操作。<code>React</code> 会保存你传递的函数（我们将它称之为 “<code>effect</code>”），并且在执行 <code>DOM</code> 更新之后调用它。在这个 <code>effect</code> 中，我们设置了 <code>document</code> 的 <code>title</code> 属性，不过我们也可以执行数据获取或调用其他命令式的 API。</p>\n</blockquote>\n<blockquote>\n<p>为什么在组件内部调用 <code>useEffect</code>？ 将 <code>useEffect</code> 放在组件内部让我们可以在 <code>effect</code> 中直接访问 <code>count</code> <code>state</code> 变量（或其他 <code>props</code>）。我们不需要特殊的 <code>API</code> 来读取它 —— 它已经保存在函数作用域中。<code>Hook</code> 使用了 <code>JavaScript</code> 的闭包机制，而不用在 <code>JavaScript</code> 已经提供了解决方案的情况下，还引入特定的 React API。</p>\n</blockquote>\n<blockquote>\n<p><code>useEffect</code> 会在每次渲染后都执行吗？ 是的，默认情况下，它在第一次渲染之后和每次更新之后都会执行。（我们稍后会谈到如何控制它。）你可能会更容易接受 <code>effect</code> 发生在“渲染之后”这种概念，不用再去考虑“挂载”还是“更新”。<code>React</code> 保证了每次运行 <code>effect</code> 的同时，<code>DOM</code> 都已经更新完毕。</p>\n</blockquote>\n<div class=\"tag-plugin note\"><div class=\"title\"><strong>warning,</strong></div><div class=\"body\"><p>与 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 不同，使用 <code>useEffect</code> 调度的 <code>effect</code> 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，<code>effect</code> 不需要同步地执行。在个别情况下（例如测量布局），有单独的 <code>useLayoutEffect Hook</code> 供你使用，其 <code>API</code> 与 <code>useEffect</code> 相同。</p></div></div>\n\n<h4 id=\"2-需要清除的-Effect\"><a href=\"#2-需要清除的-Effect\" class=\"headerlink\" title=\"(2) 需要清除的 Effect\"></a>(2) 需要清除的 <code>Effect</code></h4><blockquote>\n<p>之前，我们研究了如何使用不需要清除的副作用，还有一些副作用是需要清除的。例如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！现在让我们来比较一下如何用 <code>Class</code> 和 <code>Hook</code> 来实现。</p>\n</blockquote>\n<ul>\n<li>使用 <code>class</code> 的示例</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FriendStatus</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state = &#123; <span class=\"attr\">isOnline</span>: <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.handleStatusChange = <span class=\"built_in\">this</span>.handleStatusChange.bind(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(<span class=\"built_in\">this</span>.props.friend.id, <span class=\"built_in\">this</span>.handleStatusChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">componentWillUnmount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    ChatAPI.unsubscribeFromFriendStatus(<span class=\"built_in\">this</span>.props.friend.id, <span class=\"built_in\">this</span>.handleStatusChange);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">handleStatusChange</span>(<span class=\"params\">status</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.setState(&#123;</span><br><span class=\"line\">      isOnline: status.isOnline</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.state.isOnline === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;Loading...&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.state.isOnline ? <span class=\"string\">&quot;Online&quot;</span> : <span class=\"string\">&quot;Offline&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>Hook</code> 的示例</li>\n</ul>\n<div class=\"tag-plugin note\"><div class=\"title\"><strong>warning,</strong></div><div class=\"body\"><p>眼尖的读者可能已经注意到了，这个示例还需要编写 componentDidUpdate 方法才能保证完全正确。我们先暂时忽略这一点，本章节中后续部分会介绍它。</p></div></div>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FriendStatus</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [isOnline, setIsOnline] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleStatusChange</span>(<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">      setIsOnline(status.isOnline);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    <span class=\"comment\">// Specify how to clean up after this effect:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cleanup</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isOnline === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Loading...&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isOnline ? <span class=\"string\">&quot;Online&quot;</span> : <span class=\"string\">&quot;Offline&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为什么要在 <code>effect</code> 中返回一个函数？ 这是 <code>effect</code> 可选的清除机制。每个 <code>effect</code> 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 <code>effect</code> 的一部分。</p>\n</blockquote>\n<blockquote>\n<p><code>React</code> 何时清除 <code>effect</code>？ <code>React</code> 会在组件卸载的时候执行清除操作。正如之前学到的，<code>effect</code> 在每次渲染的时候都会执行。这就是为什么 <code>React</code> 会在执行当前 <code>effect</code> 之前对上一个 <code>effect</code> 进行清除。我们稍后将讨论为什么这将助于避免 <code>bug</code> 以及如何在遇到性能问题时跳过此行为。</p>\n</blockquote>\n<div class=\"tag-plugin note\"><div class=\"title\"><strong>warning,</strong></div><div class=\"body\"><p>并不是必须为 <code>effect</code> 中返回的函数命名。这里我们将其命名为 <code>cleanup</code> 是为了表明此函数的目的，但其实也可以返回一个箭头函数或者给起一个别的名字。</p></div></div>\n\n<h3 id=\"11-3-Hook-规则\"><a href=\"#11-3-Hook-规则\" class=\"headerlink\" title=\"11.3 Hook 规则\"></a>11.3 Hook 规则</h3><h4 id=\"1-只在最顶层使用-Hook\"><a href=\"#1-只在最顶层使用-Hook\" class=\"headerlink\" title=\"(1) 只在最顶层使用 Hook\"></a>(1) 只在最顶层使用 <code>Hook</code></h4><blockquote>\n<p>不要在循环，条件或嵌套函数中调用 <code>Hook</code>， 确保总是在你的 <code>React</code> 函数的最顶层调用他们。遵守这条规则，你就能确保 <code>Hook</code> 在每一次渲染中都按照同样的顺序被调用。这让 <code>React</code> 能够在多次的 <code>useState</code> 和 <code>useEffect</code> 调用之间保持 <code>hook</code> 状态的正确。</p>\n</blockquote>\n<h4 id=\"2-只在-React-函数中调用-Hook\"><a href=\"#2-只在-React-函数中调用-Hook\" class=\"headerlink\" title=\"(2) 只在 React 函数中调用 Hook\"></a>(2) 只在 <code>React</code> 函数中调用 <code>Hook</code></h4><blockquote>\n<p>不要在普通的 <code>JavaScript</code> 函数中调用 <code>Hook</code>。你可以：</p>\n</blockquote>\n<ul>\n<li>✅ 在 <code>React</code> 的函数组件中调用 <code>Hook</code></li>\n<li>✅ 在自定义 <code>Hook</code> 中调用其他 <code>Hook</code></li>\n</ul>\n<h3 id=\"11-4-自定义-Hook\"><a href=\"#11-4-自定义-Hook\" class=\"headerlink\" title=\"11.4 自定义 Hook\"></a>11.4 自定义 Hook</h3><blockquote>\n<p>通过自定义 <code>Hook</code>，可以将组件逻辑提取到可重用的函数中。</p>\n</blockquote>\n<h4 id=\"1-提取自定义-Hook\"><a href=\"#1-提取自定义-Hook\" class=\"headerlink\" title=\"(1) 提取自定义 Hook\"></a>(1) 提取自定义 <code>Hook</code></h4><blockquote>\n<p>当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。而组件和 <code>Hook</code> 都是函数，所以也同样适用这种方式。</p>\n</blockquote>\n<blockquote>\n<p>自定义 <code>Hook</code> 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 <code>Hook</code>。 例如，下面的 <code>useFriendStatus</code> 是我们第一个自定义的 <code>Hook</code>:</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">useFriendStatus</span>(<span class=\"params\">friendID</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [isOnline, setIsOnline] = useState(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleStatusChange</span>(<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">      setIsOnline(status.isOnline);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> isOnline;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-使用自定义-Hook\"><a href=\"#2-使用自定义-Hook\" class=\"headerlink\" title=\"(2) 使用自定义 Hook\"></a>(2) 使用自定义 <code>Hook</code></h4><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FriendStatus</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isOnline === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Loading...&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> isOnline ? <span class=\"string\">&quot;Online&quot;</span> : <span class=\"string\">&quot;Offline&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FriendListItem</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isOnline = useFriendStatus(props.friend.id);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">color:</span> <span class=\"attr\">isOnline</span> ? &quot;<span class=\"attr\">green</span>&quot; <span class=\"attr\">:</span> &quot;<span class=\"attr\">black</span>&quot; &#125;&#125;&gt;</span>&#123;props.friend.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-5-Hook-API-索引\"><a href=\"#11-5-Hook-API-索引\" class=\"headerlink\" title=\"11.5 Hook API 索引\"></a>11.5 Hook API 索引</h3><blockquote>\n<p>参见 <a href=\"https://react.docschina.org/docs/hooks-reference.html\">Hook API</a></p>\n</blockquote>\n<h4 id=\"11-5-1-基础-Hook\"><a href=\"#11-5-1-基础-Hook\" class=\"headerlink\" title=\"11.5.1 基础 Hook\"></a>11.5.1 基础 Hook</h4><h5 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h5><blockquote>\n<p><a href=\"#linkUseState\">点击跳转</a></p>\n</blockquote>\n<h5 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h5><blockquote>\n<p><a href=\"#linkUseEffect\">点击跳转</a></p>\n</blockquote>\n<h5 id=\"useContext\"><a href=\"#useContext\" class=\"headerlink\" title=\"useContext\"></a>useContext</h5><blockquote>\n<p>订阅 <code>context</code> 的变化，感觉就是对于获取 <code>context</code> 的值换了一种写法而已。相对于之前的写法，在函数组件中添加 <code>context</code> 更加简单。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> context = React.createContext(&#123;&#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; Provider, Consumer  &#125; = context;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// hooks的写法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;Provider value=&#123;&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;li&#x27;</span> &#125;&#125;&gt;</span><br><span class=\"line\">            &lt;Hello/&gt;</span><br><span class=\"line\">        &lt;/Provider&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = useContext(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>value: &#123;value.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原本的写法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span> (<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span> (<span class=\"params\">&#123;name&#125;</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>value: &#123;value.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;Consumer&gt;</span><br><span class=\"line\">        &#123;render&#125;</span><br><span class=\"line\">      &lt;/Consumer&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-5-2-额外的-Hook\"><a href=\"#11-5-2-额外的-Hook\" class=\"headerlink\" title=\"11.5.2 额外的 Hook\"></a>11.5.2 额外的 Hook</h4><h5 id=\"useReducer\"><a href=\"#useReducer\" class=\"headerlink\" title=\"useReducer\"></a>useReducer</h5><blockquote>\n<p>类似于 <code>redux</code> 那样的状态更新方案。使用场景（基本上就是 <code>redux</code> 的应用场景），管理的状态值是对象，并且键值较多。<code>state</code> 每个 <code>key</code> 修改的逻辑比较复杂，需要单独放到一个文件里面管理。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initialState = &#123; <span class=\"attr\">count</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer</span>(<span class=\"params\">state, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;increment&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; <span class=\"attr\">count</span>: state.count + <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;decrement&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; <span class=\"attr\">count</span>: state.count - <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      Count: &#123;state.count&#125;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;increment&quot;</span> &#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class=\"line\">      &lt;button onClick=&#123;<span class=\"function\">() =&gt;</span> dispatch(&#123; <span class=\"attr\">type</span>: <span class=\"string\">&quot;decrement&quot;</span> &#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"useCallback\"><a href=\"#useCallback\" class=\"headerlink\" title=\"useCallback\"></a>useCallback</h5><blockquote>\n<p>仅在指定的依赖项发生变化时，会返回一个新的函数引用，函数体并没有发生变化。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoizedCallback = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  doSomething(a, b);</span><br><span class=\"line\">&#125;, [a, b]);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这样使用的好处：不会在每次组件 <code>render</code> 的时候，重新生成一个函数，节省开销。例如</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cacheCallback = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    doSomething(a, b);</span><br><span class=\"line\">  &#125;, [a, b]);</span><br><span class=\"line\">  <span class=\"comment\">// 和下面这样的形式相比, 每次组件渲染的时候，都会重新创建一个 doSometing 函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSometing</span>(<span class=\"params\">a, b</span>) </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以保持函数的引用保持不变。我们都知道在类组件，事件处理函数基本上都是通过 <code>this.method</code> 的方式绑定的，这样做的方式有一个好处，对方法的引用一直保持不变。 那么在函数组件就可以通过使用 <code>useCallback</code> 来实现。</p>\n</blockquote>\n<blockquote>\n<p>可以实现在子组件把该回调作为依赖处理。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cacheCallback = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    doSometing(a, b);</span><br><span class=\"line\">  &#125;, [a, b]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Child</span> <span class=\"attr\">handler</span>=<span class=\"string\">&#123;cacheCallback&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">&#123; handler &#125;</span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    handler();</span><br><span class=\"line\">  &#125;, [handler]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h5><blockquote>\n<p>类似于 <code>vue</code> 的 <code>computed</code>，在依赖发生变化的时候重新计算缓存值。其实自己实现起来也很容易，和 <code>vue</code> 的计算属性不同的是，<code>vue</code> 的计算属性是自动收集依赖的，而使用 <code>useMeno</code> 需要手动在数组种传入依赖项。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoizedValue = useMemo(<span class=\"function\">() =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></p>\n</blockquote>\n<h5 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h5><blockquote>\n<p>故名思义，该 <code>hook</code> 主要是用来获取组件实例或者或者 <code>dom</code> 节点。 但是它更有用的地方，是可以返回一个在组件生命周期内，引用不变的对象。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> elRef = uesRef(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;elRef&#125;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>用来存储数据的话，考虑下面的场景。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> handler = <span class=\"function\">() =&gt;</span> &#123;&#125;; <span class=\"comment\">// 事件处理函数</span></span><br><span class=\"line\"><span class=\"comment\">// 不使用 useRef, 可以使用函数外部的一个变量来存储数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, handler);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> moveScroll = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">&quot;scorll&quot;</span>, handler);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div onClick=&#123;moveScroll&#125; ref=&#123;elRef&#125;&gt;</span><br><span class=\"line\">      移除scroll监听</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用useRef的版本，可以使代码更加内聚。但是前提是必须要理解useRef这个hooks。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> handler = useRef(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  handler.current = <span class=\"function\">() =&gt;</span> &#123;&#125;; <span class=\"comment\">// 事件处理</span></span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&quot;scroll&quot;</span>, handler.current);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> moveScroll = useCallback(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.removeEventListener(<span class=\"string\">&quot;scorll&quot;</span>, handler.current);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div onClick=&#123;moveScroll&#125; ref=&#123;elRef&#125;&gt;</span><br><span class=\"line\">      移除scroll监听</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"useImperativeHandle\"><a href=\"#useImperativeHandle\" class=\"headerlink\" title=\"useImperativeHandle\"></a>useImperativeHandle</h5><blockquote>\n<p><code>useImperativeHandle</code> 可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Fancy = React.forwardRef(<span class=\"function\">(<span class=\"params\">props, ref</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;input type=<span class=\"string\">&quot;text&quot;</span> ref=&#123;ref&#125; /&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ref = useRef(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;current&quot;</span>, ref); <span class=\"comment\">// &#123; current: Input &#125;</span></span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Fancy</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"useLayoutEffect\"><a href=\"#useLayoutEffect\" class=\"headerlink\" title=\"useLayoutEffect\"></a>useLayoutEffect</h5><blockquote>\n<p>函数签名和 <code>useEffect</code> 是一样的， 可以使用它来读取 <code>DOM</code> 布局并 <code>同步</code> 触发重渲染。</p>\n</blockquote>\n<h5 id=\"useDebugValue\"><a href=\"#useDebugValue\" class=\"headerlink\" title=\"useDebugValue\"></a>useDebugValue</h5><blockquote>\n<p>用来给 <code>hooks</code> 添加上打印信息。</p>\n</blockquote>\n"},{"title":"前端自动化测试","date":"2020-02-16T16:00:00.000Z","_content":"\n## 1. 单元测试\n\n对软件中的最小可测试单元进行检查和验证，在前端一般为一个模块。\n\n### 1.1 单元测试的优缺点\n\n1. 测试覆盖率高\n2. 业务耦合度高\n3. 代码量大\n4. 过于独立\n\n### 1.2 总结\n\n在某些场景下适合适用单元测试，某些场景下不适合适用单元测试\n\n## 2. 集成测试\n\n又叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。\n\n## 3. jest 中的匹配器\n\n[jest 匹配器官网](https://jestjs.io/docs/en/expect)\n\n修改 `jest`  默认配置命令 `npx jest --init`\n\n### 3.1 实时监听测试用例的改变\n\n`jest --watchAll` 一旦某个测试用例发生变化，所有的测试用例都将会重新执行\n\n`jest --watch`  默认进入 `o`  模式，即只对发生变化的测试用例重新执行\n\n### 3.2 常用匹配器\n\n### 3.2.1 toBe()\n\n```jsx\ntest(\"测试toBe的匹配器\", () => {\n  const a = { name: \"张三\" };\n  expect(a).toBe({ name: \"张三\" });\n});\n// ❌ 因为引用类型使用toBe不是全等效果\n```\n\n`toBe` 匹配器类似于 `===`。\n\n---\n\n### 3.2.2 toEqual()\n\n```jsx\ntest(\"测试toEqual的匹配器\", () => {\n  const a = { name: \"张三\" };\n  expect(a).toBe({ name: \"张三\" });\n});\n// ✅ 因为toEqual只是对结果的匹配，而不是全等效果\n```\n\n`toEqual` 匹配器只是对结果相等与否进行匹配\n\n---\n\n### 3.2.3 toBeNull()\n\n```jsx\ntest(\"测试toBeNull的匹配器\", () => {\n  const a = null;\n  expect(a).toBeNull();\n});\n// ✅\n```\n\n`toBeNull` 是对 `null` 值的匹配\n\n---\n\n### 3.2.4 toBeUndefined()\n\n```jsx\ntest(\"测试toBeUndefined的匹配器\", () => {\n  const a = undefined;\n  expect(a).toBeUndefined();\n});\n// ✅\n```\n\n`toBeUndefined` 是对 `undefined` 值的匹配\n\n---\n\n### 3.2.5 toBeDefined()\n\n```jsx\ntest(\"测试toBeDefined的匹配器\", () => {\n  const a = 1;\n  expect(a).toBeDefined();\n});\n// ✅\n```\n\n`toBeDefined` 是对已经定义的值的匹配，若为 `undefined` 则不通过\n\n---\n\n### 3.2.6 toBeTruthy()\n\n```jsx\ntest(\"测试toBeTruthy的匹配器\", () => {\n  const a = 0;\n  expect(a).toBeTruthy();\n});\n// 0 => ❌，因为 toBeTruthy 是对 true 值的匹配\n// 1 => ✅\n```\n\n`toBeTruthy` 是对 `true` 值的匹配\n\n---\n\n### 3.2.7 toBeFalsy()\n\n```jsx\ntest(\"测试toBeFalsy的匹配器\", () => {\n  const a = 1;\n  expect(a).toBeFalsy();\n});\n// 1 => ❌\n// 0 => ✅\n```\n\n`toBeFalsy` 是对 `false` 值的匹配\n\n---\n\n### 3.2.8 toBeGreaterThan()\n\n```jsx\ntest(\"测试toBeGreaterThan匹配器\", () => {\n  const count = 10;\n  expect(a).toBeGreaterThan(9);\n});\n// ✅\n```\n\n`toBeGreaterThan` 相当于 `>`\n\n---\n\n### 3.2.9 toBeLessThan()\n\n```jsx\ntest(\"测试toBeLessThan匹配器\", () => {\n  const count = 8;\n  expect(a).toBeLessThan(9);\n});\n// ✅\n```\n\n`toBeLessThan` 相当于 `<`\n\n---\n\n### 3.2.10 toBeGreaterThanOrEqual()\n\n```jsx\ntest(\"测试toBeGreaterThanOrEqual匹配器\", () => {\n  const count = 10;\n  expect(a).toBeGreaterThanOrEqual(10);\n});\n// ✅\n```\n\n`toBeGreaterThanOrEqual` 相当于 `>=`\n\n---\n\n### 3.2.11 toBeLessThanOrEqual()\n\n```jsx\ntest(\"测试toBeLessThanOrEqual匹配器\", () => {\n  const count = 10;\n  expect(a).toBeLessThanOrEqual(10);\n});\n// ✅\n```\n\n`toBeLessThanOrEqual` 相当于 `<=`\n\n---\n\n### 3.2.12 toBeCloseTo()\n\n```jsx\ntest(\"测试toBeCloseTo匹配器\", () => {\n  const one = 0.1;\n  const two = 0.2;\n  expect(one + two).toEqual(0.3);\n});\n// ❌ 因为浮点精度不同\n\ntest(\"测试toBeCloseTo匹配器\", () => {\n  const one = 0.1;\n  const two = 0.2;\n  expect(one + two).toBeCloseTo(0.3);\n});\n// ✅\n```\n\n`toBeCloseTo` 为了解决浮点精度不同导致的无法匹配的问题\n\n---\n\n### 3.2.13 toMatch()\n\n```jsx\ntest(\"测试toMatch匹配器\", () => {\n  const str = \"张三、李四、王五\";\n  expect(str).toMatch(\"李四\");\n});\n// ✅\n\ntest(\"测试toMatch匹配器\", () => {\n  const str = \"张三、李四、王五\";\n  expect(str).toMatch(/李四/);\n});\n// ✅\n```\n\n`toMatch` 为字符串包含匹配器，用来匹配字符串中包含的内容，也可传正则表达式\n\n---\n\n### 3.2.14 toContain()\n\n```jsx\ntest(\"测试toContain匹配器\", () => {\n  const arr = [\"张三\", \"李四\", \"王五\"];\n  expect(arr).toContain(\"张三\");\n});\n// ✅\n\ntest(\"测试toContain匹配器\", () => {\n  const arr = [\"张三\", \"李四\", \"王五\"];\n  const data = new Set(arr);\n  expect(data).toContain(\"张三\");\n});\n```\n\n`toContain` 为数据包含匹器，用来匹配数组中包含的项。同时可完全兼容 `Set` 测试\n\n---\n\n### 3.2.15 toHaveLength()\n\n```jsx\n/// functions.js\nexport default {\n  getIntArray(num) {\n    if (!Number.isInteger(num)) {\n      throw Error('\"getIntArray\"只接受整数类型的参数');\n    }\n    let result = [];\n    for (let i = 0, len = num; i < len; i++) {\n      result.push(i);\n    }\n    return result;\n  }\n};\n\n/// functions.test.js\nimport { getIntArray } from \"../src/functions\";\ntest(\"getIntArray(3)返回的数组长度应该为3\", () => {\n  expect(getIntArray(3)).toHaveLength(3);\n});\n```\n\n`toHaveLength`可以很方便的用来测试字符串和数组类型的长度是否满足预期。\n\n### 3.2.16 toThrow()\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试toThrow匹配器\", () => {\n  expect(throwNewErrorFunc).toThrow();\n});\n```\n\n`toThrow` 是专门对异常进行处理的匹配器，可以检测一个方法会不会抛出异常\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试toThrow匹配器\", () => {\n  expect(throwNewErrorFunc).toThrow(\"this is a new error\");\n});\n```\n\n我们也可以对这个匹配器中加一些字符串，意思就是抛出的异常必须和字符串相对应，如果字符串不匹配，也没办法通过异常测试。\n\n---\n\n### 3.2.17 not()\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试not匹配器\", () => {\n  expect(throwNewErrorFunc).not.toThrow();\n});\n```\n\n`not` 匹配器是 `jest` 中比较特殊的匹配器，意思就是 “相反” 或者说 “取反” .比如上面的例子，我们不希望方法抛出异常，就可以使用`not` 匹配器。\n\n---\n\n### 3.3 异步代码测试方法\n\n### 3.3.1 回调函数式\n\n```jsx\n/// fetchData.js\nimport axios from \"axios\";\nexport const fetchData = fn => {\n  axios.get(\"http://a.jspang.com/jestTest.json\").then(res => {\n    fn(res.data);\n  });\n};\n\n/// fetchData.test.js\nimport { fetchData } from \"./fetchData.js\";\ntest(\"fetchData测试\", done => {\n  fetchData(data => {\n    expect(data).toEqual({ success: true });\n    done();\n  });\n});\n```\n\n必须加入一个 `done` 方法，保证我们的回调已经完成了，这时候我们表示测试完成\n\n---\n\n### 3.3.2 直接返回 Promise\n\n```jsx\n/// fetchTwoData.js\nimport axios from \"axios\";\nexport const fetchTwoData = () => axios.get(\"http://a.jspang.com/jestTest.json\";\n\n/// fetchTwoData.test.js\nimport { fetchTwoData } from \"./fetchTwoData.js\";\ntest(\"fetchTwoData的测试用例\", () => {\n return fetchTwoData().then(res => {\n  expect(res.data).toEqual({ success: true });\n });\n});\n```\n\n注意要 `return`\n\n### 3.3.3 不存在的接口\n\n```jsx\n/// fetchData.js\nexport const fetchData = () => {\n  return axios.get(\"http://a.jspang.com/jestTest_error.json\"); // 此地址并不存在\n};\n\n/// fetchData.test.js\n// 方式1\ntest(\"fetchData测试\", () => {\n  expect.assertions(1); // 断言，必须执行一次 expect\n  return fetchData().catch(err => {\n    expect(err.toString().indexOf(\"404\") > -1).toBe(true);\n  });\n});\n\n// 方式2\ntest(\"fetchData测试\", async () => {\n  return await fetchData().rejects.toThrow();\n});\n\n// 方式3\ntest(\"fetchData测试\", async () => {\n  expect().assertions(1); // 断言，必须执行一次 expect\n  try {\n    await fetchData();\n  } catch (err) {\n    expect(err.toString().indexOf(\"404\") > -1).toBe(true);\n  }\n});\n```\n\n因为测试用例使用了 `catch` 方法，也就是说只有出现异常的时候才会走这个方法，而现在没有出现异常，就不会走这个测试方法，`jest` 就默认这个用例通过了测试。因此必须要执行断言，即必须让其执行一次即可。\n\n### 3.3.4 async/await\n\n```jsx\n/// fetchData.js\nexport const fetchData = () => {\n return axios.get(\"http://a.jspang.com/jestTest.json\"); // 此地址并不存在};\n\n/// fetchData.test.js\n// 方式1\ntest(\"fetchData测试\", async () => {\n await expect(fetchData()).resolves.toMatchObject({\n  data: {\n   success: true\n  }\n });\n});\n\n// 方式2\ntest(\"fetchData测试\", async () => {\n const response = await fetchData();\n expect(response.data).toEqual({ success: true });\n});\n```\n\n这时候我们的代码使用 `async....await...` 的形式，这里我们还使用了 `resolves` 用于把现有对象转换成 `Promise` 对象，然后使用 `jest` 中的 `toMatchObject` 进行匹配对象中的属性。\n\n## 4. jest 中的四个钩子函数\n\n### 4.1 beforeAll()\n\n`beforeAll()`钩子函数的意思是在所有测试用例之前进行执行。\n\n### 4.2 afterAll()\n\n`afterAll()`钩子函数是在完成所有测试用例之后才执行的函数。\n\n### 4.3 beforeEach()\n\n`beforeEach()`钩子函数，是在每个测试用例前都会执行一次的钩子函数。\n\n### 4.4 afterEach()\n\n`afterEach()`钩子函数，是在每次测试用例完成测试之后执行一次的钩子函数。\n\n## 5. jest 测试用例分组\n\n```jsx\n/// eat.js\nexport default class Eat {\n  setName(number) {\n    this.name = number === 1 ? \"水饺\" : \"火锅\";\n  }\n  setDesc() {\n    this.desc = this.user + \"描述\";\n  }\n  setMoney() {\n    this.money = this.name === \"水饺\" ? 80 : 300;\n  }\n}\n\n/// eat.test.js\nimport Eat from \"./eat\";\nconst eat = new Eat();\nbeforeAll(() => {\n  console.log(\"开始吃饭\");\n});\nafterAll(() => {\n  console.log(\"吃完饭了\");\n});\ndescribe(\"水饺相关内容\", () => {\n  test(\"测试水饺描述\", () => {\n    eat.setName(1);\n    eat.setDesc();\n    expect(eat.desc).toEqual(\"水饺描述\");\n  });\n  test(\"测试水饺价格\", () => {\n    eat.setName(1);\n    eat.setMoney();\n    expect(eat.money).toEqual(80);\n  });\n});\ndescribe(\"火锅相关内容\", () => {\n  test(\"测试火锅描述\", () => {\n    eat.setName(2);\n    eat.setDesc();\n    expect(eat.desc).toEqual(\"火锅描述\");\n  });\n  test(\"测试火锅价格\", () => {\n    eat.setName(2);\n    eat.setMoney();\n    expect(eat.money).toEqual(300);\n  });\n});\n```\n\n## 6. 钩子函数的作用域\n\n### 6.1 钩子函数在父级分组可作用域子集，类似继承\n\n即父级作用域下的钩子函数在子作用域下也生效\n\n### 6.2 钩子函数同级分组作用域互不干扰，各起作用\n\n同作用域下将都会执行\n\n### 6.3 先执行外部的钩子函数，再执行内部的钩子函数\n\n优先父级作用域下的钩子函数，其次执行子作用域下的钩子函数\n\n### 6.4 在进行测试准备的时候，将对应逻辑写到钩子函数\n\n如果将对应逻辑写到了非钩子函数的位置，那么将会优先执行，然后才会执行钩子函数\n\n### 6.5 对单个测试用例的调试\n\n当一个测试文件中的测试用例变得越来越多的时候，假如此时我们相对其中某一个测试用例进行调试，那么我们就需要使用 `test.only`\n\n```jsx\ntest.only(\"测试用例\", () => {\n  expect(1 + 1).toBe(2);\n});\n```\n\n## 7. Jest 中的 Mock\n\n### 7.1 作用\n\n### 7.1.1 捕获函数的调用和返回结果，以及 `this` 和调用顺序\n\n### 7.1.2 它可以让我们自由的设置返回结果\n\n### 7.1.3 改变内部函数的实现\n\n### 7.2 判定函数是否被调用\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback();\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  expect(func).toBeCalled(); // 测试用例被调用\n});\n```\n\n`jest.fn()`  可以帮助我们捕获函数的调用\n\n### 7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.calls.length).toBe(2); // 测试用例被调用2次\n  expect(func.mock.calls[0]).toEqual([\"张三\"]); // 测试用例传递的第一个参数是 \"张三\"\n});\n```\n\n此处打印 `func.mock`  将会打印一些常用的方法，可以根据需求进行相应的用例测试\n\n### 7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  // func.mockReturnValue(\"Common\")\n  // 所有模拟返回值都是 \"Common\"\n  func.mockReturnValueOnce(\"A\"); // 第一次模拟返回值返回 \"A\"\n  func.mockReturnValueOnce(\"B\"); // 第二次模拟返回值返回 \"B\"\n  func.mockReturnValueOnce(\"C\"); // 第三次模拟返回值返回 \"C\"\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.results[0].value).toBe(\"A\");\n  expect(func.mock.results[1].value).toBe(\"B\");\n  expect(func.mock.results[2].value).toBe(\"C\");\n});\n```\n\n`func.mockReturnValue()`  将对所有模拟返回的值生效\n\n`func.mockReturnValueOnce()`  执行到第几次就对第几个函数的模拟返回值生效\n\n支持链式调用\n\n### 7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.invocationCallOrder).toEqual([1, 2, 3]);\n});\n```\n\n### 7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向\n\n```jsx\n// demo.js\nexport const createObject = (ClassItem) => {\n  new ClassItem();\n}\n\n// demo.test.js\nimport { createObject } from \"./demo\";\ntest(\"测试 createObject\", () => {\n  const func = jest.fn();\n  createObject(func);\n  expect(func.mock.instances).toEqual([mockConstructor{}]); // 此处的 this 就是 mockConstructor\n});\n```\n\n### 7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  // func.mockImplementation(() => \"hello\"); 等价于 jest.fn(() => \"hello\")\n  // func.mockImplementation(() => this); 等价于 jest.fn().mockReturnThis()\n  func.mockImplementationOnce(() => \"dell\");\n  func.mockImplementationOnce(() => \"lee\");\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.results[0].value).toBe(\"dell\");\n  expect(func.mock.results[1].value).toBe(\"lee\");\n});\n```\n\n`mockImplementation`  比 `mockReturnValue`  更健壮，因为内部可以写一些额外的逻辑\n\n### 7.8 toBeCalledWith() 来判定每次函数调用时的参数\n\n```jsx\n// demo.js\nexport const runCallback = (callback) => {\n  callback(\"ABC\");\n}\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  expect(func.mock.results[0]).toEqual([\"ABC\");\n  expect(func).toBeCalledWith(\"ABC\");\n});\n```\n\n### 7.9 模拟异步请求\n\n对于前端来说一般异步接口是测试是否发送了，而不测试后端接口返回的内容，是属于后端自动化测试的内容\n\n### 7.9.1 通过模拟库的方式来模拟异步测试\n\n```jsx\n// demo.js\nexport const getData = () => {\n  return axios.get(\"/api\").then(res => res.data);\n};\n\n// demo.test.js\nimport axios from \"axios\";\nimport { getData } from \"./demo\";\njest.mock(\"axios\"); // 对 axios 进行模拟，这样就不会请求真正数据\ntest(\"测试 getData\", async () => {\n  axios.get.mockResolvedValue({ data: \"hello\" }); // 使用 axios 请求的时候模拟成功的返回值就是 hello\n  await getData().then(data => {\n    expect(data).toBe(\"hello\");\n  });\n});\n```\n\n`mockResolvedValue` 模拟不限次数\n\n`mockResolvedValueOnce` 模拟一次，模拟两次就会报错，需再次调用\n\n### 7.9.2 通过模拟 Promise 方式模拟异步\n\n```jsx\n// demo.js\nexport const fetchData = () => {\n  return axios.get(\"/\").then(res => res.data);\n};\n\n// __mocks__/demo.js\nexport const fetchData = () => {\n  return new Promise((resolve, reject) => {\n    resolve(\"function() { return '123' }\");\n  });\n};\n\n// demo.test.js\njest.mock(\"./demo\");\nimport { fetchData } from \"./demo\";\ntest(\"测试fetchData\", () => {\n  return fetchData().then(data => {\n    expect(eval(data)).toEqual(\"123\");\n  });\n});\n\n/// 实现方式3\n// 修改jest.config.js 可以自动查找项目内部__mocks__下与要测试文件名字相同的文件做替换\n// 等同于 jest.mock(\"要测试文件名字相同的__mocks__下的文件\"){  automock: true; }\n```\n\n### 7.9.3 通过修改 jest.config.js 来自动识别**mocks**下的文件\n\n修改 `jest.config.js` 可以自动查找项目内部 `__mocks__` 下与要测试文件名字相同的文件做替换\n\n等同于> `jest.mock(\"要测试文件名字相同的__mocks__下的文件\")`\n\n### 7.9.4 使用 jest.unmock() 可取消 mock 模拟\n\n### 7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题\n\n```jsx\n// demo.js\nexport const fetchData = () => {\n  return axios.get(\"/\").then(res => res.data);\n};\nexport const getNumber = () => 123;\n\n// __mocks__/demo.js\nexport const fetchData = () => {\n  return new Promise((resolve, reject) => {\n    resolve(\"function() { return '123' }\");\n  });\n};\n\n// demo.test.js\njest.mock(\"./demo\");\nimport { fetchData } from \"./demo\";\nconst { getNumber } = jest.requireActual(\"./demo\"); // 引入真实文件\ntest(\"测试 fetchData\", () => {\n  return fetchData().then(data => {\n    expect(eval(data)).toEqual(\"123\");\n  });\n});\n\ntest(\"测试 getNumber\", () => {\n  expect(getNumber()).toEqual(123);\n});\n```\n\n## 8. snapshot 快照测试\n\n常用于测试配置文件\n\n### 8.1 toMatchSnapshot()\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\"\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  expect(generateConfig()).toMatchSnapshot(); // 将会在项目里生成快照文件\n});\n```\n\n如果要确认更新快照，需要在控制台选择。 `u`  代表对所有快照进行更新， `i`  代表对单个确认的快照进行更新\n\n### 8.2 测试部分可变变量的内容\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\",\n    time: new Date(),\n    // 可变变量\n    random: Math.random()\n    // 可变变量\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  expect(generateConfig()).toMatchSnapshot({\n    time: expect.any(Date),\n    random: expect.any(Number)\n  });\n});\n```\n\n### 8.3 行内的 snapshot\n\n`npm install prettier --save`\n\n可以快照放到行内的测试用例中\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\",\n    time: new Date(),\n    // 可变变量\n    random: Math.random()\n    // 可变变量\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  // toMatchInlineSnapshot 可以快照放到行内的测试用例中\n  expect(generateConfig()).toMatchInlineSnapshot({\n    time: expect.any(Date),\n    random: expect.any(Number)\n  });\n});\n```\n\n---\n\n## 9. Test Driven Development(TDD) 测试驱动开发\n\n### 9.1 TDD 开发流程\n\n1. 编写测试用例（知道功能，先写测试用例）\n2. 运行测试，测试用例无法通过测试\n3. 编写代码，使测试用例通过测试\n4. 优化代码， 完成开发\n5. 新增功能，重复执行 1-4\n\n### 9.2 TDD 的优势\n\n1. 长期减少项目的回归 bug（减少修改代码产生的 bug）\n2. 代码质量更好（组织，可维护性好）\n3. 测试覆盖率高（因为是先编写测试用例，但测试覆盖率过高会影响很大精力）\n4. 错误测试代码不容易出现\n\n### 9.3 TDD 的适用场景\n\n1. 不适用于开发业务代码时使用（开发业务代码时会大量的与业务代码产生耦合，加大工作量）\n2. 适用于一些库的开发（开发库时代码耦合度较低，通常只处理函数等相关功能）\n\n---\n\n## 10. Behavior Driven Development(BDD) 行为驱动开发\n\n### 10.1 BDD 开发流程\n\n1. 先编写业务代码，不关心测试\n2. 思考并描述用户行为\n3. 根据用户行为模拟测试\n\n### 10.2 vue example\n\n```jsx\n/// testUtils.js\nexport const findTestWrapper = (wrapper, tag) => {\n  return wrapper.find(`[data-test=\"${tag}\"]`);\n};\n```\n\n```jsx\n/// __tests__/integration/TodoList.test.js\nimport { mount } from \"@vue/test-utils\";\nimport { findTestWrapper } from \"../../../../utils/testUtils\";\nimport TodoList from \"../../TodoList\";\n// import store from \"../../../../store\"\nit(`    \n 新增内容逻辑的集成测试    \n 1. 用户会在header输入框输入内容    \n 2. 用户会点击回车按钮  \n 3. 列表项应该增加用户输入内容的列表项`, () => {\n  const wrapper = mount(TodoList);\n  // const wrapper = mount(TodoList, { store })\n  // 如果使用 vuex，也几乎无改动\n  const inputElem = findTestWrapper(wrapper, \"header-input\").at(0);\n  const content = \"Dell lee\";\n  inputElem.setValue(content);\n  inputElem.trigger(\"change\");\n  inputElem.trigger(\"keyup.enter\");\n  const listItems = findTestWrapper(wrapper, \"list-item\").at(0);\n  expect(listItems.length).toBe(1);\n  expect(listItems.at(0).text()).toContain(content);\n});\n```\n\n### 10.3 react example\n\n```jsx\n/// testUtils.js\nexport const findTestWrapper = (wrapper, tag) => {\n  return wrapper.find(`[data-test=\"${tag}\"]`);\n};\n```\n\n```jsx\n/// __tests__/integration/TodoList.test.js\nimport React from \"react\";\n// import { Provider } from \"react-redux\";\nimport Enzyme, { mount } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport TodoList from \"../../TodoList\";\n// import store from \"../../../../store/createStore\";\nEnzyme.configure({ adapter: new Adapter() });\n\nit(`\n    新增内容逻辑的集成测试\n    1. 用户会在header输入框输入内容\n    2. 用户会点击回车按钮\n   3. 列表项应该增加用户输入内容的列表项\n`, () => {\n  const wrapper = mount(<TodoList />);\n  /** \n  const wrapper = mount(\n   <Provider store={store}>\n    <TodoList /></Provider>\n   </Provider>\n  )  \n  // 如果使用 redux，也几乎无改动\n */\n  const inputElem = findTestWrapper(wrapper, \"header-input\");\n  const content = \"Dell lee\";\n  inputElem.simulate(\"change\", { target: { value: content } });\n  inputElem.simulate(\"keyUp\", { keyCode: 13 });\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(1);\n  expect(listItems.text()).toContain(content);\n});\n```\n\n---\n\n## 11. TDD 和 BDD 的对比\n\n1. `TDD` 先写测试后写代码; `BDD` 先写代码后写测试\n2. `TDD` 创建的是 `unit` 单元测试文件夹，一般结合单元测试，属于白盒测试(知道实现测试代码); `BDD` 创建的是 `integration` 集成测试文件夹，一般结合集成测试，属于黑盒测试(不知道实现测试代码)\n3. `TDD` 测试重点在代码; `BDD` 测试重点在 `UI` ( `DOM`)\n4. `TDD` 安全感低(无法保证各个组件拼撞到一起是否不会有问题); `BDD` 安全感高\n5. `TDD` 速度快; `BDD` 速度慢\n\n---\n\n## 12. TDD 与 BDD 混用\n\n### 12.1 对一些工具函数的测试\n\n### 12.2 对 vuex 的 store 进行测试\n\n```jsx\n/// __tests__/unit/store.test.js\nimport store from \"../../../../store\";\nit(\"当 store 接受 changeInputValue 的 commit 时, inputValue 发生变化\", () => {\n  const value = \"123\";\n  store.commit(\"changeInputValue\", value);\n  expect(store.state.inputValue).toBe(value);\n});\n```\n\n### 12.3 对 redux 的 store 进行测试\n\n```jsx\n/// __tests__/unit/store.test.js\nimport store from \"../../../../store/createStore\";\nimport { changeInputValue } from \"../../../../store/actions\";\nit(\"当 store 接受 changeInputValue 的 dispatch 时, inputValue 发生变化\", () => {\n  const value = \"123\";\n  /**   \n  const changeInputValue = (payload) => ({ \n   type: CHANGE_IMPUT_VALUE, payload \n  })   \n */\n  store.dispatch(changeInputValue(value));\n  expect(store.getState().inputValue).toBe(value);\n});\n```\n\n---\n\n## 13. 异步测试\n\n注意：异步测试如果用到了异步函数，则需要调用 `done`  函数\n\n### 13.1 vue 的异步测试\n\n```javascript\n/// __mocks__/axios.js\nconst undoList = {  success: true,  data: [\n { status: \"div\", value: \"dell\" },\n { status: \"div\", value: \"lee\" }\n]};\nexport default {\n get(url) {\n  if (url === \"/getUndoList.json\") {\n   return new Promise((resolve, reject) => {\n    if (this.success === true) {\n     resolve(undoList);\n    } else {\n     reject(new Error());\n    }\n   });\n  }\n }};\n\n/// __tests__/integration/TodoList.test.js\nimport { mount } from \"@vue/test-utils\";\nimport { findTestWrapper } from \"../../../../utils/testUtils\";\nimport TodoList from \"../../TodoList\";\nimport store from \"../../../../store\";\n\nbeforeEach(() => {\n axios.success = true;\n jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响});\nit(`1. 用户进入页面时，请求远程测试; 2. 列表应该显示远程返回的数据`, done => {\n  const wrapper = mount(TodoList, { store });\n  wrapper.vm.$nickTick(() => {\n   const listItems = findTestWrapper(wrapper, \"list-item\");\n   expect(listItems.length).toBe(2);\n   done();\n  });\n });\nit(`1. 用户进入页面时，等待5s; 2. 列表应该显示远程返回的数据`, done => {\n const wrapper = mount(TodoList, { store });\n expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n jest.runAllTimers();\n wrapper.vm.$nickTick(() => {\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(2);\n  done();\n });\n});\n\nit(`1. 用户进入页面时，请求远程数据失败; 2. 列表应该显示空数据，不应该挂掉`, done => {\n axios.success = false;\n const wrapper = mount(TodoList, { store });\n expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n jest.runAllTimers();\n wrapper.vm.$nickTick(() => {\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(0);\n  done();\n });\n});\n```\n\n### 13.2 react 的异步测试\n\n```jsx\n/// __mocks__/axios.js\nconst undoList = {\n  success: true,\n  data: [\n    { status: \"div\", value: \"dell\" },\n    { status: \"div\", value: \"lee\" }\n  ]\n};\n\nexport default {\n  get(url) {\n    if (url === \"/getUndoList.json\") {\n      return new Promise((resolve, reject) => {\n        if (this.success === true) {\n          resolve(undoList);\n        } else {\n          reject(new Error());\n        }\n      });\n    }\n  }\n};\n\n/// __tests__/integration/TodoList.test.js\nimport React from \"react\";\nimport { Provider } from \"react-redux\";\nimport Enzyme, { mount } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport TodoList from \"../../TodoList\";\nimport store from \"../../../../store/createStore\";\nEnzyme.configure({ adapter: new Adapter() });\n\nbeforeEach(() => {\n  axios.success = true;\n  jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响\n});\n\nit(`\n    1. 用户进入页面时，请求远程测试\n    2. 列表应该显示远程返回的数据\n`, done => {\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  process.nickTick(() => {\n    wrapper.update();\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(2);\n    done();\n  });\n});\n\nit(`\n    1. 用户进入页面时，等待5s\n    2. 列表应该显示远程返回的数据\n`, done => {\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n  jest.runAllTimers();\n  process.nickTick(() => {\n    wrapper.update(); // 更新 wrapper 防止取上一次的 wrapper\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(2);\n    done();\n  });\n});\n\nit(`\n  1. 用户进入页面时，请求远程数据失败\n  2. 列表应该显示空数据，不应该挂掉\n`, done => {\n  axios.success = false;\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n  jest.runAllTimers();\n  process.nickTick(() => {\n    wrapper.update();\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(0);\n    done();\n  });\n});\n```\n\n---\n\n## 14. vue 项目的自动化测试\n\n### 14.1 使用传统方式对 vue 组件进行测试\n\n```jsx\n// HelloWorld.test.js\nimport Vue from \"vue\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const root = document.createElement(\"div\");\n    root.className = \"root\";\n    document.body.appendChild(root);\n    new Vue({\n      render: h =>\n        h(HelloWorld, {\n          props: {\n            msg: \"dell lee\"\n          }\n        })\n    }).$mount(\".root\");\n    expect(document.getElementByClassName(\"hello\").length).toBe(1);\n  });\n});\n```\n\n缺点：写法过于复杂，局限性也很大，部分属性无法进行测试\n\n### 14.2 使用 @vue/test-utils 对 vue 组件进行测试\n\n- [官方文档](https://vue-test-utils.vuejs.org/zh/)\n\n### 14.2.1 for example\n\n```jsx\n// HelloWorld.test.js\nimport { shallowMount } from \"@vue/test-utils\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const msg = \"dell lee\";\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    });\n    expect(wrapper.text()).toMatch(msg);\n  });\n});\n```\n\n### 14.2.2 快照测试\n\n使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听\n\n好处: 可以帮助我们及时发现组件中 `dom` 结构的变化\n\n```jsx\n// HelloWorld.test.js\nimport { shallowMount } from \"@vue/test-utils\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue 组件渲染正常\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const msg = \"dell lee\";\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    });\n    expect(wrapper).toMatchSnapshot();\n  });\n});\n```\n\n---\n\n## 15. react 项目的自动化测试\n\n### 15.1 使用传统方式对 react 组件进行测试\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nit(\"render App\", () => {\n  const div = document.createElement(\"div\");\n  ReactDOM.render(<App />, div);\n  const container = div.getElementsByClassName(\"App\");\n  expect(container.length).toBe(1);\n});\n```\n\n缺点：写法过于复杂，局限性也很大，部分属性无法进行测试\n\n### 15.2 enzyme 的配置和使用\n\n- [官方文档](https://enzymejs.github.io/enzyme/)\n- [github](https://github.com/enzymejs/enzyme)\n- [jest-enzyme](https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzyme)\n\n### 15.2.1 for example\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport Enzyme, { shallow } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport App from \"App\";\nEnzyme.configure({ adapter: new Adapter() });\nit(\"render App\", () => {\n  const wrapper = shallow(<App />);\n  expect(wrapper.find('[data-test=\"App\"]').length).toBe(2);\n});\n```\n\n使用自定义 `props` 可以降低代码耦合度\n\n`shallow` 适合单元测试，属于浅渲染； `mount` 适合集成测试，会将当前组件包括其子组件一起渲染\n\n单元测试时更倾向于使用 `api` `.state()` ；集成测试时更倾向于使用 `api` `.prop()`\n\n### 15.2.2 快照测试\n\n使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听\n\n好处: 可以帮助我们及时发现组件中 `dom` 结构的变化\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport Enzyme, { shallow } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport App from \"App\";\nEnzyme.configure({ adapter: new Adapter() });\nit(\"render App\", () => {\n  const wrapper = shallow(<App />);\n  expect(wrapper).toMatchSnapshot();\n});\n```\n\n---\n\n## 16. 前端自动化测试的优势\n\n- 更好的代码组织，项目的可维护性强\n- 更少的 `Bug` 出现概率，尤其是回归测试中的 `Bug`\n- 修改工程质量差的项目，更加安全\n- 项目具备潜在的文档特性\n- 扩展前端的知识面\n\n## 17 总结重要的点\n\n1. `BDD` 和 `TDD`\n2. 集成测试 和 单元测试\n3. 测试和业务的解耦\n4. 代码测试覆盖率并不代表一定靠谱\n5. 功能性测试 和 `UI`测试\n6. 测试越独立，隐藏的问题就越多\n","source":"_posts/前端/前端自动化测试.md","raw":"---\ntitle: 前端自动化测试\ndate: 2020-02-17\ncategories: [前端, js]\ntags: \n  - 自动化测试\n---\n\n## 1. 单元测试\n\n对软件中的最小可测试单元进行检查和验证，在前端一般为一个模块。\n\n### 1.1 单元测试的优缺点\n\n1. 测试覆盖率高\n2. 业务耦合度高\n3. 代码量大\n4. 过于独立\n\n### 1.2 总结\n\n在某些场景下适合适用单元测试，某些场景下不适合适用单元测试\n\n## 2. 集成测试\n\n又叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。\n\n## 3. jest 中的匹配器\n\n[jest 匹配器官网](https://jestjs.io/docs/en/expect)\n\n修改 `jest`  默认配置命令 `npx jest --init`\n\n### 3.1 实时监听测试用例的改变\n\n`jest --watchAll` 一旦某个测试用例发生变化，所有的测试用例都将会重新执行\n\n`jest --watch`  默认进入 `o`  模式，即只对发生变化的测试用例重新执行\n\n### 3.2 常用匹配器\n\n### 3.2.1 toBe()\n\n```jsx\ntest(\"测试toBe的匹配器\", () => {\n  const a = { name: \"张三\" };\n  expect(a).toBe({ name: \"张三\" });\n});\n// ❌ 因为引用类型使用toBe不是全等效果\n```\n\n`toBe` 匹配器类似于 `===`。\n\n---\n\n### 3.2.2 toEqual()\n\n```jsx\ntest(\"测试toEqual的匹配器\", () => {\n  const a = { name: \"张三\" };\n  expect(a).toBe({ name: \"张三\" });\n});\n// ✅ 因为toEqual只是对结果的匹配，而不是全等效果\n```\n\n`toEqual` 匹配器只是对结果相等与否进行匹配\n\n---\n\n### 3.2.3 toBeNull()\n\n```jsx\ntest(\"测试toBeNull的匹配器\", () => {\n  const a = null;\n  expect(a).toBeNull();\n});\n// ✅\n```\n\n`toBeNull` 是对 `null` 值的匹配\n\n---\n\n### 3.2.4 toBeUndefined()\n\n```jsx\ntest(\"测试toBeUndefined的匹配器\", () => {\n  const a = undefined;\n  expect(a).toBeUndefined();\n});\n// ✅\n```\n\n`toBeUndefined` 是对 `undefined` 值的匹配\n\n---\n\n### 3.2.5 toBeDefined()\n\n```jsx\ntest(\"测试toBeDefined的匹配器\", () => {\n  const a = 1;\n  expect(a).toBeDefined();\n});\n// ✅\n```\n\n`toBeDefined` 是对已经定义的值的匹配，若为 `undefined` 则不通过\n\n---\n\n### 3.2.6 toBeTruthy()\n\n```jsx\ntest(\"测试toBeTruthy的匹配器\", () => {\n  const a = 0;\n  expect(a).toBeTruthy();\n});\n// 0 => ❌，因为 toBeTruthy 是对 true 值的匹配\n// 1 => ✅\n```\n\n`toBeTruthy` 是对 `true` 值的匹配\n\n---\n\n### 3.2.7 toBeFalsy()\n\n```jsx\ntest(\"测试toBeFalsy的匹配器\", () => {\n  const a = 1;\n  expect(a).toBeFalsy();\n});\n// 1 => ❌\n// 0 => ✅\n```\n\n`toBeFalsy` 是对 `false` 值的匹配\n\n---\n\n### 3.2.8 toBeGreaterThan()\n\n```jsx\ntest(\"测试toBeGreaterThan匹配器\", () => {\n  const count = 10;\n  expect(a).toBeGreaterThan(9);\n});\n// ✅\n```\n\n`toBeGreaterThan` 相当于 `>`\n\n---\n\n### 3.2.9 toBeLessThan()\n\n```jsx\ntest(\"测试toBeLessThan匹配器\", () => {\n  const count = 8;\n  expect(a).toBeLessThan(9);\n});\n// ✅\n```\n\n`toBeLessThan` 相当于 `<`\n\n---\n\n### 3.2.10 toBeGreaterThanOrEqual()\n\n```jsx\ntest(\"测试toBeGreaterThanOrEqual匹配器\", () => {\n  const count = 10;\n  expect(a).toBeGreaterThanOrEqual(10);\n});\n// ✅\n```\n\n`toBeGreaterThanOrEqual` 相当于 `>=`\n\n---\n\n### 3.2.11 toBeLessThanOrEqual()\n\n```jsx\ntest(\"测试toBeLessThanOrEqual匹配器\", () => {\n  const count = 10;\n  expect(a).toBeLessThanOrEqual(10);\n});\n// ✅\n```\n\n`toBeLessThanOrEqual` 相当于 `<=`\n\n---\n\n### 3.2.12 toBeCloseTo()\n\n```jsx\ntest(\"测试toBeCloseTo匹配器\", () => {\n  const one = 0.1;\n  const two = 0.2;\n  expect(one + two).toEqual(0.3);\n});\n// ❌ 因为浮点精度不同\n\ntest(\"测试toBeCloseTo匹配器\", () => {\n  const one = 0.1;\n  const two = 0.2;\n  expect(one + two).toBeCloseTo(0.3);\n});\n// ✅\n```\n\n`toBeCloseTo` 为了解决浮点精度不同导致的无法匹配的问题\n\n---\n\n### 3.2.13 toMatch()\n\n```jsx\ntest(\"测试toMatch匹配器\", () => {\n  const str = \"张三、李四、王五\";\n  expect(str).toMatch(\"李四\");\n});\n// ✅\n\ntest(\"测试toMatch匹配器\", () => {\n  const str = \"张三、李四、王五\";\n  expect(str).toMatch(/李四/);\n});\n// ✅\n```\n\n`toMatch` 为字符串包含匹配器，用来匹配字符串中包含的内容，也可传正则表达式\n\n---\n\n### 3.2.14 toContain()\n\n```jsx\ntest(\"测试toContain匹配器\", () => {\n  const arr = [\"张三\", \"李四\", \"王五\"];\n  expect(arr).toContain(\"张三\");\n});\n// ✅\n\ntest(\"测试toContain匹配器\", () => {\n  const arr = [\"张三\", \"李四\", \"王五\"];\n  const data = new Set(arr);\n  expect(data).toContain(\"张三\");\n});\n```\n\n`toContain` 为数据包含匹器，用来匹配数组中包含的项。同时可完全兼容 `Set` 测试\n\n---\n\n### 3.2.15 toHaveLength()\n\n```jsx\n/// functions.js\nexport default {\n  getIntArray(num) {\n    if (!Number.isInteger(num)) {\n      throw Error('\"getIntArray\"只接受整数类型的参数');\n    }\n    let result = [];\n    for (let i = 0, len = num; i < len; i++) {\n      result.push(i);\n    }\n    return result;\n  }\n};\n\n/// functions.test.js\nimport { getIntArray } from \"../src/functions\";\ntest(\"getIntArray(3)返回的数组长度应该为3\", () => {\n  expect(getIntArray(3)).toHaveLength(3);\n});\n```\n\n`toHaveLength`可以很方便的用来测试字符串和数组类型的长度是否满足预期。\n\n### 3.2.16 toThrow()\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试toThrow匹配器\", () => {\n  expect(throwNewErrorFunc).toThrow();\n});\n```\n\n`toThrow` 是专门对异常进行处理的匹配器，可以检测一个方法会不会抛出异常\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试toThrow匹配器\", () => {\n  expect(throwNewErrorFunc).toThrow(\"this is a new error\");\n});\n```\n\n我们也可以对这个匹配器中加一些字符串，意思就是抛出的异常必须和字符串相对应，如果字符串不匹配，也没办法通过异常测试。\n\n---\n\n### 3.2.17 not()\n\n```jsx\nconst throwNewErrorFunc = () => {\n  throw new Error(\"this is a new error\");\n};\n\ntest(\"测试not匹配器\", () => {\n  expect(throwNewErrorFunc).not.toThrow();\n});\n```\n\n`not` 匹配器是 `jest` 中比较特殊的匹配器，意思就是 “相反” 或者说 “取反” .比如上面的例子，我们不希望方法抛出异常，就可以使用`not` 匹配器。\n\n---\n\n### 3.3 异步代码测试方法\n\n### 3.3.1 回调函数式\n\n```jsx\n/// fetchData.js\nimport axios from \"axios\";\nexport const fetchData = fn => {\n  axios.get(\"http://a.jspang.com/jestTest.json\").then(res => {\n    fn(res.data);\n  });\n};\n\n/// fetchData.test.js\nimport { fetchData } from \"./fetchData.js\";\ntest(\"fetchData测试\", done => {\n  fetchData(data => {\n    expect(data).toEqual({ success: true });\n    done();\n  });\n});\n```\n\n必须加入一个 `done` 方法，保证我们的回调已经完成了，这时候我们表示测试完成\n\n---\n\n### 3.3.2 直接返回 Promise\n\n```jsx\n/// fetchTwoData.js\nimport axios from \"axios\";\nexport const fetchTwoData = () => axios.get(\"http://a.jspang.com/jestTest.json\";\n\n/// fetchTwoData.test.js\nimport { fetchTwoData } from \"./fetchTwoData.js\";\ntest(\"fetchTwoData的测试用例\", () => {\n return fetchTwoData().then(res => {\n  expect(res.data).toEqual({ success: true });\n });\n});\n```\n\n注意要 `return`\n\n### 3.3.3 不存在的接口\n\n```jsx\n/// fetchData.js\nexport const fetchData = () => {\n  return axios.get(\"http://a.jspang.com/jestTest_error.json\"); // 此地址并不存在\n};\n\n/// fetchData.test.js\n// 方式1\ntest(\"fetchData测试\", () => {\n  expect.assertions(1); // 断言，必须执行一次 expect\n  return fetchData().catch(err => {\n    expect(err.toString().indexOf(\"404\") > -1).toBe(true);\n  });\n});\n\n// 方式2\ntest(\"fetchData测试\", async () => {\n  return await fetchData().rejects.toThrow();\n});\n\n// 方式3\ntest(\"fetchData测试\", async () => {\n  expect().assertions(1); // 断言，必须执行一次 expect\n  try {\n    await fetchData();\n  } catch (err) {\n    expect(err.toString().indexOf(\"404\") > -1).toBe(true);\n  }\n});\n```\n\n因为测试用例使用了 `catch` 方法，也就是说只有出现异常的时候才会走这个方法，而现在没有出现异常，就不会走这个测试方法，`jest` 就默认这个用例通过了测试。因此必须要执行断言，即必须让其执行一次即可。\n\n### 3.3.4 async/await\n\n```jsx\n/// fetchData.js\nexport const fetchData = () => {\n return axios.get(\"http://a.jspang.com/jestTest.json\"); // 此地址并不存在};\n\n/// fetchData.test.js\n// 方式1\ntest(\"fetchData测试\", async () => {\n await expect(fetchData()).resolves.toMatchObject({\n  data: {\n   success: true\n  }\n });\n});\n\n// 方式2\ntest(\"fetchData测试\", async () => {\n const response = await fetchData();\n expect(response.data).toEqual({ success: true });\n});\n```\n\n这时候我们的代码使用 `async....await...` 的形式，这里我们还使用了 `resolves` 用于把现有对象转换成 `Promise` 对象，然后使用 `jest` 中的 `toMatchObject` 进行匹配对象中的属性。\n\n## 4. jest 中的四个钩子函数\n\n### 4.1 beforeAll()\n\n`beforeAll()`钩子函数的意思是在所有测试用例之前进行执行。\n\n### 4.2 afterAll()\n\n`afterAll()`钩子函数是在完成所有测试用例之后才执行的函数。\n\n### 4.3 beforeEach()\n\n`beforeEach()`钩子函数，是在每个测试用例前都会执行一次的钩子函数。\n\n### 4.4 afterEach()\n\n`afterEach()`钩子函数，是在每次测试用例完成测试之后执行一次的钩子函数。\n\n## 5. jest 测试用例分组\n\n```jsx\n/// eat.js\nexport default class Eat {\n  setName(number) {\n    this.name = number === 1 ? \"水饺\" : \"火锅\";\n  }\n  setDesc() {\n    this.desc = this.user + \"描述\";\n  }\n  setMoney() {\n    this.money = this.name === \"水饺\" ? 80 : 300;\n  }\n}\n\n/// eat.test.js\nimport Eat from \"./eat\";\nconst eat = new Eat();\nbeforeAll(() => {\n  console.log(\"开始吃饭\");\n});\nafterAll(() => {\n  console.log(\"吃完饭了\");\n});\ndescribe(\"水饺相关内容\", () => {\n  test(\"测试水饺描述\", () => {\n    eat.setName(1);\n    eat.setDesc();\n    expect(eat.desc).toEqual(\"水饺描述\");\n  });\n  test(\"测试水饺价格\", () => {\n    eat.setName(1);\n    eat.setMoney();\n    expect(eat.money).toEqual(80);\n  });\n});\ndescribe(\"火锅相关内容\", () => {\n  test(\"测试火锅描述\", () => {\n    eat.setName(2);\n    eat.setDesc();\n    expect(eat.desc).toEqual(\"火锅描述\");\n  });\n  test(\"测试火锅价格\", () => {\n    eat.setName(2);\n    eat.setMoney();\n    expect(eat.money).toEqual(300);\n  });\n});\n```\n\n## 6. 钩子函数的作用域\n\n### 6.1 钩子函数在父级分组可作用域子集，类似继承\n\n即父级作用域下的钩子函数在子作用域下也生效\n\n### 6.2 钩子函数同级分组作用域互不干扰，各起作用\n\n同作用域下将都会执行\n\n### 6.3 先执行外部的钩子函数，再执行内部的钩子函数\n\n优先父级作用域下的钩子函数，其次执行子作用域下的钩子函数\n\n### 6.4 在进行测试准备的时候，将对应逻辑写到钩子函数\n\n如果将对应逻辑写到了非钩子函数的位置，那么将会优先执行，然后才会执行钩子函数\n\n### 6.5 对单个测试用例的调试\n\n当一个测试文件中的测试用例变得越来越多的时候，假如此时我们相对其中某一个测试用例进行调试，那么我们就需要使用 `test.only`\n\n```jsx\ntest.only(\"测试用例\", () => {\n  expect(1 + 1).toBe(2);\n});\n```\n\n## 7. Jest 中的 Mock\n\n### 7.1 作用\n\n### 7.1.1 捕获函数的调用和返回结果，以及 `this` 和调用顺序\n\n### 7.1.2 它可以让我们自由的设置返回结果\n\n### 7.1.3 改变内部函数的实现\n\n### 7.2 判定函数是否被调用\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback();\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  expect(func).toBeCalled(); // 测试用例被调用\n});\n```\n\n`jest.fn()`  可以帮助我们捕获函数的调用\n\n### 7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.calls.length).toBe(2); // 测试用例被调用2次\n  expect(func.mock.calls[0]).toEqual([\"张三\"]); // 测试用例传递的第一个参数是 \"张三\"\n});\n```\n\n此处打印 `func.mock`  将会打印一些常用的方法，可以根据需求进行相应的用例测试\n\n### 7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  // func.mockReturnValue(\"Common\")\n  // 所有模拟返回值都是 \"Common\"\n  func.mockReturnValueOnce(\"A\"); // 第一次模拟返回值返回 \"A\"\n  func.mockReturnValueOnce(\"B\"); // 第二次模拟返回值返回 \"B\"\n  func.mockReturnValueOnce(\"C\"); // 第三次模拟返回值返回 \"C\"\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.results[0].value).toBe(\"A\");\n  expect(func.mock.results[1].value).toBe(\"B\");\n  expect(func.mock.results[2].value).toBe(\"C\");\n});\n```\n\n`func.mockReturnValue()`  将对所有模拟返回的值生效\n\n`func.mockReturnValueOnce()`  执行到第几次就对第几个函数的模拟返回值生效\n\n支持链式调用\n\n### 7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.invocationCallOrder).toEqual([1, 2, 3]);\n});\n```\n\n### 7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向\n\n```jsx\n// demo.js\nexport const createObject = (ClassItem) => {\n  new ClassItem();\n}\n\n// demo.test.js\nimport { createObject } from \"./demo\";\ntest(\"测试 createObject\", () => {\n  const func = jest.fn();\n  createObject(func);\n  expect(func.mock.instances).toEqual([mockConstructor{}]); // 此处的 this 就是 mockConstructor\n});\n```\n\n### 7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理\n\n```jsx\n// demo.js\nexport const runCallback = callback => {\n  callback(\"张三\");\n};\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  // func.mockImplementation(() => \"hello\"); 等价于 jest.fn(() => \"hello\")\n  // func.mockImplementation(() => this); 等价于 jest.fn().mockReturnThis()\n  func.mockImplementationOnce(() => \"dell\");\n  func.mockImplementationOnce(() => \"lee\");\n  runCallback(func);\n  runCallback(func);\n  runCallback(func);\n  expect(func.mock.results[0].value).toBe(\"dell\");\n  expect(func.mock.results[1].value).toBe(\"lee\");\n});\n```\n\n`mockImplementation`  比 `mockReturnValue`  更健壮，因为内部可以写一些额外的逻辑\n\n### 7.8 toBeCalledWith() 来判定每次函数调用时的参数\n\n```jsx\n// demo.js\nexport const runCallback = (callback) => {\n  callback(\"ABC\");\n}\n\n// demo.test.js\nimport { runCallback } from \"./demo\";\ntest(\"测试 runCallback\", () => {\n  const func = jest.fn();\n  runCallback(func);\n  expect(func.mock.results[0]).toEqual([\"ABC\");\n  expect(func).toBeCalledWith(\"ABC\");\n});\n```\n\n### 7.9 模拟异步请求\n\n对于前端来说一般异步接口是测试是否发送了，而不测试后端接口返回的内容，是属于后端自动化测试的内容\n\n### 7.9.1 通过模拟库的方式来模拟异步测试\n\n```jsx\n// demo.js\nexport const getData = () => {\n  return axios.get(\"/api\").then(res => res.data);\n};\n\n// demo.test.js\nimport axios from \"axios\";\nimport { getData } from \"./demo\";\njest.mock(\"axios\"); // 对 axios 进行模拟，这样就不会请求真正数据\ntest(\"测试 getData\", async () => {\n  axios.get.mockResolvedValue({ data: \"hello\" }); // 使用 axios 请求的时候模拟成功的返回值就是 hello\n  await getData().then(data => {\n    expect(data).toBe(\"hello\");\n  });\n});\n```\n\n`mockResolvedValue` 模拟不限次数\n\n`mockResolvedValueOnce` 模拟一次，模拟两次就会报错，需再次调用\n\n### 7.9.2 通过模拟 Promise 方式模拟异步\n\n```jsx\n// demo.js\nexport const fetchData = () => {\n  return axios.get(\"/\").then(res => res.data);\n};\n\n// __mocks__/demo.js\nexport const fetchData = () => {\n  return new Promise((resolve, reject) => {\n    resolve(\"function() { return '123' }\");\n  });\n};\n\n// demo.test.js\njest.mock(\"./demo\");\nimport { fetchData } from \"./demo\";\ntest(\"测试fetchData\", () => {\n  return fetchData().then(data => {\n    expect(eval(data)).toEqual(\"123\");\n  });\n});\n\n/// 实现方式3\n// 修改jest.config.js 可以自动查找项目内部__mocks__下与要测试文件名字相同的文件做替换\n// 等同于 jest.mock(\"要测试文件名字相同的__mocks__下的文件\"){  automock: true; }\n```\n\n### 7.9.3 通过修改 jest.config.js 来自动识别**mocks**下的文件\n\n修改 `jest.config.js` 可以自动查找项目内部 `__mocks__` 下与要测试文件名字相同的文件做替换\n\n等同于> `jest.mock(\"要测试文件名字相同的__mocks__下的文件\")`\n\n### 7.9.4 使用 jest.unmock() 可取消 mock 模拟\n\n### 7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题\n\n```jsx\n// demo.js\nexport const fetchData = () => {\n  return axios.get(\"/\").then(res => res.data);\n};\nexport const getNumber = () => 123;\n\n// __mocks__/demo.js\nexport const fetchData = () => {\n  return new Promise((resolve, reject) => {\n    resolve(\"function() { return '123' }\");\n  });\n};\n\n// demo.test.js\njest.mock(\"./demo\");\nimport { fetchData } from \"./demo\";\nconst { getNumber } = jest.requireActual(\"./demo\"); // 引入真实文件\ntest(\"测试 fetchData\", () => {\n  return fetchData().then(data => {\n    expect(eval(data)).toEqual(\"123\");\n  });\n});\n\ntest(\"测试 getNumber\", () => {\n  expect(getNumber()).toEqual(123);\n});\n```\n\n## 8. snapshot 快照测试\n\n常用于测试配置文件\n\n### 8.1 toMatchSnapshot()\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\"\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  expect(generateConfig()).toMatchSnapshot(); // 将会在项目里生成快照文件\n});\n```\n\n如果要确认更新快照，需要在控制台选择。 `u`  代表对所有快照进行更新， `i`  代表对单个确认的快照进行更新\n\n### 8.2 测试部分可变变量的内容\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\",\n    time: new Date(),\n    // 可变变量\n    random: Math.random()\n    // 可变变量\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  expect(generateConfig()).toMatchSnapshot({\n    time: expect.any(Date),\n    random: expect.any(Number)\n  });\n});\n```\n\n### 8.3 行内的 snapshot\n\n`npm install prettier --save`\n\n可以快照放到行内的测试用例中\n\n```jsx\n// demo.js\nexport const generateConfig = () => {\n  return {\n    server: \"http://localhost\",\n    port: 8080,\n    domain: \"localhost\",\n    time: new Date(),\n    // 可变变量\n    random: Math.random()\n    // 可变变量\n  };\n};\n\n// demo.test.js\nimport { generateConfig } from \"./demo\";\ntest(\"测试 generateConfig\", () => {\n  // toMatchInlineSnapshot 可以快照放到行内的测试用例中\n  expect(generateConfig()).toMatchInlineSnapshot({\n    time: expect.any(Date),\n    random: expect.any(Number)\n  });\n});\n```\n\n---\n\n## 9. Test Driven Development(TDD) 测试驱动开发\n\n### 9.1 TDD 开发流程\n\n1. 编写测试用例（知道功能，先写测试用例）\n2. 运行测试，测试用例无法通过测试\n3. 编写代码，使测试用例通过测试\n4. 优化代码， 完成开发\n5. 新增功能，重复执行 1-4\n\n### 9.2 TDD 的优势\n\n1. 长期减少项目的回归 bug（减少修改代码产生的 bug）\n2. 代码质量更好（组织，可维护性好）\n3. 测试覆盖率高（因为是先编写测试用例，但测试覆盖率过高会影响很大精力）\n4. 错误测试代码不容易出现\n\n### 9.3 TDD 的适用场景\n\n1. 不适用于开发业务代码时使用（开发业务代码时会大量的与业务代码产生耦合，加大工作量）\n2. 适用于一些库的开发（开发库时代码耦合度较低，通常只处理函数等相关功能）\n\n---\n\n## 10. Behavior Driven Development(BDD) 行为驱动开发\n\n### 10.1 BDD 开发流程\n\n1. 先编写业务代码，不关心测试\n2. 思考并描述用户行为\n3. 根据用户行为模拟测试\n\n### 10.2 vue example\n\n```jsx\n/// testUtils.js\nexport const findTestWrapper = (wrapper, tag) => {\n  return wrapper.find(`[data-test=\"${tag}\"]`);\n};\n```\n\n```jsx\n/// __tests__/integration/TodoList.test.js\nimport { mount } from \"@vue/test-utils\";\nimport { findTestWrapper } from \"../../../../utils/testUtils\";\nimport TodoList from \"../../TodoList\";\n// import store from \"../../../../store\"\nit(`    \n 新增内容逻辑的集成测试    \n 1. 用户会在header输入框输入内容    \n 2. 用户会点击回车按钮  \n 3. 列表项应该增加用户输入内容的列表项`, () => {\n  const wrapper = mount(TodoList);\n  // const wrapper = mount(TodoList, { store })\n  // 如果使用 vuex，也几乎无改动\n  const inputElem = findTestWrapper(wrapper, \"header-input\").at(0);\n  const content = \"Dell lee\";\n  inputElem.setValue(content);\n  inputElem.trigger(\"change\");\n  inputElem.trigger(\"keyup.enter\");\n  const listItems = findTestWrapper(wrapper, \"list-item\").at(0);\n  expect(listItems.length).toBe(1);\n  expect(listItems.at(0).text()).toContain(content);\n});\n```\n\n### 10.3 react example\n\n```jsx\n/// testUtils.js\nexport const findTestWrapper = (wrapper, tag) => {\n  return wrapper.find(`[data-test=\"${tag}\"]`);\n};\n```\n\n```jsx\n/// __tests__/integration/TodoList.test.js\nimport React from \"react\";\n// import { Provider } from \"react-redux\";\nimport Enzyme, { mount } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport TodoList from \"../../TodoList\";\n// import store from \"../../../../store/createStore\";\nEnzyme.configure({ adapter: new Adapter() });\n\nit(`\n    新增内容逻辑的集成测试\n    1. 用户会在header输入框输入内容\n    2. 用户会点击回车按钮\n   3. 列表项应该增加用户输入内容的列表项\n`, () => {\n  const wrapper = mount(<TodoList />);\n  /** \n  const wrapper = mount(\n   <Provider store={store}>\n    <TodoList /></Provider>\n   </Provider>\n  )  \n  // 如果使用 redux，也几乎无改动\n */\n  const inputElem = findTestWrapper(wrapper, \"header-input\");\n  const content = \"Dell lee\";\n  inputElem.simulate(\"change\", { target: { value: content } });\n  inputElem.simulate(\"keyUp\", { keyCode: 13 });\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(1);\n  expect(listItems.text()).toContain(content);\n});\n```\n\n---\n\n## 11. TDD 和 BDD 的对比\n\n1. `TDD` 先写测试后写代码; `BDD` 先写代码后写测试\n2. `TDD` 创建的是 `unit` 单元测试文件夹，一般结合单元测试，属于白盒测试(知道实现测试代码); `BDD` 创建的是 `integration` 集成测试文件夹，一般结合集成测试，属于黑盒测试(不知道实现测试代码)\n3. `TDD` 测试重点在代码; `BDD` 测试重点在 `UI` ( `DOM`)\n4. `TDD` 安全感低(无法保证各个组件拼撞到一起是否不会有问题); `BDD` 安全感高\n5. `TDD` 速度快; `BDD` 速度慢\n\n---\n\n## 12. TDD 与 BDD 混用\n\n### 12.1 对一些工具函数的测试\n\n### 12.2 对 vuex 的 store 进行测试\n\n```jsx\n/// __tests__/unit/store.test.js\nimport store from \"../../../../store\";\nit(\"当 store 接受 changeInputValue 的 commit 时, inputValue 发生变化\", () => {\n  const value = \"123\";\n  store.commit(\"changeInputValue\", value);\n  expect(store.state.inputValue).toBe(value);\n});\n```\n\n### 12.3 对 redux 的 store 进行测试\n\n```jsx\n/// __tests__/unit/store.test.js\nimport store from \"../../../../store/createStore\";\nimport { changeInputValue } from \"../../../../store/actions\";\nit(\"当 store 接受 changeInputValue 的 dispatch 时, inputValue 发生变化\", () => {\n  const value = \"123\";\n  /**   \n  const changeInputValue = (payload) => ({ \n   type: CHANGE_IMPUT_VALUE, payload \n  })   \n */\n  store.dispatch(changeInputValue(value));\n  expect(store.getState().inputValue).toBe(value);\n});\n```\n\n---\n\n## 13. 异步测试\n\n注意：异步测试如果用到了异步函数，则需要调用 `done`  函数\n\n### 13.1 vue 的异步测试\n\n```javascript\n/// __mocks__/axios.js\nconst undoList = {  success: true,  data: [\n { status: \"div\", value: \"dell\" },\n { status: \"div\", value: \"lee\" }\n]};\nexport default {\n get(url) {\n  if (url === \"/getUndoList.json\") {\n   return new Promise((resolve, reject) => {\n    if (this.success === true) {\n     resolve(undoList);\n    } else {\n     reject(new Error());\n    }\n   });\n  }\n }};\n\n/// __tests__/integration/TodoList.test.js\nimport { mount } from \"@vue/test-utils\";\nimport { findTestWrapper } from \"../../../../utils/testUtils\";\nimport TodoList from \"../../TodoList\";\nimport store from \"../../../../store\";\n\nbeforeEach(() => {\n axios.success = true;\n jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响});\nit(`1. 用户进入页面时，请求远程测试; 2. 列表应该显示远程返回的数据`, done => {\n  const wrapper = mount(TodoList, { store });\n  wrapper.vm.$nickTick(() => {\n   const listItems = findTestWrapper(wrapper, \"list-item\");\n   expect(listItems.length).toBe(2);\n   done();\n  });\n });\nit(`1. 用户进入页面时，等待5s; 2. 列表应该显示远程返回的数据`, done => {\n const wrapper = mount(TodoList, { store });\n expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n jest.runAllTimers();\n wrapper.vm.$nickTick(() => {\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(2);\n  done();\n });\n});\n\nit(`1. 用户进入页面时，请求远程数据失败; 2. 列表应该显示空数据，不应该挂掉`, done => {\n axios.success = false;\n const wrapper = mount(TodoList, { store });\n expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n jest.runAllTimers();\n wrapper.vm.$nickTick(() => {\n  const listItems = findTestWrapper(wrapper, \"list-item\");\n  expect(listItems.length).toBe(0);\n  done();\n });\n});\n```\n\n### 13.2 react 的异步测试\n\n```jsx\n/// __mocks__/axios.js\nconst undoList = {\n  success: true,\n  data: [\n    { status: \"div\", value: \"dell\" },\n    { status: \"div\", value: \"lee\" }\n  ]\n};\n\nexport default {\n  get(url) {\n    if (url === \"/getUndoList.json\") {\n      return new Promise((resolve, reject) => {\n        if (this.success === true) {\n          resolve(undoList);\n        } else {\n          reject(new Error());\n        }\n      });\n    }\n  }\n};\n\n/// __tests__/integration/TodoList.test.js\nimport React from \"react\";\nimport { Provider } from \"react-redux\";\nimport Enzyme, { mount } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport TodoList from \"../../TodoList\";\nimport store from \"../../../../store/createStore\";\nEnzyme.configure({ adapter: new Adapter() });\n\nbeforeEach(() => {\n  axios.success = true;\n  jest.useFakeTimers(); // 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响\n});\n\nit(`\n    1. 用户进入页面时，请求远程测试\n    2. 列表应该显示远程返回的数据\n`, done => {\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  process.nickTick(() => {\n    wrapper.update();\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(2);\n    done();\n  });\n});\n\nit(`\n    1. 用户进入页面时，等待5s\n    2. 列表应该显示远程返回的数据\n`, done => {\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n  jest.runAllTimers();\n  process.nickTick(() => {\n    wrapper.update(); // 更新 wrapper 防止取上一次的 wrapper\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(2);\n    done();\n  });\n});\n\nit(`\n  1. 用户进入页面时，请求远程数据失败\n  2. 列表应该显示空数据，不应该挂掉\n`, done => {\n  axios.success = false;\n  const wrapper = mount(\n    <Provider store={store}>\n      <TodoList />\n    </Provider>\n  );\n  expect(setTimeout).toHaveBeenCalledTimes(1); // 至少执行一次定时器\n  jest.runAllTimers();\n  process.nickTick(() => {\n    wrapper.update();\n    const listItems = findTestWrapper(wrapper, \"list-item\");\n    expect(listItems.length).toBe(0);\n    done();\n  });\n});\n```\n\n---\n\n## 14. vue 项目的自动化测试\n\n### 14.1 使用传统方式对 vue 组件进行测试\n\n```jsx\n// HelloWorld.test.js\nimport Vue from \"vue\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const root = document.createElement(\"div\");\n    root.className = \"root\";\n    document.body.appendChild(root);\n    new Vue({\n      render: h =>\n        h(HelloWorld, {\n          props: {\n            msg: \"dell lee\"\n          }\n        })\n    }).$mount(\".root\");\n    expect(document.getElementByClassName(\"hello\").length).toBe(1);\n  });\n});\n```\n\n缺点：写法过于复杂，局限性也很大，部分属性无法进行测试\n\n### 14.2 使用 @vue/test-utils 对 vue 组件进行测试\n\n- [官方文档](https://vue-test-utils.vuejs.org/zh/)\n\n### 14.2.1 for example\n\n```jsx\n// HelloWorld.test.js\nimport { shallowMount } from \"@vue/test-utils\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const msg = \"dell lee\";\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    });\n    expect(wrapper.text()).toMatch(msg);\n  });\n});\n```\n\n### 14.2.2 快照测试\n\n使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听\n\n好处: 可以帮助我们及时发现组件中 `dom` 结构的变化\n\n```jsx\n// HelloWorld.test.js\nimport { shallowMount } from \"@vue/test-utils\";\nimport HelloWorld from \"@/components/HelloWorld\";\ndescribe(\"HelloWorld.vue 组件渲染正常\", () => {\n  it(\"renders props.msg when passed\", () => {\n    const msg = \"dell lee\";\n    const wrapper = shallowMount(HelloWorld, {\n      propsData: { msg }\n    });\n    expect(wrapper).toMatchSnapshot();\n  });\n});\n```\n\n---\n\n## 15. react 项目的自动化测试\n\n### 15.1 使用传统方式对 react 组件进行测试\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nit(\"render App\", () => {\n  const div = document.createElement(\"div\");\n  ReactDOM.render(<App />, div);\n  const container = div.getElementsByClassName(\"App\");\n  expect(container.length).toBe(1);\n});\n```\n\n缺点：写法过于复杂，局限性也很大，部分属性无法进行测试\n\n### 15.2 enzyme 的配置和使用\n\n- [官方文档](https://enzymejs.github.io/enzyme/)\n- [github](https://github.com/enzymejs/enzyme)\n- [jest-enzyme](https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzyme)\n\n### 15.2.1 for example\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport Enzyme, { shallow } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport App from \"App\";\nEnzyme.configure({ adapter: new Adapter() });\nit(\"render App\", () => {\n  const wrapper = shallow(<App />);\n  expect(wrapper.find('[data-test=\"App\"]').length).toBe(2);\n});\n```\n\n使用自定义 `props` 可以降低代码耦合度\n\n`shallow` 适合单元测试，属于浅渲染； `mount` 适合集成测试，会将当前组件包括其子组件一起渲染\n\n单元测试时更倾向于使用 `api` `.state()` ；集成测试时更倾向于使用 `api` `.prop()`\n\n### 15.2.2 快照测试\n\n使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听\n\n好处: 可以帮助我们及时发现组件中 `dom` 结构的变化\n\n```jsx\n// App.test.js\nimport React from \"react\";\nimport Enzyme, { shallow } from \"enzyme\";\nimport Adapter from \"enzyme-adapter-react-16\";\nimport App from \"App\";\nEnzyme.configure({ adapter: new Adapter() });\nit(\"render App\", () => {\n  const wrapper = shallow(<App />);\n  expect(wrapper).toMatchSnapshot();\n});\n```\n\n---\n\n## 16. 前端自动化测试的优势\n\n- 更好的代码组织，项目的可维护性强\n- 更少的 `Bug` 出现概率，尤其是回归测试中的 `Bug`\n- 修改工程质量差的项目，更加安全\n- 项目具备潜在的文档特性\n- 扩展前端的知识面\n\n## 17 总结重要的点\n\n1. `BDD` 和 `TDD`\n2. 集成测试 和 单元测试\n3. 测试和业务的解耦\n4. 代码测试覆盖率并不代表一定靠谱\n5. 功能性测试 和 `UI`测试\n6. 测试越独立，隐藏的问题就越多\n","slug":"前端/前端自动化测试","published":1,"updated":"2021-04-07T07:39:19.368Z","_id":"ckn7476aw003byx7y6rl88saa","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-单元测试\"><a href=\"#1-单元测试\" class=\"headerlink\" title=\"1. 单元测试\"></a>1. 单元测试</h2><p>对软件中的最小可测试单元进行检查和验证，在前端一般为一个模块。</p>\n<h3 id=\"1-1-单元测试的优缺点\"><a href=\"#1-1-单元测试的优缺点\" class=\"headerlink\" title=\"1.1 单元测试的优缺点\"></a>1.1 单元测试的优缺点</h3><ol>\n<li>测试覆盖率高</li>\n<li>业务耦合度高</li>\n<li>代码量大</li>\n<li>过于独立</li>\n</ol>\n<h3 id=\"1-2-总结\"><a href=\"#1-2-总结\" class=\"headerlink\" title=\"1.2 总结\"></a>1.2 总结</h3><p>在某些场景下适合适用单元测试，某些场景下不适合适用单元测试</p>\n<h2 id=\"2-集成测试\"><a href=\"#2-集成测试\" class=\"headerlink\" title=\"2. 集成测试\"></a>2. 集成测试</h2><p>又叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</p>\n<h2 id=\"3-jest-中的匹配器\"><a href=\"#3-jest-中的匹配器\" class=\"headerlink\" title=\"3. jest 中的匹配器\"></a>3. jest 中的匹配器</h2><p><a href=\"https://jestjs.io/docs/en/expect\">jest 匹配器官网</a></p>\n<p>修改 <code>jest</code>  默认配置命令 <code>npx jest --init</code></p>\n<h3 id=\"3-1-实时监听测试用例的改变\"><a href=\"#3-1-实时监听测试用例的改变\" class=\"headerlink\" title=\"3.1 实时监听测试用例的改变\"></a>3.1 实时监听测试用例的改变</h3><p><code>jest --watchAll</code> 一旦某个测试用例发生变化，所有的测试用例都将会重新执行</p>\n<p><code>jest --watch</code>  默认进入 <code>o</code>  模式，即只对发生变化的测试用例重新执行</p>\n<h3 id=\"3-2-常用匹配器\"><a href=\"#3-2-常用匹配器\" class=\"headerlink\" title=\"3.2 常用匹配器\"></a>3.2 常用匹配器</h3><h3 id=\"3-2-1-toBe\"><a href=\"#3-2-1-toBe\" class=\"headerlink\" title=\"3.2.1 toBe()\"></a>3.2.1 toBe()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBe的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span> &#125;;</span><br><span class=\"line\">  expect(a).toBe(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ❌ 因为引用类型使用toBe不是全等效果</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBe</code> 匹配器类似于 <code>===</code>。</p>\n<hr>\n<h3 id=\"3-2-2-toEqual\"><a href=\"#3-2-2-toEqual\" class=\"headerlink\" title=\"3.2.2 toEqual()\"></a>3.2.2 toEqual()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toEqual的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span> &#125;;</span><br><span class=\"line\">  expect(a).toBe(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅ 因为toEqual只是对结果的匹配，而不是全等效果</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toEqual</code> 匹配器只是对结果相等与否进行匹配</p>\n<hr>\n<h3 id=\"3-2-3-toBeNull\"><a href=\"#3-2-3-toBeNull\" class=\"headerlink\" title=\"3.2.3 toBeNull()\"></a>3.2.3 toBeNull()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeNull的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  expect(a).toBeNull();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeNull</code> 是对 <code>null</code> 值的匹配</p>\n<hr>\n<h3 id=\"3-2-4-toBeUndefined\"><a href=\"#3-2-4-toBeUndefined\" class=\"headerlink\" title=\"3.2.4 toBeUndefined()\"></a>3.2.4 toBeUndefined()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeUndefined的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  expect(a).toBeUndefined();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeUndefined</code> 是对 <code>undefined</code> 值的匹配</p>\n<hr>\n<h3 id=\"3-2-5-toBeDefined\"><a href=\"#3-2-5-toBeDefined\" class=\"headerlink\" title=\"3.2.5 toBeDefined()\"></a>3.2.5 toBeDefined()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeDefined的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  expect(a).toBeDefined();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeDefined</code> 是对已经定义的值的匹配，若为 <code>undefined</code> 则不通过</p>\n<hr>\n<h3 id=\"3-2-6-toBeTruthy\"><a href=\"#3-2-6-toBeTruthy\" class=\"headerlink\" title=\"3.2.6 toBeTruthy()\"></a>3.2.6 toBeTruthy()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeTruthy的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  expect(a).toBeTruthy();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 0 =&gt; ❌，因为 toBeTruthy 是对 true 值的匹配</span></span><br><span class=\"line\"><span class=\"comment\">// 1 =&gt; ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeTruthy</code> 是对 <code>true</code> 值的匹配</p>\n<hr>\n<h3 id=\"3-2-7-toBeFalsy\"><a href=\"#3-2-7-toBeFalsy\" class=\"headerlink\" title=\"3.2.7 toBeFalsy()\"></a>3.2.7 toBeFalsy()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeFalsy的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  expect(a).toBeFalsy();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 1 =&gt; ❌</span></span><br><span class=\"line\"><span class=\"comment\">// 0 =&gt; ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeFalsy</code> 是对 <code>false</code> 值的匹配</p>\n<hr>\n<h3 id=\"3-2-8-toBeGreaterThan\"><a href=\"#3-2-8-toBeGreaterThan\" class=\"headerlink\" title=\"3.2.8 toBeGreaterThan()\"></a>3.2.8 toBeGreaterThan()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeGreaterThan匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">  expect(a).toBeGreaterThan(<span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeGreaterThan</code> 相当于 <code>&gt;</code></p>\n<hr>\n<h3 id=\"3-2-9-toBeLessThan\"><a href=\"#3-2-9-toBeLessThan\" class=\"headerlink\" title=\"3.2.9 toBeLessThan()\"></a>3.2.9 toBeLessThan()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeLessThan匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">8</span>;</span><br><span class=\"line\">  expect(a).toBeLessThan(<span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeLessThan</code> 相当于 <code>&lt;</code></p>\n<hr>\n<h3 id=\"3-2-10-toBeGreaterThanOrEqual\"><a href=\"#3-2-10-toBeGreaterThanOrEqual\" class=\"headerlink\" title=\"3.2.10 toBeGreaterThanOrEqual()\"></a>3.2.10 toBeGreaterThanOrEqual()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeGreaterThanOrEqual匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">  expect(a).toBeGreaterThanOrEqual(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeGreaterThanOrEqual</code> 相当于 <code>&gt;=</code></p>\n<hr>\n<h3 id=\"3-2-11-toBeLessThanOrEqual\"><a href=\"#3-2-11-toBeLessThanOrEqual\" class=\"headerlink\" title=\"3.2.11 toBeLessThanOrEqual()\"></a>3.2.11 toBeLessThanOrEqual()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeLessThanOrEqual匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">  expect(a).toBeLessThanOrEqual(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeLessThanOrEqual</code> 相当于 <code>&lt;=</code></p>\n<hr>\n<h3 id=\"3-2-12-toBeCloseTo\"><a href=\"#3-2-12-toBeCloseTo\" class=\"headerlink\" title=\"3.2.12 toBeCloseTo()\"></a>3.2.12 toBeCloseTo()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeCloseTo匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> one = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> two = <span class=\"number\">0.2</span>;</span><br><span class=\"line\">  expect(one + two).toEqual(<span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ❌ 因为浮点精度不同</span></span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toBeCloseTo匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> one = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> two = <span class=\"number\">0.2</span>;</span><br><span class=\"line\">  expect(one + two).toBeCloseTo(<span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeCloseTo</code> 为了解决浮点精度不同导致的无法匹配的问题</p>\n<hr>\n<h3 id=\"3-2-13-toMatch\"><a href=\"#3-2-13-toMatch\" class=\"headerlink\" title=\"3.2.13 toMatch()\"></a>3.2.13 toMatch()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toMatch匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> str = <span class=\"string\">&quot;张三、李四、王五&quot;</span>;</span><br><span class=\"line\">  expect(str).toMatch(<span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toMatch匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> str = <span class=\"string\">&quot;张三、李四、王五&quot;</span>;</span><br><span class=\"line\">  expect(str).toMatch(<span class=\"regexp\">/李四/</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toMatch</code> 为字符串包含匹配器，用来匹配字符串中包含的内容，也可传正则表达式</p>\n<hr>\n<h3 id=\"3-2-14-toContain\"><a href=\"#3-2-14-toContain\" class=\"headerlink\" title=\"3.2.14 toContain()\"></a>3.2.14 toContain()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toContain匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [<span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>, <span class=\"string\">&quot;王五&quot;</span>];</span><br><span class=\"line\">  expect(arr).toContain(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toContain匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [<span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>, <span class=\"string\">&quot;王五&quot;</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr);</span><br><span class=\"line\">  expect(data).toContain(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>toContain</code> 为数据包含匹器，用来匹配数组中包含的项。同时可完全兼容 <code>Set</code> 测试</p>\n<hr>\n<h3 id=\"3-2-15-toHaveLength\"><a href=\"#3-2-15-toHaveLength\" class=\"headerlink\" title=\"3.2.15 toHaveLength()\"></a>3.2.15 toHaveLength()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// functions.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getIntArray</span>(<span class=\"params\">num</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Number</span>.isInteger(num)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;&quot;getIntArray&quot;只接受整数类型的参数&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = num; i &lt; len; i++) &#123;</span><br><span class=\"line\">      result.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// functions.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getIntArray &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../src/functions&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;getIntArray(3)返回的数组长度应该为3&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(getIntArray(<span class=\"number\">3</span>)).toHaveLength(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>toHaveLength</code>可以很方便的用来测试字符串和数组类型的长度是否满足预期。</p>\n<h3 id=\"3-2-16-toThrow\"><a href=\"#3-2-16-toThrow\" class=\"headerlink\" title=\"3.2.16 toThrow()\"></a>3.2.16 toThrow()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throwNewErrorFunc = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;this is a new error&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toThrow匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(throwNewErrorFunc).toThrow();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>toThrow</code> 是专门对异常进行处理的匹配器，可以检测一个方法会不会抛出异常</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throwNewErrorFunc = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;this is a new error&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toThrow匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(throwNewErrorFunc).toThrow(<span class=\"string\">&quot;this is a new error&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以对这个匹配器中加一些字符串，意思就是抛出的异常必须和字符串相对应，如果字符串不匹配，也没办法通过异常测试。</p>\n<hr>\n<h3 id=\"3-2-17-not\"><a href=\"#3-2-17-not\" class=\"headerlink\" title=\"3.2.17 not()\"></a>3.2.17 not()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throwNewErrorFunc = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;this is a new error&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试not匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(throwNewErrorFunc).not.toThrow();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>not</code> 匹配器是 <code>jest</code> 中比较特殊的匹配器，意思就是 “相反” 或者说 “取反” .比如上面的例子，我们不希望方法抛出异常，就可以使用<code>not</code> 匹配器。</p>\n<hr>\n<h3 id=\"3-3-异步代码测试方法\"><a href=\"#3-3-异步代码测试方法\" class=\"headerlink\" title=\"3.3 异步代码测试方法\"></a>3.3 异步代码测试方法</h3><h3 id=\"3-3-1-回调函数式\"><a href=\"#3-3-1-回调函数式\" class=\"headerlink\" title=\"3.3.1 回调函数式\"></a>3.3.1 回调函数式</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// fetchData.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&quot;axios&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> &#123;</span><br><span class=\"line\">  axios.get(<span class=\"string\">&quot;http://a.jspang.com/jestTest.json&quot;</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fn(res.data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// fetchData.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fetchData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./fetchData.js&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetchData(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(data).toEqual(&#123; <span class=\"attr\">success</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>必须加入一个 <code>done</code> 方法，保证我们的回调已经完成了，这时候我们表示测试完成</p>\n<hr>\n<h3 id=\"3-3-2-直接返回-Promise\"><a href=\"#3-3-2-直接返回-Promise\" class=\"headerlink\" title=\"3.3.2 直接返回 Promise\"></a>3.3.2 直接返回 Promise</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// fetchTwoData.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&quot;axios&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchTwoData = <span class=\"function\">() =&gt;</span> axios.get(<span class=\"string\">&quot;http://a.jspang.com/jestTest.json&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// fetchTwoData.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fetchTwoData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./fetchTwoData.js&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchTwoData的测试用例&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> fetchTwoData().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  expect(res.data).toEqual(&#123; <span class=\"attr\">success</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>注意要 <code>return</code></p>\n<h3 id=\"3-3-3-不存在的接口\"><a href=\"#3-3-3-不存在的接口\" class=\"headerlink\" title=\"3.3.3 不存在的接口\"></a>3.3.3 不存在的接口</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// fetchData.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;http://a.jspang.com/jestTest_error.json&quot;</span>); <span class=\"comment\">// 此地址并不存在</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// fetchData.test.js</span></span><br><span class=\"line\"><span class=\"comment\">// 方式1</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect.assertions(<span class=\"number\">1</span>); <span class=\"comment\">// 断言，必须执行一次 expect</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetchData().catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(err.toString().indexOf(<span class=\"string\">&quot;404&quot;</span>) &gt; -<span class=\"number\">1</span>).toBe(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> fetchData().rejects.toThrow();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式3</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  expect().assertions(<span class=\"number\">1</span>); <span class=\"comment\">// 断言，必须执行一次 expect</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> fetchData();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    expect(err.toString().indexOf(<span class=\"string\">&quot;404&quot;</span>) &gt; -<span class=\"number\">1</span>).toBe(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>因为测试用例使用了 <code>catch</code> 方法，也就是说只有出现异常的时候才会走这个方法，而现在没有出现异常，就不会走这个测试方法，<code>jest</code> 就默认这个用例通过了测试。因此必须要执行断言，即必须让其执行一次即可。</p>\n<h3 id=\"3-3-4-async-await\"><a href=\"#3-3-4-async-await\" class=\"headerlink\" title=\"3.3.4 async/await\"></a>3.3.4 async/await</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// fetchData.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;http://a.jspang.com/jestTest.json&quot;</span>); <span class=\"comment\">// 此地址并不存在&#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// fetchData.test.js</span></span><br><span class=\"line\"><span class=\"comment\">// 方式1</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">await</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">   success: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetchData();</span><br><span class=\"line\"> expect(response.data).toEqual(&#123; <span class=\"attr\">success</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这时候我们的代码使用 <code>async....await...</code> 的形式，这里我们还使用了 <code>resolves</code> 用于把现有对象转换成 <code>Promise</code> 对象，然后使用 <code>jest</code> 中的 <code>toMatchObject</code> 进行匹配对象中的属性。</p>\n<h2 id=\"4-jest-中的四个钩子函数\"><a href=\"#4-jest-中的四个钩子函数\" class=\"headerlink\" title=\"4. jest 中的四个钩子函数\"></a>4. jest 中的四个钩子函数</h2><h3 id=\"4-1-beforeAll\"><a href=\"#4-1-beforeAll\" class=\"headerlink\" title=\"4.1 beforeAll()\"></a>4.1 beforeAll()</h3><p><code>beforeAll()</code>钩子函数的意思是在所有测试用例之前进行执行。</p>\n<h3 id=\"4-2-afterAll\"><a href=\"#4-2-afterAll\" class=\"headerlink\" title=\"4.2 afterAll()\"></a>4.2 afterAll()</h3><p><code>afterAll()</code>钩子函数是在完成所有测试用例之后才执行的函数。</p>\n<h3 id=\"4-3-beforeEach\"><a href=\"#4-3-beforeEach\" class=\"headerlink\" title=\"4.3 beforeEach()\"></a>4.3 beforeEach()</h3><p><code>beforeEach()</code>钩子函数，是在每个测试用例前都会执行一次的钩子函数。</p>\n<h3 id=\"4-4-afterEach\"><a href=\"#4-4-afterEach\" class=\"headerlink\" title=\"4.4 afterEach()\"></a>4.4 afterEach()</h3><p><code>afterEach()</code>钩子函数，是在每次测试用例完成测试之后执行一次的钩子函数。</p>\n<h2 id=\"5-jest-测试用例分组\"><a href=\"#5-jest-测试用例分组\" class=\"headerlink\" title=\"5. jest 测试用例分组\"></a>5. jest 测试用例分组</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// eat.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Eat</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setName</span>(<span class=\"params\">number</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = number === <span class=\"number\">1</span> ? <span class=\"string\">&quot;水饺&quot;</span> : <span class=\"string\">&quot;火锅&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setDesc</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.desc = <span class=\"built_in\">this</span>.user + <span class=\"string\">&quot;描述&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setMoney</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.money = <span class=\"built_in\">this</span>.name === <span class=\"string\">&quot;水饺&quot;</span> ? <span class=\"number\">80</span> : <span class=\"number\">300</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// eat.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Eat <span class=\"keyword\">from</span> <span class=\"string\">&quot;./eat&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eat = <span class=\"keyword\">new</span> Eat();</span><br><span class=\"line\">beforeAll(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;开始吃饭&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">afterAll(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;吃完饭了&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">describe(<span class=\"string\">&quot;水饺相关内容&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  test(<span class=\"string\">&quot;测试水饺描述&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    eat.setName(<span class=\"number\">1</span>);</span><br><span class=\"line\">    eat.setDesc();</span><br><span class=\"line\">    expect(eat.desc).toEqual(<span class=\"string\">&quot;水饺描述&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  test(<span class=\"string\">&quot;测试水饺价格&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    eat.setName(<span class=\"number\">1</span>);</span><br><span class=\"line\">    eat.setMoney();</span><br><span class=\"line\">    expect(eat.money).toEqual(<span class=\"number\">80</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">describe(<span class=\"string\">&quot;火锅相关内容&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  test(<span class=\"string\">&quot;测试火锅描述&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    eat.setName(<span class=\"number\">2</span>);</span><br><span class=\"line\">    eat.setDesc();</span><br><span class=\"line\">    expect(eat.desc).toEqual(<span class=\"string\">&quot;火锅描述&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  test(<span class=\"string\">&quot;测试火锅价格&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    eat.setName(<span class=\"number\">2</span>);</span><br><span class=\"line\">    eat.setMoney();</span><br><span class=\"line\">    expect(eat.money).toEqual(<span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-钩子函数的作用域\"><a href=\"#6-钩子函数的作用域\" class=\"headerlink\" title=\"6. 钩子函数的作用域\"></a>6. 钩子函数的作用域</h2><h3 id=\"6-1-钩子函数在父级分组可作用域子集，类似继承\"><a href=\"#6-1-钩子函数在父级分组可作用域子集，类似继承\" class=\"headerlink\" title=\"6.1 钩子函数在父级分组可作用域子集，类似继承\"></a>6.1 钩子函数在父级分组可作用域子集，类似继承</h3><p>即父级作用域下的钩子函数在子作用域下也生效</p>\n<h3 id=\"6-2-钩子函数同级分组作用域互不干扰，各起作用\"><a href=\"#6-2-钩子函数同级分组作用域互不干扰，各起作用\" class=\"headerlink\" title=\"6.2 钩子函数同级分组作用域互不干扰，各起作用\"></a>6.2 钩子函数同级分组作用域互不干扰，各起作用</h3><p>同作用域下将都会执行</p>\n<h3 id=\"6-3-先执行外部的钩子函数，再执行内部的钩子函数\"><a href=\"#6-3-先执行外部的钩子函数，再执行内部的钩子函数\" class=\"headerlink\" title=\"6.3 先执行外部的钩子函数，再执行内部的钩子函数\"></a>6.3 先执行外部的钩子函数，再执行内部的钩子函数</h3><p>优先父级作用域下的钩子函数，其次执行子作用域下的钩子函数</p>\n<h3 id=\"6-4-在进行测试准备的时候，将对应逻辑写到钩子函数\"><a href=\"#6-4-在进行测试准备的时候，将对应逻辑写到钩子函数\" class=\"headerlink\" title=\"6.4 在进行测试准备的时候，将对应逻辑写到钩子函数\"></a>6.4 在进行测试准备的时候，将对应逻辑写到钩子函数</h3><p>如果将对应逻辑写到了非钩子函数的位置，那么将会优先执行，然后才会执行钩子函数</p>\n<h3 id=\"6-5-对单个测试用例的调试\"><a href=\"#6-5-对单个测试用例的调试\" class=\"headerlink\" title=\"6.5 对单个测试用例的调试\"></a>6.5 对单个测试用例的调试</h3><p>当一个测试文件中的测试用例变得越来越多的时候，假如此时我们相对其中某一个测试用例进行调试，那么我们就需要使用 <code>test.only</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.only(<span class=\"string\">&quot;测试用例&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(<span class=\"number\">1</span> + <span class=\"number\">1</span>).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-Jest-中的-Mock\"><a href=\"#7-Jest-中的-Mock\" class=\"headerlink\" title=\"7. Jest 中的 Mock\"></a>7. Jest 中的 Mock</h2><h3 id=\"7-1-作用\"><a href=\"#7-1-作用\" class=\"headerlink\" title=\"7.1 作用\"></a>7.1 作用</h3><h3 id=\"7-1-1-捕获函数的调用和返回结果，以及-this-和调用顺序\"><a href=\"#7-1-1-捕获函数的调用和返回结果，以及-this-和调用顺序\" class=\"headerlink\" title=\"7.1.1 捕获函数的调用和返回结果，以及 this 和调用顺序\"></a>7.1.1 捕获函数的调用和返回结果，以及 <code>this</code> 和调用顺序</h3><h3 id=\"7-1-2-它可以让我们自由的设置返回结果\"><a href=\"#7-1-2-它可以让我们自由的设置返回结果\" class=\"headerlink\" title=\"7.1.2 它可以让我们自由的设置返回结果\"></a>7.1.2 它可以让我们自由的设置返回结果</h3><h3 id=\"7-1-3-改变内部函数的实现\"><a href=\"#7-1-3-改变内部函数的实现\" class=\"headerlink\" title=\"7.1.3 改变内部函数的实现\"></a>7.1.3 改变内部函数的实现</h3><h3 id=\"7-2-判定函数是否被调用\"><a href=\"#7-2-判定函数是否被调用\" class=\"headerlink\" title=\"7.2 判定函数是否被调用\"></a>7.2 判定函数是否被调用</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func).toBeCalled(); <span class=\"comment\">// 测试用例被调用</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>jest.fn()</code>  可以帮助我们捕获函数的调用</p>\n<h3 id=\"7-3-jest-fn-mock-calls-判定函数被调用了几次和传递的参数\"><a href=\"#7-3-jest-fn-mock-calls-判定函数被调用了几次和传递的参数\" class=\"headerlink\" title=\"7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数\"></a>7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.calls.length).toBe(<span class=\"number\">2</span>); <span class=\"comment\">// 测试用例被调用2次</span></span><br><span class=\"line\">  expect(func.mock.calls[<span class=\"number\">0</span>]).toEqual([<span class=\"string\">&quot;张三&quot;</span>]); <span class=\"comment\">// 测试用例传递的第一个参数是 &quot;张三&quot;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>此处打印 <code>func.mock</code>  将会打印一些常用的方法，可以根据需求进行相应的用例测试</p>\n<h3 id=\"7-4-jest-fn-mockReturnValue-判定函数执行了几次和返回结果\"><a href=\"#7-4-jest-fn-mockReturnValue-判定函数执行了几次和返回结果\" class=\"headerlink\" title=\"7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果\"></a>7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  <span class=\"comment\">// func.mockReturnValue(&quot;Common&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">// 所有模拟返回值都是 &quot;Common&quot;</span></span><br><span class=\"line\">  func.mockReturnValueOnce(<span class=\"string\">&quot;A&quot;</span>); <span class=\"comment\">// 第一次模拟返回值返回 &quot;A&quot;</span></span><br><span class=\"line\">  func.mockReturnValueOnce(<span class=\"string\">&quot;B&quot;</span>); <span class=\"comment\">// 第二次模拟返回值返回 &quot;B&quot;</span></span><br><span class=\"line\">  func.mockReturnValueOnce(<span class=\"string\">&quot;C&quot;</span>); <span class=\"comment\">// 第三次模拟返回值返回 &quot;C&quot;</span></span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">0</span>].value).toBe(<span class=\"string\">&quot;A&quot;</span>);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">1</span>].value).toBe(<span class=\"string\">&quot;B&quot;</span>);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">2</span>].value).toBe(<span class=\"string\">&quot;C&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>func.mockReturnValue()</code>  将对所有模拟返回的值生效</p>\n<p><code>func.mockReturnValueOnce()</code>  执行到第几次就对第几个函数的模拟返回值生效</p>\n<p>支持链式调用</p>\n<h3 id=\"7-5-jest-fn-mock-invocationCallOrder-判定函数执行顺序\"><a href=\"#7-5-jest-fn-mock-invocationCallOrder-判定函数执行顺序\" class=\"headerlink\" title=\"7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序\"></a>7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.invocationCallOrder).toEqual([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-jest-fn-mock-instances-判定函数调用了几次以及-this-指向\"><a href=\"#7-6-jest-fn-mock-instances-判定函数调用了几次以及-this-指向\" class=\"headerlink\" title=\"7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向\"></a>7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createObject = <span class=\"function\">(<span class=\"params\">ClassItem</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> ClassItem();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createObject &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 createObject&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  createObject(func);</span><br><span class=\"line\">  expect(func.mock.instances).toEqual([mockConstructor&#123;&#125;]); <span class=\"comment\">// 此处的 this 就是 mockConstructor</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-7-jest-fn-mockImplementation-判定函数返回结果和其他逻辑处理\"><a href=\"#7-7-jest-fn-mockImplementation-判定函数返回结果和其他逻辑处理\" class=\"headerlink\" title=\"7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理\"></a>7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  <span class=\"comment\">// func.mockImplementation(() =&gt; &quot;hello&quot;); 等价于 jest.fn(() =&gt; &quot;hello&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">// func.mockImplementation(() =&gt; this); 等价于 jest.fn().mockReturnThis()</span></span><br><span class=\"line\">  func.mockImplementationOnce(<span class=\"function\">() =&gt;</span> <span class=\"string\">&quot;dell&quot;</span>);</span><br><span class=\"line\">  func.mockImplementationOnce(<span class=\"function\">() =&gt;</span> <span class=\"string\">&quot;lee&quot;</span>);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">0</span>].value).toBe(<span class=\"string\">&quot;dell&quot;</span>);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">1</span>].value).toBe(<span class=\"string\">&quot;lee&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>mockImplementation</code>  比 <code>mockReturnValue</code>  更健壮，因为内部可以写一些额外的逻辑</p>\n<h3 id=\"7-8-toBeCalledWith-来判定每次函数调用时的参数\"><a href=\"#7-8-toBeCalledWith-来判定每次函数调用时的参数\" class=\"headerlink\" title=\"7.8 toBeCalledWith() 来判定每次函数调用时的参数\"></a>7.8 toBeCalledWith() 来判定每次函数调用时的参数</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\">(<span class=\"params\">callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;ABC&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">0</span>]).toEqual([<span class=\"string\">&quot;ABC&quot;</span>);</span><br><span class=\"line\">  expect(func).toBeCalledWith(<span class=\"string\">&quot;ABC&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-9-模拟异步请求\"><a href=\"#7-9-模拟异步请求\" class=\"headerlink\" title=\"7.9 模拟异步请求\"></a>7.9 模拟异步请求</h3><p>对于前端来说一般异步接口是测试是否发送了，而不测试后端接口返回的内容，是属于后端自动化测试的内容</p>\n<h3 id=\"7-9-1-通过模拟库的方式来模拟异步测试\"><a href=\"#7-9-1-通过模拟库的方式来模拟异步测试\" class=\"headerlink\" title=\"7.9.1 通过模拟库的方式来模拟异步测试\"></a>7.9.1 通过模拟库的方式来模拟异步测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;/api&quot;</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&quot;axios&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">jest.mock(<span class=\"string\">&quot;axios&quot;</span>); <span class=\"comment\">// 对 axios 进行模拟，这样就不会请求真正数据</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 getData&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  axios.get.mockResolvedValue(&#123; <span class=\"attr\">data</span>: <span class=\"string\">&quot;hello&quot;</span> &#125;); <span class=\"comment\">// 使用 axios 请求的时候模拟成功的返回值就是 hello</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> getData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(data).toBe(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>mockResolvedValue</code> 模拟不限次数</p>\n<p><code>mockResolvedValueOnce</code> 模拟一次，模拟两次就会报错，需再次调用</p>\n<h3 id=\"7-9-2-通过模拟-Promise-方式模拟异步\"><a href=\"#7-9-2-通过模拟-Promise-方式模拟异步\" class=\"headerlink\" title=\"7.9.2 通过模拟 Promise 方式模拟异步\"></a>7.9.2 通过模拟 Promise 方式模拟异步</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;/&quot;</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// __mocks__/demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">&quot;function() &#123; return &#x27;123&#x27; &#125;&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\">jest.mock(<span class=\"string\">&quot;./demo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fetchData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试fetchData&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetchData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(<span class=\"built_in\">eval</span>(data)).toEqual(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 实现方式3</span></span><br><span class=\"line\"><span class=\"comment\">// 修改jest.config.js 可以自动查找项目内部__mocks__下与要测试文件名字相同的文件做替换</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于 jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;)&#123;  automock: true; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-9-3-通过修改-jest-config-js-来自动识别mocks下的文件\"><a href=\"#7-9-3-通过修改-jest-config-js-来自动识别mocks下的文件\" class=\"headerlink\" title=\"7.9.3 通过修改 jest.config.js 来自动识别mocks下的文件\"></a>7.9.3 通过修改 jest.config.js 来自动识别<strong>mocks</strong>下的文件</h3><p>修改 <code>jest.config.js</code> 可以自动查找项目内部 <code>__mocks__</code> 下与要测试文件名字相同的文件做替换</p>\n<p>等同于&gt; <code>jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;)</code></p>\n<h3 id=\"7-9-4-使用-jest-unmock-可取消-mock-模拟\"><a href=\"#7-9-4-使用-jest-unmock-可取消-mock-模拟\" class=\"headerlink\" title=\"7.9.4 使用 jest.unmock() 可取消 mock 模拟\"></a>7.9.4 使用 jest.unmock() 可取消 mock 模拟</h3><h3 id=\"7-9-5-解决测试文件中部分功能不需要-mock，部分功能需要-mock-模拟异步的问题\"><a href=\"#7-9-5-解决测试文件中部分功能不需要-mock，部分功能需要-mock-模拟异步的问题\" class=\"headerlink\" title=\"7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题\"></a>7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;/&quot;</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getNumber = <span class=\"function\">() =&gt;</span> <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// __mocks__/demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">&quot;function() &#123; return &#x27;123&#x27; &#125;&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\">jest.mock(<span class=\"string\">&quot;./demo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fetchData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; getNumber &#125; = jest.requireActual(<span class=\"string\">&quot;./demo&quot;</span>); <span class=\"comment\">// 引入真实文件</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 fetchData&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetchData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(<span class=\"built_in\">eval</span>(data)).toEqual(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 getNumber&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(getNumber()).toEqual(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-snapshot-快照测试\"><a href=\"#8-snapshot-快照测试\" class=\"headerlink\" title=\"8. snapshot 快照测试\"></a>8. snapshot 快照测试</h2><p>常用于测试配置文件</p>\n<h3 id=\"8-1-toMatchSnapshot\"><a href=\"#8-1-toMatchSnapshot\" class=\"headerlink\" title=\"8.1 toMatchSnapshot()\"></a>8.1 toMatchSnapshot()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> generateConfig = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    server: <span class=\"string\">&quot;http://localhost&quot;</span>,</span><br><span class=\"line\">    port: <span class=\"number\">8080</span>,</span><br><span class=\"line\">    domain: <span class=\"string\">&quot;localhost&quot;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; generateConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 generateConfig&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(generateConfig()).toMatchSnapshot(); <span class=\"comment\">// 将会在项目里生成快照文件</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果要确认更新快照，需要在控制台选择。 <code>u</code>  代表对所有快照进行更新， <code>i</code>  代表对单个确认的快照进行更新</p>\n<h3 id=\"8-2-测试部分可变变量的内容\"><a href=\"#8-2-测试部分可变变量的内容\" class=\"headerlink\" title=\"8.2 测试部分可变变量的内容\"></a>8.2 测试部分可变变量的内容</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> generateConfig = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    server: <span class=\"string\">&quot;http://localhost&quot;</span>,</span><br><span class=\"line\">    port: <span class=\"number\">8080</span>,</span><br><span class=\"line\">    domain: <span class=\"string\">&quot;localhost&quot;</span>,</span><br><span class=\"line\">    time: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">    <span class=\"comment\">// 可变变量</span></span><br><span class=\"line\">    random: <span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">    <span class=\"comment\">// 可变变量</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; generateConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 generateConfig&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(generateConfig()).toMatchSnapshot(&#123;</span><br><span class=\"line\">    time: expect.any(<span class=\"built_in\">Date</span>),</span><br><span class=\"line\">    random: expect.any(<span class=\"built_in\">Number</span>)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-行内的-snapshot\"><a href=\"#8-3-行内的-snapshot\" class=\"headerlink\" title=\"8.3 行内的 snapshot\"></a>8.3 行内的 snapshot</h3><p><code>npm install prettier --save</code></p>\n<p>可以快照放到行内的测试用例中</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> generateConfig = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    server: <span class=\"string\">&quot;http://localhost&quot;</span>,</span><br><span class=\"line\">    port: <span class=\"number\">8080</span>,</span><br><span class=\"line\">    domain: <span class=\"string\">&quot;localhost&quot;</span>,</span><br><span class=\"line\">    time: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">    <span class=\"comment\">// 可变变量</span></span><br><span class=\"line\">    random: <span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">    <span class=\"comment\">// 可变变量</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; generateConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 generateConfig&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// toMatchInlineSnapshot 可以快照放到行内的测试用例中</span></span><br><span class=\"line\">  expect(generateConfig()).toMatchInlineSnapshot(&#123;</span><br><span class=\"line\">    time: expect.any(<span class=\"built_in\">Date</span>),</span><br><span class=\"line\">    random: expect.any(<span class=\"built_in\">Number</span>)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"9-Test-Driven-Development-TDD-测试驱动开发\"><a href=\"#9-Test-Driven-Development-TDD-测试驱动开发\" class=\"headerlink\" title=\"9. Test Driven Development(TDD) 测试驱动开发\"></a>9. Test Driven Development(TDD) 测试驱动开发</h2><h3 id=\"9-1-TDD-开发流程\"><a href=\"#9-1-TDD-开发流程\" class=\"headerlink\" title=\"9.1 TDD 开发流程\"></a>9.1 TDD 开发流程</h3><ol>\n<li>编写测试用例（知道功能，先写测试用例）</li>\n<li>运行测试，测试用例无法通过测试</li>\n<li>编写代码，使测试用例通过测试</li>\n<li>优化代码， 完成开发</li>\n<li>新增功能，重复执行 1-4</li>\n</ol>\n<h3 id=\"9-2-TDD-的优势\"><a href=\"#9-2-TDD-的优势\" class=\"headerlink\" title=\"9.2 TDD 的优势\"></a>9.2 TDD 的优势</h3><ol>\n<li>长期减少项目的回归 bug（减少修改代码产生的 bug）</li>\n<li>代码质量更好（组织，可维护性好）</li>\n<li>测试覆盖率高（因为是先编写测试用例，但测试覆盖率过高会影响很大精力）</li>\n<li>错误测试代码不容易出现</li>\n</ol>\n<h3 id=\"9-3-TDD-的适用场景\"><a href=\"#9-3-TDD-的适用场景\" class=\"headerlink\" title=\"9.3 TDD 的适用场景\"></a>9.3 TDD 的适用场景</h3><ol>\n<li>不适用于开发业务代码时使用（开发业务代码时会大量的与业务代码产生耦合，加大工作量）</li>\n<li>适用于一些库的开发（开发库时代码耦合度较低，通常只处理函数等相关功能）</li>\n</ol>\n<hr>\n<h2 id=\"10-Behavior-Driven-Development-BDD-行为驱动开发\"><a href=\"#10-Behavior-Driven-Development-BDD-行为驱动开发\" class=\"headerlink\" title=\"10. Behavior Driven Development(BDD) 行为驱动开发\"></a>10. Behavior Driven Development(BDD) 行为驱动开发</h2><h3 id=\"10-1-BDD-开发流程\"><a href=\"#10-1-BDD-开发流程\" class=\"headerlink\" title=\"10.1 BDD 开发流程\"></a>10.1 BDD 开发流程</h3><ol>\n<li>先编写业务代码，不关心测试</li>\n<li>思考并描述用户行为</li>\n<li>根据用户行为模拟测试</li>\n</ol>\n<h3 id=\"10-2-vue-example\"><a href=\"#10-2-vue-example\" class=\"headerlink\" title=\"10.2 vue example\"></a>10.2 vue example</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// testUtils.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> findTestWrapper = <span class=\"function\">(<span class=\"params\">wrapper, tag</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> wrapper.find(<span class=\"string\">`[data-test=&quot;<span class=\"subst\">$&#123;tag&#125;</span>&quot;]`</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __tests__/integration/TodoList.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@vue/test-utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; findTestWrapper &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../utils/testUtils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../TodoList&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import store from &quot;../../../../store&quot;</span></span><br><span class=\"line\">it(<span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\"> 新增内容逻辑的集成测试    </span></span><br><span class=\"line\"><span class=\"string\"> 1. 用户会在header输入框输入内容    </span></span><br><span class=\"line\"><span class=\"string\"> 2. 用户会点击回车按钮  </span></span><br><span class=\"line\"><span class=\"string\"> 3. 列表项应该增加用户输入内容的列表项`</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(TodoList);</span><br><span class=\"line\">  <span class=\"comment\">// const wrapper = mount(TodoList, &#123; store &#125;)</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果使用 vuex，也几乎无改动</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputElem = findTestWrapper(wrapper, <span class=\"string\">&quot;header-input&quot;</span>).at(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> content = <span class=\"string\">&quot;Dell lee&quot;</span>;</span><br><span class=\"line\">  inputElem.setValue(content);</span><br><span class=\"line\">  inputElem.trigger(<span class=\"string\">&quot;change&quot;</span>);</span><br><span class=\"line\">  inputElem.trigger(<span class=\"string\">&quot;keyup.enter&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>).at(<span class=\"number\">0</span>);</span><br><span class=\"line\">  expect(listItems.length).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">  expect(listItems.at(<span class=\"number\">0</span>).text()).toContain(content);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-3-react-example\"><a href=\"#10-3-react-example\" class=\"headerlink\" title=\"10.3 react example\"></a>10.3 react example</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// testUtils.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> findTestWrapper = <span class=\"function\">(<span class=\"params\">wrapper, tag</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> wrapper.find(<span class=\"string\">`[data-test=&quot;<span class=\"subst\">$&#123;tag&#125;</span>&quot;]`</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __tests__/integration/TodoList.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import &#123; Provider &#125; from &quot;react-redux&quot;;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Enzyme, &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Adapter <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme-adapter-react-16&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../TodoList&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import store from &quot;../../../../store/createStore&quot;;</span></span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    新增内容逻辑的集成测试</span></span><br><span class=\"line\"><span class=\"string\">    1. 用户会在header输入框输入内容</span></span><br><span class=\"line\"><span class=\"string\">    2. 用户会点击回车按钮</span></span><br><span class=\"line\"><span class=\"string\">   3. 列表项应该增加用户输入内容的列表项</span></span><br><span class=\"line\"><span class=\"string\">`</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">TodoList</span> /&gt;</span></span>);</span><br><span class=\"line\">  <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  const wrapper = mount(</span></span><br><span class=\"line\"><span class=\"comment\">   &lt;Provider store=&#123;store&#125;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;TodoList /&gt;&lt;/Provider&gt;</span></span><br><span class=\"line\"><span class=\"comment\">   &lt;/Provider&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  )  </span></span><br><span class=\"line\"><span class=\"comment\">  // 如果使用 redux，也几乎无改动</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputElem = findTestWrapper(wrapper, <span class=\"string\">&quot;header-input&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> content = <span class=\"string\">&quot;Dell lee&quot;</span>;</span><br><span class=\"line\">  inputElem.simulate(<span class=\"string\">&quot;change&quot;</span>, &#123; <span class=\"attr\">target</span>: &#123; <span class=\"attr\">value</span>: content &#125; &#125;);</span><br><span class=\"line\">  inputElem.simulate(<span class=\"string\">&quot;keyUp&quot;</span>, &#123; <span class=\"attr\">keyCode</span>: <span class=\"number\">13</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">  expect(listItems.length).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">  expect(listItems.text()).toContain(content);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"11-TDD-和-BDD-的对比\"><a href=\"#11-TDD-和-BDD-的对比\" class=\"headerlink\" title=\"11. TDD 和 BDD 的对比\"></a>11. TDD 和 BDD 的对比</h2><ol>\n<li><code>TDD</code> 先写测试后写代码; <code>BDD</code> 先写代码后写测试</li>\n<li><code>TDD</code> 创建的是 <code>unit</code> 单元测试文件夹，一般结合单元测试，属于白盒测试(知道实现测试代码); <code>BDD</code> 创建的是 <code>integration</code> 集成测试文件夹，一般结合集成测试，属于黑盒测试(不知道实现测试代码)</li>\n<li><code>TDD</code> 测试重点在代码; <code>BDD</code> 测试重点在 <code>UI</code> ( <code>DOM</code>)</li>\n<li><code>TDD</code> 安全感低(无法保证各个组件拼撞到一起是否不会有问题); <code>BDD</code> 安全感高</li>\n<li><code>TDD</code> 速度快; <code>BDD</code> 速度慢</li>\n</ol>\n<hr>\n<h2 id=\"12-TDD-与-BDD-混用\"><a href=\"#12-TDD-与-BDD-混用\" class=\"headerlink\" title=\"12. TDD 与 BDD 混用\"></a>12. TDD 与 BDD 混用</h2><h3 id=\"12-1-对一些工具函数的测试\"><a href=\"#12-1-对一些工具函数的测试\" class=\"headerlink\" title=\"12.1 对一些工具函数的测试\"></a>12.1 对一些工具函数的测试</h3><h3 id=\"12-2-对-vuex-的-store-进行测试\"><a href=\"#12-2-对-vuex-的-store-进行测试\" class=\"headerlink\" title=\"12.2 对 vuex 的 store 进行测试\"></a>12.2 对 vuex 的 store 进行测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __tests__/unit/store.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store&quot;</span>;</span><br><span class=\"line\">it(<span class=\"string\">&quot;当 store 接受 changeInputValue 的 commit 时, inputValue 发生变化&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">  store.commit(<span class=\"string\">&quot;changeInputValue&quot;</span>, value);</span><br><span class=\"line\">  expect(store.state.inputValue).toBe(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-3-对-redux-的-store-进行测试\"><a href=\"#12-3-对-redux-的-store-进行测试\" class=\"headerlink\" title=\"12.3 对 redux 的 store 进行测试\"></a>12.3 对 redux 的 store 进行测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __tests__/unit/store.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store/createStore&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; changeInputValue &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store/actions&quot;</span>;</span><br><span class=\"line\">it(<span class=\"string\">&quot;当 store 接受 changeInputValue 的 dispatch 时, inputValue 发生变化&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">/**   </span></span><br><span class=\"line\"><span class=\"comment\">  const changeInputValue = (payload) =&gt; (&#123; </span></span><br><span class=\"line\"><span class=\"comment\">   type: CHANGE_IMPUT_VALUE, payload </span></span><br><span class=\"line\"><span class=\"comment\">  &#125;)   </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  store.dispatch(changeInputValue(value));</span><br><span class=\"line\">  expect(store.getState().inputValue).toBe(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"13-异步测试\"><a href=\"#13-异步测试\" class=\"headerlink\" title=\"13. 异步测试\"></a>13. 异步测试</h2><p>注意：异步测试如果用到了异步函数，则需要调用 <code>done</code>  函数</p>\n<h3 id=\"13-1-vue-的异步测试\"><a href=\"#13-1-vue-的异步测试\" class=\"headerlink\" title=\"13.1 vue 的异步测试\"></a>13.1 vue 的异步测试</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __mocks__/axios.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> undoList = &#123;  <span class=\"attr\">success</span>: <span class=\"literal\">true</span>,  <span class=\"attr\">data</span>: [</span><br><span class=\"line\"> &#123; <span class=\"attr\">status</span>: <span class=\"string\">&quot;div&quot;</span>, <span class=\"attr\">value</span>: <span class=\"string\">&quot;dell&quot;</span> &#125;,</span><br><span class=\"line\"> &#123; <span class=\"attr\">status</span>: <span class=\"string\">&quot;div&quot;</span>, <span class=\"attr\">value</span>: <span class=\"string\">&quot;lee&quot;</span> &#125;</span><br><span class=\"line\">]&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">url</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (url === <span class=\"string\">&quot;/getUndoList.json&quot;</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.success === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">     resolve(undoList);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// __tests__/integration/TodoList.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@vue/test-utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; findTestWrapper &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../utils/testUtils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../TodoList&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">beforeEach(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> axios.success = <span class=\"literal\">true</span>;</span><br><span class=\"line\"> jest.useFakeTimers(); <span class=\"comment\">// 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响&#125;);</span></span><br><span class=\"line\">it(<span class=\"string\">`1. 用户进入页面时，请求远程测试; 2. 列表应该显示远程返回的数据`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(TodoList, &#123; store &#125;);</span><br><span class=\"line\">  wrapper.vm.$nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">   expect(listItems.length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">   done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">it(<span class=\"string\">`1. 用户进入页面时，等待5s; 2. 列表应该显示远程返回的数据`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> wrapper = mount(TodoList, &#123; store &#125;);</span><br><span class=\"line\"> expect(<span class=\"built_in\">setTimeout</span>).toHaveBeenCalledTimes(<span class=\"number\">1</span>); <span class=\"comment\">// 至少执行一次定时器</span></span><br><span class=\"line\"> jest.runAllTimers();</span><br><span class=\"line\"> wrapper.vm.$nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">  expect(listItems.length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">  done();</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`1. 用户进入页面时，请求远程数据失败; 2. 列表应该显示空数据，不应该挂掉`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\"> axios.success = <span class=\"literal\">false</span>;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> wrapper = mount(TodoList, &#123; store &#125;);</span><br><span class=\"line\"> expect(<span class=\"built_in\">setTimeout</span>).toHaveBeenCalledTimes(<span class=\"number\">1</span>); <span class=\"comment\">// 至少执行一次定时器</span></span><br><span class=\"line\"> jest.runAllTimers();</span><br><span class=\"line\"> wrapper.vm.$nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">  expect(listItems.length).toBe(<span class=\"number\">0</span>);</span><br><span class=\"line\">  done();</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-react-的异步测试\"><a href=\"#13-2-react-的异步测试\" class=\"headerlink\" title=\"13.2 react 的异步测试\"></a>13.2 react 的异步测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __mocks__/axios.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> undoList = &#123;</span><br><span class=\"line\">  success: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  data: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">status</span>: <span class=\"string\">&quot;div&quot;</span>, <span class=\"attr\">value</span>: <span class=\"string\">&quot;dell&quot;</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">status</span>: <span class=\"string\">&quot;div&quot;</span>, <span class=\"attr\">value</span>: <span class=\"string\">&quot;lee&quot;</span> &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">url</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url === <span class=\"string\">&quot;/getUndoList.json&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.success === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">          resolve(undoList);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// __tests__/integration/TodoList.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Enzyme, &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Adapter <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme-adapter-react-16&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../TodoList&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store/createStore&quot;</span>;</span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">beforeEach(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  axios.success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  jest.useFakeTimers(); <span class=\"comment\">// 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    1. 用户进入页面时，请求远程测试</span></span><br><span class=\"line\"><span class=\"string\">    2. 列表应该显示远程返回的数据</span></span><br><span class=\"line\"><span class=\"string\">`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &lt;TodoList /&gt;</span><br><span class=\"line\">    &lt;/Provider&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  process.nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    wrapper.update();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">    expect(listItems.length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    1. 用户进入页面时，等待5s</span></span><br><span class=\"line\"><span class=\"string\">    2. 列表应该显示远程返回的数据</span></span><br><span class=\"line\"><span class=\"string\">`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &lt;TodoList /&gt;</span><br><span class=\"line\">    &lt;/Provider&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  expect(<span class=\"built_in\">setTimeout</span>).toHaveBeenCalledTimes(<span class=\"number\">1</span>); <span class=\"comment\">// 至少执行一次定时器</span></span><br><span class=\"line\">  jest.runAllTimers();</span><br><span class=\"line\">  process.nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    wrapper.update(); <span class=\"comment\">// 更新 wrapper 防止取上一次的 wrapper</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">    expect(listItems.length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  1. 用户进入页面时，请求远程数据失败</span></span><br><span class=\"line\"><span class=\"string\">  2. 列表应该显示空数据，不应该挂掉</span></span><br><span class=\"line\"><span class=\"string\">`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  axios.success = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &lt;TodoList /&gt;</span><br><span class=\"line\">    &lt;/Provider&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  expect(<span class=\"built_in\">setTimeout</span>).toHaveBeenCalledTimes(<span class=\"number\">1</span>); <span class=\"comment\">// 至少执行一次定时器</span></span><br><span class=\"line\">  jest.runAllTimers();</span><br><span class=\"line\">  process.nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    wrapper.update();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">    expect(listItems.length).toBe(<span class=\"number\">0</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"14-vue-项目的自动化测试\"><a href=\"#14-vue-项目的自动化测试\" class=\"headerlink\" title=\"14. vue 项目的自动化测试\"></a>14. vue 项目的自动化测试</h2><h3 id=\"14-1-使用传统方式对-vue-组件进行测试\"><a href=\"#14-1-使用传统方式对-vue-组件进行测试\" class=\"headerlink\" title=\"14.1 使用传统方式对 vue 组件进行测试\"></a>14.1 使用传统方式对 vue 组件进行测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">&quot;@/components/HelloWorld&quot;</span>;</span><br><span class=\"line\">describe(<span class=\"string\">&quot;HelloWorld.vue&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  it(<span class=\"string\">&quot;renders props.msg when passed&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;div&quot;</span>);</span><br><span class=\"line\">    root.className = <span class=\"string\">&quot;root&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.appendChild(root);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">      render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span></span><br><span class=\"line\">        h(HelloWorld, &#123;</span><br><span class=\"line\">          props: &#123;</span><br><span class=\"line\">            msg: <span class=\"string\">&quot;dell lee&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;).$mount(<span class=\"string\">&quot;.root&quot;</span>);</span><br><span class=\"line\">    expect(<span class=\"built_in\">document</span>.getElementByClassName(<span class=\"string\">&quot;hello&quot;</span>).length).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p>\n<h3 id=\"14-2-使用-vue-test-utils-对-vue-组件进行测试\"><a href=\"#14-2-使用-vue-test-utils-对-vue-组件进行测试\" class=\"headerlink\" title=\"14.2 使用 @vue/test-utils 对 vue 组件进行测试\"></a>14.2 使用 @vue/test-utils 对 vue 组件进行测试</h3><ul>\n<li><a href=\"https://vue-test-utils.vuejs.org/zh/\">官方文档</a></li>\n</ul>\n<h3 id=\"14-2-1-for-example\"><a href=\"#14-2-1-for-example\" class=\"headerlink\" title=\"14.2.1 for example\"></a>14.2.1 for example</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; shallowMount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@vue/test-utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">&quot;@/components/HelloWorld&quot;</span>;</span><br><span class=\"line\">describe(<span class=\"string\">&quot;HelloWorld.vue&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  it(<span class=\"string\">&quot;renders props.msg when passed&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> msg = <span class=\"string\">&quot;dell lee&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wrapper = shallowMount(HelloWorld, &#123;</span><br><span class=\"line\">      propsData: &#123; msg &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    expect(wrapper.text()).toMatch(msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-2-2-快照测试\"><a href=\"#14-2-2-快照测试\" class=\"headerlink\" title=\"14.2.2 快照测试\"></a>14.2.2 快照测试</h3><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p>\n<p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; shallowMount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@vue/test-utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">&quot;@/components/HelloWorld&quot;</span>;</span><br><span class=\"line\">describe(<span class=\"string\">&quot;HelloWorld.vue 组件渲染正常&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  it(<span class=\"string\">&quot;renders props.msg when passed&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> msg = <span class=\"string\">&quot;dell lee&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wrapper = shallowMount(HelloWorld, &#123;</span><br><span class=\"line\">      propsData: &#123; msg &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    expect(wrapper).toMatchSnapshot();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"15-react-项目的自动化测试\"><a href=\"#15-react-项目的自动化测试\" class=\"headerlink\" title=\"15. react 项目的自动化测试\"></a>15. react 项目的自动化测试</h2><h3 id=\"15-1-使用传统方式对-react-组件进行测试\"><a href=\"#15-1-使用传统方式对-react-组件进行测试\" class=\"headerlink\" title=\"15.1 使用传统方式对 react 组件进行测试\"></a>15.1 使用传统方式对 react 组件进行测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;./App&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">&quot;render App&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;div&quot;</span>);</span><br><span class=\"line\">  ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>, div);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> container = div.getElementsByClassName(<span class=\"string\">&quot;App&quot;</span>);</span><br><span class=\"line\">  expect(container.length).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p>\n<h3 id=\"15-2-enzyme-的配置和使用\"><a href=\"#15-2-enzyme-的配置和使用\" class=\"headerlink\" title=\"15.2 enzyme 的配置和使用\"></a>15.2 enzyme 的配置和使用</h3><ul>\n<li><a href=\"https://enzymejs.github.io/enzyme/\">官方文档</a></li>\n<li><a href=\"https://github.com/enzymejs/enzyme\">github</a></li>\n<li><a href=\"https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzyme\">jest-enzyme</a></li>\n</ul>\n<h3 id=\"15-2-1-for-example\"><a href=\"#15-2-1-for-example\" class=\"headerlink\" title=\"15.2.1 for example\"></a>15.2.1 for example</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Enzyme, &#123; shallow &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Adapter <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme-adapter-react-16&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;App&quot;</span>;</span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\">it(<span class=\"string\">&quot;render App&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = shallow(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>);</span><br><span class=\"line\">  expect(wrapper.find(<span class=\"string\">&#x27;[data-test=&quot;App&quot;]&#x27;</span>).length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用自定义 <code>props</code> 可以降低代码耦合度</p>\n<p><code>shallow</code> 适合单元测试，属于浅渲染； <code>mount</code> 适合集成测试，会将当前组件包括其子组件一起渲染</p>\n<p>单元测试时更倾向于使用 <code>api</code> <code>.state()</code> ；集成测试时更倾向于使用 <code>api</code> <code>.prop()</code></p>\n<h3 id=\"15-2-2-快照测试\"><a href=\"#15-2-2-快照测试\" class=\"headerlink\" title=\"15.2.2 快照测试\"></a>15.2.2 快照测试</h3><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p>\n<p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Enzyme, &#123; shallow &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Adapter <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme-adapter-react-16&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;App&quot;</span>;</span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\">it(<span class=\"string\">&quot;render App&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = shallow(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>);</span><br><span class=\"line\">  expect(wrapper).toMatchSnapshot();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"16-前端自动化测试的优势\"><a href=\"#16-前端自动化测试的优势\" class=\"headerlink\" title=\"16. 前端自动化测试的优势\"></a>16. 前端自动化测试的优势</h2><ul>\n<li>更好的代码组织，项目的可维护性强</li>\n<li>更少的 <code>Bug</code> 出现概率，尤其是回归测试中的 <code>Bug</code></li>\n<li>修改工程质量差的项目，更加安全</li>\n<li>项目具备潜在的文档特性</li>\n<li>扩展前端的知识面</li>\n</ul>\n<h2 id=\"17-总结重要的点\"><a href=\"#17-总结重要的点\" class=\"headerlink\" title=\"17 总结重要的点\"></a>17 总结重要的点</h2><ol>\n<li><code>BDD</code> 和 <code>TDD</code></li>\n<li>集成测试 和 单元测试</li>\n<li>测试和业务的解耦</li>\n<li>代码测试覆盖率并不代表一定靠谱</li>\n<li>功能性测试 和 <code>UI</code>测试</li>\n<li>测试越独立，隐藏的问题就越多</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-单元测试\"><a href=\"#1-单元测试\" class=\"headerlink\" title=\"1. 单元测试\"></a>1. 单元测试</h2><p>对软件中的最小可测试单元进行检查和验证，在前端一般为一个模块。</p>\n<h3 id=\"1-1-单元测试的优缺点\"><a href=\"#1-1-单元测试的优缺点\" class=\"headerlink\" title=\"1.1 单元测试的优缺点\"></a>1.1 单元测试的优缺点</h3><ol>\n<li>测试覆盖率高</li>\n<li>业务耦合度高</li>\n<li>代码量大</li>\n<li>过于独立</li>\n</ol>\n<h3 id=\"1-2-总结\"><a href=\"#1-2-总结\" class=\"headerlink\" title=\"1.2 总结\"></a>1.2 总结</h3><p>在某些场景下适合适用单元测试，某些场景下不适合适用单元测试</p>\n<h2 id=\"2-集成测试\"><a href=\"#2-集成测试\" class=\"headerlink\" title=\"2. 集成测试\"></a>2. 集成测试</h2><p>又叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。</p>\n<h2 id=\"3-jest-中的匹配器\"><a href=\"#3-jest-中的匹配器\" class=\"headerlink\" title=\"3. jest 中的匹配器\"></a>3. jest 中的匹配器</h2><p><a href=\"https://jestjs.io/docs/en/expect\">jest 匹配器官网</a></p>\n<p>修改 <code>jest</code>  默认配置命令 <code>npx jest --init</code></p>\n<h3 id=\"3-1-实时监听测试用例的改变\"><a href=\"#3-1-实时监听测试用例的改变\" class=\"headerlink\" title=\"3.1 实时监听测试用例的改变\"></a>3.1 实时监听测试用例的改变</h3><p><code>jest --watchAll</code> 一旦某个测试用例发生变化，所有的测试用例都将会重新执行</p>\n<p><code>jest --watch</code>  默认进入 <code>o</code>  模式，即只对发生变化的测试用例重新执行</p>\n<h3 id=\"3-2-常用匹配器\"><a href=\"#3-2-常用匹配器\" class=\"headerlink\" title=\"3.2 常用匹配器\"></a>3.2 常用匹配器</h3><h3 id=\"3-2-1-toBe\"><a href=\"#3-2-1-toBe\" class=\"headerlink\" title=\"3.2.1 toBe()\"></a>3.2.1 toBe()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBe的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span> &#125;;</span><br><span class=\"line\">  expect(a).toBe(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ❌ 因为引用类型使用toBe不是全等效果</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBe</code> 匹配器类似于 <code>===</code>。</p>\n<hr>\n<h3 id=\"3-2-2-toEqual\"><a href=\"#3-2-2-toEqual\" class=\"headerlink\" title=\"3.2.2 toEqual()\"></a>3.2.2 toEqual()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toEqual的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span> &#125;;</span><br><span class=\"line\">  expect(a).toBe(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;张三&quot;</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅ 因为toEqual只是对结果的匹配，而不是全等效果</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toEqual</code> 匹配器只是对结果相等与否进行匹配</p>\n<hr>\n<h3 id=\"3-2-3-toBeNull\"><a href=\"#3-2-3-toBeNull\" class=\"headerlink\" title=\"3.2.3 toBeNull()\"></a>3.2.3 toBeNull()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeNull的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  expect(a).toBeNull();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeNull</code> 是对 <code>null</code> 值的匹配</p>\n<hr>\n<h3 id=\"3-2-4-toBeUndefined\"><a href=\"#3-2-4-toBeUndefined\" class=\"headerlink\" title=\"3.2.4 toBeUndefined()\"></a>3.2.4 toBeUndefined()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeUndefined的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  expect(a).toBeUndefined();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeUndefined</code> 是对 <code>undefined</code> 值的匹配</p>\n<hr>\n<h3 id=\"3-2-5-toBeDefined\"><a href=\"#3-2-5-toBeDefined\" class=\"headerlink\" title=\"3.2.5 toBeDefined()\"></a>3.2.5 toBeDefined()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeDefined的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  expect(a).toBeDefined();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeDefined</code> 是对已经定义的值的匹配，若为 <code>undefined</code> 则不通过</p>\n<hr>\n<h3 id=\"3-2-6-toBeTruthy\"><a href=\"#3-2-6-toBeTruthy\" class=\"headerlink\" title=\"3.2.6 toBeTruthy()\"></a>3.2.6 toBeTruthy()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeTruthy的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"number\">0</span>;</span><br><span class=\"line\">  expect(a).toBeTruthy();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 0 =&gt; ❌，因为 toBeTruthy 是对 true 值的匹配</span></span><br><span class=\"line\"><span class=\"comment\">// 1 =&gt; ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeTruthy</code> 是对 <code>true</code> 值的匹配</p>\n<hr>\n<h3 id=\"3-2-7-toBeFalsy\"><a href=\"#3-2-7-toBeFalsy\" class=\"headerlink\" title=\"3.2.7 toBeFalsy()\"></a>3.2.7 toBeFalsy()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeFalsy的匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">  expect(a).toBeFalsy();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 1 =&gt; ❌</span></span><br><span class=\"line\"><span class=\"comment\">// 0 =&gt; ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeFalsy</code> 是对 <code>false</code> 值的匹配</p>\n<hr>\n<h3 id=\"3-2-8-toBeGreaterThan\"><a href=\"#3-2-8-toBeGreaterThan\" class=\"headerlink\" title=\"3.2.8 toBeGreaterThan()\"></a>3.2.8 toBeGreaterThan()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeGreaterThan匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">  expect(a).toBeGreaterThan(<span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeGreaterThan</code> 相当于 <code>&gt;</code></p>\n<hr>\n<h3 id=\"3-2-9-toBeLessThan\"><a href=\"#3-2-9-toBeLessThan\" class=\"headerlink\" title=\"3.2.9 toBeLessThan()\"></a>3.2.9 toBeLessThan()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeLessThan匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">8</span>;</span><br><span class=\"line\">  expect(a).toBeLessThan(<span class=\"number\">9</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeLessThan</code> 相当于 <code>&lt;</code></p>\n<hr>\n<h3 id=\"3-2-10-toBeGreaterThanOrEqual\"><a href=\"#3-2-10-toBeGreaterThanOrEqual\" class=\"headerlink\" title=\"3.2.10 toBeGreaterThanOrEqual()\"></a>3.2.10 toBeGreaterThanOrEqual()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeGreaterThanOrEqual匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">  expect(a).toBeGreaterThanOrEqual(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeGreaterThanOrEqual</code> 相当于 <code>&gt;=</code></p>\n<hr>\n<h3 id=\"3-2-11-toBeLessThanOrEqual\"><a href=\"#3-2-11-toBeLessThanOrEqual\" class=\"headerlink\" title=\"3.2.11 toBeLessThanOrEqual()\"></a>3.2.11 toBeLessThanOrEqual()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeLessThanOrEqual匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> count = <span class=\"number\">10</span>;</span><br><span class=\"line\">  expect(a).toBeLessThanOrEqual(<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeLessThanOrEqual</code> 相当于 <code>&lt;=</code></p>\n<hr>\n<h3 id=\"3-2-12-toBeCloseTo\"><a href=\"#3-2-12-toBeCloseTo\" class=\"headerlink\" title=\"3.2.12 toBeCloseTo()\"></a>3.2.12 toBeCloseTo()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toBeCloseTo匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> one = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> two = <span class=\"number\">0.2</span>;</span><br><span class=\"line\">  expect(one + two).toEqual(<span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ❌ 因为浮点精度不同</span></span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toBeCloseTo匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> one = <span class=\"number\">0.1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> two = <span class=\"number\">0.2</span>;</span><br><span class=\"line\">  expect(one + two).toBeCloseTo(<span class=\"number\">0.3</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toBeCloseTo</code> 为了解决浮点精度不同导致的无法匹配的问题</p>\n<hr>\n<h3 id=\"3-2-13-toMatch\"><a href=\"#3-2-13-toMatch\" class=\"headerlink\" title=\"3.2.13 toMatch()\"></a>3.2.13 toMatch()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toMatch匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> str = <span class=\"string\">&quot;张三、李四、王五&quot;</span>;</span><br><span class=\"line\">  expect(str).toMatch(<span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toMatch匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> str = <span class=\"string\">&quot;张三、李四、王五&quot;</span>;</span><br><span class=\"line\">  expect(str).toMatch(<span class=\"regexp\">/李四/</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br></pre></td></tr></table></figure>\n\n<p><code>toMatch</code> 为字符串包含匹配器，用来匹配字符串中包含的内容，也可传正则表达式</p>\n<hr>\n<h3 id=\"3-2-14-toContain\"><a href=\"#3-2-14-toContain\" class=\"headerlink\" title=\"3.2.14 toContain()\"></a>3.2.14 toContain()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test(<span class=\"string\">&quot;测试toContain匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [<span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>, <span class=\"string\">&quot;王五&quot;</span>];</span><br><span class=\"line\">  expect(arr).toContain(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// ✅</span></span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toContain匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> arr = [<span class=\"string\">&quot;张三&quot;</span>, <span class=\"string\">&quot;李四&quot;</span>, <span class=\"string\">&quot;王五&quot;</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr);</span><br><span class=\"line\">  expect(data).toContain(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>toContain</code> 为数据包含匹器，用来匹配数组中包含的项。同时可完全兼容 <code>Set</code> 测试</p>\n<hr>\n<h3 id=\"3-2-15-toHaveLength\"><a href=\"#3-2-15-toHaveLength\" class=\"headerlink\" title=\"3.2.15 toHaveLength()\"></a>3.2.15 toHaveLength()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// functions.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getIntArray</span>(<span class=\"params\">num</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">Number</span>.isInteger(num)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;&quot;getIntArray&quot;只接受整数类型的参数&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, len = num; i &lt; len; i++) &#123;</span><br><span class=\"line\">      result.push(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// functions.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getIntArray &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../src/functions&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;getIntArray(3)返回的数组长度应该为3&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(getIntArray(<span class=\"number\">3</span>)).toHaveLength(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>toHaveLength</code>可以很方便的用来测试字符串和数组类型的长度是否满足预期。</p>\n<h3 id=\"3-2-16-toThrow\"><a href=\"#3-2-16-toThrow\" class=\"headerlink\" title=\"3.2.16 toThrow()\"></a>3.2.16 toThrow()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throwNewErrorFunc = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;this is a new error&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toThrow匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(throwNewErrorFunc).toThrow();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>toThrow</code> 是专门对异常进行处理的匹配器，可以检测一个方法会不会抛出异常</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throwNewErrorFunc = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;this is a new error&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试toThrow匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(throwNewErrorFunc).toThrow(<span class=\"string\">&quot;this is a new error&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以对这个匹配器中加一些字符串，意思就是抛出的异常必须和字符串相对应，如果字符串不匹配，也没办法通过异常测试。</p>\n<hr>\n<h3 id=\"3-2-17-not\"><a href=\"#3-2-17-not\" class=\"headerlink\" title=\"3.2.17 not()\"></a>3.2.17 not()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> throwNewErrorFunc = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;this is a new error&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试not匹配器&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(throwNewErrorFunc).not.toThrow();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>not</code> 匹配器是 <code>jest</code> 中比较特殊的匹配器，意思就是 “相反” 或者说 “取反” .比如上面的例子，我们不希望方法抛出异常，就可以使用<code>not</code> 匹配器。</p>\n<hr>\n<h3 id=\"3-3-异步代码测试方法\"><a href=\"#3-3-异步代码测试方法\" class=\"headerlink\" title=\"3.3 异步代码测试方法\"></a>3.3 异步代码测试方法</h3><h3 id=\"3-3-1-回调函数式\"><a href=\"#3-3-1-回调函数式\" class=\"headerlink\" title=\"3.3.1 回调函数式\"></a>3.3.1 回调函数式</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// fetchData.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&quot;axios&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\"><span class=\"params\">fn</span> =&gt;</span> &#123;</span><br><span class=\"line\">  axios.get(<span class=\"string\">&quot;http://a.jspang.com/jestTest.json&quot;</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fn(res.data);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// fetchData.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fetchData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./fetchData.js&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  fetchData(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(data).toEqual(&#123; <span class=\"attr\">success</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>必须加入一个 <code>done</code> 方法，保证我们的回调已经完成了，这时候我们表示测试完成</p>\n<hr>\n<h3 id=\"3-3-2-直接返回-Promise\"><a href=\"#3-3-2-直接返回-Promise\" class=\"headerlink\" title=\"3.3.2 直接返回 Promise\"></a>3.3.2 直接返回 Promise</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// fetchTwoData.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&quot;axios&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchTwoData = <span class=\"function\">() =&gt;</span> axios.get(<span class=\"string\">&quot;http://a.jspang.com/jestTest.json&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// fetchTwoData.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fetchTwoData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./fetchTwoData.js&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchTwoData的测试用例&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> fetchTwoData().then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> &#123;</span><br><span class=\"line\">  expect(res.data).toEqual(&#123; <span class=\"attr\">success</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>注意要 <code>return</code></p>\n<h3 id=\"3-3-3-不存在的接口\"><a href=\"#3-3-3-不存在的接口\" class=\"headerlink\" title=\"3.3.3 不存在的接口\"></a>3.3.3 不存在的接口</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// fetchData.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;http://a.jspang.com/jestTest_error.json&quot;</span>); <span class=\"comment\">// 此地址并不存在</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// fetchData.test.js</span></span><br><span class=\"line\"><span class=\"comment\">// 方式1</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect.assertions(<span class=\"number\">1</span>); <span class=\"comment\">// 断言，必须执行一次 expect</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetchData().catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(err.toString().indexOf(<span class=\"string\">&quot;404&quot;</span>) &gt; -<span class=\"number\">1</span>).toBe(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> fetchData().rejects.toThrow();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式3</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  expect().assertions(<span class=\"number\">1</span>); <span class=\"comment\">// 断言，必须执行一次 expect</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> fetchData();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    expect(err.toString().indexOf(<span class=\"string\">&quot;404&quot;</span>) &gt; -<span class=\"number\">1</span>).toBe(<span class=\"literal\">true</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>因为测试用例使用了 <code>catch</code> 方法，也就是说只有出现异常的时候才会走这个方法，而现在没有出现异常，就不会走这个测试方法，<code>jest</code> 就默认这个用例通过了测试。因此必须要执行断言，即必须让其执行一次即可。</p>\n<h3 id=\"3-3-4-async-await\"><a href=\"#3-3-4-async-await\" class=\"headerlink\" title=\"3.3.4 async/await\"></a>3.3.4 async/await</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// fetchData.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;http://a.jspang.com/jestTest.json&quot;</span>); <span class=\"comment\">// 此地址并不存在&#125;;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// fetchData.test.js</span></span><br><span class=\"line\"><span class=\"comment\">// 方式1</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">await</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">   success: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 方式2</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;fetchData测试&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetchData();</span><br><span class=\"line\"> expect(response.data).toEqual(&#123; <span class=\"attr\">success</span>: <span class=\"literal\">true</span> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>这时候我们的代码使用 <code>async....await...</code> 的形式，这里我们还使用了 <code>resolves</code> 用于把现有对象转换成 <code>Promise</code> 对象，然后使用 <code>jest</code> 中的 <code>toMatchObject</code> 进行匹配对象中的属性。</p>\n<h2 id=\"4-jest-中的四个钩子函数\"><a href=\"#4-jest-中的四个钩子函数\" class=\"headerlink\" title=\"4. jest 中的四个钩子函数\"></a>4. jest 中的四个钩子函数</h2><h3 id=\"4-1-beforeAll\"><a href=\"#4-1-beforeAll\" class=\"headerlink\" title=\"4.1 beforeAll()\"></a>4.1 beforeAll()</h3><p><code>beforeAll()</code>钩子函数的意思是在所有测试用例之前进行执行。</p>\n<h3 id=\"4-2-afterAll\"><a href=\"#4-2-afterAll\" class=\"headerlink\" title=\"4.2 afterAll()\"></a>4.2 afterAll()</h3><p><code>afterAll()</code>钩子函数是在完成所有测试用例之后才执行的函数。</p>\n<h3 id=\"4-3-beforeEach\"><a href=\"#4-3-beforeEach\" class=\"headerlink\" title=\"4.3 beforeEach()\"></a>4.3 beforeEach()</h3><p><code>beforeEach()</code>钩子函数，是在每个测试用例前都会执行一次的钩子函数。</p>\n<h3 id=\"4-4-afterEach\"><a href=\"#4-4-afterEach\" class=\"headerlink\" title=\"4.4 afterEach()\"></a>4.4 afterEach()</h3><p><code>afterEach()</code>钩子函数，是在每次测试用例完成测试之后执行一次的钩子函数。</p>\n<h2 id=\"5-jest-测试用例分组\"><a href=\"#5-jest-测试用例分组\" class=\"headerlink\" title=\"5. jest 测试用例分组\"></a>5. jest 测试用例分组</h2><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// eat.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Eat</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setName</span>(<span class=\"params\">number</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = number === <span class=\"number\">1</span> ? <span class=\"string\">&quot;水饺&quot;</span> : <span class=\"string\">&quot;火锅&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setDesc</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.desc = <span class=\"built_in\">this</span>.user + <span class=\"string\">&quot;描述&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setMoney</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.money = <span class=\"built_in\">this</span>.name === <span class=\"string\">&quot;水饺&quot;</span> ? <span class=\"number\">80</span> : <span class=\"number\">300</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// eat.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Eat <span class=\"keyword\">from</span> <span class=\"string\">&quot;./eat&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eat = <span class=\"keyword\">new</span> Eat();</span><br><span class=\"line\">beforeAll(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;开始吃饭&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">afterAll(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;吃完饭了&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">describe(<span class=\"string\">&quot;水饺相关内容&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  test(<span class=\"string\">&quot;测试水饺描述&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    eat.setName(<span class=\"number\">1</span>);</span><br><span class=\"line\">    eat.setDesc();</span><br><span class=\"line\">    expect(eat.desc).toEqual(<span class=\"string\">&quot;水饺描述&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  test(<span class=\"string\">&quot;测试水饺价格&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    eat.setName(<span class=\"number\">1</span>);</span><br><span class=\"line\">    eat.setMoney();</span><br><span class=\"line\">    expect(eat.money).toEqual(<span class=\"number\">80</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">describe(<span class=\"string\">&quot;火锅相关内容&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  test(<span class=\"string\">&quot;测试火锅描述&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    eat.setName(<span class=\"number\">2</span>);</span><br><span class=\"line\">    eat.setDesc();</span><br><span class=\"line\">    expect(eat.desc).toEqual(<span class=\"string\">&quot;火锅描述&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  test(<span class=\"string\">&quot;测试火锅价格&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    eat.setName(<span class=\"number\">2</span>);</span><br><span class=\"line\">    eat.setMoney();</span><br><span class=\"line\">    expect(eat.money).toEqual(<span class=\"number\">300</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-钩子函数的作用域\"><a href=\"#6-钩子函数的作用域\" class=\"headerlink\" title=\"6. 钩子函数的作用域\"></a>6. 钩子函数的作用域</h2><h3 id=\"6-1-钩子函数在父级分组可作用域子集，类似继承\"><a href=\"#6-1-钩子函数在父级分组可作用域子集，类似继承\" class=\"headerlink\" title=\"6.1 钩子函数在父级分组可作用域子集，类似继承\"></a>6.1 钩子函数在父级分组可作用域子集，类似继承</h3><p>即父级作用域下的钩子函数在子作用域下也生效</p>\n<h3 id=\"6-2-钩子函数同级分组作用域互不干扰，各起作用\"><a href=\"#6-2-钩子函数同级分组作用域互不干扰，各起作用\" class=\"headerlink\" title=\"6.2 钩子函数同级分组作用域互不干扰，各起作用\"></a>6.2 钩子函数同级分组作用域互不干扰，各起作用</h3><p>同作用域下将都会执行</p>\n<h3 id=\"6-3-先执行外部的钩子函数，再执行内部的钩子函数\"><a href=\"#6-3-先执行外部的钩子函数，再执行内部的钩子函数\" class=\"headerlink\" title=\"6.3 先执行外部的钩子函数，再执行内部的钩子函数\"></a>6.3 先执行外部的钩子函数，再执行内部的钩子函数</h3><p>优先父级作用域下的钩子函数，其次执行子作用域下的钩子函数</p>\n<h3 id=\"6-4-在进行测试准备的时候，将对应逻辑写到钩子函数\"><a href=\"#6-4-在进行测试准备的时候，将对应逻辑写到钩子函数\" class=\"headerlink\" title=\"6.4 在进行测试准备的时候，将对应逻辑写到钩子函数\"></a>6.4 在进行测试准备的时候，将对应逻辑写到钩子函数</h3><p>如果将对应逻辑写到了非钩子函数的位置，那么将会优先执行，然后才会执行钩子函数</p>\n<h3 id=\"6-5-对单个测试用例的调试\"><a href=\"#6-5-对单个测试用例的调试\" class=\"headerlink\" title=\"6.5 对单个测试用例的调试\"></a>6.5 对单个测试用例的调试</h3><p>当一个测试文件中的测试用例变得越来越多的时候，假如此时我们相对其中某一个测试用例进行调试，那么我们就需要使用 <code>test.only</code></p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test.only(<span class=\"string\">&quot;测试用例&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(<span class=\"number\">1</span> + <span class=\"number\">1</span>).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-Jest-中的-Mock\"><a href=\"#7-Jest-中的-Mock\" class=\"headerlink\" title=\"7. Jest 中的 Mock\"></a>7. Jest 中的 Mock</h2><h3 id=\"7-1-作用\"><a href=\"#7-1-作用\" class=\"headerlink\" title=\"7.1 作用\"></a>7.1 作用</h3><h3 id=\"7-1-1-捕获函数的调用和返回结果，以及-this-和调用顺序\"><a href=\"#7-1-1-捕获函数的调用和返回结果，以及-this-和调用顺序\" class=\"headerlink\" title=\"7.1.1 捕获函数的调用和返回结果，以及 this 和调用顺序\"></a>7.1.1 捕获函数的调用和返回结果，以及 <code>this</code> 和调用顺序</h3><h3 id=\"7-1-2-它可以让我们自由的设置返回结果\"><a href=\"#7-1-2-它可以让我们自由的设置返回结果\" class=\"headerlink\" title=\"7.1.2 它可以让我们自由的设置返回结果\"></a>7.1.2 它可以让我们自由的设置返回结果</h3><h3 id=\"7-1-3-改变内部函数的实现\"><a href=\"#7-1-3-改变内部函数的实现\" class=\"headerlink\" title=\"7.1.3 改变内部函数的实现\"></a>7.1.3 改变内部函数的实现</h3><h3 id=\"7-2-判定函数是否被调用\"><a href=\"#7-2-判定函数是否被调用\" class=\"headerlink\" title=\"7.2 判定函数是否被调用\"></a>7.2 判定函数是否被调用</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func).toBeCalled(); <span class=\"comment\">// 测试用例被调用</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>jest.fn()</code>  可以帮助我们捕获函数的调用</p>\n<h3 id=\"7-3-jest-fn-mock-calls-判定函数被调用了几次和传递的参数\"><a href=\"#7-3-jest-fn-mock-calls-判定函数被调用了几次和传递的参数\" class=\"headerlink\" title=\"7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数\"></a>7.3 jest.fn().mock.calls 判定函数被调用了几次和传递的参数</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.calls.length).toBe(<span class=\"number\">2</span>); <span class=\"comment\">// 测试用例被调用2次</span></span><br><span class=\"line\">  expect(func.mock.calls[<span class=\"number\">0</span>]).toEqual([<span class=\"string\">&quot;张三&quot;</span>]); <span class=\"comment\">// 测试用例传递的第一个参数是 &quot;张三&quot;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>此处打印 <code>func.mock</code>  将会打印一些常用的方法，可以根据需求进行相应的用例测试</p>\n<h3 id=\"7-4-jest-fn-mockReturnValue-判定函数执行了几次和返回结果\"><a href=\"#7-4-jest-fn-mockReturnValue-判定函数执行了几次和返回结果\" class=\"headerlink\" title=\"7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果\"></a>7.4 jest.fn().mockReturnValue() 判定函数执行了几次和返回结果</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  <span class=\"comment\">// func.mockReturnValue(&quot;Common&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">// 所有模拟返回值都是 &quot;Common&quot;</span></span><br><span class=\"line\">  func.mockReturnValueOnce(<span class=\"string\">&quot;A&quot;</span>); <span class=\"comment\">// 第一次模拟返回值返回 &quot;A&quot;</span></span><br><span class=\"line\">  func.mockReturnValueOnce(<span class=\"string\">&quot;B&quot;</span>); <span class=\"comment\">// 第二次模拟返回值返回 &quot;B&quot;</span></span><br><span class=\"line\">  func.mockReturnValueOnce(<span class=\"string\">&quot;C&quot;</span>); <span class=\"comment\">// 第三次模拟返回值返回 &quot;C&quot;</span></span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">0</span>].value).toBe(<span class=\"string\">&quot;A&quot;</span>);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">1</span>].value).toBe(<span class=\"string\">&quot;B&quot;</span>);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">2</span>].value).toBe(<span class=\"string\">&quot;C&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>func.mockReturnValue()</code>  将对所有模拟返回的值生效</p>\n<p><code>func.mockReturnValueOnce()</code>  执行到第几次就对第几个函数的模拟返回值生效</p>\n<p>支持链式调用</p>\n<h3 id=\"7-5-jest-fn-mock-invocationCallOrder-判定函数执行顺序\"><a href=\"#7-5-jest-fn-mock-invocationCallOrder-判定函数执行顺序\" class=\"headerlink\" title=\"7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序\"></a>7.5 jest.fn().mock.invocationCallOrder 判定函数执行顺序</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.invocationCallOrder).toEqual([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-jest-fn-mock-instances-判定函数调用了几次以及-this-指向\"><a href=\"#7-6-jest-fn-mock-instances-判定函数调用了几次以及-this-指向\" class=\"headerlink\" title=\"7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向\"></a>7.6 jest.fn().mock.instances 判定函数调用了几次以及 this 指向</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> createObject = <span class=\"function\">(<span class=\"params\">ClassItem</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> ClassItem();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createObject &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 createObject&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  createObject(func);</span><br><span class=\"line\">  expect(func.mock.instances).toEqual([mockConstructor&#123;&#125;]); <span class=\"comment\">// 此处的 this 就是 mockConstructor</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-7-jest-fn-mockImplementation-判定函数返回结果和其他逻辑处理\"><a href=\"#7-7-jest-fn-mockImplementation-判定函数返回结果和其他逻辑处理\" class=\"headerlink\" title=\"7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理\"></a>7.7 jest.fn().mockImplementation() 判定函数返回结果和其他逻辑处理</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\"><span class=\"params\">callback</span> =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  <span class=\"comment\">// func.mockImplementation(() =&gt; &quot;hello&quot;); 等价于 jest.fn(() =&gt; &quot;hello&quot;)</span></span><br><span class=\"line\">  <span class=\"comment\">// func.mockImplementation(() =&gt; this); 等价于 jest.fn().mockReturnThis()</span></span><br><span class=\"line\">  func.mockImplementationOnce(<span class=\"function\">() =&gt;</span> <span class=\"string\">&quot;dell&quot;</span>);</span><br><span class=\"line\">  func.mockImplementationOnce(<span class=\"function\">() =&gt;</span> <span class=\"string\">&quot;lee&quot;</span>);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">0</span>].value).toBe(<span class=\"string\">&quot;dell&quot;</span>);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">1</span>].value).toBe(<span class=\"string\">&quot;lee&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>mockImplementation</code>  比 <code>mockReturnValue</code>  更健壮，因为内部可以写一些额外的逻辑</p>\n<h3 id=\"7-8-toBeCalledWith-来判定每次函数调用时的参数\"><a href=\"#7-8-toBeCalledWith-来判定每次函数调用时的参数\" class=\"headerlink\" title=\"7.8 toBeCalledWith() 来判定每次函数调用时的参数\"></a>7.8 toBeCalledWith() 来判定每次函数调用时的参数</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> runCallback = <span class=\"function\">(<span class=\"params\">callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  callback(<span class=\"string\">&quot;ABC&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; runCallback &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 runCallback&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> func = jest.fn();</span><br><span class=\"line\">  runCallback(func);</span><br><span class=\"line\">  expect(func.mock.results[<span class=\"number\">0</span>]).toEqual([<span class=\"string\">&quot;ABC&quot;</span>);</span><br><span class=\"line\">  expect(func).toBeCalledWith(<span class=\"string\">&quot;ABC&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-9-模拟异步请求\"><a href=\"#7-9-模拟异步请求\" class=\"headerlink\" title=\"7.9 模拟异步请求\"></a>7.9 模拟异步请求</h3><p>对于前端来说一般异步接口是测试是否发送了，而不测试后端接口返回的内容，是属于后端自动化测试的内容</p>\n<h3 id=\"7-9-1-通过模拟库的方式来模拟异步测试\"><a href=\"#7-9-1-通过模拟库的方式来模拟异步测试\" class=\"headerlink\" title=\"7.9.1 通过模拟库的方式来模拟异步测试\"></a>7.9.1 通过模拟库的方式来模拟异步测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;/api&quot;</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">&quot;axios&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; getData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">jest.mock(<span class=\"string\">&quot;axios&quot;</span>); <span class=\"comment\">// 对 axios 进行模拟，这样就不会请求真正数据</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 getData&quot;</span>, <span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  axios.get.mockResolvedValue(&#123; <span class=\"attr\">data</span>: <span class=\"string\">&quot;hello&quot;</span> &#125;); <span class=\"comment\">// 使用 axios 请求的时候模拟成功的返回值就是 hello</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> getData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(data).toBe(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p><code>mockResolvedValue</code> 模拟不限次数</p>\n<p><code>mockResolvedValueOnce</code> 模拟一次，模拟两次就会报错，需再次调用</p>\n<h3 id=\"7-9-2-通过模拟-Promise-方式模拟异步\"><a href=\"#7-9-2-通过模拟-Promise-方式模拟异步\" class=\"headerlink\" title=\"7.9.2 通过模拟 Promise 方式模拟异步\"></a>7.9.2 通过模拟 Promise 方式模拟异步</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;/&quot;</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// __mocks__/demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">&quot;function() &#123; return &#x27;123&#x27; &#125;&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\">jest.mock(<span class=\"string\">&quot;./demo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fetchData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试fetchData&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetchData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(<span class=\"built_in\">eval</span>(data)).toEqual(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// 实现方式3</span></span><br><span class=\"line\"><span class=\"comment\">// 修改jest.config.js 可以自动查找项目内部__mocks__下与要测试文件名字相同的文件做替换</span></span><br><span class=\"line\"><span class=\"comment\">// 等同于 jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;)&#123;  automock: true; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-9-3-通过修改-jest-config-js-来自动识别mocks下的文件\"><a href=\"#7-9-3-通过修改-jest-config-js-来自动识别mocks下的文件\" class=\"headerlink\" title=\"7.9.3 通过修改 jest.config.js 来自动识别mocks下的文件\"></a>7.9.3 通过修改 jest.config.js 来自动识别<strong>mocks</strong>下的文件</h3><p>修改 <code>jest.config.js</code> 可以自动查找项目内部 <code>__mocks__</code> 下与要测试文件名字相同的文件做替换</p>\n<p>等同于&gt; <code>jest.mock(&quot;要测试文件名字相同的__mocks__下的文件&quot;)</code></p>\n<h3 id=\"7-9-4-使用-jest-unmock-可取消-mock-模拟\"><a href=\"#7-9-4-使用-jest-unmock-可取消-mock-模拟\" class=\"headerlink\" title=\"7.9.4 使用 jest.unmock() 可取消 mock 模拟\"></a>7.9.4 使用 jest.unmock() 可取消 mock 模拟</h3><h3 id=\"7-9-5-解决测试文件中部分功能不需要-mock，部分功能需要-mock-模拟异步的问题\"><a href=\"#7-9-5-解决测试文件中部分功能不需要-mock，部分功能需要-mock-模拟异步的问题\" class=\"headerlink\" title=\"7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题\"></a>7.9.5 解决测试文件中部分功能不需要 mock，部分功能需要 mock 模拟异步的问题</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(<span class=\"string\">&quot;/&quot;</span>).then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.data);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> getNumber = <span class=\"function\">() =&gt;</span> <span class=\"number\">123</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// __mocks__/demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> fetchData = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    resolve(<span class=\"string\">&quot;function() &#123; return &#x27;123&#x27; &#125;&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\">jest.mock(<span class=\"string\">&quot;./demo&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; fetchData &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; getNumber &#125; = jest.requireActual(<span class=\"string\">&quot;./demo&quot;</span>); <span class=\"comment\">// 引入真实文件</span></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 fetchData&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetchData().then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    expect(<span class=\"built_in\">eval</span>(data)).toEqual(<span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 getNumber&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(getNumber()).toEqual(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"8-snapshot-快照测试\"><a href=\"#8-snapshot-快照测试\" class=\"headerlink\" title=\"8. snapshot 快照测试\"></a>8. snapshot 快照测试</h2><p>常用于测试配置文件</p>\n<h3 id=\"8-1-toMatchSnapshot\"><a href=\"#8-1-toMatchSnapshot\" class=\"headerlink\" title=\"8.1 toMatchSnapshot()\"></a>8.1 toMatchSnapshot()</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> generateConfig = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    server: <span class=\"string\">&quot;http://localhost&quot;</span>,</span><br><span class=\"line\">    port: <span class=\"number\">8080</span>,</span><br><span class=\"line\">    domain: <span class=\"string\">&quot;localhost&quot;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; generateConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 generateConfig&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(generateConfig()).toMatchSnapshot(); <span class=\"comment\">// 将会在项目里生成快照文件</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>如果要确认更新快照，需要在控制台选择。 <code>u</code>  代表对所有快照进行更新， <code>i</code>  代表对单个确认的快照进行更新</p>\n<h3 id=\"8-2-测试部分可变变量的内容\"><a href=\"#8-2-测试部分可变变量的内容\" class=\"headerlink\" title=\"8.2 测试部分可变变量的内容\"></a>8.2 测试部分可变变量的内容</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> generateConfig = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    server: <span class=\"string\">&quot;http://localhost&quot;</span>,</span><br><span class=\"line\">    port: <span class=\"number\">8080</span>,</span><br><span class=\"line\">    domain: <span class=\"string\">&quot;localhost&quot;</span>,</span><br><span class=\"line\">    time: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">    <span class=\"comment\">// 可变变量</span></span><br><span class=\"line\">    random: <span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">    <span class=\"comment\">// 可变变量</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; generateConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 generateConfig&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  expect(generateConfig()).toMatchSnapshot(&#123;</span><br><span class=\"line\">    time: expect.any(<span class=\"built_in\">Date</span>),</span><br><span class=\"line\">    random: expect.any(<span class=\"built_in\">Number</span>)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-3-行内的-snapshot\"><a href=\"#8-3-行内的-snapshot\" class=\"headerlink\" title=\"8.3 行内的 snapshot\"></a>8.3 行内的 snapshot</h3><p><code>npm install prettier --save</code></p>\n<p>可以快照放到行内的测试用例中</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// demo.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> generateConfig = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    server: <span class=\"string\">&quot;http://localhost&quot;</span>,</span><br><span class=\"line\">    port: <span class=\"number\">8080</span>,</span><br><span class=\"line\">    domain: <span class=\"string\">&quot;localhost&quot;</span>,</span><br><span class=\"line\">    time: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">    <span class=\"comment\">// 可变变量</span></span><br><span class=\"line\">    random: <span class=\"built_in\">Math</span>.random()</span><br><span class=\"line\">    <span class=\"comment\">// 可变变量</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// demo.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; generateConfig &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./demo&quot;</span>;</span><br><span class=\"line\">test(<span class=\"string\">&quot;测试 generateConfig&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// toMatchInlineSnapshot 可以快照放到行内的测试用例中</span></span><br><span class=\"line\">  expect(generateConfig()).toMatchInlineSnapshot(&#123;</span><br><span class=\"line\">    time: expect.any(<span class=\"built_in\">Date</span>),</span><br><span class=\"line\">    random: expect.any(<span class=\"built_in\">Number</span>)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"9-Test-Driven-Development-TDD-测试驱动开发\"><a href=\"#9-Test-Driven-Development-TDD-测试驱动开发\" class=\"headerlink\" title=\"9. Test Driven Development(TDD) 测试驱动开发\"></a>9. Test Driven Development(TDD) 测试驱动开发</h2><h3 id=\"9-1-TDD-开发流程\"><a href=\"#9-1-TDD-开发流程\" class=\"headerlink\" title=\"9.1 TDD 开发流程\"></a>9.1 TDD 开发流程</h3><ol>\n<li>编写测试用例（知道功能，先写测试用例）</li>\n<li>运行测试，测试用例无法通过测试</li>\n<li>编写代码，使测试用例通过测试</li>\n<li>优化代码， 完成开发</li>\n<li>新增功能，重复执行 1-4</li>\n</ol>\n<h3 id=\"9-2-TDD-的优势\"><a href=\"#9-2-TDD-的优势\" class=\"headerlink\" title=\"9.2 TDD 的优势\"></a>9.2 TDD 的优势</h3><ol>\n<li>长期减少项目的回归 bug（减少修改代码产生的 bug）</li>\n<li>代码质量更好（组织，可维护性好）</li>\n<li>测试覆盖率高（因为是先编写测试用例，但测试覆盖率过高会影响很大精力）</li>\n<li>错误测试代码不容易出现</li>\n</ol>\n<h3 id=\"9-3-TDD-的适用场景\"><a href=\"#9-3-TDD-的适用场景\" class=\"headerlink\" title=\"9.3 TDD 的适用场景\"></a>9.3 TDD 的适用场景</h3><ol>\n<li>不适用于开发业务代码时使用（开发业务代码时会大量的与业务代码产生耦合，加大工作量）</li>\n<li>适用于一些库的开发（开发库时代码耦合度较低，通常只处理函数等相关功能）</li>\n</ol>\n<hr>\n<h2 id=\"10-Behavior-Driven-Development-BDD-行为驱动开发\"><a href=\"#10-Behavior-Driven-Development-BDD-行为驱动开发\" class=\"headerlink\" title=\"10. Behavior Driven Development(BDD) 行为驱动开发\"></a>10. Behavior Driven Development(BDD) 行为驱动开发</h2><h3 id=\"10-1-BDD-开发流程\"><a href=\"#10-1-BDD-开发流程\" class=\"headerlink\" title=\"10.1 BDD 开发流程\"></a>10.1 BDD 开发流程</h3><ol>\n<li>先编写业务代码，不关心测试</li>\n<li>思考并描述用户行为</li>\n<li>根据用户行为模拟测试</li>\n</ol>\n<h3 id=\"10-2-vue-example\"><a href=\"#10-2-vue-example\" class=\"headerlink\" title=\"10.2 vue example\"></a>10.2 vue example</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// testUtils.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> findTestWrapper = <span class=\"function\">(<span class=\"params\">wrapper, tag</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> wrapper.find(<span class=\"string\">`[data-test=&quot;<span class=\"subst\">$&#123;tag&#125;</span>&quot;]`</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __tests__/integration/TodoList.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@vue/test-utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; findTestWrapper &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../utils/testUtils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../TodoList&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import store from &quot;../../../../store&quot;</span></span><br><span class=\"line\">it(<span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\"> 新增内容逻辑的集成测试    </span></span><br><span class=\"line\"><span class=\"string\"> 1. 用户会在header输入框输入内容    </span></span><br><span class=\"line\"><span class=\"string\"> 2. 用户会点击回车按钮  </span></span><br><span class=\"line\"><span class=\"string\"> 3. 列表项应该增加用户输入内容的列表项`</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(TodoList);</span><br><span class=\"line\">  <span class=\"comment\">// const wrapper = mount(TodoList, &#123; store &#125;)</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果使用 vuex，也几乎无改动</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputElem = findTestWrapper(wrapper, <span class=\"string\">&quot;header-input&quot;</span>).at(<span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> content = <span class=\"string\">&quot;Dell lee&quot;</span>;</span><br><span class=\"line\">  inputElem.setValue(content);</span><br><span class=\"line\">  inputElem.trigger(<span class=\"string\">&quot;change&quot;</span>);</span><br><span class=\"line\">  inputElem.trigger(<span class=\"string\">&quot;keyup.enter&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>).at(<span class=\"number\">0</span>);</span><br><span class=\"line\">  expect(listItems.length).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">  expect(listItems.at(<span class=\"number\">0</span>).text()).toContain(content);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-3-react-example\"><a href=\"#10-3-react-example\" class=\"headerlink\" title=\"10.3 react example\"></a>10.3 react example</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// testUtils.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> findTestWrapper = <span class=\"function\">(<span class=\"params\">wrapper, tag</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> wrapper.find(<span class=\"string\">`[data-test=&quot;<span class=\"subst\">$&#123;tag&#125;</span>&quot;]`</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __tests__/integration/TodoList.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import &#123; Provider &#125; from &quot;react-redux&quot;;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Enzyme, &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Adapter <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme-adapter-react-16&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../TodoList&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// import store from &quot;../../../../store/createStore&quot;;</span></span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    新增内容逻辑的集成测试</span></span><br><span class=\"line\"><span class=\"string\">    1. 用户会在header输入框输入内容</span></span><br><span class=\"line\"><span class=\"string\">    2. 用户会点击回车按钮</span></span><br><span class=\"line\"><span class=\"string\">   3. 列表项应该增加用户输入内容的列表项</span></span><br><span class=\"line\"><span class=\"string\">`</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">TodoList</span> /&gt;</span></span>);</span><br><span class=\"line\">  <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">  const wrapper = mount(</span></span><br><span class=\"line\"><span class=\"comment\">   &lt;Provider store=&#123;store&#125;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;TodoList /&gt;&lt;/Provider&gt;</span></span><br><span class=\"line\"><span class=\"comment\">   &lt;/Provider&gt;</span></span><br><span class=\"line\"><span class=\"comment\">  )  </span></span><br><span class=\"line\"><span class=\"comment\">  // 如果使用 redux，也几乎无改动</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> inputElem = findTestWrapper(wrapper, <span class=\"string\">&quot;header-input&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> content = <span class=\"string\">&quot;Dell lee&quot;</span>;</span><br><span class=\"line\">  inputElem.simulate(<span class=\"string\">&quot;change&quot;</span>, &#123; <span class=\"attr\">target</span>: &#123; <span class=\"attr\">value</span>: content &#125; &#125;);</span><br><span class=\"line\">  inputElem.simulate(<span class=\"string\">&quot;keyUp&quot;</span>, &#123; <span class=\"attr\">keyCode</span>: <span class=\"number\">13</span> &#125;);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">  expect(listItems.length).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">  expect(listItems.text()).toContain(content);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"11-TDD-和-BDD-的对比\"><a href=\"#11-TDD-和-BDD-的对比\" class=\"headerlink\" title=\"11. TDD 和 BDD 的对比\"></a>11. TDD 和 BDD 的对比</h2><ol>\n<li><code>TDD</code> 先写测试后写代码; <code>BDD</code> 先写代码后写测试</li>\n<li><code>TDD</code> 创建的是 <code>unit</code> 单元测试文件夹，一般结合单元测试，属于白盒测试(知道实现测试代码); <code>BDD</code> 创建的是 <code>integration</code> 集成测试文件夹，一般结合集成测试，属于黑盒测试(不知道实现测试代码)</li>\n<li><code>TDD</code> 测试重点在代码; <code>BDD</code> 测试重点在 <code>UI</code> ( <code>DOM</code>)</li>\n<li><code>TDD</code> 安全感低(无法保证各个组件拼撞到一起是否不会有问题); <code>BDD</code> 安全感高</li>\n<li><code>TDD</code> 速度快; <code>BDD</code> 速度慢</li>\n</ol>\n<hr>\n<h2 id=\"12-TDD-与-BDD-混用\"><a href=\"#12-TDD-与-BDD-混用\" class=\"headerlink\" title=\"12. TDD 与 BDD 混用\"></a>12. TDD 与 BDD 混用</h2><h3 id=\"12-1-对一些工具函数的测试\"><a href=\"#12-1-对一些工具函数的测试\" class=\"headerlink\" title=\"12.1 对一些工具函数的测试\"></a>12.1 对一些工具函数的测试</h3><h3 id=\"12-2-对-vuex-的-store-进行测试\"><a href=\"#12-2-对-vuex-的-store-进行测试\" class=\"headerlink\" title=\"12.2 对 vuex 的 store 进行测试\"></a>12.2 对 vuex 的 store 进行测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __tests__/unit/store.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store&quot;</span>;</span><br><span class=\"line\">it(<span class=\"string\">&quot;当 store 接受 changeInputValue 的 commit 时, inputValue 发生变化&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">  store.commit(<span class=\"string\">&quot;changeInputValue&quot;</span>, value);</span><br><span class=\"line\">  expect(store.state.inputValue).toBe(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-3-对-redux-的-store-进行测试\"><a href=\"#12-3-对-redux-的-store-进行测试\" class=\"headerlink\" title=\"12.3 对 redux 的 store 进行测试\"></a>12.3 对 redux 的 store 进行测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __tests__/unit/store.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store/createStore&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; changeInputValue &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store/actions&quot;</span>;</span><br><span class=\"line\">it(<span class=\"string\">&quot;当 store 接受 changeInputValue 的 dispatch 时, inputValue 发生变化&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">  <span class=\"comment\">/**   </span></span><br><span class=\"line\"><span class=\"comment\">  const changeInputValue = (payload) =&gt; (&#123; </span></span><br><span class=\"line\"><span class=\"comment\">   type: CHANGE_IMPUT_VALUE, payload </span></span><br><span class=\"line\"><span class=\"comment\">  &#125;)   </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">  store.dispatch(changeInputValue(value));</span><br><span class=\"line\">  expect(store.getState().inputValue).toBe(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"13-异步测试\"><a href=\"#13-异步测试\" class=\"headerlink\" title=\"13. 异步测试\"></a>13. 异步测试</h2><p>注意：异步测试如果用到了异步函数，则需要调用 <code>done</code>  函数</p>\n<h3 id=\"13-1-vue-的异步测试\"><a href=\"#13-1-vue-的异步测试\" class=\"headerlink\" title=\"13.1 vue 的异步测试\"></a>13.1 vue 的异步测试</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __mocks__/axios.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> undoList = &#123;  <span class=\"attr\">success</span>: <span class=\"literal\">true</span>,  <span class=\"attr\">data</span>: [</span><br><span class=\"line\"> &#123; <span class=\"attr\">status</span>: <span class=\"string\">&quot;div&quot;</span>, <span class=\"attr\">value</span>: <span class=\"string\">&quot;dell&quot;</span> &#125;,</span><br><span class=\"line\"> &#123; <span class=\"attr\">status</span>: <span class=\"string\">&quot;div&quot;</span>, <span class=\"attr\">value</span>: <span class=\"string\">&quot;lee&quot;</span> &#125;</span><br><span class=\"line\">]&#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">url</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (url === <span class=\"string\">&quot;/getUndoList.json&quot;</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.success === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">     resolve(undoList);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// __tests__/integration/TodoList.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@vue/test-utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; findTestWrapper &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../utils/testUtils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../TodoList&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">beforeEach(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\"> axios.success = <span class=\"literal\">true</span>;</span><br><span class=\"line\"> jest.useFakeTimers(); <span class=\"comment\">// 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响&#125;);</span></span><br><span class=\"line\">it(<span class=\"string\">`1. 用户进入页面时，请求远程测试; 2. 列表应该显示远程返回的数据`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(TodoList, &#123; store &#125;);</span><br><span class=\"line\">  wrapper.vm.$nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">   expect(listItems.length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">   done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">it(<span class=\"string\">`1. 用户进入页面时，等待5s; 2. 列表应该显示远程返回的数据`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> wrapper = mount(TodoList, &#123; store &#125;);</span><br><span class=\"line\"> expect(<span class=\"built_in\">setTimeout</span>).toHaveBeenCalledTimes(<span class=\"number\">1</span>); <span class=\"comment\">// 至少执行一次定时器</span></span><br><span class=\"line\"> jest.runAllTimers();</span><br><span class=\"line\"> wrapper.vm.$nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">  expect(listItems.length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">  done();</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`1. 用户进入页面时，请求远程数据失败; 2. 列表应该显示空数据，不应该挂掉`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\"> axios.success = <span class=\"literal\">false</span>;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> wrapper = mount(TodoList, &#123; store &#125;);</span><br><span class=\"line\"> expect(<span class=\"built_in\">setTimeout</span>).toHaveBeenCalledTimes(<span class=\"number\">1</span>); <span class=\"comment\">// 至少执行一次定时器</span></span><br><span class=\"line\"> jest.runAllTimers();</span><br><span class=\"line\"> wrapper.vm.$nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">  expect(listItems.length).toBe(<span class=\"number\">0</span>);</span><br><span class=\"line\">  done();</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-react-的异步测试\"><a href=\"#13-2-react-的异步测试\" class=\"headerlink\" title=\"13.2 react 的异步测试\"></a>13.2 react 的异步测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// __mocks__/axios.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> undoList = &#123;</span><br><span class=\"line\">  success: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  data: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">status</span>: <span class=\"string\">&quot;div&quot;</span>, <span class=\"attr\">value</span>: <span class=\"string\">&quot;dell&quot;</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">status</span>: <span class=\"string\">&quot;div&quot;</span>, <span class=\"attr\">value</span>: <span class=\"string\">&quot;lee&quot;</span> &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">url</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (url === <span class=\"string\">&quot;/getUndoList.json&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.success === <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">          resolve(undoList);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/// __tests__/integration/TodoList.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-redux&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Enzyme, &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Adapter <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme-adapter-react-16&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../TodoList&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> store <span class=\"keyword\">from</span> <span class=\"string\">&quot;../../../../store/createStore&quot;</span>;</span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">beforeEach(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  axios.success = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  jest.useFakeTimers(); <span class=\"comment\">// 写在钩子函数中的意义是为了清除统计次数，重新开始，防止上一个测试用例对下一个测试用例产生影响</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    1. 用户进入页面时，请求远程测试</span></span><br><span class=\"line\"><span class=\"string\">    2. 列表应该显示远程返回的数据</span></span><br><span class=\"line\"><span class=\"string\">`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &lt;TodoList /&gt;</span><br><span class=\"line\">    &lt;/Provider&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  process.nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    wrapper.update();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">    expect(listItems.length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    1. 用户进入页面时，等待5s</span></span><br><span class=\"line\"><span class=\"string\">    2. 列表应该显示远程返回的数据</span></span><br><span class=\"line\"><span class=\"string\">`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &lt;TodoList /&gt;</span><br><span class=\"line\">    &lt;/Provider&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  expect(<span class=\"built_in\">setTimeout</span>).toHaveBeenCalledTimes(<span class=\"number\">1</span>); <span class=\"comment\">// 至少执行一次定时器</span></span><br><span class=\"line\">  jest.runAllTimers();</span><br><span class=\"line\">  process.nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    wrapper.update(); <span class=\"comment\">// 更新 wrapper 防止取上一次的 wrapper</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">    expect(listItems.length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  1. 用户进入页面时，请求远程数据失败</span></span><br><span class=\"line\"><span class=\"string\">  2. 列表应该显示空数据，不应该挂掉</span></span><br><span class=\"line\"><span class=\"string\">`</span>, <span class=\"function\"><span class=\"params\">done</span> =&gt;</span> &#123;</span><br><span class=\"line\">  axios.success = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = mount(</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &lt;TodoList /&gt;</span><br><span class=\"line\">    &lt;/Provider&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">  expect(<span class=\"built_in\">setTimeout</span>).toHaveBeenCalledTimes(<span class=\"number\">1</span>); <span class=\"comment\">// 至少执行一次定时器</span></span><br><span class=\"line\">  jest.runAllTimers();</span><br><span class=\"line\">  process.nickTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    wrapper.update();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> listItems = findTestWrapper(wrapper, <span class=\"string\">&quot;list-item&quot;</span>);</span><br><span class=\"line\">    expect(listItems.length).toBe(<span class=\"number\">0</span>);</span><br><span class=\"line\">    done();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"14-vue-项目的自动化测试\"><a href=\"#14-vue-项目的自动化测试\" class=\"headerlink\" title=\"14. vue 项目的自动化测试\"></a>14. vue 项目的自动化测试</h2><h3 id=\"14-1-使用传统方式对-vue-组件进行测试\"><a href=\"#14-1-使用传统方式对-vue-组件进行测试\" class=\"headerlink\" title=\"14.1 使用传统方式对 vue 组件进行测试\"></a>14.1 使用传统方式对 vue 组件进行测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">&quot;vue&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">&quot;@/components/HelloWorld&quot;</span>;</span><br><span class=\"line\">describe(<span class=\"string\">&quot;HelloWorld.vue&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  it(<span class=\"string\">&quot;renders props.msg when passed&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> root = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;div&quot;</span>);</span><br><span class=\"line\">    root.className = <span class=\"string\">&quot;root&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.appendChild(root);</span><br><span class=\"line\">    <span class=\"keyword\">new</span> Vue(&#123;</span><br><span class=\"line\">      render: <span class=\"function\"><span class=\"params\">h</span> =&gt;</span></span><br><span class=\"line\">        h(HelloWorld, &#123;</span><br><span class=\"line\">          props: &#123;</span><br><span class=\"line\">            msg: <span class=\"string\">&quot;dell lee&quot;</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;).$mount(<span class=\"string\">&quot;.root&quot;</span>);</span><br><span class=\"line\">    expect(<span class=\"built_in\">document</span>.getElementByClassName(<span class=\"string\">&quot;hello&quot;</span>).length).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p>\n<h3 id=\"14-2-使用-vue-test-utils-对-vue-组件进行测试\"><a href=\"#14-2-使用-vue-test-utils-对-vue-组件进行测试\" class=\"headerlink\" title=\"14.2 使用 @vue/test-utils 对 vue 组件进行测试\"></a>14.2 使用 @vue/test-utils 对 vue 组件进行测试</h3><ul>\n<li><a href=\"https://vue-test-utils.vuejs.org/zh/\">官方文档</a></li>\n</ul>\n<h3 id=\"14-2-1-for-example\"><a href=\"#14-2-1-for-example\" class=\"headerlink\" title=\"14.2.1 for example\"></a>14.2.1 for example</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; shallowMount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@vue/test-utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">&quot;@/components/HelloWorld&quot;</span>;</span><br><span class=\"line\">describe(<span class=\"string\">&quot;HelloWorld.vue&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  it(<span class=\"string\">&quot;renders props.msg when passed&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> msg = <span class=\"string\">&quot;dell lee&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wrapper = shallowMount(HelloWorld, &#123;</span><br><span class=\"line\">      propsData: &#123; msg &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    expect(wrapper.text()).toMatch(msg);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-2-2-快照测试\"><a href=\"#14-2-2-快照测试\" class=\"headerlink\" title=\"14.2.2 快照测试\"></a>14.2.2 快照测试</h3><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p>\n<p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HelloWorld.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; shallowMount &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@vue/test-utils&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> HelloWorld <span class=\"keyword\">from</span> <span class=\"string\">&quot;@/components/HelloWorld&quot;</span>;</span><br><span class=\"line\">describe(<span class=\"string\">&quot;HelloWorld.vue 组件渲染正常&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  it(<span class=\"string\">&quot;renders props.msg when passed&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> msg = <span class=\"string\">&quot;dell lee&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wrapper = shallowMount(HelloWorld, &#123;</span><br><span class=\"line\">      propsData: &#123; msg &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    expect(wrapper).toMatchSnapshot();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"15-react-项目的自动化测试\"><a href=\"#15-react-项目的自动化测试\" class=\"headerlink\" title=\"15. react 项目的自动化测试\"></a>15. react 项目的自动化测试</h2><h3 id=\"15-1-使用传统方式对-react-组件进行测试\"><a href=\"#15-1-使用传统方式对-react-组件进行测试\" class=\"headerlink\" title=\"15.1 使用传统方式对 react 组件进行测试\"></a>15.1 使用传统方式对 react 组件进行测试</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">&quot;react-dom&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;./App&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">it(<span class=\"string\">&quot;render App&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> div = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&quot;div&quot;</span>);</span><br><span class=\"line\">  ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>, div);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> container = div.getElementsByClassName(<span class=\"string\">&quot;App&quot;</span>);</span><br><span class=\"line\">  expect(container.length).toBe(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>缺点：写法过于复杂，局限性也很大，部分属性无法进行测试</p>\n<h3 id=\"15-2-enzyme-的配置和使用\"><a href=\"#15-2-enzyme-的配置和使用\" class=\"headerlink\" title=\"15.2 enzyme 的配置和使用\"></a>15.2 enzyme 的配置和使用</h3><ul>\n<li><a href=\"https://enzymejs.github.io/enzyme/\">官方文档</a></li>\n<li><a href=\"https://github.com/enzymejs/enzyme\">github</a></li>\n<li><a href=\"https://github.com/enzymejs/enzyme-matchers/tree/master/packages/jest-enzyme\">jest-enzyme</a></li>\n</ul>\n<h3 id=\"15-2-1-for-example\"><a href=\"#15-2-1-for-example\" class=\"headerlink\" title=\"15.2.1 for example\"></a>15.2.1 for example</h3><figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Enzyme, &#123; shallow &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Adapter <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme-adapter-react-16&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;App&quot;</span>;</span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\">it(<span class=\"string\">&quot;render App&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = shallow(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>);</span><br><span class=\"line\">  expect(wrapper.find(<span class=\"string\">&#x27;[data-test=&quot;App&quot;]&#x27;</span>).length).toBe(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>使用自定义 <code>props</code> 可以降低代码耦合度</p>\n<p><code>shallow</code> 适合单元测试，属于浅渲染； <code>mount</code> 适合集成测试，会将当前组件包括其子组件一起渲染</p>\n<p>单元测试时更倾向于使用 <code>api</code> <code>.state()</code> ；集成测试时更倾向于使用 <code>api</code> <code>.prop()</code></p>\n<h3 id=\"15-2-2-快照测试\"><a href=\"#15-2-2-快照测试\" class=\"headerlink\" title=\"15.2.2 快照测试\"></a>15.2.2 快照测试</h3><p>使用场景: 一般用于测试组件正常渲染，而不测试组件功能时使用。比如对样式和布局的修改做监听</p>\n<p>好处: 可以帮助我们及时发现组件中 <code>dom</code> 结构的变化</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.test.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Enzyme, &#123; shallow &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Adapter <span class=\"keyword\">from</span> <span class=\"string\">&quot;enzyme-adapter-react-16&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">&quot;App&quot;</span>;</span><br><span class=\"line\">Enzyme.configure(&#123; <span class=\"attr\">adapter</span>: <span class=\"keyword\">new</span> Adapter() &#125;);</span><br><span class=\"line\">it(<span class=\"string\">&quot;render App&quot;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> wrapper = shallow(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">App</span> /&gt;</span></span>);</span><br><span class=\"line\">  expect(wrapper).toMatchSnapshot();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"16-前端自动化测试的优势\"><a href=\"#16-前端自动化测试的优势\" class=\"headerlink\" title=\"16. 前端自动化测试的优势\"></a>16. 前端自动化测试的优势</h2><ul>\n<li>更好的代码组织，项目的可维护性强</li>\n<li>更少的 <code>Bug</code> 出现概率，尤其是回归测试中的 <code>Bug</code></li>\n<li>修改工程质量差的项目，更加安全</li>\n<li>项目具备潜在的文档特性</li>\n<li>扩展前端的知识面</li>\n</ul>\n<h2 id=\"17-总结重要的点\"><a href=\"#17-总结重要的点\" class=\"headerlink\" title=\"17 总结重要的点\"></a>17 总结重要的点</h2><ol>\n<li><code>BDD</code> 和 <code>TDD</code></li>\n<li>集成测试 和 单元测试</li>\n<li>测试和业务的解耦</li>\n<li>代码测试覆盖率并不代表一定靠谱</li>\n<li>功能性测试 和 <code>UI</code>测试</li>\n<li>测试越独立，隐藏的问题就越多</li>\n</ol>\n"},{"title":"TypeScript 文档","date":"2020-09-09T16:00:00.000Z","_content":"\n## 一、 基础类型\n\n### 1.1 类型断言\n\n> 有时候你会遇到这样的情况，你会比 `TypeScript` 更了解某个值的详细信息。通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。类型断言好比其它语言里的类型转换，但是不尽兴特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。\n\n- 类型断言有两种形式\n\n- 第一种：尖括号语法 (当在 `TypeScript` 里使用 `JSX` 时，只有 `as` 语言断言是被允许的)\n\n```typescript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n```\n\n- 第二种：`as` 语法\n\n```typescript\nlet _someValue: any = \"this is a string\";\nlet _strLength: number = (_someValue as string).length;\n```\n\n### 1.2 基础类型\n\n#### 1.2.1 布尔值\n\n```typescript\nlet isDone: boolean = false;\n```\n\n#### 1.2.2 数字\n\n> 与 `javascript` 一样，`TypeScript` 里的所有数字都是浮点数。这些浮点数的类型是 `number`。 除了支持十进制和十六进制字面量， `TypeScript` 还支持 `ECMA2015` 中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\n```\n\n#### 1.2.3 字符串\n\n```typescript\nlet strName: string = \"bob\";\n```\n\n#### 1.2.4 数组\n\n> `TypeScript` 像 `JavaScript` 一样可以操作数组元素。有两种方法定义数组。\n\n- 第一种：可以在元素类型后面接上 `[]`;\n\n```typescript\nlet list1: number[] = [1, 2, 3];\n```\n\n- 第二种：使用数组泛型, `Array<元素类型>`\n\n```typescript\nlet list2: Array<number> = [1, 2, 3];\n```\n\n#### 1.2.5 元组 Tuple\n\n- 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。\n\n```typescript\nlet x: [string, number];\nx = [\"hello\", 10]; // => Ok\nx = [10, \"hello\"]; // => Error\n```\n\n- 当访问一个已知索引的元素，会得到正确的类型\n\n```typescript\nconsole.log(x[0].substr(1)); // => Ok\nconsole.log(x[1].substr(1)); // => Error\n```\n\n- 当访问一个越界的元素，会使用联合类型替代\n\n```typescript\nx[3] = \"world\"; // Ok, 字符串可以赋值给(string | number)类型\nconsole.log(x[5].toString()); // Ok, \"string\"和\"number\"都有toString方法\nx[6] = true; // Error, 布尔不是(string | number)类型\n```\n\n#### 1.2.6 枚举\n\n- `enum` 类型是对 `JavaScript` 标准数据类型的一个补充。像 `C#` 等其他语言一样，使用枚举类型可以为一组数值赋予友好的名字\n\n```typescript\nenum Color {\n  Red,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\n```\n\n- 默认情况下，从 `0` 开始为元素编号。你也可以手动的指定成员的数值。\n\n```typescript\nenum Color1 {\n  Red = 1,\n  Green,\n  Blue\n}\nlet c1: Color1 = Color1.Green;\n```\n\n- 或者全部采用赋值\n\n```typescript\nenum Color2 {\n  Red = 1,\n  Green = 2,\n  Blue = 4\n}\nlet c2: Color2 = Color2.Green;\n```\n\n- 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。\n\n```typescript\nenum Color3 {\n  Red = 1,\n  Green,\n  Blue\n}\nlet colorName: string = Color3[2];\nconsole.log(colorName);\n```\n\n#### 1.2.7 Any\n\n- 有时候，我们想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自于动态的内容，比如来自用户输入或第三方库。这种情况下，我们不希望类型检查器对这些值进行检查而是让它们通过编译阶段的检查。那么我们可以使用 `any` 类型来标记这些变量\n\n```typescript\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // Ok\n```\n\n- 在对现有代码进行改写的时候，`any` 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。你可能认为 `Object` 有相似的作用，就像在其他语言中那样。但是 `Object` 类型的变量只是允许你给他赋任意值，但是却不能够在它上面调用任意的方法，即使它真有这些方法。\n\n```typescript\nlet notSure1: any = 4;\nnotSure1.ifItExists(); // Ok\nnotSure1.toFixed(); // Ok\nlet prettySure: Object = 4;\n// prettySure.toFixed(); // Error, Property 'toFixed' doesn't exist on type 'Object'.\n```\n\n- 当你只知道一部分数据类型时，`any` 类型也是有用的。\n\n```typescript\nlet list: any[] = [1, true, \"free\"];\nlist[1] = 100;\n```\n\n#### 1.2.8 Void\n\n- 某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 `void`。\n\n```typescript\nfunction warnUser(): void {\n  console.log(\"This is my warning message\");\n}\n```\n\n- 声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`\n\n```typescript\nlet unusbale: void = undefined;\n```\n\n#### 1.2.9 Null 和 Undefined\n\n- `TypeScript` 里，`undefined` 和 `null` 两者各有自己的类型分别叫做 `undefined` 和 `null`。和 `void` 相似，它们本身的类型用处不是很大。\n\n```typescript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n- 默认情况下 `null` 和 `undefined` 是所有类型的子类型。就是说你可以把 `null` 和 `undefined` 赋值给 `number` 类型的变量。\n- 然而，当你指定了一个 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自。这能避免很多常见的问题。也许在某处你想传入一个 `string` 或 `null` 或 `undefined`，你可以使用联合类型 `string | null | undefined`。\n\n#### 1.2.10 Never\n\n- `never` 类型表示的是那些永不存在的值的类型。例如：`never` 类型是那些总会抛出异常或根本不会有返回值的函数表达式或箭头函数表达式的返回值类型；\n- 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。\n- `never` 类型是任何类型的子类型，也可以赋值给任何类型；\n\n> 然而，没有类型是 `never` 的子类型或可以赋值给 `never` 类型(除了 `never` 本身之外)。即使 `any` 也不可以赋值给 `never`。\n\n```typescript\n// 返回 never 的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message);\n}\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\");\n}\n// 返回 never 的函数必须存在法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n```\n\n#### 1.2.11 Object\n\n- `Object` 表示非原始类型，也就是除 `number`, `string`, `boolean`, `symbol`, `null` 或 `undefined` 之外的类型。\n- 使用 `Object` 类型，就可以更好的表示像 `Object.create` 这样的 `API`。\n\n```typescript\ndeclare function create(o: object | null): void;\ncreate({ prop: 0 }); // Ok\ncreate(null); // Ok\ncreate(42); //Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n```\n\n## 二、变量声明\n\n### 2.1 介绍\n\n> `let` 和 `const` 是 `JavaScript` 里相对较新的变量声明方式。 像我们之前提到过的， `let` 在很多方面与 `var` 是相似的，但是可以帮助大家避免在 `JavaScript` 里常见一些问题。 `const` 是对 `let` 的一个增强，它能阻止对一个变量再次赋值。\n> 因为 `TypeScript` 是 `JavaScript` 的超集，所以它本身就支持 `let` 和 `const` 。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 `var`。\n> 如果你之前使用 `JavaScript` 时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 `var` 声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n### 2.2 var 声明\n\n> 一直以来我们都是通过 `var` 关键字定义 `JavaScript` 变量。\n\n```typescript\nvar a = 10;\n```\n\n> 大家都能理解，这里定义了一个名为 `a` 值为 `10` 的变量。\n> 我们也可以在函数内部定义变量：\n\n```typescript\nfunction f() {\n  var message = \"Hello, world!\";\n  return message;\n}\n```\n\n> 并且我们也可以在其它函数内部访问相同的变量。\n\n```typescript\nfunction f() {\n  var a = 10;\n  return function g() {\n    var b = a + 1;\n    return b;\n  };\n}\n\nvar g = f();\ng(); // returns 11;\n```\n\n> 上面的例子里，`g` 可以获取到 `f` 函数里定义的 `a` 变量。 每当 `g` 被调用时，它都可以访问到 `f` 里的 `a` 变量。 即使当 `g` 在 `f` 已经执行完后才被调用，它仍然可以访问及修改 `a`。\n\n```typescript\nfunction f() {\n  var a = 1;\n\n  a = 2;\n  var b = g();\n  a = 3;\n\n  return b;\n\n  function g() {\n    return a;\n  }\n}\n\nf(); // returns 2\n```\n\n### 2.3 作用域规则\n\n> 对于熟悉其它语言的人来说，`var` 声明有些奇怪的作用域规则。 看下面的例子：\n\n```typescript\nfunction f(shouldInitialize: boolean) {\n  if (shouldInitialize) {\n    var x = 10;\n  }\n  return x;\n}\n\nf(true); // returns '10'\nf(false); // returns 'undefined'\n```\n\n> 有些读者可能要多看几遍这个例子。 变量 `x` 是定义在 `if` 语句里面\\_，但是我们却可以在语句的外面访问它。 这是因为 `var` 声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为 `var` 作用域或函数作用域。函数参数也使用函数作用域。\n> 这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n  var sum = 0;\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n```\n\n> 这里很容易看出一些问题，里层的 `for` 循环会覆盖变量 `i`，因为所有 `i` 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n### 2.4 捕获变量怪异之处\n\n> 快速的猜一下下面的代码会返回什么：\n\n```typescript\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\n> 介绍一下，`setTimeout` 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。\n> 好吧，看一下结果：\n\n```typescript\n10;\n10;\n10;\n10;\n10;\n10;\n10;\n10;\n10;\n10;\n```\n\n> 很多 `JavaScript` 程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：\n\n```typescript\n0;\n1;\n2;\n3;\n4;\n5;\n6;\n7;\n8;\n9;\n```\n\n> 还记得我们上面提到的捕获变量吗？\n> 我们传给 `setTimeout` 的每一个函数表达式实际上都引用了相同作用域里的同一个 `i`。\n> 让我们花点时间思考一下这是为什么。 `setTimeout` 在若干毫秒后执行一个函数，并且是在 `for` 循环结束后。 `for` 循环结束后，`i` 的值为 `10`。 所以当函数被调用的时候，它会打印出 `10！`\n> 一个通常的解决方法是使用立即执行的函数表达式（`IIFE`）来捕获每次迭代时 `i` 的值：\n\n```typescript\nfor (var i = 0; i < 10; i++) {\n  // capture the current state of 'i'\n  // by invoking a function with its current value\n  (function (i) {\n    setTimeout(function () {\n      console.log(i);\n    }, 100 * i);\n  })(i);\n}\n```\n\n> 这种奇怪的形式我们已经司空见惯了。 参数 `i` 会覆盖 `for` 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 `for` 循环体里的代码。\n\n### 2.5 let 声明\n\n> 现在你已经知道了 `var` 存在一些问题，这恰好说明了为什么用 `let` 语句来声明变量。 除了名字不同外， let 与 `var` 的写法一致。\n\n```typescript\nlet hello = \"Hello!\";\n```\n\n> 主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n### 2.6 块作用域\n\n> 当用 `let` 声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 `var` 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 `for` 循环之外是不能访问的。\n\n```typescript\nfunction f(input: boolean) {\n  let a = 100;\n  if (input) {\n    // Still okay to reference 'a'\n    let b = a + 1;\n    return b;\n  }\n\n  // Error: 'b' doesn't exist here\n  return b;\n}\n```\n\n> 这里我们定义了`2`个变量 `a` 和 `b` 。 `a` 的作用域是 `f` 函数体内，而 `b` 的作用域是 `if` 语句块里。\n> 在 `catch` 语句里声明的变量也具有同样的作用域规则。\n\n```typescript\ntry {\n  throw \"oh no!\";\n} catch (e) {\n  console.log(\"Oh well.\");\n}\n\n// Error: 'e' doesn't exist here\nconsole.log(e);\n```\n\n> 拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 `let` 语句之前访问它们，幸运的是 `TypeScript` 可以告诉我们这些信息。\n\n```typescript\na++; // illegal to use 'a' before it's declared;\nlet a;\n```\n\n> 注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 `ES2015`，现代的运行时会抛出一个错误；然而，现今 `TypeScript` 是不会报错的。\n\n```typescript\nfunction foo() {\n  // okay to capture 'a'\n  return a;\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo();\n\nlet a;\n```\n\n> 关于暂时性死区的更多信息，查看这里 [Mozilla Developer Network.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)\n\n### 2.7 重定义及屏蔽\n\n> 我们提过使用 `var` 声明时，它不在乎你声明多少次；你只会得到 `1` 个。\n\n```typescript\nfunction f(x) {\n  var x;\n  var x;\n  if (true) {\n    var x;\n  }\n}\n```\n\n> 在上面的例子里，所有 `x` 的声明实际上都引用一个相同的 `x`，并且这是完全有效的代码。 这经常会成为`bug` 的来源。 好的是， `let` 声明就不会这么宽松了。\n\n```typescript\nlet x = 10;\nlet x = 20; // 错误，不能在1个作用域里多次声明`x\n```\n\n> 并不是要求两个均是块级作用域的声明 `TypeScript` 才会给出一个错误的警告。\n\n```typescript\nfunction f(x) {\n  let x = 100; // error: interferes with parameter declaration\n}\n\nfunction g() {\n  let x = 100;\n  var x = 100; // error: can't have both declarations of 'x'\n}\n```\n\n> 并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\n```typescript\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100;\n    return x;\n  }\n  return x;\n}\n\nf(false, 0); // returns 0\nf(true, 0); // returns 100\n```\n\n> 在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 `let` 重写之前的 `sumMatrix` 函数。\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0;\n  for (let i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n```\n\n> 这个版本的循环能得到正确的结果，因为内层循环的 i 可以屏蔽掉外层循环的 `i`。\n> 通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。\n\n### 2.8 块级作用域变量的获取\n\n> 在我们最初谈及获取用 `var` 声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n```typescript\nfunction theCityThatAlwaysSleeps() {\n  let getCity;\n  if (true) {\n    let city = \"Seattle\";\n    getCity = function () {\n      return city;\n    };\n  }\n  return getCity();\n}\n```\n\n> 因为我们已经在 `city` 的环境里获取到了 `city` ，所以就算 if 语句执行结束后我们仍然可以访问它。\n> 回想一下前面 `setTimeout` 的例子，我们最后需要使用立即执行的函数表达式来获取每次 `for` 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 `TypeScript` 里这样做了。\n> 当 `let` 声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 `setTimeout` 例子里我们仅使用 `let` 声明就可以了。\n\n```typescript\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\n> 会输出与预料一致的结果：\n\n```typescript\n0;\n1;\n2;\n3;\n4;\n5;\n6;\n7;\n8;\n9;\n```\n\n### 2.9 const 声明\n\n> `const` 声明是声明变量的另一种方式。\n\n```typescript\nconst numLivesForCat = 9;\n```\n\n> 它们与 `let` 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 `let` 相同的作用域规则，但是不能对它们重新赋值。\n> 这很好理解，它们引用的值是不可变的。\n\n```typescript\nconst numLivesForCat = 9;\nconst kitty = {\n  name: \"Aurora\",\n  numLives: numLivesForCat\n};\n\n// Error\nkitty = {\n  name: \"Danielle\",\n  numLives: numLivesForCat\n};\n\n// all \"okay\"\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;\n```\n\n> 除非你使用特殊的方法去避免，实际上 `const` 变量的内部状态是可修改的。 幸运的是，`TypeScript` 允许你将对象的成员设置成只读的。 接口一章有详细说明。\n\n### 2.10 let vs. const\n\n> 现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。\n> 使用最小特权原则，所有变量除了你计划去修改的都应该使用 `const`。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 `const` 也可以让我们更容易的推测数据的流动。\n> 跟据你的自己判断，如果合适的话，与团队成员商议一下。\n> 这个手册大部分地方都使用了 `let` 声明。\n\n### 2.11 解构\n\n> `Another TypeScript` 已经可以解析其它 `ECMAScript 2015` 特性了。 完整列表请参见 [the article on the Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。 本章，我们将给出一个简短的概述。\n\n#### 2.11.1 解构数组\n\n> 最简单的解构莫过于数组的解构赋值了：\n\n```typescript\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n```\n\n> 这创建了 `2` 个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：\n\n```typescript\nfirst = input[0];\nsecond = input[1];\n```\n\n> 解构作用于已声明的变量会更好：\n\n```typescript\n// swap variables\n[first, second] = [second, first];\n```\n\n> 作用于函数参数：\n\n```typescript\nfunction f([first, second]: [number, number]) {\n  console.log(first);\n  console.log(second);\n}\nf(input);\n```\n\n> 你可以在数组里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n```\n\n> 当然，由于是 `JavaScript`, 你可以忽略你不关心的尾随元素：\n\n```typescript\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n\n> 或其它元素：\n\n```typescript\nlet [, second, , fourth] = [1, 2, 3, 4];\n```\n\n#### 2.11.2 对象解构\n\n> 你也可以解构对象：\n\n```typescript\nlet o = {\n  a: \"foo\",\n  b: 12,\n  c: \"bar\"\n};\nlet { a, b } = o;\n```\n\n> 这通过 `o.a and o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。\n> 就像数组解构，你可以用没有声明的赋值：\n\n```typescript\n({ a, b } = { a: \"baz\", b: 101 });\n```\n\n> 注意，我们需要用括号将它括起来，因为 `Javascript` 通常会将以 `{` 起始的语句解析为一个块。\n> 你可以在对象里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n\n#### 2.11.3 属性重命名\n\n> 你也可以给属性以不同的名字：\n\n```typescript\nlet { a: newName1, b: newName2 } = o;\n```\n\n> 这里的语法开始变得混乱。 你可以将 `a: newName1` 读做 \"`a` 作为 `newName1`\"。 方向是从左到右，好像你写成了以下样子：\n\n```typescript\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n\n> 令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。\n\n```typescript\nlet { a, b }: { a: string; b: number } = o;\n```\n\n#### 2.11.4 默认值\n\n> 默认值可以让你在属性为 `undefined` 时使用缺省值：\n\n```typescript\nfunction keepWholeObject(wholeObject: { a: string; b?: number }) {\n  let { a, b = 1001 } = wholeObject;\n}\n```\n\n> 现在，即使 `b` 为 `undefined` ， `keepWholeObject` 函数的变量 `wholeObject` 的属性 `a` 和 `b` 都会有值。\n\n#### 2.11.5 函数声明\n\n> 解构也能用于函数声明。 看以下简单的情况：\n\n```typescript\ntype C = { a: string; b?: number };\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n\n> 但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\n```typescript\nfunction f({ a = \"\", b = 0 } = {}): void {\n  // ...\n}\nf();\n```\n\n> 上面的代码是一个类型推断的例子，将在本手册后文介绍。\n> 其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 `C` 的定义有一个 `b` 可选属性：\n\n```typescript\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n  // ...\n}\nf({ a: \"yes\" }); // ok, default b = 0\nf(); // ok, default to {a: \"\"}, which then defaults b = 0\nf({}); // error, 'a' is required if you supply an argument\n```\n\n> 要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。\n\n#### 2.11.6 展开\n\n> 展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：\n\n```typescript\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n\n> 这会令 `bothPlus` 的值为 `[0, 1, 2, 3, 4, 5]`。 展开操作创建了 `first` 和 `second` 的一份浅拷贝。 它们不会被展开操作所改变。\n> 你还可以展开对象：\n\n```typescript\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { ...defaults, food: \"rich\" };\n```\n\n> `search` 的值为 `{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }`。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\n```typescript\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { food: \"rich\", ...defaults };\n```\n\n> 那么，`defaults` 里的 `food` 属性会重写 `food: \"rich\"`，在这里这并不是我们想要的结果。\n> 对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 [自身的可枚举属性](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。 大体上是说当你展开一个对象实例时，你会丢失其方法：\n\n```typescript\nclass C {\n  p = 12;\n  m() {}\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n```\n\n> 其次，`TypeScript` 编译器不允许展开泛型函数上的类型参数。 这个特性会在 `TypeScript` 的未来版本中考虑实现。\n\n## 三、接口\n\n### 3.1 实现一个简单的接口\n\n```typescript\ninterface LabelledValue {\n  label: string;\n}\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\nlet myObj = { size: 10, label: \"size 10 Object\" };\nprintLabel(myObj);\n```\n\n### 3.2 可选属性\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\nfunction createConfig(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: \"white\", area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\nlet mySquare = createConfig({ color: \"black\", width: 20 });\nconsole.log(mySquare);\n```\n\n### 3.3 只读属性\n\n```typescript\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n}\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error! 因为属性是只读的\n```\n\n### 3.4 额外的属性检查\n\n> 问题：将\" _可选属性_ \"与\" `option bags` \"模式相结合而引发\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\nfunction createConfig(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: \"white\", area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n```\n\n> `let mySquare = createConfig({ colour: \"red\", width: 100 }); //报错`\n\n- 解决方案一：采用类型断言\n\n```typescript\nlet mySquare = createConfig({ width: 100, opacity: 0.5 } as SquareConfig);\n```\n\n- 解决方案二：采用添加一个字符串索引签名(最佳方案)\n\n```typescript\ninterface _SquareConfig {\n  color?: string;\n  width?: number;\n  [propName: string]: any;\n}\n```\n\n- 解决方案三：变量赋值\n\n### 3.5 函数类型\n\n#### 3.5.1 函数类型\n\n```typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\nlet mySearch: SearchFunc;\nmySearch = function (source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n};\n```\n\n#### 3.5.2 函数类型\n\n```typescript\nlet add: (baseValue: number, increment: number) => number = (x, y) => x + y;\n\nlet add2 = (x: number, y: number): number => x + y;\n\nlet buildNameFun: (fname: string, ...rest: Array<string>) => string = (firstName: string, ...restOfName: Array<string>) => `${firstName}, ${restOfName.join(\" \")}`;\n\nlet fn = (a: number, b: number): number => a + b;\n```\n\n#### 3.5.3 函数类型\n\n```typescript\ninterface func {\n  (x: string, y: string): boolean;\n}\nlet func: func = (x: string, y: string) => {\n  return x.search(y) > -1;\n};\n```\n\n### 3.6 可索引类型\n\n- 例如：`a[10]` 或 `ageMap[\"daniel\"]`\n- 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型\n\n```typescript\ninterface StringArray {\n  [index: number]: string;\n}\nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\nlet myStr: string = myArray[0];\nconsole.log(myStr);\n```\n\n> `Ts` 支持两种索引签名：字符串 和 数字。可以同时使用两种类型的索引，但数字索引的返回值必须是字符串索引返回值类型的子类型。\n\n### 3.7 类类型\n\n> 接口描述了类的公共部分，而不是类的公有和私有两部分。它不会帮你检查类是否具有某些私有成员\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date;\n  setTime(d: Date); // 在接口中描述的方法\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date;\n  setTime(d: Date) {\n    // 在类中的具体实现\n    this.currentTime = d;\n  }\n  constructor(h: number, m: number) {}\n}\n```\n\n> 当操作类的时候，我们需要知道类是具有两个类型的：_静态部分的类型_ 和 _实例的类型_。\n> 当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误。\n> 因为当一个类实现了一个接口时，只对其实例部分进行类型检查。`constructor` 存在于类的静态部分，所以不在检查的范围内。\n\n- 因此应当直接操作 _类的静态部分_\n\n```typescript\ninterface err_ClockConstructor {\n  new (hour: number, minute: number);\n}\nclass err_Clock implements err_ClockConstructor {\n  currentTime: Date;\n  constructor(h: number, m: number) {}\n}\n```\n\n- 下面是实现对 _静态类型_ 的检查工作\n\n> 因为 `createClock` 的第一个参数是 `ClockConstructor` 类型，在 `createClock(AnalogClock, 7, 32)` 里，会检查 `AnalogClock` 是否符合构造函数签名\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n\ninterface ClockInterface {\n  tick();\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n  return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n\n  tick() {\n    console.log(\"beep beep\");\n  }\n}\n\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n\n  tick() {\n    console.log(\"tick tick\");\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\nconsole.log(digital);\nconsole.log(analog);\n```\n\n### 3.8 接口继承\n\n- 和类一样，接口也可以相互继承。可以灵活地将接口分割到可重用的模块里。\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface Square extends Shape {\n  sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\n```\n\n- 一个接口可以继承多个接口，创建出多个接口的合成接口\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface PenStroke {\n  penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n\n- 目的: `=>` 灵活地将接口分割到可重用的模块中\n\n```typescript\ninterface Lamp {\n  lampOn(): void;\n\n  lampOff(): void;\n}\n\ninterface wx {\n  wxNumber: number;\n\n  showWxNumber(): string;\n}\n\ninterface Photo extends Lamp, wx {\n  photo(): string;\n}\n\nclass HuaWeiPhone implements Photo {\n  public wxNumber: number;\n\n  photo(): string {\n    return \"华为手机\";\n  }\n\n  lampOn(): void {}\n\n  lampOff(): void {}\n  constructor(wxNumber: number) {\n    this.wxNumber = wxNumber;\n  }\n\n  showWxNumber(): string {\n    return \"我的微信号：123\";\n  }\n}\nlet huaWeiPhone = new HuaWeiPhone(12345678910);\nconsole.log(huaWeiPhone.showWxNumber());\nconsole.log(huaWeiPhone.photo());\n```\n\n### 3.9 混合类型\n\n> 一个对象可以同时做为函数和对象使用，并带有额外的属性\n\n```typescript\ninterface Counter {\n  (start: number): string;\n\n  interval: number;\n\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = <Counter>function (start: number) {\n    // return start + 'string';\n  };\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.interval = 5.0;\nc.reset();\n```\n\n### 3.10 接口继承类\n\n1. 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。\n2. 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。\n3. 接口同样会继承到类的 `private` 和 `protected` 成员。\n4. 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现( `implement` )。\n5. 当你有一个庞大的继承接口时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。这个子类除了继承至基类外与基类没有任何关系。\n\n```typescript\nclass Control {\n  private state: any;\n}\n\ninterface SelectableControl extends Control {\n  select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n  select(): void {}\n}\n\nclass TextBox extends Control {\n  select(): void {}\n}\n\n// 错误：\"Image\"类型缺少\"state\"属性\nclass Image implements SelectableControl {\n  select(): void {}\n}\nclass Location {}\n```\n\n> 在上面的例子中，`SelectableControl` 包含了 `Control` 的所有成员。包括私有成员 `state`。因为 `state` 是私有成员，所以只能够是 `Control` 的子类们才能实现 `SelectableControl` 接口，因为只有 `Control` 的子类才能够拥有一个声明于 `Control` 的私有成员 `state`，这对私有成员的兼容性是必需的。\n> 在 `Control` 类内部，是允许通过 `SelectableControl` 的实例来访问私有成员 `state` 的。实际上，`SelectableControl` 接口和拥有 `select` 方法的 `Control` 类是一样的。`Button` 和 `TextBox` 类是 `SelectableControl` 的子类(因为它们都继承自 `Control` 并有 `select` 方法，但 `Image` 和 `Location` 类并不是这样的。)\n\n### 3.11 接口继承接口\n\n> 目的: `=>` 灵活地将接口分割到可重用的模块中\n\n```typescript\ninterface Lamp {\n  lampOn(): void;\n  lampOff(): void;\n}\ninterface wx {\n  wxNumber: number;\n  showWxNumber(): string;\n}\n\ninterface Photo extends Lamp, wx {\n  photo(): string;\n}\n\nclass HuaWeiPhone implements Photo {\n  public wxNumber: number;\n  photo(): string {\n    return \"华为手机\";\n  }\n  lampOn() {}\n  lampOff() {}\n  constructor(wxNumber: number) {\n    this.wxNumber = wxNumber;\n  }\n  showWxNumber() {\n    return \"我的微信号是：123\";\n  }\n}\n\nlet huaWeiPhone = new HuaWeiPhone(13100970071);\nconsole.log(huaWeiPhone.showWxNumber());\nconsole.log(huaWeiPhone.photo());\n```\n\n### 3.12 类接口实现\n\n> 手机类是一个大类\n> 华为是手机类下的一个类\n> 华为手机有拍照和闪光灯功能，照相机也有拍照和闪光灯功能\n> 因此华为手机和照相机的公共特性就是拍照和闪光灯\n> 所以通过关键字 `implements` 来标识提取出来的接口\n\n```typescript\n// 拍照\ninterface Photo {\n  photo(): string;\n}\n// 闪光灯\ninterface Lamp {\n  lampOn(): void;\n  lampOff(): void;\n}\n\nclass Phone {}\n\nclass HuaWei extends Phone implements Photo, Lamp {\n  photo(): string {\n    return \"华为拍照\";\n  }\n  lampOn() {}\n  lampOff() {}\n}\n\nclass DigitalCamera implements Photo, Lamp {\n  photo(): string {\n    return \"照相机拍照\";\n  }\n  lampOn() {}\n  lampOff() {}\n}\n```\n\n## 四、类\n\n### 4.1 创建一个基本类\n\n```typescript\nclass Gretter {\n  public gretting: string;\n  constructor(message: string) {\n    this.gretting = message;\n  }\n  public greet() {\n    return `Hello, ${this.gretting}`;\n  }\n}\n\nlet gretter: Gretter = new Gretter(\"world!\");\nconsole.log(gretter);\n```\n\n### 4.2 继承\n\n```typescript\nclass Animal {\n  name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n  move(distanceInMeters: number = 0) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  move(distanceInMeters = 5) {\n    console.log(\"Slithering...\");\n    super.move(distanceInMeters);\n  }\n}\n\nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  move(distanceInMeters = 45) {\n    console.log(\"Galloping\");\n    super.move(distanceInMeters);\n  }\n}\n\nlet sam = new Snake(\"Sammy the Python\");\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\n\nsam.move();\ntom.move(34);\n```\n\n### 4.3 public 关键字\n\n> 默认为 `public`\n> 在 `TypeScript` 中,成员都默认为 `public`\n\n```typescript\nclass Animal_public {\n  public name: string;\n  public constructor(theName: string) {\n    this.name = theName;\n  }\n  public move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n```\n\n### 4.4 private 关键字\n\n> 理解 `private`\n>\n> 1. 当成员被标记成 `private` 时，它就不能在声明它的类的外部访问\n> 2. 如果其中一个类型里包含一个 `private` 成员，那么只有当另外一个类型中也存在这样一个 `private` 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。\n\n```typescript\nclass Animal_private {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\nconst cat = new Animal_private(\"Cat\");\n// cat.name; // 错误：'name'是私有的\n\nclass Animal_private_1 {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\nclass Rhino extends Animal_private_1 {\n  constructor() {\n    super(\"Rhino\");\n  }\n}\nclass Employee {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\nlet animal = new Animal_private_1(\"Goat\");\nlet rhino = new Rhino();\nlet employee = new Employee(\"Bob\");\n\nanimal = rhino;\n// animal = employee; //错误：Animal与Employee不兼容\n```\n\n### 4.5 protected 关键字\n\n- 理解 `protected`\n\n> `protected` 修饰符与 `private` 修饰符的行为很相似，但是有一点不同，`protected` 成员在派生类中仍然可以访问。\n\n```typescript\nclass Person {\n  protected name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nclass _Employee extends Person {\n  private department: string;\n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}`;\n  }\n}\nlet howard = new _Employee(\"Howard\", \"Sales\");\nconsole.log(howard.getElevatorPitch());\n// console.log(howard.name); // 错误，因为 name 无法在外部访问，但是可以在派生类中访问\n```\n\n- 构造函数也可以被标记成 `protected`\n\n> 这意味着这个类不能在包含它的类外被实例化。但是能被继承。\n\n```typescript\nclass __Person {\n  protected name: string;\n  protected constructor(theName: string) {\n    this.name = theName;\n  }\n}\n// __Employee 能够继承 Person\nclass __Employee extends __Person {\n  private department: string;\n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n  }\n}\nlet __howard = new __Employee(\"Howard\", \"Sales\");\n// let __join = new __Person(\"John\");// 错误：'Person'的构造函数是被保护的\n```\n\n### 4.6 readonly 修饰符\n\n- 你可以使用 `readonly` 关键字将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化\n\n```typescript\nclass Octopus {\n  readonly name: string;\n  readonly numberOfLegs: number = 8;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\nlet dad = new Octopus(\"Man with the 8 strong legs\");\n// dad.name = \"Man with the 3-piece suit\";// 错误，name是只读的\n```\n\n- 参数属性\n\n> 1. 参数属性可以方便地让我们在一个地方定义并初始化一个成员。\n> 2. 参数属性通过给构造函数参数前面添加一个访问限定符来声明。\n> 3. 使用 `private` 限定一个参数属性会声明并初始化一个私有成员；对于 `public` 和 `protected` 来说也是一样。\n\n```typescript\nclass _Octopus {\n  readonly numberOfLegs: number = 9;\n  constructor(readonly name: string) {}\n}\n```\n\n### 4.7 存取器 get & set\n\n> 存取器 支持 `es5+`，不支持 `es3`\n\n1. `TypeScript` 支持通过 `getters/setters` 来截取对对象成员的访问。它能帮助你有效的控制对对象成员的访问。\n2. 没有存取器的例子\n\n```typescript\nclass _Employee {\n  fullName: string;\n}\nlet _employee = new _Employee();\n_employee.fullName = \"Bob Smith\";\nif (_employee.fullName) {\n  console.log(_employee.fullName);\n}\n```\n\n3. 拥有存取器的例子\n\n> 1. 我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。\n> 2. 只带有 `get` 不带有 `set` 的存取器自动被推断为 `readonly`。\n> 3. 这在从代码生成 `.d.ts` 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n```typescript\nlet passcode = \"secret passcode\";\nclass Employee {\n  private _fullName: string;\n\n  get fullName(): string {\n    return this._fullName;\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode === \"secret passcode\") {\n      this._fullName = newName;\n    } else {\n      console.log(\"Error: Unauthorized update of employee!\");\n    }\n  }\n}\nlet employee = new Employee();\nemployee.fullName = \"Bob smith\";\nif (employee.fullName) {\n  console.log(employee.fullName);\n}\n```\n\n### 4.8 静态属性\n\n> 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。\n\n```typescript\nclass Gird {\n  public static origin = { x: 0, y: 0 };\n  public calculateDistanceFromOrigin(point: { x: number; y: number }) {\n    let xDist = point.x - Gird.origin.x;\n    let yDist = point.y - Gird.origin.y;\n    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n  }\n  public constructor(public scale: number) {}\n}\nconsole.log(Gird.origin.x);\nlet grid1 = new Gird(1.0);\nlet gird2 = new Gird(5.0);\nconsole.log(grid1.calculateDistanceFromOrigin({ x: 10, y: 10 }));\nconsole.log(gird2.calculateDistanceFromOrigin({ x: 10, y: 10 }));\n```\n\n### 4.9 抽象类\n\n1. 抽象类作为其他派生类的基类使用，它们一般不会直接被实例化。\n2. 不同于接口，抽象类可以包含成员的实现细节\n3. `abstract` 关键字是用于定义抽象类和在抽象类内部定义抽象方法\n\n```typescript\nabstract class Animal {\n  abstract makeSound(): void;\n  move(): void {\n    console.log(\"roaming the earth ...\");\n  }\n}\n```\n\n4. 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。\n5. 抽象方法的语法于接口方法相似，二者都是定义方法签名但不包含方法体。然而抽象方法必须包含 `abstract` 关键字并且可以包含访问修饰符\n\n```typescript\nabstract class Department {\n  constructor(public name: string) {}\n  printName(): void {\n    console.log(`Department name: ${this.name}`);\n  }\n  abstract printMeeting(): void; // 必须在派生类中实现\n}\nclass AccountingDepartment extends Department {\n  constructor() {\n    super(\"Accounting and Auditing\");\n  }\n  printMeeting(): void {\n    console.log(\"The Accounting Department meets each Monday at 10am.\");\n  }\n  generateReports(): void {\n    console.log(\"Generating accounting reports...\");\n  }\n}\nlet department: Department; // 允许创建一个对抽象类的引用\n// department = new Departmemnt(); // 错误，不能创建一个抽象类的实例\ndepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName();\ndepartment.printMeeting();\n// department.generateReports(); // 错误，方法在声明的抽象类中不存在\n```\n\n### 4.10 高级技巧(构造函数)\n\n> 当在 `TypeScript` 里声明了一个类的时候，实际上声明了很多东西。首先就是类的实例类型\n\n```typescript\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    return \"Hello,\" + this.greeting;\n  }\n}\nlet greeter: Greeter; // =>意思：Greeter类的实例的类型是Greeter\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet());\n```\n\n> 可以认为类具有 _实例部分_ 与 _静态部分_\n\n```typescript\nclass _Greeter {\n  static standardGreeting = \"Hello, there\";\n  greeting: string;\n  greet() {\n    if (this.greeting) {\n      return \"Hello,\" + this.greeting;\n    } else {\n      return _Greeter.standardGreeting;\n    }\n  }\n}\nlet _greeter: _Greeter;\n_greeter = new _Greeter();\nconsole.log(_greeter.greet());\n```\n\n> 此处创建了一个 `greeterMaker` 的变量，这个变量保存了这个 _类_ 或者说保存了 _类构造函数_。然后使用 `typeof _Greeter`，意思是取 `Greeter` 类的类型，而不是实例的类型。或者更确切的说，\"告诉我 `Greeter` 标识符的类型\"，也就是构造函数的类型。这个类型包含了类的所有静态成员和构造函数。\n\n```typescript\nlet _greeterMaker: typeof _Greeter = _Greeter;\n_greeterMaker.standardGreeting = \"Hey there!\";\nlet _greeter2: _Greeter = new _greeterMaker();\nconsole.log(_greeter2.greet());\n```\n\n### 4.11 高级技巧(把类当作接口使用)\n\n> 类定义会创建两个东西：_类的实例类型_ 和 _一个构造函数_。\n> 因为类可以创建出类型，所以能够在允许使用接口的地方使用类\n\n```typescript\nclass Point {\n  x: number;\n  y: number;\n}\n\ninterface Point3d extends Point {\n  z: number;\n}\n\nlet point3d: Point3d = { x: 1, y: 2, z: 4 };\n```\n\n## 五、函数\n\n### 5.1 介绍\n\n> 函数是 `JavaScript` 应用程序的基础。它帮助你实现抽象层，模拟层，信息隐藏和模块。在 `TypeScript` 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。`TypeScript` 为 `JavaScript` 函数添加了额外的功能，让我们可以更容易的使用。\n\n### 5.2 函数类型\n\n#### 5.2.1 为函数定义类型\n\n> 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。\n\n> `TypeScript` 能够根据返回语句自动推断出返回值类型，因此我们通常省略它。\n\n```typescript\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n\nlet myAdd = function (x: number, y: number): number {\n  return x + y;\n};\n```\n\n#### 5.2.2 书写完整的函数类型\n\n```typescript\nlet myAdd1: (x: number, y: number) => number = function (x: number, y: number): number {\n  return x + y;\n};\n```\n\n> 函数类型分为两个部分：_参数类型_ 和 _返回值类型_。当写出完整函数类型的时候，这两部分都是需要的。我们以参数列表的形式写出参数类型，为每一个参数指定一个名字和类型。这个名字只是为了增加可读性。\n\n> 1. 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n> 2. 第二部分是返回值类型。对于返回值，我们在函数和返回值类型之间使用 `=>` 符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 `void`,而不能留空。\n\n> 函数的类型只是由参数类型和返回值组成的。函数中使用的捕获变量不会体现在类型里。实际上，这些变量是函数的隐藏状态并不是组成 `API` 的一部分。\n\n- 我们也可以这么写：\n\n```typescript\nlet myAdd2: (baseValue: number, increment: number) => number = function (x: number, y: number): number {\n  return x + y;\n};\n```\n\n#### 5.2.3 推断类型\n\n> 在尝试下面这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型。这叫做：\"按上下文归类\"，是类型推论的一种。它帮助我们更好地为程序指定类型。\n\n```typescript\n// myAdd has the full function type\nlet myAdd3 = function(x: number, y: number): number { return x + y };\n// The parameters `x` and `y` have the type number\nlet myAdd4: (baseValue: number, increment: number) =number = function (x, y) {\n  return x + y;\n};\n```\n\n### 5.3 可选参数和默认参数\n\n> `TypeScript` 里的每个函数参数都是必须的。这不是指不能传递 `null` 或 `undefined` 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。\n\n1. 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\n```typescript\nfunction buildName(firstName: string, lastName: string) {\n  return firstName + \" \" + lastName;\n}\n// let result1 =  buildName(\"Bob\"); // error\n// let result2 = buildName(\"Bob\", \"Jack\", \"Sr.\"); // error\nlet result3 = buildName(\"Bob\", \"Jack\");\n```\n\n2. `JavaScript`里，每个参数都是可选的，可传可不传。没传参的时候，它的值就是 `undefined`。在 `TypeScript` 里我们可以在参数旁边使用 `?` 实现可选参数的功能。\n3. 注意：可选参数必须跟在必选参数后面，不能放在前面\n\n```typescript\nfunction buildName1(firstName: string, lastName?: string) {\n  if (lastName) {\n    return firstName + \" \" + lastName;\n  } else {\n    return firstName;\n  }\n}\nlet result_1 = buildName1(\"Bob\");\nlet result_2 = buildName1(\"Bob\", \"Jack\");\n// let result_3 = buildName1(\"Bob\", \"Jack\", \"Sr.\"); // error\n```\n\n4. 可以设置默认初始化的参数\n5. 在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。也就是说，可选参数与末尾的默认参数共享参数类型。\n\n```typescript\nfunction buildName2(firstName: string, lastName = \"Smith\") {\n  return firstName + \" \" + lastName;\n}\n```\n\n6. 与普通可选参数参数不同的是，带默认值的参数不需要放在必须参数的后面。如果带默认值的参数出现在必须参数的前面，用户必须明确的传入 `undefined` 值来获得默认值。\n\n```typescript\nfunction buildName3(firstName = \"Will\", lastName: string) {\n  return firstName + \" \" + lastName;\n}\n// let result__1 = buildName3(\"Bob\"); // error\n// let result__2 = buildName3(\"Bob\", \"Jack\", \"Sr.\"); // error\nlet result__3 = buildName3(\"Bob\", \"Jack\");\nlet result__4 = buildName3(undefined, \"Jack\");\n```\n\n### 5.4 剩余参数\n\n> 必要参数，默认参数 和 可选参数 有个共同点：它们表示某一个参数。有时，你想同时操作多个参数，或者你并不知道会有多少参数传进来。在 `JavaScript` 里，你可以使用 `arguments` 来访问所有传入的参数。在 `TypeScript` 里，你可以把所有参数收集到一个变量里\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + \" \" + restOfName.join(\" \");\n}\n\nlet employeeName = buildName(\"Jose\", \"Smith\", \"Bob\", \"Alice\");\n```\n\n> 剩余参数会被当作个数不限的可选参数。可以一个都没有，也可以有任意个。编译器创建参数数组，名字是你在省略号后面给定的名字，你可以在函数体内使用这个数组。\n\n```typescript\nfunction buildName1(firstName: string, ...restOfName: string[]) {\n  return firstName + \" \" + restOfName.join(\" \");\n}\n\nlet buildNameFun: (fName: string, ...rest: string[]) => string = buildName1;\n```\n\n> `this` 参数。在使用了 `--noImplicitThis` 标记之后，`this` 类型可能会是 `any`。此时需要提供一个显示的 `this` 参数。\n\n```typescript\ninterface Card {\n  suit: string;\n  card: number;\n}\n\ninterface Deck {\n  suits: string[];\n  cards: number[];\n\n  createCardPicker(this: Deck): () => Card;\n}\n\nlet deck: Deck = {\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n  cards: Array(52),\n  createCardPicker(): (this: Deck) => Card {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n\n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  }\n};\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\nconsole.log(`card: ${pickedCard.card} of ${pickedCard.suit}`);\n```\n\n## 六、泛型\n\n### 6.1 介绍\n\n> 在软件工程中，我们不仅要创建一致的定义良好的 `API`，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n> 在像 `C#` 和 `Java` 这样的语言中，可以使用 `泛型` 来创建可重用组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。\n> 除了泛型接口，我们还可以创建泛型类。注意，无法创建泛型枚举和泛型命名空间。\n\n### 6.2 泛型之 hello world\n\n> 创建一个 `identity` 函数，这个函数会返回任何传入它的值。\n\n- 如果不使用泛型，函数可能是：\n\n```typescript\nfunction identity(arg: number): number {\n  return arg;\n}\n```\n\n- 也可以使用 `any` 类型定义函数，但是这样可能会导致传入的类型与返回的类型不相同。\n\n```typescript\nfunction identity1(arg: any): any {\n  return arg;\n}\n```\n\n> 因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。\n\n- 这里我们使用了类型变量，它是一种特殊的变量，只能用于表示类型而不是值。\n\n```typescript\nfunction identity2<T>(arg: T): T {\n  return arg;\n}\n```\n\n- 使用方式一：传入所有的参数，包括类型参数\n\n```typescript\nlet output = identity2<string>(\"myString\");\n```\n\n- 使用方式二(更普遍)：利用了类型推论-即编译器会根据传入的参数自动地帮助我们确定 `T` 的类型。\n\n```typescript\nlet output2 = identity2(\"myString\");\n```\n\n### 6.3 使用泛型变量\n\n> 使用泛型创建像 `identity` 这样的函数时，编译器要求你在函数体必须正确的使用这个通用的类型。换句话说，你必须把这些参数当作是任意或所有类型。\n\n- 如果我们想打印出 `arg` 的长度，也许会这样做。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length); // 错误，T 类型也许不会有.length属性\n  return arg;\n}\n```\n\n- 如果我们像操作 `T` 类型的数组\n\n```typescript\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length);\n  return arg;\n}\nfunction loggingIdentity2<T>(arg: Array<T>): Array<T> {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n### 6.4 泛型类型(泛型接口)\n\n1. 泛型函数的类型和非泛型函数的类型一样，首先列出类型参数，类似于函数声明。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity: <T>(arg: T) => T = identity;\n```\n\n2. 我们也可以为类型中的泛型类型参数使用不同的名称，只要在数量上和使用方式上能对应上就可以。\n\n```typescript\nfunction identity1<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity1: <U>(arg: U) => U = identity;\n```\n\n3. 我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```typescript\nfunction identity2<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity2: { <T>(arg: T): T } = identity;\n```\n\n4. 这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```typescript\ninterface GenericIdentityFn {\n  <T>(arg: T): T;\n}\n\nfunction identity3<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity3: GenericIdentityFn = identity3;\n```\n\n5. 我们可能想把泛型参数当作整个接口的一个参数。这样我们就能清楚的知道使用的具体是哪个泛型类型(比如：`Dictionary<string>` 而不只是 `Dictionary`)。这样接口里的其它成员也能知道这个参数的类型了。\n\n```typescript\ninterface _GenericIdentityFn<T> {\n  (arg: T): T;\n}\n\nfunction _identity<T>(arg: T): T {\n  return arg;\n}\n\nlet _myIdentity: _GenericIdentityFn<number> = _identity;\n```\n\n> 注意，我们的示例做了少许改动。不再描述泛型函数，而是把非泛型函数签名作为泛型类型的一部分。\n\n> 当我们使用 `GenericIdentityFn` 的时候，还得传入一个类型参数来指定泛型类型(这里是：`number`)，从而锁定之后代码里使用的类型。\n\n> 对于描述哪部分类型属于泛型部分来说，理解何时把参数 \"放在调用签名里\" 和何时 \"放在接口上\" 是很有帮助的。\n\n### 6.5 泛型类\n\n> 泛型类和泛型接口差不多。泛型类使用 `<>` 括起泛型类型，跟在类名后面。类分为两部分：静态部分 和 实例部分。泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n> `enericNumber` 类的使用是非常直观的，并没有什么去限制它只能使用 `number` 类型。\n\n- 也可以使用字符串或其它更复杂的类型。\n\n```typescript\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = (x, y) => x + y;\n```\n\n> 与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n```typescript\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \" \";\nstringNumeric.add = (x, y) => x + y;\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\n```\n\n### 6.6 泛型约束\n\n> 我们应该记得之前的一个例子，我们有时候想要操作某类型的一组值，并且我们知道这组值具有什么样的属性。\n\n> 在 `loggingIdentity` 例子中，我们想访问 `arg` 的 `length` 属性，但是编译器并不能证明每种类型都有 length 属性。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n> 相比与操作 `any` 所有类型，我们想要限制函数去处理任意带有 `.length` 属性的所有类型。只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 `T` 的约束要求。\n\n> 为此，我们需要定义一个接口来描述约束条件。创建一个包含 `.length` 属性的接口，使用这个接口和 `extends` 关键字来实现约束。\n\n```typescript\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n- 此时这个泛型函数被定义了约束。因此它不再适用于任意类型：\n\n```typescript\nloggingIdentity(3); // error\n```\n\n- 我们需要传入符合约束类型的值，必须包含的属性。\n\n```typescript\nloggingIdentity({ length: 10, value: 3 });\n```\n\n### 6.7 在泛型约束中使用类型参数\n\n> 你可以声明一个类型参数，且它被另一个类型参数所约束。例如，现在我们需想要用属性名从对象里获取这个属性。并且我们想要确保这个属性存在于对象 `obj` 上，因此我们需要在这两个类型之间使用约束。\n\n```typescript\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key];\n}\nlet x = { a: 1, b: 2, c: 3, d: 4 };\ngetProperty(x, \"a\");\ngetProperty(x, \"m\"); // error\n```\n\n### 6.8 在泛型里使用类类型\n\n> 在 `TypeScript` 使用泛型创建工厂函数时，需要引用构造函数的类类型。\n\n```typescript\nfunction create<T>(c: { new (): T }): T {\n  return new c();\n}\n```\n\n> 下面是一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。\n\n```typescript\nclass BeeKeeper {\n  hasMask: boolean;\n}\n\nclass ZooKeeper {\n  nameTag: string;\n}\n\nclass Animal {\n  numLegs: number;\n}\n\nclass Bee extends Animal {\n  keeper: BeeKeeper;\n}\n\nclass Lion extends Animal {\n  keeper: ZooKeeper;\n}\n\nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n\ncreateInstance(Lion).keeper.nameTag;\ncreateInstance(Bee).keeper.hasMask;\n```\n\n### 6.9 多个类型变量\n\n```typescript\nfunction info<S, N>(name: S, age: N): [S, N] {\n  return [name, age];\n}\n\nconsole.log(info(\"pr\", 10));\nconsole.log(info<string, number>(\"pr\", 18));\n```\n\n## 七、枚举\n\n### 7.1 介绍\n\n> 使用枚举我们可以定义一些带有名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。`TypeScript` 支持数字的和基于字符串的枚举。\n\n### 7.2 数字枚举\n\n```typescript\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}\n```\n\n> 如上，我们定义了一个数字枚举，`Up`使用初始化为 `1`，其余成员会从 `1` 开始自动增长。 换句话说，`Direction.Up` 的值为 `1`，`Down` 值为 `2`，`Left` 值为 `3`，`Right` 值为 `4`。\n\n1. 我们还可以完全不使用初始化器\n\n```typescript\nenum Direction2 {\n  Up,\n  Down,\n  Left,\n  Right\n}\n```\n\n> 现在，`Up` 的值为 `0`，`Down` 的值为 `1` 等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。\n\n2. 使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：\n\n```typescript\nenum _Response {\n  No = 0,\n  Yes = 1\n}\n\nfunction respond(recipient: string, message: _Response): void {}\n\nrespond(\"Princess Caroline\", _Response.Yes);\n```\n\n3. 数字枚举可以被混入到计算过的和常量成员（如下所示）。\n\n> 简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。换句话说，下面的情况是不被允许的：\n\n```typescript\nenum E {\n  A = getSomeValue(),\n  B // error! 'A' is not constant-initialized, so 'B' needs an initializer\n}\n```\n\n### 7.3 字符串枚举\n\n> 字符串枚举的概念很简单，但是有细微的运行时的差别。在一个字符串枚举里，每个成员都必须使用字符串字面量，或另外一个字符串枚举成员进行初始化。\n\n```typescript\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\"\n}\n```\n\n> 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。\n\n### 7.4 异构枚举\n\n> 从技术的角度来说，枚举可以混合字符串和数字成员，但是你似乎并不会这么做：\n\n```typescript\nenum BooleanLikeHeterogeneousEnum {\n  No = 0,\n  Yes = \"YES\"\n}\n```\n\n> 除非你真的想要利用 `JavaScript` 运行时的行为，否则我们不建议这样做。\n\n### 7.5 计算的和常量成员\n\n> 每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当作是常量\n\n1. 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 `0`：\n\n```typescript\nenum E {\n  X\n}\n```\n\n2. 它不带有初始化器且它之前的枚举成员是一个数字常量。这种情况下，当前枚举成员的值为它上一个枚举成员的值加 `1`。\n\n```typescript\nenum E1 {\n  X,\n  Y,\n  Z\n}\nenum E2 {\n  A = 1,\n  B,\n  C\n}\n```\n\n3. 枚举成员使用 常量枚举表达式进行初始化。常量枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。\n\n> 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：\n>\n> 1. 一个枚举表达式字面量（主要是字符串字面量或数字字面量）\n> 2. 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）\n> 3. 带括号的常量枚举表达式\n> 4. 一元运算符 +，-，～ 其中之一应用在了常量枚举表达式\n> 5. 常量枚举表达式作为二元运算符 `+，-，*，/，%，<<，>>，>>>，&，|，^` 的操作对象\n\n> 若常量枚举表达式求值后为 `NaN` 或 `Infinity`，则会在编译阶段报错。\n\n> 所有其它情况的枚举成员被当作是需要计算得出的值\n\n```typescript\nenum FileAccess {\n  // constant numbers\n  None,\n  Read = 1 << 1,\n  White = 1 << 2,\n  ReadWhite = Read | White,\n  // computed number\n  G = \"123\".length\n}\n```\n\n### 7.6 联合枚举与枚举成员的类型\n\n> 存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员，或者是被初始化为：\n>\n> 1. 任何字符串字面量(例如：`\"foo\", \"bar\", \"baz\"`)\n> 2. 任何数字字面量(例如：`1, 100`)\n> 3. 应用了一元 - 符号的数字字面量(例如：`-1, -100`) 当所有枚举成员都拥有字面量枚举值时，它就有了一种特殊的含义。\n\n> 首先，枚举成员成为了类型！例如，我们可以说某些成员只能是枚举成员的值：\n\n```typescript\nenum ShapeKind {\n  Circle,\n  Square\n}\n\ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\n\ninterface Square {\n  kind: ShapeKind.Square;\n  sideLength: number;\n}\n\nlet c: Circle = {\n  kind: ShapeKind.Square, // error\n  radius: 100\n};\n```\n\n> 另一个变化是枚举类型本身变成了每个枚举成员的联合。虽然我们还没有讨论 联合类型 。但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。因此，`TypeScript` 能够捕获在比较值的时候犯的愚蠢的错误。例如：\n\n```typescript\nenum E {\n  Foo,\n  Bar\n}\nfunction f(x: E) {\n  if (x !== E.Foo || x !== E.Bar) {\n    // // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.\n  }\n}\n```\n\n> 这个例子里，我们先检查 `x` 是否不是 `E.Foo`。 如果通过了这个检查，然后 `||` 会发生短路效果，\n> `if` 语句体里的内容会被执行。 然而，这个检查没有通过，那么 x 则只能为 `E.Foo`，因此没理由再去检查它是否为 `E.Bar`。\n\n### 7.7 运行时的枚举\n\n- 枚举是在运行时真正存在的对象。\n\n```typescript\nenum E {\n  X,\n  Y,\n  Z\n}\n```\n\n- 可以传递给函数么？\n\n```typescript\nfunction f(obj: { X: number }) {\n  return obj.X;\n}\n```\n\n- 没问题，因为 `\"E\"` 包含一个数值型属性 `\"X\"`\n\n```typescript\nf(E);\n```\n\n### 7.8 编译时的枚举\n\n> 尽管一个枚举是在运行时真正存在的对象，但 `keyof` 关键字的行为与其作用在对象上时有所不同。应该使用 `keyof` `typeof` 来获取一个表示枚举里所有字符串 `key` 的类型。\n\n```typescript\nenum LogLevel {\n  ERROR,\n  WARN,\n  INFO,\n  DEBUG\n}\n```\n\n- 等同于：\n\n```typescript\ntype LogLevelStrings = \"ERROR\" | \"WARN\" | \"INFO\" | \"DEBUG\";\ntype LogLevelStrings = keyof typeof LogLevel;\n```\n\n```typescript\nfunction printImportant(key: LogLevelStrings, message: string) {\n  const num = LogLevel[key];\n  if (num <= LogLevel.WARN) {\n    console.log(\"Log Level key is: \", key);\n    console.log(\"Log Level value is: \", num);\n    console.log(\"Log Level message is \", message);\n  }\n}\nprintImportant(\"ERROR\", \"This is a message\");\n```\n\n### 7.9 反向映射\n\n> 除了创建一个以属性名作为对象成员的对象外，数字枚举成员还具有了反向映射，从枚举值到枚举名字。\n\n- 例如在下面的例子中：\n\n```typescript\nenum _Enum {\n  A\n}\nlet _a = _Enum.A;\nlet _nameOfA = _Enum[_a]; // \"A\"\n```\n\n- `TypeScript` 可能会将这段代码编译为下面的 `JavaScript`：\n\n```typescript\nvar Enum;\n(function (Enum) {\n  Enum[(Enum[\"A\"] = 0)] = \"A\";\n})(Enum || (Enum = {}));\nvar a = Enum.A;\nvar nameOfA = Enum[a]; // \"A\"\n```\n\n> 生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（`name -> value`）和反向映射（`value -> name`）。\n\n> 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。\n\n> 要注意的是不会为字符串枚举成员生成反向映射。\n\n### 7.10 const 枚举\n\n> 大多数情况下，枚举是十分有效的方案。然而在某些情况下需求很严格。为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 `const` 枚举。\n\n> 常量枚举通过在枚举上使用 `const` 修饰符来定义。\n\n```typescript\nconst enum Enum {\n  A = 1,\n  B = A * 2\n}\n```\n\n> 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\n\n```typescript\nconst enum Directions {\n  Up,\n  Down,\n  Left,\n  Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n// 生成后的代码为：\nvar directions1 = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n```\n\n### 7.11 外部枚举\n\n> 外部枚举 用来描述已经存在的枚举类型的形状。\n\n```typescript\ndeclare enum Enum {\n  A = 1,\n  B,\n  C = 2\n}\n```\n\n> 外部枚举 和 非外部枚举 之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。\n\n> 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。\n\n## 八、类型别名\n\n### 8.1 类型别名\n\n1. 创建别名需要使用关键字 `type`\n2. 使用别名通常用在有 联合类型 的场景下\n\n> 注意：不要混淆了 `TypeScript` 中的 `=>`; 和 `ES6` 中的 `=>` 在 `TypeScript` 的类型定义中，`=>` 用来表示函数的定义。(左边是输入类型，需要用括号扩起来，右边是输出类型)；在 `ES6` 中，`=>` 叫做箭头函数。\n\n```typescript\ntype Name = string;\ntype ShowName = () => string;\ntype NameOrShowName = Name | ShowName;\n\nconst getName = (name: NameOrShowName) => {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  return name();\n};\n\nlet showName = () => \"pr is a boy\";\nconsole.log(getName(\"pr\"));\nconsole.log(getName(showName()));\n```\n\n### 8.2 字符串字面量类型\n\n```typescript\ntype EventNames = \"click\" | \"scroll\" | \"mousemove\";\nconst handleEvent: (a: Element, b: EventNames) => string = (ele: Element, event: EventNames) => {\n  return `${ele} ${event}`;\n};\nhandleEvent(document.getElementById(\"header\"), \"scroll\");\nhandleEvent(document.getElementById(\"footer\"), \"click\");\n```\n\n## 九、类型推论\n\n### 9.1 基础\n\n> 在 `TypeScript` 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子：\n\n```typescript\nlet x = 3;\n```\n\n> 变量 `x` 的类型被推断为数字。这种推断发生在初始化变量和成员，设置默认参数和决定函数返回值时。\n\n> 大多数情况下，类型推论是直接了当地。\n\n### 9.2 最佳通用类型\n\n> 当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断出一个最合适的通用类型。\n\n```typescript\nlet x = [0, 1, null];\n```\n\n> 为了推断 `x` 的类型，我们必须考虑所有元素的类型。这里有两种选择: `number` 和 `null`。计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n> 由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。\n\n```typescript\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n```\n\n> 这里，我们想让 `zoo` 被推断为 `Animal[]` 类型，但是这个数组里没有对象是 `Animal` 类型的，因此不能推断出这个结果。\n\n> 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：\n\n```typescript\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n```\n\n> 如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Rhino | Elephant | Snake)[]`。\n\n### 9.3 上下文归类\n\n1. `TypeScript` 类型推论也可能按照相反的方向进行，这被叫做\"上下文归类\"。按上下文归类会发生在表达式类型与所处的位置相关时。\n\n> 在下面这个例子里，`TypeScript` 类型检查器会使用 `Window.onmousedown` 函数的类型来推断右边函数表达式的类型。所以它能够推断出 `mouseEvent` 参数的类型中包含了 `button` 属性而不包含 `kangaroo` 属性。\n\n```typescript\nwindow.onmousedown = function (mouseEvent) {\n  console.log(mouseEvent.button); // <- Ok\n  console.log(mouseEvent.kangaroo); // <- error\n};\n```\n\n2. `TypeScript` 还能够很好地推断出其它上下文中的类型。\n\n```typescript\nwindow.onscroll = function (uiEvent) {\n  console.log(uiEvent.button); // Error\n};\n```\n\n> 上面的函数被赋给 ` window.onscroll``，TypeScript ` 能够知道 `uiEvent` 是 `UIEvent`，而不是 `MouseEvent。UIEvent` 对象不包含 `button` 属性，因此 `TypeScript` 会报错。\n\n1. 如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为 `any` 类型，而且也不会报错(除非你开启了 `--noImplicitAny` 选项)\n\n```typescript\nconst handler = function (uiEvent) {\n  console.log(uiEvent.button); // <- Ok\n};\n```\n\n- 我们也可以明确地为函数参数类型赋值来覆写上下文类型：\n\n```typescript\nwindow.onscroll = function (uiEvent: any) {\n  console.log(uiEvent.button); // <- Now, no error is given\n};\n```\n\n> 但这段代码会打印 `undefined`，因为 `uiEvent` 并不包含 `button` 属性。\n\n> 上下文归类会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。\n\n- 上下文类型也会做为最佳通用类型的候选类型。比如：\n\n```typescript\nfunction createZoo(): Animal[] {\n  return [new Rhino(), new Elephant(), new Snake()];\n}\n```\n\n> 上面这个例子里，最佳通用类型有 `4` 个候选者：`Animal, Rhino, Elephant, Snake`。当然，`Animal` 会被作为最佳通用类型。\n\n## 十、类型兼容性\n\n### 10.1 介绍\n\n> `TypeScript` 里的兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。它正好与名义( `nominal` )类型形成对比。(译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。)看下面的例子：\n\n```typescript\ninterface Named {\n  name: string;\n}\n\nclass Person {\n  name: string;\n}\n\nlet p: Named;\n// Ok, because of structural typing\np = new Person();\n```\n\n> 在使用基于名义类型的断言，比如 `C#` 或 `Java` 中，这段代码会报错， 因为 `Person` 类没有明确说明其实现了 `Named` 接口。\n> `TypeScript` 的结构性子类型是根据 `JavaScript` 代码的典型写法来设计的。 因为 `JavaScript` 里广泛地使用匿名对象，例如函数表达式和对象字面量， 所以使用结构类型系统来描述这些类型比使用名义类型系统更好。\n\n### 10.2 关于可靠性的注意事项\n\n> `TypeScript` 的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript 允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。\n\n### 10.3 开始\n\n- `TypeScript` 结构化类型系统的基本规则是，如果 `x` 要兼容 `y`，那么 `y` 至少具有与 `x` 相同的属性。比如：\n\n```typescript\ninterface Named {\n  name: string;\n}\n\nlet x: Named;\n// y's inferred type is { name: string; location: string }\nlet y = { name: \"Alice\", location: \"Seattle\" };\nx = y;\n```\n\n> 这里要检查 `y` 是否能赋值给 `x`，编译器检查 `x` 中的每个属性，看是否能在 `y` 中也找到对应属性。\n\n> 在这个例子中，`y` 必须包含名字是 `name` 的 `string` 类型成员。`y` 满足条件，因此赋值正确。\n\n- 检查函数参数时使用相同的规则\n\n```typescript\nfunction greet(n: Named) {\n  console.log(\"Hello, \" + n.name);\n}\n\ngreet(y); // OK\n```\n\n> 注意，`y` 有个额外的 `location` 属性，但这不会引发错误。\n> 只有目标类型（这里是 `Named`）的成员会被一一检查是否兼容。\n> 这个比较过程是递归进行的，检查每个成员及子成员。\n\n### 10.4 比较两个函数\n\n1. 相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。\n\n- 下面我们从两个简单的函数入手，它们仅是参数列表略有不同：\n\n```typescript\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // <- Ok\n// x = y; // <- Error\n```\n\n> 要查看 `x` 是否能赋值给 `y`，首先看它们的参数列表。 `x` 的每个参数必须能在 `y` 里找到对应类型的参数。注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，`x` 的每个参数在 `y` 中都能找到对应的参数，所以允许赋值。第二个赋值错误，因为 `y` 有个必需的第二个参数，但是 `x` 并没有，所以不允许赋值。\n> 你可能会疑惑为什么允许忽略参数，像例子 `y = x` 中那样。 原因是忽略额外的参数在 `JavaScript` 里是很常见的。\n> 例如，`Array.forEach` 给回调函数传 `3` 个参数：数组元素，索引 和 整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：\n\n```typescript\nlet items = [1, 2, 3];\n// Don't force these extra arguments\nitems.forEach((item, index, array) => console.log(item));\n// Should be Ok\nitems.forEach(item => console.log(item));\n```\n\n2. 下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数。\n\n```typescript\nlet x1 = () => ({ name: \"Alice\" });\nlet y1 = () => ({ name: \"Alice\", location: \"Seattle\" });\n\nx1 = y1; // Ok\ny1 = x1; // Error, because x() lacks a location property\n```\n\n3. 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。\n\n### 10.5 函数参数双向协变\n\n> 当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。实际上，这极少会发声错误，并且能够实现很多 `JavaScript` 里的常见模式。\n\n- 例如：\n\n```typescript\nenum EventType {\n  Mouse,\n  Keyboard\n}\n\ninterface Event {\n  timestamp: number;\n}\n\ninterface MouseEvent extends Event {\n  x1: number;\n  y1: number;\n}\n\ninterface keyEvent extends Event {\n  keyCode: number;\n}\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n  /* …… */\n}\n\n// Unsound, but useful and common 不完整，但是常用常见\nlistenEvent(EventType.Mouse, (e: MouseEvent) => console.log(`${e.x1},${e.y1}`));\n\n// Undesirable alternatives in presence of soundness 完整但是不受欢迎\nlistenEvent(EventType.Mouse, (e: Event) => console.log(`${(<MouseEvent>e).x1},${(<MouseEvent>e).y1}`));\n\nlistenEvent(EventType.Mouse, <(e: Event) => void>((e: MouseEvent) => console.log(`${e.x1},${e.y1}`)));\n// Still disallowed (clear error). Type safety enforced for wholly incompatible types\n// 仍然不允许（清除错误）。完全不兼容类型所强制规定的类型安全\n// listenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\n### 10.6 可选参数和剩余参数\n\n1. 比较函数兼容性的时候，可选参数与必须参数是可互换的。源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。\n2. 当一个函数有剩余参数时，它被当做无限个可选参数。\n3. 这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些 undefined 。\n\n> 有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数 但对类型系统来说是不确定的参数来调用：\n\n```typescript\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n  /* ... Invoke callback with 'args' ... 通过args调用callback */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\n// 不健全的是 - 被调用时候可能会提供任意数量的参数\ninvokeLater([1, 2], (x, y) => console.log(x + \",\" + y));\n\n// Confusing (x and y are actually required) and unrecoverable\n// 令我们困惑(是否需要 x 和 y) 并且 不可恢复\ninvokeLater([1, 2], (x?, y?) => console.log(x + \",\" + y));\n```\n\n### 10.7 函数重载\n\n> 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。这确保了目标函数可以在所有源函数可调用的地方调用。\n\n### 10.8 枚举\n\n> 枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。\n\n- 比如：\n\n```typescript\nenum Status {\n  Ready,\n  Waiting\n}\n\nenum Color {\n  Red,\n  Blue,\n  Green\n}\n\nlet _status = Status.Ready;\n// _status = Color.Green; // Error\n```\n\n### 10.9 类\n\n> 类与对象字面量和接口差不多，但是有一点不同：类的静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。静态成员和构造函数不在比较的范围内。\n\n```typescript\nclass Animal {\n  feet: number;\n\n  constructor(name: string, numFeet: number, c: boolean) {}\n}\n\nclass Size {\n  feet: number;\n\n  constructor(numFeet: number) {}\n}\n\nlet a: Animal;\nlet s: Size;\na = s; //Ok\ns = a; //Ok\n\n/*  */\n```\n\n### 10.10 类的私有和受保护成员\n\n> 类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。\n\n### 10.11 泛型\n\n> 因为 `TypeScript` 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。\n\n- 比如\n\n```typescript\ninterface Empty<T> {}\n\nlet x: Empty<number>;\nlet y: Empty<string>;\n\nx = y; // Ok, because y matches structure of x\n```\n\n> 上面代码里，`x` 和 `y` 是兼容的，因为它们的结构使用类型参数时，并没有什么不同。\n\n- 把这个例子改变一下，增加一个成员，就能看出是如何工作的了。\n\n```typescript\ninterface NotEmpty<T> {\n  data: T;\n}\n\nlet x1: NotEmpty<number>;\nlet y1: NotEmpty<string>;\nx1 = y1; // Error，because x and y are not compatible\n```\n\n> 在这里，泛型类型在使用时就好比不是一个泛型类型。\n\n> 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 `any` 比较。然后用结果类型进行比较，就像上面第一个例子。\n\n- 比如：\n\n```typescript\nlet identity = function <T>(x: T): T {\n  // ...\n  return;\n};\nlet reverse = function <U>(y: U): U {\n  // ...\n  return;\n};\nidentity = reverse; // Ok, because (x: any) => any matches (y: any) => any\n```\n\n### 10.12 高级主题\n\n- 子类型和赋值\n\n> 目前为止，我们使用了\"兼容性\"，它在语言规范里没有定义，在 `TypeScript` 里，有两种兼容性：子类型 和 赋值。它们的不同点在于：赋值扩展了子类型兼容性，增加了一些规则，允许和 `any` 来回赋值，以及 enum 和对应数字值之间的来回赋值。\n> 语言里的不同地方分别使用了它们之中的机制。实际上，类型兼容性是由赋值兼容性来控制的，即使在 `implements` 和 `extends` 语句也不例外。\n\n## 十一、高级类型\n\n### 11.1 交叉类型\n\n> 交叉类型 是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。例如，`Person & Serializable & Loggable` 同时是 `Person` 和 `Serializable` 和 `Loggable`。就是说这个类型的对象同时拥有了这三种类型的成员。\n> 我们大多数是在混入( `mixins` )或其它不适合典型面向对象模型的地方看到交叉类型的使用。(在 `JavaScript` 里发生这种情况的场合很多！)\n\n#### 11.1.1 `ReadOnly` 的实现\n\n```typescript\ntype ReadOnly<T> = {\n    readOnly [P in keyof T]: T[P];\n}\n```\n\n#### 11.1.2 `Partial` 的实现\n\n```typescript\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n#### 11.1.3 `Pick` 的实现\n\n```typescript\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n```\n\n#### 11.1.4 `Record` 的实现\n\n```typescript\ntype Record<K extends string, T> = {\n  [P in K]: T;\n};\n```\n\n> 下面是如何创建混入的一个简单的例子(`\"target\": \"es5\"`):\n\n```typescript\nfunction extend<First, Second>(first: First, second: Second): First & Second {\n    const result: Partial<First & Second>= {};\n    for (const prop in first) {\n        if (first.hasOwnProperty(prop)) {\n            (<First>result)[prop] = first[prop];\n        }\n    }\n    for (const prop in second) {\n        if (second.hasOwnProperty(prop)) {\n            (<Second>result)[prop] = second[prop];\n        }\n    }\n    return <First & Second>result;\n}\n>\nclass Person {\n    constructor(public name: string) {\n    }\n}\ninterface Loggable {\n    log(name: string): void;\n}\nclass ConsoleLogger implements Loggable {\n    log(name) {\n        console.log(`Hello, I'm ${name}`)\n    }\n}\nconst jim = extend(new Person(\"Jim\"), ConsoleLogger.prototype);\nlet c = jim.log(jim.name);\nconsole.log(c);\n```\n\n### 11.2 联合类型\n\n> 联合类型 和 交叉类型 很有关联，但是使用上却完全不同。偶尔你会遇到这种情况，一个代码库希望传入 `number` 或 `string` 类型的参数。例如下面的函数：\n\n```typescript\n/**\n * Takes a string and adds \"padding\" to the left.\n * If 'padding' is a string, then 'padding' is appended to the left side.\n * If 'padding' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft(value: string, padding: any) {\n  if (typeof padding === \"number\") {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  if (typeof padding === \"string\") {\n    return padding + value;\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`);\n}\n\npadLeft(\"Hello World\", 4);\n```\n\n> `padLeft` 存在一个问题，`padding` 参数的类型指定成了 `any`。这就是说我们可以传入一个既不是 `number` 也不是 `string` 类型的参数，但是 `TypeScript` 却不会报错。\n>\n> ```typescript\n> let indentedString = padLeft(\"Hello World\", true); // 编译阶段通过，运行时报错。\n> ```\n\n````\n>  在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。这么做显然是非常清晰的，但同时也存在了过度设计。`padLeft` 原始版本的好处之一就是允许我们传入原始类型。这样做的话使用起来既简单又方便。如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。代替 `any`，我们可以使用 联合类型 作为 `padding` 的参数。\n\n\n\n```typescript\n/**\n * Takes a string and adds \"padding\" to the left.\n * If 'padding' is a string, then 'padding' is appended to the left side.\n * If 'padding' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft1(value: string, padding: string | number) {\n    // ...\n}\n\n// let indentedString1 = padLeft1(\"Hello world\", true); // errors during compilation\n````\n\n> 联合类型 表示一个值可以是几种类型之一。我们使用竖线(`|`)分隔每个类型，所以 `number | string | boolean` 表示一个值可能是 `number`, `string`, `boolean`\n\n```typescript\ninterface Bird {\n  fly();\n\n  lagEggs();\n}\n\ninterface Fish {\n  swim();\n\n  layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n  // ...\n}\nlet pet = getSmallPet();\npet.layEggs(); // <- ok\n// pet.swim(); // <- errors\n```\n\n> 这里的联合类型可能有点复杂，但是你很容易就习惯了。如果一个值的类型是 `A | B`，我们能够确定的是它包含了 `A` 和 `B` 中共有的成员。这个例子里，`Bird` 具有一个 `fly` 成员。我们不能确定一个 `Bird | Fish` 类型的变量是否有 `fly` 方法。如果变量在运行时是 `Fish` 类型，那么调用 `pet.fly()` 就出错了。\n\n### 11.3 类型守卫与类型区分\n\n> 联合类型适用于那些值可以为不同类型的情况。但当我们想确切地了解是否为 `Fish` 时怎么办？`JavaScript` 里常用来区分 `2` 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\n```typescript\ninterface Fish {\n  swim();\n  layEggs();\n}\ninterface Bird {\n  fly();\n  layEggs();\n}\nfunction getSmallPet(): Fish | Bird {\n  return;\n}\nlet pet = getSmallPet();\n```\n\n> 每一个访问的成员都会报错\n\n```typescript\nif (pet.swim) {\n  pet.swim();\n} else if (pet.fly) {\n  pet.fly();\n}\n```\n\n> 为了让这段代码工作，我们需要使用类型断言\n\n```typescript\nif ((<Fish>pet).swim) {\n  (<Fish>pet).swim();\n} else if ((<Bird>pet).fly) {\n  (<Bird>pet).fly();\n}\n```\n\n### 11.4 用户自定义的类型守卫\n\n> 这里我们注意到不得不多次使用类型断言。假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 `pet` 的类型的话就好了。\n\n> `TypeScript` 里的类型守卫机制让它成为了现实。类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。要想定义一个类型守卫，我们只需要简单地定义一个函数，它的返回值是一个类型谓词：\n\n```typescript\ninterface Fish {\n  swim();\n\n  layEggs();\n}\n\ninterface Bird {\n  fly();\n\n  layEggs();\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (<Fish>pet).swim !== undefined;\n}\n```\n\n> 在这个例子里，`pet is Fish` 就是类型谓词。谓词为 `parameterName is Type` 这种形式， `parameterName` 必须是来自于当前函数签名里的一个参数名。\n> 每当使用一些变量调用 `isFish` `时，TypeScript` 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的\n> `swim` 和 `fly` 的调用都没有问题了\n\n```typescript\nif (isFish(pet)) {\n  pet.swim();\n} else {\n  pet.fly();\n}\n```\n\n> 注意 `TypeScript` 不仅知道在 `if` 分支里 `pet` 是 `Fish` 类型；它还清楚在 `else` 分之里，一定不是 `Fish` 类型，一定是 Bird 类型。\n\n### 11.5 typeof 类型守卫\n\n> 现在我们回过头来看看怎么使用联合类型书写 `padLeft` 代码。 我们可以像下面这样利用类型断言来写：\n\n```typescript\nfunction isNumber(x: any): x is number {\n  return typeof x === \"number\";\n}\n\nfunction isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n\nfunction padLeft(value: string, padding: string | number) {\n  if (isNumber(padding)) {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  if (isString(padding)) {\n    return padding + value;\n  }\n  throw new Error(`Expected string or number, go ${padding}.`);\n}\n```\n\n> 然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。幸运的是，现在我们不必将 `typeof x === \"number\"` 抽象成一个函数，因为 `TypeScript` 可以将它识别为一个类型守卫。也就是说，我们可以直接在代码里检查类型了。\n\n```typescript\nfunction newPadLeft(value: string, padding: string | number) {\n  if (typeof padding === \"number\") {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  if (typeof padding === \"string\") {\n    return padding + value;\n  }\n  throw new Error(`Expected string or number, go ${padding}.`);\n}\n```\n\n> 这些 `typeof` 类型守卫只有两种形式能被识别：`typeof v === \"typename\"` 和 `typeof v !== \"typename\"`, `\"typename\"` 必须是 `\"number\"`, `\"string\"`, `\"boolean\"` 或 `\"symbol\"`。但是 `TypeScript` 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。\n\n### 11.6 instanceof 类型守卫\n\n> `instanceof` 类型守卫是通过构造函数来细化类型的一种方式。比如，我们借鉴一下之前字符串填充的例子：\n\n```typescript\ninterface Padder {\n  getPaddingString(): string;\n}\n\nclass SpaceRepeatingPadder implements Padder {\n  constructor(private numSpaces: number) {}\n\n  getPaddingString() {\n    return Array(this.numSpaces + 1).join(\" \");\n  }\n}\n\nclass StringPadder implements Padder {\n  constructor(private value: string) {}\n\n  getPaddingString() {\n    return this.value;\n  }\n}\n\nfunction getRandomPadder() {\n  return Math.random() < 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(\" \");\n}\n\n// 类型为 SpaceRepeatingPadder | StringPadder\nlet padder: Padder = getRandomPadder();\n\nif (padder instanceof SpaceRepeatingPadder) {\n  padder; // 类型细化为 'SpaceRepeatingPadder'\n}\nif (padder instanceof StringPadder) {\n  padder; // 类型细化为 'StringPadder'\n}\n```\n\n> `instanceof` 的右侧要求是一个构造函数，`TypeScript` 将细化为:\n\n1. 此构造函数的 `prototype` 属性的类型，如果它的类型不为 `any` 的话\n2. 标签签名所返回的类型的联合\n\n> 以此顺序。\n\n### 11.7 可为 null 的类型\n\n> `TypeScript` 具有两种特殊的类型，`null` 和 `undefined` ，它们分别具有值 `null` 和 `undefined`。默认情况下，类型检查器会认为 `null` 和 `undefined` 可以赋值给任何类型。`null` 和 `undefined` 是所有其它类型的一个有效值。这意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。\n\n> `--strictNullChecks` 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 `null` 或 `undefined`。\n\n- 你可以使用联合类型明确的包含它们：```typescript\n  let s = \"foo\";\n  s = null; // --strictNullChecks 模式下 错误， 'null' 不能赋值给 'string'\n  let sn: string | null = \"bar\";\n  sn = null; // Ok\n  sn = undefined; // --strictNullChecks 模式下 error, 因为'undefined'不能赋值给'string | null'\n\n````\n\n\n\n\n>  注意：按照 `JavaScript` `的语义，TypeScript` 会把 `null` 和 `undefined` 区别对待。\n\n\n\n> `string | null`，`string | undefined` 和 `string | undefined | null` 是不同的类型。\n\n\n\n### 11.8 可选参数和可选属性\n\n\n- 使用了 `--strictNullChecks` ，可选参数会被自动地加上 `| undefined`:\n\n\n\n```typescript\nfunction f(x: number, y?: number) {\n    return x + (y || 0);\n}\nf(1, 2);\nf(1);\nf(1, undefined);\nf(1, null); // error, 'null' is not assignable to 'number | undefined'\n````\n\n- 可选属性也会有同样的处理\n\n```typescript\nclass C {\n  a: number;\n  b?: number;\n}\nlet c = new C();\nc.a = 12;\nc.a = undefined; // error, 'undefined' is not assignable to 'number'\nc.b = 13;\nc.b = undefined; // Ok\nc.b = null; // error, 'null' is not assignable to 'number | undefined'\n```\n\n### 11.9 类型守卫和类型断言\n\n> 由于可以为 `null` 的类型是通过联合类型实现，那么你需要使用类型守卫来去除 `null`。幸运地是这与在 `JavaScript` 里写的代码一致：\n\n```typescript\nfunction f(sn: string | null): string {\n  if (sn == null) {\n    return \"default\";\n  } else {\n    return sn;\n  }\n}\n```\n\n> 这里很明显地去除了 `null`, 你也可以使用短路运算符:\n\n```typescript\nfunction f1(sn: string | null): string {\n  return sn || \"default\";\n}\n```\n\n> 如果编译器不能够去除 `null` 或 `undefined`，你可以使用类型断言手动去除。语法是添加 `!` 后缀：`identifier!` 从 `identifier` 的类型里去除了 `null` 和 `undefined`：\n\n```typescript\nfunction broken(name: string | null): string {\n  function postfix(epihet: string) {\n    return name.charAt(0) + \". the\" + epihet; // error, 'name' is possibly null\n  }\n  name = name || \"Bob\";\n  return postfix(\"great\");\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epihet: string) {\n    return name!.charAt(0) + \". the\" + epihet; // Ok\n  }\n  name = name || \"Bob\";\n  return postfix(\"great\");\n}\n```\n\n> 本例使用了嵌套函数，因为编译器无法去除嵌套函数的 `null` (除非是立即调用的函数表达式)。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数作为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 `name` 的类型。\n\n### 11.10 类型别名\n\n1. 类型别名会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于 原始值，联合类型，元组 以及其它任何你需要手写的类型。\n\n```typescript\ntype Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\n\nfunction getName(n: NameOrResolver): Name {\n  if (typeof n === \"string\") {\n    return n;\n  } else {\n    return n();\n  }\n}\n```\n\n2. 起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。\n\n3.给原始类型起别名通常没有什么用，尽管可以作为文档的一种形式使用。\n\n4. 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入。\n\n```typescript\ntype Container<T> = { value: T };\n```\n\n5. 我们也可以使用类型别名来在属性里引用自己：\n\n```typescript\ntype Tree<T> = {\n  value: T;\n  left: Tree<T>;\n  right: Tree<T>;\n};\n```\n\n6. 与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型\n\n```typescript\ntype LinkedList<T> = T & { next: LinkedList<T> };\n\ninterface Person {\n  name: string;\n}\n\nvar people: LinkedList<Person>;\nvar s = people.name;\nvar s = people.next.name;\nvar s = people.next.next.name;\nvar s = people.next.next.next.name;\n```\n\n> 然而，类型别名不能出现在声明右侧的任何地方\n\n```typescript\n// type Yikes = Array<Yikes>; // error\n```\n\n### 11.11 接口 vs 类型别名\n\n> 像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。\n\n1. 接口创建了一个新的名字，可以在其它任何地方使用。类型别名并不创建新名字 - 比如，错误信息就不会使用别名。\n\n> 在下面的示例代码里，在编译器中将鼠标悬停在 `interfaced` 上，显示它返回的是 `Interface`，但悬停在 `aliased` 上时，显示的却是对象字面量类型。\n\n```typescript\ntype Alias = { num: number };\n\ninterface Interface {\n  num: number;\n}\n\ndeclare function aliased(arg: Alias): Alias;\n\ndeclare function interfaced(arg: Interface): Interface;\n```\n\n2. 另一个重要区别是类型别名不能被 `extends` 和 `implements` (自己也不能 `extends` 和 `implements` 其它类型)。因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。\n3. 另一方面，如果你无法通过接口来描述一个类型并且需要使用 联合类型 或 元组类型，这时通常会使用类型别名。\n\n### 11.12 字符串字面量类型\n\n> 字符串字面量类型允许你指定字符串必须的固定值。在实际应用中，字符串字面量类型可以与联合类型，类型守卫和类型别名很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\n```typescript\ntype Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\";\n\nclass UIElement {\n  animate(dx: number, dy: number, easing: Easing) {\n    if (easing === \"ease-in\") {\n      // ...\n    } else if (easing === \"ease-out\") {\n      // ...\n    } else if (easing === \"ease-in-out\") {\n      // ...\n    } else {\n      // error! should not pass null or undefined.\n    }\n  }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, \"ease-in\");\n// button.animate(0, 0,\"uneasy\"); // error: \"uneasy\" is not allowed here\n```\n\n- 你只能从三种允许的字符中选择其一来作为参数传递，传入其它值则会产生错误。\n\n```typescript\n// Argument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n```\n\n- 字符串字面量类型还可以用于区分函数重载\n\n```typescript\nfunction createElement(tagName: \"img\"): HTMLImageElement;\nfunction createELement(tagName: \"input\"): HTMLInputElement;\n// ... more overloads ...\nfunction createElement(tagName: \"string\"): Element {\n  // ... code goes here ...\n}\n```\n\n### 11.13 数字字面量类型\n\n- `TypeScript` 还具有数字字面量类型\n\n```typescript\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n  // ...\n}\n```\n\n- 我们很少直接这样使用，但它们可以用在缩小范围调试 `bug` 的时候。\n\n```typescript\nfunction foo(x: number) {\n  if (x !== 1 || x !== 2) {\n    // ~~~~~~\n    // Operator '!==' cannot be applied to types '1' and '2'\n  }\n}\n```\n\n> 换句话说，当 `x` 与 `2` 进行比较的时候，它的值必须为 `1`，这就意味着上面的比较检查是非法的。\n\n### 11.14 枚举成员类型\n\n> 如我们在枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。在我们谈及“单例类型”的时候，多数是指 枚举成员类型 和 数字/字符串 字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。\n\n### 11.15 可辨识联合\n\n> 你可以合并 单例类型，联合类型，类型守卫 和 类型别名 来创建一个叫做 可辨识联合 的高级模式，它也称作 标签联合 或 代数数据类型。可辨识联合 在函数式编程里很有用处。一些语言会自动地为你辨识联合；而 `TypeScript` 则基于已有的 `JavaScript` 模式，。它具有 `3` 个要素：\n\n1. 具有普通的单例类型属性 - 可辨识的特征\n2. 一个类型别名包含了那些类型的联合 - 联合。\n3. 此属性上的类型守卫\n\n```typescript\ninterface Square {\n  kind: \"square\";\n  size: number;\n}\n\ninterface Rectangle {\n  kind: \"rectangle\";\n  width: number;\n  height: number;\n}\n\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n```\n\n> 首先我们声明了将要联合的接口。每个接口都有 `kind` 属性但有不同的字符串字面量类型。`kind` 属性称作 可辨识的特征或标签。其它的属性则特定于各个接口。注意，目前各个接口间是没有联系的。\n\n- 下面我们将它们联合到一起。\n\n```typescript\ntype Shape = Square | Rectangle | Circle;\n```\n\n- 现在我们使用可辨识联合\n\n```typescript\nfunction area(s: Shape) {\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.width * s.height;\n    case \"circle\":\n      return Math.PI * s.radius ** 2;\n  }\n}\nlet areaSquare = area({ kind: \"square\", size: 12 });\nlet areaRectangle = area({ kind: \"rectangle\", width: 14, height: 13 });\nlet areaCircle = area({ kind: \"circle\", radius: 5 });\nconsole.log(areaSquare, areaRectangle, areaCircle);\n```\n\n### 11.16 完整性检查\n\n> 当没有涵盖所有 可辨识联合 的变化时，我们想让编译器可以通知我们。比如，如果我们添加了 `Triangle` 和 `Shape`，我们同时还需要更新 `area`：\n\n```typescript\ninterface Square {\n  kind: \"square\";\n  size: number;\n}\n\ninterface Rectangle {\n  kind: \"rectangle\";\n  width: number;\n  height: number;\n}\n\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\n// interface Triangle { kind: \"triangle\", bottom: number, height: number }\n\ntype Shape = Square | Rectangle | Circle;\n\nfunction area(s: Shape) {\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.width * s.height;\n    case \"circle\":\n      return Math.PI * s.radius ** 2;\n  }\n  // should error here - we didn't handle case \"triangle\"\n}\n```\n\n- 有两种方式可以实现。\n\n1. 首先是启用 `--strictNullChecks` 并且指定一个返回值类型:\n\n```typescript\nfunction area1(s: Shape): number {\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.height * s.width;\n    case \"circle\":\n      return Math.PI * s.radius ** 2;\n  }\n}\n```\n\n> 因为 `switch` 没有包含所有情况，所以 `TypeScript` 认为这个函数有时候会返回 `undefined`。如果你明确地指定了返回值类型为 `number`，那么你会看到一个错误，因为实际上返回值类型为 `number | undefined`。然而，这种方法存在些微妙之处且 `--strictNullChecks` 对旧代码支持不好。\n\n2. 第二种方法使用 `never` 类型，编译器用它来进行完整性检查\n\n```typescript\nfunction assertNever(x: never): never {\n throw new Error(\"Unexpected object: \" + x);\n}\n>\nfunction area2(s: Shape) {\n switch (s.kind) {\n     case \"square\":\n         return s.size * s.size;\n     case \"rectangle\":\n         return s.width * s.height;\n     case \"circle\":\n         return Math.PI * s.radius ** 2;\n     default:\n         return assertNever(s); // error here if there are missing cases\n }\n}\n```\n\n> 这里，`assertNever` 检查 `s` 是否为 `never` 类型 - 即为除去所有可能情况后剩下的类型。如果你忘记了某个 `case`，那么 `s` 将具有一个真实的类型并且你会得到一个错误。这种方式需要你定义一个额外的函数，但是在你忘记某个 `case` 的时候也更加明显。\n\n### 11.17 多态的 this 类型\n\n> 多态的 `this` 类型表示的是某个包含类或接口的子类型。这被称作是 `F-bounded` 多态性。它能很容易的表现连贯接口间的继承。\n\n- 比如，在计算器的例子里，在每个操作之后都返回 `this` 类型。\n\n```typescript\nclass BasicCalculator {\n  public constructor(protected value: number = 0) {}\n\n  public currentValue(): number {\n    return this.value;\n  }\n\n  public add(operand: number): this {\n    this.value += operand;\n    return this;\n  }\n\n  public multiply(operand: number): this {\n    this.value *= operand;\n    return this;\n  }\n\n  //...other operations go here...\n}\n\nlet v = new BasicCalculator(2).multiply(5).add(1).currentValue();\nconsole.log(v);\n```\n\n> 由于这个类使用了 `this` 类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何改变。\n\n```typescript\nclass ScientificCalculator extends BasicCalculator {\n  public constructor(value = 0) {\n    super(value);\n  }\n\n  public sin() {\n    this.value = Math.sin(this.value);\n    return this;\n  }\n\n  // ... other operations go here ...\n}\n\nlet v1 = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();\nconsole.log(v1);\n```\n\n> 如果没有 `this` 类型，`ScientificCalculator` 就不能够在继承 `BasicCalculator` 的同时还保持接口的连贯性。`multiply` 将会返回 `BasicCalculator`，它并没有 `sin` 方法。然而，使用 `this` 类型，`multiply` 会返回 `this`，在这里就是 `ScientificCalculator`。\n\n### 11.18 索引类型\n\n> 使用索引类型，编译器就能够检查使用了动态属性名的代码。\n\n- 例如，一个常见的 `JavaScript` 模式是从对象中选取属性的子集。\n\n```typescript\nfunction js_pluck(o, names) {\n  return names.map(n => o[n]);\n}\n```\n\n- 下面是如何在 `TypeScript` 里使用此函数，通过 索引类型查询和 索引访问 操作符：\n\n```typescript\nfunction pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {\n  return names.map(n => o[n]);\n}\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\nlet person: Person = {\n  name: \"Jarid\",\n  age: 35\n};\nlet strings: string[] = pluck(person, [\"name\"]);\nconsole.log(strings);\n```\n\n> 编译器会检查 `name` 是否真的是 `Person` 的一个属性。本例还引入了几个新的类型操作符。\n\n#### 11.18.1 首先是 `keyof T`，索引类型查询操作符。\n\n> 对于任何类型 `T` ，`keyof T` 的结果为 `T` 上已知的公共属性名的联合。\n\n- 例如：\n\n```typescript\nlet personProps: keyof Person; // 'name' | 'age'\n```\n\n> `keyof Person` 是完全可以与 `'name' \\| 'age'` 互相替换的。不同的是如果你添加了其它的属性到 `Person`, 例如 `address: string`，那么`keyof Person` 会自动变为 `'name' | 'age' | 'address'`。你可以像 `pluck` 函数这类上下文里使用 `keyof` ，因为在使用之前你并不清楚可能出现的属性名。但编译器会检查你是否传入了正确的属性名给 `pluck`：\n\n```typescript\n// pluck(person, ['age', 'unknown']); // error, 'unknown' is not in 'name' | 'age'\n```\n\n#### 11.18.2 第二个操作符是 `T[K]`, 索引访问操作符。\n\n> 在这里，类型语法反应了表达式语法。这意味着 `person['name']` 具有类型 `Person['name']` -- 在我们的例子里则为 `string` 类型。然而，就像索引类型查询一样，你可以在普通的上下文里使用 `T[K]`，这正是它的强大所在。你只要确保类型变量 `K extends keyof T` 就可以了。\n\n- 例如下面 `getProperty` 函数的例子：\n\n```typescript\nfunction getProperty<T, K extends keyof T>(o: T, name: K): T[K] {\n  return o[name]; // o[name] is of type T[K]\n}\n```\n\n> `getProperty` 里的 `o: T` 和 `name: K`，意味着 `o[name]: T[K]`。当你返回 `T[K]` 的结果，\n\n> 编译器会是实例化键的真实类型，因此 `getProperty` 的返回值类型会随着你需要的属性改变。\n\n```typescript\nlet _name: string = getProperty(person, \"name\");\nlet _age: number = getProperty(person, \"age\");\n// let unknown = getProperty(person, \"unknown\"); // error, 'unknown' is not in 'name' | 'age'\nconsole.log(_name, \" \", _age);\n```\n\n### 11.19 索引类型和字符串索引签名\n\n> `keyof` 和 `T[K]` 与字符串索引签名进行交互。如果你有一个带有字符串索引签名的类型，那么 `keyof T` 会是 `string`。并且 `T[string]` 为索引签名的类型。\n\n```typescript\ninterface Dictionary<T> {\n  [key: string]: T;\n}\nlet keys: keyof Dictionary<number>; // string\nlet value: Dictionary<number>[\"foo\"]; // number\n```\n\n### 11.20 映射类型\n\n- 一个常见的任务是将一个已知的类型每个属性都变为可选的。\n\n```typescript\ninterface PersonPartial {\n  name?: string;\n  age?: number;\n}\n```\n\n- 或者我们只想要一个只读版本\n\n```typescript\ninterface PersonReadonly {\n  readonly name: string;\n  readonly age: number;\n}\n```\n\n> 这在 `JavaScript` 里经常出现。`TypeScript` 提供了从旧类型中创建新类型的一种方式 `--` 映射类型。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。假如，你可以令每个属性成为 `readonly` 类型或可选的。\n\n- 下面是一些例子：\n\n```typescript\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n- 像下面这样使用\n\n```typescript\ninterface Person {}\ntype PersonPartial = Partial;\ntype PersonReadonly = Readonly;\n```\n\n> 需要注意的是，这个语法描述的是类型而非成员。若想添加额外的成员，则可以使用 交叉类型。\n\n- 这样使用\n\n```typescript\ntype PartialWithNewMember<T> = {\n  [P in keyof T]?: T[P];\n} & { newMember: boolean };\n```\n\n- 不要这样使用\n\n```typescript\ntype PartialWithNewMember<T> = {\n  [P in keyof T]?: T[P];\n  newMember: boolean;\n}\n```\n\n> 下面来看看最简单的映射类型和它的组成部分\n\n```typescript\ntype Keys = \"option1\" | \"option2\";\ntype Flags = { [K in Keys]: boolean };\n```\n\n> 它的语法与索引签名的语法类型，内部使用了 `for...in`。具有三个部分：\n\n1. 类型变量 `K`，它会依次绑定到每个属性。\n2. 字符串字面量联合的 `Keys`，它包含了要迭代的属性名的集合。\n3. 属性的结果类型。\n\n> 在上面这个简单的例子里，`Keys` 是硬编码的属性列表并且属性类型永远是 `boolean`，因此这个映射类型\n\n- 等同于：\n\n```typescript\ntype _FLags = {\n  option1: boolean;\n  option2: boolean;\n};\n```\n\n> 在真正的应用里，可能不同于上面的 `Readonly` 或 `Partial`。它们会基于一些已存在的类型，且按照一定的方式转换字段。这就是 `keyof` 和 `索引访问类型` 要做的事情。\n\n```typescript\ntype NullablePerson = { [P in keyof Person]: Person[P] | null };\ntype PartialPerson = { [P in keyof Person]?: Person[P] };\n```\n\n> 但它更有用的地方是可以有一些通用版本。\n\n```typescript\ntype Nullable<T> = { [P in keyof T]: T[P] | null };\ntype Partial1<T> = { [P in keyof T]?: T[P] };\n```\n\n> 在这些例子里，属性列表是 `keyof T` 且结果类型是 `T[P]` 的变体。这是使用通用映射类型的一个好模版。因为这类转换是同态的，映射只作用于 `T` 的属性而没有其它的。编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。假如，假设 `Person.name` 是只读的，那么 `Partial1<Person>.name` 也将是只读的且为可选的。\n\n> 下面是另一个例子，`T[P]` 被包装在 `Proxy<T>` 类里：\n\n```typescript\ntype Proxy<T> = {\n  get(): T;\n  set(value: T): void;\n};\ntype Proxify<T> = {\n  [P in keyof T]: Proxy<T[P]>;\n};\nfunction proxify<T>(o: T): Proxify<T> {\n  // ...wrap proxies\n}\nlet proxyProps = proxify(props);\n```\n\n> 注意 `Readonly<T>` 和 `Partial<T>` 用处不小，因此它们于 `pick` 和 `Record` 一同被包含进了 `TypeScript` 的标准库里：\n\n```typescript\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\ntype Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n```\n\n> `Readonly`, `Partial` 和 `Pick` 是同态的，但 `Record` 不是。因为 `Record` 并不需要输入类型来拷贝属性，所以它不属于同态：\n\n```typescript\ntype ThreeStringProps = Record<\"prop1\" | \"prop2\" | \"prop3\", string>;\n```\n\n> 非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。\n\n### 11.21 由映射类型进行判断\n\n> 现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。其实这也非常容易：\n\n```typescript\ntype Proxify<T> = {\n  get(): T;\n  set(value: T): void;\n};\n\nfunction unproxify<T>(t: Proxify<T>): T {\n  let result = {} as T;\n  for (const k in t) {\n    result[k] = t[k].get();\n  }\n  return result;\n}\n// let originalProps = unproxify(proxyProps);\n```\n\n> 注意这个拆包推断只适用于同态的映射类型。如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。\n\n### 11.22 有条件类型\n\n> `TypeScript 2.8` 引入了有条件类型，它能够表示非统一的类型。有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：\n\n```typescript\nT extends U ? X : Y\n```\n\n> 上面的类型意思是：若 `T` 能够赋值给 `U`，那么类型是 `X`，否则为 `Y`\n\n> 有条件的类型 `T extends U ? X : Y` 或者解析为 `X`，或者解析为 `Y`，再或者延迟解析，因为它可能依赖一个或多个类型变量。若 `T` 或 `U` 包含类型参数，那么是否解析为 `X` 或 `Y` 或推迟，取决于类型系统是否有足够的信息来确定 `T` 总是可以赋值给 `U`。\n\n- 下面是一些类型可以被立即解析的例子：\n\n```typescript\ndeclare function f<T extends boolean>(x: T): T extends true ? string : number;\n\n// Type is 'string' | 'number'\nlet x = f(Math.random() < 0.5);\n```\n\n> 另外一个例子涉及 `TypeName` 类型别名，它使用了嵌套了有条件类型\n\n```typescript\ntype TypeName<T> = T extends string ? \"string\" : T extends number ? \"number\" : T extends boolean ? \"boolean\" : T extends undefined ? \"undefined\" : T extends Function ? \"function\" : \"object\";\n\ntype T0 = TypeName<string>; // \"string\"\ntype T1 = TypeName<\"a\">; // \"string\"\ntype T2 = TypeName<true>; // \"boolean\"\ntype T3 = TypeName<() => void>; // \"function\"\ntype T4 = TypeName<string[]>; // \"object\"\n```\n\n- 下面是一个有条件类型被推迟解析的例子\n\n```typescript\ninterface Foo {\n  propA: boolean;\n  propB: boolean;\n}\ndeclare function f<T>(x: T): T extends Foo ? string : number;\nfunction foo<U>(x: U) {\n  // Has type 'U extends Foo ? string : number'\n  let a = f(x);\n  // This assignment is allowed though!\n  let b: string | number = a;\n}\n```\n\n> 这里，`a` 变量含有未确定的有条件类型。当有另一段代码调用 `foo`，它会用其它类型替换 `U`，`TypeScript` 将重新计算有条件类型，决定它是否可以选择一个分支。与此同时，我们可以将有条件类型赋值给其它类型，只要有条件类型的每个分支，都可以赋值给目标类型。因此在我们的例子里，我们可以将 `U extends Foo ? string : number` 赋值给 `string | number`，因为不管这个有条件类型最终结果是什么，它只能是 `string | number`。\n\n### 11.23 分布式有条件类型\n\n> 如果有条件类型里待检查的类型是 `naked type parameter` ，那么它也被称为\"分布式有条件类型\"。分布式有条件类型在实例化时会自动分发成联合类型。例如：实例化 `T extends U ? X : Y`，`T` 的类型为 `A | B | C`，会被解析为 `(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)`。\n\n- 例子：```typescript\n  type TypeName<T> =\n  T extends string ? \"string\" :\n  T extends number ? \"number\" :\n  T extends boolean ? \"boolean\" :\n  T extends undefined ? \"undefined\" :\n  T extends Function ? \"function\" : \"object\";\n  type T10 = TypeName<string | (() => void)>; // \"string\" | \"function\"\n  type T11 = TypeName<string | string[] | undefined>; // \"string\" | \"object\" | \"undefined\"\n  type T12 = TypeName<string[] | number[]>; // \"object\"\n\n````\n\n\n\n\n>  在 `T extends U ? X : Y` 的实例化里，对 `T` 的引用被解析为联合类型的一部分(比如，`T` 指向某一单个部分，在有条件类型分布到联合类型之后)。此外，在 `X` 内对 `T` 的引用有一个附加的类型参数约束 `U`(例如，`T` 被当成在 `X` 内可赋值给 `U`)。\n\n\n\n- 例子：\n\n\n\n```typescript\ntype BoxedValue<T> = { value: T };\ntype BoxedArray<T> = { array: T[] };\ntype Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;\n\ntype T20 = Boxed<string>; // BoxedValue<string>;\ntype T21 = Boxed<number[]>; // BoxedArray<number>;\ntype T22 = Boxed<string | number[]>; // BoxedValue<string> | BoxedArray<number>;\n````\n\n#### 11.23.1 有条件类型的分布式的属性可以方便地用来过滤联合类型：\n\n```typescript\ntype Diff<T, U> = T extends U ? never : T; // Remove types from T that are assignable to U(从 T 中删除可分配给 U 的类型)\ntype Filter<T, U> = T extends U ? T : never; // Remove types from T that are not assignable to U(从 T 中删除不可赋值给 U 的类型)\n\ntype T30 = Diff<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"b\" | \"d\"\ntype T31 = Filter<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"\ntype T32 = Diff<string | number | (() => void), Function>; // string | number\ntype T33 = Filter<string | number | (() => void), Function>; // () => void\n\ntype _NonNullable<T> = Diff<T, null | undefined>; // Remove null and undefined from T\n\ntype T34 = _NonNullable<string | number | undefined>; // string | number\ntype T35 = _NonNullable<string | string[] | null | undefined>; // string | string[]\n\nfunction f1<T>(x: T, y: _NonNullable<T>) {\n  x = y; // Ok\n  // y = x ;// Error\n}\nfunction f2<T extends string | undefined>(x: T, y: _NonNullable<T>) {\n  x = y; // Ok\n  // y = x; //Error\n  // let s1: string = x; // Error\n  let s2: string = y; // Ok\n}\n```\n\n#### 11.23.2 有条件类型与映射类型结合时特别有用\n\n```typescript\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n\ntype NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\ninterface Part {\n  id: number;\n  name: string;\n  subparts: Part[];\n  updatePart(newName: string): void;\n}\n\ntype T40 = FunctionPropertyNames<Part>; // \"updatePart\"\ntype T41 = NonFunctionPropertyNames<Part>; // \"id\" | \"name\" | \"subparts\"\ntype T42 = FunctionProperties<Part>; // { updatePart(newName: string): void }\ntype T43 = NonFunctionProperties<Part>; // { id: number, name: string, suparts: Part[] }\n```\n\n#### 11.23.3 与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。\n\n- 比如下面的错误：\n\n```typescript\n// type ElementType<T> = T extends any[] ? ElementType<T[number]>: T; // Error\n```\n\n### 11.24 有条件类型中的类型推断\n\n> 现在有条件类型的 `extends` 子语句中，允许出现 `infer` 声明，它会引入一个待推断的类型变量。这个推断的类型变量可以在有条件类型的 `true` 分支中被引用。允许出现多个同类型变量的 `infer`。\n\n> 例如：下面代码会提取函数类型的返回值\n\n```typescript\ntype _ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n> 有条件类型 可以嵌套来构成一系列的匹配模式，按顺序进行求值：\n\n```typescript\ntype Unpacked<T> = T extends (infer U)[] ? U : T extends (...args: any[]) => infer U ? U : T extends Promise<infer U> ? U : T;\n\ntype T0 = Unpacked<string>; // string\ntype T1 = Unpacked<string[]>; // string\ntype T2 = Unpacked<() => string>; // string\ntype T3 = Unpacked<Promise<string>>; // string\ntype T4 = Unpacked<Promise<string>[]>; // Promise<string>\ntype T5 = Unpacked<Unpacked<Promise<string>[]>>; // string\n```\n\n> 下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：\n\n```typescript\ntype Foo<T> = T extends { a: infer U; b: infer U } ? U : never;\ntype T10 = Foo<{ a: string; b: string }>; // string\ntype T11 = Foo<{ a: string; b: number }>; // string | number\n```\n\n> 相似地，在抗变位置上同一个类型变量的多个候选类型会被推断为交叉类型：\n>\n> ```typescript\n> type Bar<T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void } ? U : never;\n> type T20 = Bar<{ a: (x: string) => void; b: (x: string) => void }>; // string\n> type T21 = Bar<{ a: (x: string) => void; b: (x: number) => void }>; // string & number\n> ```\n\n````\n\n\n\n> 当推断具有多个调用签名(例如函数重载类型)的类型时，用最后的签名(大概是最自由的包含所有情况的签名) 进行推断。无法根据参数类型列表来进行解析重载。\n\n\n\n```typescript\ndeclare function foo(x: string): number;\ndeclare function foo(x: number): string;\ndeclare function foo(x: string | number): string | number;\n\ntype T30 = ReturnType<typeof foo>; // string | number\n````\n\n> 无法在正常类型参数的约束子语句中使用 `infer` 声明：\n\n```typescript\n// type ReturnType1<T extends (...args: any[]) => infer R> = R; // Error\n```\n\n> 但是，可以这样达到同样的效果，在约束里删掉类型变量，用 有条件类型 来替换：\n\n```typescript\ntype AnyFunction = (...args: any[]) => any;\ntype ReturnType2<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n> 实际上，就是 `ReturnType`\n\n```typescript\ntype __ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : never;\n```\n\n### 11.25 预定义的有条件类型\n\n> `TypeScript 2.8` 在 `lib.d.ts` 里增加了一些预定义的有条件类型\n\n> 1. `Exclude<T, U>` -- 从 `T` 中剔除可以赋值给 `U` 的类型\n> 2. `Extract<T, U>` -- 提取 `T` 中可以赋值给 `U` 的类型\n> 3. `NonNullable<T>` -- 从 `T` 中剔除 `null` 和 `undefined`\n> 4. `ReturnType<T>` -- 获取函数返回值类型\n> 5. `InstanceType<T>` -- 获取构造函数类型的实例类型\n\n- `Example`:\n\n```typescript\ntype T00 = Exclude<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"b\" | \"d\"\ntype T01 = Extract<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"\n\ntype T02 = Exclude<string | number | (() => void), Function>; // \"string\" | \"number\"\ntype T03 = Extract<string | number | (() => void), Function>; // () => void\n\ntype T04 = NonNullable<string | number | undefined>; // string | number\ntype T05 = NonNullable<(() => string) | string[] | null | undefined>; // (() => string) | string[]\n\nfunction f1(s: string) {\n  return { a: 1, b: s };\n}\n\nclass C {\n  x = 0;\n  y = 0;\n}\n\ntype T10 = ReturnType<() => string>; // string\ntype T11 = ReturnType<(s: string) => void>; // void\ntype T12 = ReturnType<<T>() => T>; // {}\ntype T13 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]\ntype T14 = ReturnType<typeof f1>; // { a: number, b: string }\ntype T15 = ReturnType<any>; // any\ntype T16 = ReturnType<never>; // never\n// type T17 = ReturnType<string>; // Error\n// type T18 = ReturnType<Function>; // Error\n\ntype T20 = InstanceType<typeof C>; // C\ntype T21 = InstanceType<any>; // any\ntype T22 = InstanceType<never>; // never\n// type T23 = InstanceType<string>; // Error\n// type T24 = InstanceType<Function>; // Error\n```\n\n> 注意：`Exclude` 类型是建议的 `Diff` 类型的一种实现，我们使用 `Exclude` 这个名字是为了避免破坏已经定义了的 `Diff` 的代码，并且我们感觉这个名字能更好地表达类型的语义。我们没有增加 `Omit<T, K>` 类型，因为它可以很容易的用 `Pick<T, Exclude<keyof T, K>>` 来表示\n\n## 十二、实用工具类型\n\n> `TypeScript` 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的。\n\n### 12.1 Partial 局部的\n\n> 构造类型 `T`, 并将它所有的属性设置成可选的，它的返回类型表示输入类型的所有子类型。\n\n- 例子：\n\n```typescript\ninterface PartialTodo {\n  title: string;\n  description: string;\n}\n\nfunction updateTodo(todo: PartialTodo, fieldsToUpdate: Partial<PartialTodo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n\nconst partialTodo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\"\n};\n\nconst partialTodo2 = updateTodo(partialTodo1, {\n  description: \"throw out trash\"\n});\n```\n\n### 12.2 Readonly 只读的\n\n> 构造类型 T**，并将它所有的属性设置为** readonly**，也就是说构造出的类型的属性不能被再次赋值**\n\n- 例子：\n\n```typescript\ninterface ReadonlyTodo {\n  title: string;\n}\n\nconst readonlyTodo: Readonly<ReadonlyTodo> = {\n  title: \"Delete inactive users\"\n};\n\nreadonlyTodo.title = \"Hello\"; // Error: cannot reassign a readonly property\n\n// Object.freeze\nfunction freeze<T>(obj: T): Readonly<T>;\n```\n\n### 12.3 Record<T, K> 记录\n\n> 构造一个类型，其属性名的类型为 `K`，属性值的类型为 `T`。这个工具可用来将某个类型的属性映射到另一个类型上。\n\n- 例子：\n\n```typescript\ninterface PageInfo {\n  title: string;\n}\n\ntype Page = \"home\" | \"about\" | \"contact\";\n\nconst x: Record<Page, PageInfo> = {\n  about: { title: \"about\" },\n  contact: { title: \"concat\" },\n  home: { title: \"home\" }\n};\n```\n\n### 12.4 Pick<T, K> 挑选\n\n> 从类型 `T` 中挑选部分属性 `K` 来构造类型\n\n```typescript\ninterface PickTodo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Pick<PickTodo, \"title\" | \"completed\">;\n\nconst pickTodo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false\n};\n```\n\n### 12.5 Exclude<T, U> 剔除\n\n> 从类型 `T` 中剔除所有可以赋值给 `U` 的属性，然后构造一个类型。\n\n- 例子：\n\n```typescript\ntype T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">; // \"b\" | \"c\"\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">; // \"c\"\ntype T2 = Exclude<string | number | (() => void), Function>; // string | number\n```\n\n### 12.6 Extract<T, U> 提取\n\n> 从类型 `T` 中提取所有可以赋值给 `U` 的类型，然后构造一个类型。\n\n```typescript\ntype T01 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\"\ntype T02 = Extract<string | number | (() => void), Function>; // () => void\n```\n\n### 12.7 NonNullable\n\n> 从类型 `T` 中剔除 `null` 和 `undefined`，然后构造一个类型\n\n- 例子：\n\n```typescript\ntype T10 = NonNullable<string | number | undefined>; // string | number\ntype T11 = NonNullable<string[] | null | undefined>; // string[]\n```\n\n### 12.8 ReturnType 返回值类型\n\n> 由函数类型 `T` 的返回值类型构造一个类型\n\n- 例子：\n\n```typescript\nfunction f1(s: string) {\n  return { a: 1, b: s };\n}\n\ntype _T0 = ReturnType<() => string>; // string\ntype _T1 = ReturnType<(s: string) => void>; // void\ntype _T2 = ReturnType<<T>() => T>; // {}\ntype _T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]\ntype _T4 = ReturnType<typeof f1>; // { a: number, b: string }\ntype _T5 = ReturnType<any>; // any\ntype _T6 = ReturnType<never>; // never\ntype _T7 = ReturnType<string>; // Error\ntype _T8 = ReturnType<Function>; // Error\n```\n\n### 12.9 InstanceType 构造函数 实例类型\n\n> 由构造函数类型 `T` 的实例类型构造一个类型。\n\n- 例子：\n\n```typescript\nclass C {\n  x = 0;\n  y = 0;\n}\n\ntype _T01 = InstanceType<typeof C>; // C\ntype _T02 = InstanceType<any>; // any\ntype _T03 = InstanceType<never>; // never\ntype _T04 = InstanceType<string>; // Error\ntype _T05 = InstanceType<Function>; // Error\n```\n\n### 12.10 Required\n\n> 构造一个类型，使类型 `T` 的所有属性为 `required`\n\n- 例子：\n\n```typescript\ninterface Props {\n  a?: number;\n  b?: string;\n}\n\nconst obj: Props = { a: 5 }; // Ok\nconst obj2: Required<Props> = { a: 5 }; // Error, property 'b' missing\n```\n\n### 12.11 ThisType this\n\n> 这个工具不会返回一个转换后的类型。它作为上下文的 `this` 类型的一个标记。\n> 注意：若想要使用此类型，必须启用 `--noImplicitThis`\n\n- 例子：\n\n```typescript\n// Compile with --noImplicitThis\ntype ObjectDescriptor<D, M> = {\n  data?: D;\n  methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M\n};\n\nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n  let data: object = desc.data || {};\n  let methods: object = desc.methods || {};\n  return { ...data, ...methods } as D & M;\n}\n\nlet _obj = makeObject({\n  data: { x: 0, y: 0 },\n  methods: {\n    moveBy(dx: number, dy: number) {\n      this.x += dx; // Strongly typed this\n      this.y += dy; // Strongly typed this\n    }\n  }\n});\n_obj.x = 10;\n_obj.y = 10;\n_obj.moveBy(5, 5);\n```\n\n> 上面例子中，`makeObject` 参数里的 `methods` 对象具有一个上下文类型 `ThisType<D & M>`，因此 `methods` 对象的方法里 this 的类型为 `{ x: number, y: number } & { moveBy(dx: number, dy: number): number }`。\n> 在 `lib.d.ts` 里，`ThisType<T>` 标识接口是个简单的空接口声明。除了在被识别为对象字面量的上下文类型之外，这个接口与一般的空接口没有什么不同。\n\n## 十三、Symbols\n\n> 介绍：自 `ECMAScript 2015` 起，`symbol` 成为了一种新的原生类型，就像 `number` 和 `string` 一样。\n\n### 13.1 `symbol` 类型的值是通过 `Symbol` 构造函数创建的。\n\n```typescript\nlet sym1 = Symbol();\nlet sym2 = Symbol(\"key\"); // 可选的字符串 key\n```\n\n### 13.2 `Symbols` 是不可改变且唯一的\n\n```typescript\nlet sym3 = Symbol(\"key\");\nlet sym4 = Symbol(\"key\");\nsym3 === sym4; // false symbols 是唯一的\n```\n\n### 13.3 像字符串一样，`symbols` 也可以被用作对象属性的键。\n\n```typescript\nconst sym = Symbol();\nlet obj = {\n  [sym]: \"value\"\n};\nconsole.log(obj[sym]); // \"value\"\n```\n\n### 13.4 `Symbols` 也可以与计算出的属性名相结合来声明对象的属性和类成员。\n\n```typescript\nconst getClassNameSymbol = Symbol();\n\nclass C {\n  [getClassNameSymbol]() {\n    return \"C\";\n  }\n}\n\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"\n```\n\n### 13.5 众所周知的 `Symbols`\n\n> 除了用户定义的 `Symbols`，还有一些已经众所周知的内置 `symbols`。内置 `symbols` 用来表示语言内部的行为。\n> 以下为这些 `symbols` 的列表：\n\n- `Symbol.hasInstance`\n\n> 该方法会被 `instanceof` 运算符调用。构造器对象用来识别一个对象是否是其实例。\n\n- `Symbol.isConcatSpreadable`\n\n> 布尔值，表示当在一个对象上调用 `Array.prototype.concat` 时，这个对象的数组元素是否可展开。\n\n- `Symbol.iterator`\n\n> 方法，被 `for-of` 语句调用，。返回对象的默认迭代器\n\n- `Symbol.match`\n\n> 方法，被 `String.prototype.match` 调用。正则表达式用来匹配字符串\n\n- `Symbol.replace`\n\n> 方法，被 `String.prototype.replac`e 调用。正则表达式用来替换字符串中匹配的子串。\n\n- `Symbol.search`\n\n> 方法，被 `String.prototype.search` 调用。正则表达式返回被匹配部分在字符串中的索引。\n\n- `Symbol.species`\n\n> 函数值，为一个构造函数。用来创建派生对象。\n\n- `Symbol.split`\n\n> 方法，被 `String.prototype.split` 调用。正则表达式用来分割字符串。\n\n- `Symbol.toPrimitive`\n\n> 方法，被 `ToPrimitive` 抽象操作调用。把对象转换为相应的原始值。\n\n- `Symbol.toStringTag`\n\n> 方法，被内置方法 `Object.prototype.toString` 调用。返回创建对象时默认的字符串描述。\n\n- `Symbol.unscopables`\n\n> 对象，它自己拥有的属性会被 `with` 作用域排除在外。\n\n## 十四、迭代器和生成器\n\n- 可迭代性\n\n> 当一个对象实现了 `Symbol.iterator` 属性时，我们认为它是可迭代的。一些内置的类型如 `Array`，`Map`，`Set`，`String`，`Int32Array`，`Uint32Array` 等都已经实现了各自的 `Symbol.iterator`。对象上的 `Symbol.iterator` 函数负责返回供迭代的值。\n\n### 14.1 for ... of 语句\n\n> `for ... of` 会遍历可迭代对象，调用对象上的 `Symbol.iterator` 方法。\n\n- 下面是在数组上使用 `for ... of` 的简单例子\n\n```typescript\nlet someArray = [1, \"string\", false];\n\nfor (let entry of someArray) {\n  console.log(entry); // 1, \"string\", false\n}\n```\n\n### 14.2 for ... of Vs for ... in 语句\n\n> `for ... of` 和 `for ... in` 均可迭代一个列表；但是用于迭代的值却不同，`for ... in` 迭代的是对象的 `键` 的列表，而 `for ... of` 则迭代对象的键对应的值。\n\n- 下面的例子展示了两者之间的区别：\n\n```typescript\nlet list = [4, 5, 6];\nfor (let i in list) {\n  console.log(i); // \"0\" \"1\" \"2\"\n}\nfor (let i of list) {\n  console.log(i); // \"4\" \"5\" \"6\"\n}\n```\n\n> 另一个区别是 `for ... in` 可以操作任何对象；它提供了查看对象属性的一种方法。但是 `for ... of` 关注于迭代对象的值。内置对象 `Map` 和 `Set` 已经实现了 `Symbol.iterator` 方法，让我们可以访问它们保存的值。\n\n```typescript\nlet pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\nfor (let pet in pets) {\n  console.log(pet);\n}\nfor (let pet of pets) {\n  console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}\n```\n\n### 14.3 代码生成目标为 `ES5` 和 `ES3`\n\n> 当生成目标为 `ES5` 或 `ES3`，迭代器只允许在 `Array` 类型上使用。在非数组值上使用 `for ... of` 语句会得到一个错误，就算这些非数组值已经实现了 `Symbol.iterator` 属性。\n\n> 编译器会生成一个简单的 `for` 循环做为 `for ... of` 循环，比如：\n\n```typescript\nlet numbers = [1, 2, 3];\nfor (let num of numbers) {\n  console.log(num);\n}\n// 生成的代码为：\nvar number = [1, 2, 3];\nfor (var _i = 0; _i < numbers.length; _i++) {\n  var num = numbers[_i];\n  console.log(num);\n}\n```\n\n### 14.4 目标为 `ECMAScript 2015` 或更高\n\n> 当目标为兼容 `ECMAScript 2015` 的引擎时，编译器会生成相应引擎的 `for ... of` 内置迭代器实现方式。\n\n## 十五、模块\n\n### 15.1 关于术语的一点说明\n\n> 请务必注意一点：`TypeScript 1.5` 里术语名已经发生了变化。\"`内部模块`\" 现在被称作 \"`命名空间`\"。\"`外部模块`\" 现在则简称为 \"`模块`\"。这是为了与 `ECMAScript 2015` 里的术语保持已一致， (也就是说 `module X` { 相当于现在推荐的写法 `namespace X` })\n\n### 15.2 介绍\n\n1. 从 `ECMAScript 2015` 开始，`JavaScript` 引入了模块的概念。`TypeScript` 也沿用这个概念。\n2. 模块在其自身的作用域里执行，而不是在全局作用域；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用 `export` 形式之一导出它们。相反，如果想使用其它模块导出的 `变量`，`函数`，`类`，`接口` 等的时候，你必须要导入它们，可以使用 `import` 形式之一。\n3. 模块是自声明的；两个模块之间的关系是通过在文件级别上使用 `import` 和 `exports` 建立的。\n4. 模块使用模块加载器去导入其它的模块。在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。大家最熟知的 `JavaScript` 模块加载器是服务与 `Node.js` 的 `CommonJS` 和 服务于 `Web` 应用的 `Require.js`。\n5. `TypeScript` 和 `ECMAScript 2015` 一样，任何包含顶级 `import` 或者 `export` 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 `import` 或者 `export` 声明，那么它的内容将被视为全局可见的 (因此对模块也是可见的)。\n\n### 15.3 导出\n\n#### 15.3.1. 导出声明\n\n> 任何声明( 比如 `变量`，`函数`，`类`，`类型别名` 或 `接口` )都能够通过添加 `export` 关键字来导出。\n\n```typescript\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\nexport const numberRegexp = /^[0-9]+$/;\nexport class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n```\n\n#### 15.3.2 导出语句\n\n> 导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：\n\n```typescript\nclass ZipCodeValidator1 implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\nexport { ZipCodeValidator1 };\nexport { ZipCodeValidator1 as mainValidator };\n```\n\n#### 15.3.3 重新导出\n\n> 我们经常会去扩展其它模块，并且只导出那个模块的那部分内容。\n\n> 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。\n\n```typescript\nexport class ParseIntBasedZipCodeValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && parseInt();\n  }\n}\n// 导出原先的验证器但做了重命名\nexport { ZipCodeValidator as RegExpBasedZipCodeValidator } from \"./ZipCodeValidator\";\n```\n\n> 或者一个模块可以包裹多个模块，并把它们导出的内容联合在一起，通过语法：`export * from \"module\"`\n\n```typescript\nexport * from \"./StringValidator\";\nexport * from \"./LetterOnlyValidator\";\nexport * from \"./ZipCodeValidator\";\n```\n\n### 15.4 导入\n\n> 模块的导入操作与导出一样简单，可以使用以下 `import` 形式之一来导入其它模块中的导出内容。\n\n#### 15.4.1 导入一个模块中的某个导出内容\n\n```typescript\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nlet myValidator = new ZipCodeValidator();\n```\n\n> 可以对导入内容重命名\n\n```typescript\nimport { ZipCodeValidator as ZCV } from \"./ZipCodeValidator\";\nlet myValidator = new ZCV();\n```\n\n#### 15.4.2 将整个模块导入到一个变量，并通过它来访问模块的导出部分\n\n```typescript\nimport * as validator from \"./ZipCodeValidator\";\nlet myValidator = new validator.ZipCodeValidator();\n```\n\n#### 15.4.3 具有副作用的导入模块\n\n> 尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。这些模块可能没有任何的导出或用户根本\n\n> 就不关注它的导出。使用下面的方法来导入这些模块。\n\n```typescript\nimport \"./my-module.js\";\n```\n\n### 15.5 默认导出\n\n> 每个模块都可以有一个 `default` 导出。默认导出使用 `default` 关键字标记；并且一个模块只能够有一个 `default` 导出。需要使用 一种特殊的导入形式来导入 `default` 导出。\n\n> `default` 导出十分便利。比如，像 `JQuery` 这样的类库可能有一个默认导出 `jQuery` 或 `$`，并且我们基本上也会使用同样的名字 `jQuery` 或 `$` 导出 `JQuery`。\n\n- `JQuery.d.ts`\n\n```typescript\ndeclare let $: JQuery;\nexport default $;\n```\n\n- `App.ts`\n\n```typescript\nimport $ from \"JQuery\";\n$(\"button.continue\").html(\"Next step ...\");\n```\n\n> 类和函数声明可以直接被标记为默认导出。标记为默认导出的类和函数的名字是可以省略的。\n\n- `ZipCodeValidator.ts`\n\n```typescript\nexport default class ZipCodeValidator {\n  static numberRegExp = /^[0-9]+$/;\n  isAcceptable(s: string) {\n    return s.length === 5 && ZipCodeValidator.numberRegExp.test(s);\n  }\n}\n```\n\n- `Test.ts`\n\n```typescript\nimport validator from \"./ZipCodeValidator\";\nlet myValidator = new validator();\n```\n\n> `或者`\n\n- `StaticZipCodeValidator.ts`\n\n```typescript\nconst numberRegExp = /^[0-9]+$/;\nexport default function (s: string) {\n  return s.length === 5 && numberRegExp.test(s);\n}\n```\n\n- `Test.ts`\n\n```typescript\nimport validate from \"./StaticZipCodeValidator\";\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// use function validate\nstrings.forEach(s => {\n  console.log(`\"${s}\" ${validate(s)} ? \" matches\" : \" does not match\"`);\n});\n```\n\n> `default` 导出也可以是一个值\n\n- `OneTwoThree.ts`\n\n```typescript\nexport default \"123\";\n```\n\n- `Log.ts`\n\n```typescript\nimport num from \"./OneTwoThree\";\nconsole.log(num); // 123\n```\n\n> `export =` 和 `import = require()`\n\n1. `CommonJS` 和 `AMD` 的环境里都有一个 `exports` 变量，这个变量包含了一个模块的所有导出内容。\n2. `CommonJS` 和 `AMD` 的 `exports` 都可以被赋值为一个对象，这种情况下其作用就类似于 es6 语法里的默认导出，即 `export default` 语法了。虽然作用相似，但是 `export default` 语法并不能兼容 `CommonJS` 和 `AMD` 的 `exports`。\n3. 为了支持 `CommonJS` 和 `AMD` 的 `exports`，`TypeScript` 提供了 `export =` 语法。\n4. `export =` 语法定义一个模块的导出对象。这里的对象一词指的是类，接口，命名空间，函数或枚举。\n5. 若使用 `export =` 导出一个模块，则必须使用 `TypeScript` 的特定语法 `import module = require('module')` 来导入此模块。\n\n- `ZipCodeValidator.ts`\n\n```typescript\nlet numberRegExp = /^[0-9]+$/;\n\nclass ZipCodeValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegExp.test(s);\n  }\n}\n\nexport = ZipCodeValidator; // 重点\n```\n\n- `Test.ts`\n\n```typescript\nimport zip = require(\"./ZipCodeValidator\"); // 重点\n\nlet strings = [\"Hello\", \"98502\", \"101\"];\nlet validator = new zip();\nstrings.forEach(s => {\n  console.log(`\"${s}\" - ${validator.isAcceptable(s) ? \"matches\" : \"does not match\"}`);\n});\n```\n\n### 15.6 生成模块代码\n\n> 根据编译时指定的模块目标参数，编译器会生成相应的供 `Node.js\\(CommonJS\\)，Require.js\\(AMD\\)`，`UMD`，`SystemJS` 或 `ECMAScript 2015 native module\\(ES6\\)` 模块加载系统使用的代码。\n\n> 想要了解生成代码中 `define`，`require` 和 `register` 的意义，需要参考相应的模块加载器的文档。\n\n- `SimpleModule.ts`\n\n```typescript\nimport m = require(\"mod\");\nexport let t = m.something + 1;\n```\n\n- `AMD / RequireJS SimpleModule.js`\n\n```typescript\ndefine([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) {\n  exports.t = mod_1.something + 1;\n});\n```\n\n- `CommonJS / Node SimpleModule.js`\n\n```typescript\nimport mod_1 = require(\"./mod\");\nexports.t = mod_1.something + 1;\n```\n\n- `UMD SimpleModule.js`\n\n```typescript\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    let v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([\"require\", \"exports\", \"./mod\"], factory);\n  }\n})(function (require, exports) {\n  let mod_1 = require(\"./mod\");\n  exports.t = mod_1.something + 1;\n});\n```\n\n- `System SimpleModule.js`\n\n```typescript\nSystem.register([\"./mod\"], function (exports_1) {\n  let mod_1;\n  let t;\n  return {\n    setters: [\n      function (mod_1_1) {\n        mod_1 = mod_1_1;\n      }\n    ],\n    execute: function () {\n      exports_1(\"t\", (t = mod_1.something + 1));\n    }\n  };\n});\n```\n\n- `Native ECMAScript 2015 modules SimpleModule.js`\n\n```typescript\nimport { something } from \"./mod\";\nexport let t = something + 1;\n```\n\n### 15.7 简单示例\n\n> 下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。\n\n> 为了编译，我们必须要在命令行上指定一个模块目标。对于 `Node.js` 来说，使用 `--module commonjs`；对于 `Require.js` 来说，使用 `--module amd`。\n\n- 比如：\n\n```typescript\ntsc --module commonjs Test.ts\n```\n\n> 编译完成后，每个模块会生成一个单独的 `.js` 文件。好比使用了 `reference` 标签，编译器会根据 `import` 语句编译相应的文件。\n\n- `Validation.ts`\n\n```typescript\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n```\n\n- `LetterOnlyValidator.ts`\n\n```typescript\nimport { StringValidator } from \"./Validation\";\nconst lettersRegExp = /^[A-Za-z]+$/;\n\nexport class LetterOnlyValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return lettersRegExp.test(s);\n  }\n}\n```\n\n- `ZipCodeValidator.ts`\n\n```typescript\nimport { StringValidator } from \"./Validation\";\nconst numberRegExp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return s.length === 5 && numberRegExp.test(s);\n  }\n}\n```\n\n- `Test.ts`\n\n```typescript\nimport { StringValidator } from \"./Validation\";\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nimport { LetterOnlyValidator } from \"./LetterOnlyValidator\";\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LetterOnlyValidator();\n\n// Show whether each string passed each validator\nstrings.forEach(s => {\n  for (let name in validators) {\n    console.log(`\"${s}\" - ${validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"} ${name}`);\n  }\n});\n```\n\n### 15.8 可选的模块加载和其它高级加载场景\n\n1. 有时候，你只想在某种条件下才加载某个模块。在 `TypeScript` 里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且保证类型完全。\n2. 编译器会检测是否每个模块都会在生成的 `JavaScript` 中用到。如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 `require` 这个模块的代码。省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。\n3. 这种模式的核心是 `import id = require(\"...\")` 语句可以让我们访问模块导出的类型。模块加载器会被动态调用(通过 `require`)，就像下面的 `if` 代码块里那样。它利用了省略引用的优化，所以模块只在被需要时加载。为了让这个模块工作，一定要注意 `import` 定义的标识符只能在表示类型处使用(不能在会转换成 `JavaScript` 的地方。)\n4. 为了确保类型安全性，我们可以使用 `typeof` 关键字。`typeof` 关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。\n\n- `示例 1`. `Node.js` 里的动态模块加载\n\n```typescript\ndeclare function require(moduleName: string): any;\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\nif (needZipValidator) {\n  let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");\n  let validator = new ZipCodeValidator();\n  if (validator.isAcceptable(\"...\")) {\n    /!* ... *!/;\n  }\n}\n```\n\n- `示例 2`. `require.js` 里的动态模块加载\n\n```typescript\ndeclare function require(moduleNames: string[], onLoad: (...args: any[]) => void): void;\nimport * as Zip from \"./ZipCodeValidator\";\nif (needZipValidator) {\n  require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) => {\n    let validator = new ZipCodeValidator.ZipCodeValidator();\n    if (validator.isAcceptable(\"...\")) {\n      /!* ... *!/;\n    }\n  });\n}\n```\n\n- `示例 3`. `System.js` 里的动态模块加载\n\n```typescript\ndeclare const System: any;\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\nif (needZipValidator) {\n  System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) => {\n    var x = new ZipCodeValidator();\n    if (x.isAcceptable(\"...\")) {\n      /!*...*!/;\n    }\n  });\n}\n```\n\n### 15.9 使用其它的 JavaScript 库\n\n> 要想描述非 `TypeScript` 编写的类库的类型，我们需要声明类库所暴露的 `API`。\n\n> 我们叫它声明因为它不是'外部程序'的具体实现，它们通常是在 `.d.ts` 文件里定义的。类似于 `C/C++` 里的 `.h` 文件。\n\n#### 15.9.1 外部模块\n\n> 在 `Node.js` 里大部分工作是通过加载一个或多个模块实现的。我们可以使用顶级的 `export` 声明来为每个模块都定义一个 `.d.ts` 文件，但最好还是写在一个大的 `.d.ts` 文件里。我们使用与构造一个外部命名空间相似的方法，但是这里使用 `module` 关键字并且把名字用引号括起来，方便之后 `import`。\n\n- `例如：`\n- `node.d.ts(simplified except)`\n\n```typescript\ndeclare module \"url\" {\n  export interface Url {\n    protocol?: string;\n    hostname?: string;\n    pathname?: string;\n  }\n\n  export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;\n}\n\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export let sep: string;\n}\n```\n\n> 现在我们可以 `/// <reference> node.d.ts` 并且使用 `import url = require('url')`；或 `import * as URl from \"url\"` 加载模块。`\n\n```typescript\n/// <reference path=\"node.d.ts\">\nimport * as URL from \"url\";\n\nlet myUrl = URL.parse(\"http://www.typescriptlang.org\");\n```\n\n#### 15.9.2 外部模块简写\n\n> 假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。\n\n> `declarations.d.ts`\n\n```typescript\ndeclare module \"hot-new-module\";\n```\n\n- 简写模块里所有导出类型将是 `any`\n\n```typescript\nimport x, { y } from \"hot-new-module\";\nx(y);\n```\n\n#### 15.9.3 模块声明通配符\n\n> 某些模块加载器如 `SystemJS` 和 `AMD` 支持导入非 `JavaScript` 内容。它们通常会使用一个前缀或后缀来表示特殊的加载语法，模块声明通配符可以用来表示这些情况。\n\n```typescript\ndeclare module \"*!text\" {\n  const content: string;\n  export default content;\n}\n```\n\n- `some do it the other way around`\n\n```typescript\ndeclare module \"json!*\" {\n  const value: any;\n  export default value;\n}\n```\n\n- 现在你可以就导入匹配 `\"!text\"` 或 `\"json!\"` 的内容了。\n\n```typescript\nimport fileContent from \"./xyz.txt!txt\";\nimport data from \"json!http://example.com/data.json\";\nconsole.log(data, fileContent);\n```\n\n#### 15.9.4 `UMD` 模块\n\n> 有些模块被设计成兼容多个模块加载器，或者不使用模块加载器(全局变量)。它们以 `UMD` 模块为代表。这些库可以通过导入的形式或全局变量的形式访问。\n\n- `例如：`\n- `math-lib.d.ts`\n\n```typescript\nexport function isPrime(x: number): boolean;\nexport as namespace mathLib;\n```\n\n- 之后，这个库可以在某个模块里通过导入来使用:\n\n```typescript\nimport { isPrime } from \"math-lib\";\nisPrime(2);\nmathLib.isPrime(2);\n```\n\n- 它同样可以通过全局变量的形式使用，但只能在某个脚本(指不带有模块导入或导出的脚本文件)里。\n\n```typescript\nmathLib.isPrime(2);\n```\n\n### 15.10 创建模块结构指导\n\n#### 15.10.1 尽可能地在顶层导出\n\n1. 用户应该更容易地使用你模块导出的内容。嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。\n2. 从你的模块中导出一个命名空间就是一个增加嵌套的例子。虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。这对用户来说是很不方便的并且通常是多余的。\n3. 导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。除非它能方便地表述或便于清晰使用，否则请考虑直接导出一个辅助方法。\n\n#### 15.10.2 如果仅导出单个 `class` 或 `function`，使用 `export default`\n\n> 就像\" `在顶层导出` \"帮助减少用户使用的难度，一个默认的导出也能起到这个效果。如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。这会令模块的导入和使用变得些许简单，比如：\n\n- `MyClass.ts`\n\n```typescript\nexport default class SomeType {\n  constructor() {\n    /!* ... *!/;\n  }\n}\n```\n\n- `MyFunc.ts`\n\n```typescript\nexport default function getThing() {\n  return \"thing\";\n}\n```\n\n- `Consumer.ts`\n\n```typescript\nimport t from \"./MyClass\";\nimport f from \"./MyFunc\";\nlet x = new t();\nconsole.log(f());\n```\n\n> 对用户来说这是最理想的。他们可以随意命名导入模块的类型 (本例为 `t` ) 并且不需要多余的 ( `.` ) 来找到相关对象。\n\n#### 15.10.3 如果要导出多个对象，把它们放在顶层里导出\n\n- `MyThings.ts`\n\n```typescript\nexport class SomeType {/!*...*!/}\nexport function someFunc() {\n    /*...*/\n}\n```\n\n#### 15.10.4 (相反地，当导入的时候)明确地列出导入的名字。\n\n- `Consumer.ts`\n\n```typescript\nimport { SomeType, someFunc } from \"./MyThings\";\nlet x = new SomeType();\nlet y = someFunc();\n```\n\n#### 15.10.5 使用命名空间导入模式当你要导出大量内容的时候\n\n- `MyLargeModule.ts`\n\n```typescript\nexport class Dog {}\nexport class Cat {}\nexport class Tree {}\nexport class Flower {}\n```\n\n- `Consumer.ts`\n\n```typescript\nimport * as myLargeModule from \"./MyLargeModule.ts\";\nlet x = new myLargeModule.Dog();\n```\n\n#### 15.10.6 使用重新导出进行扩展\n\n> 你可能经常需要扩展一个模块的功能。`JS` 里常用的一个模式是 `JQuery` 那样去扩展原对象。如我们之前提到的，模块不会像全局命名空间那样去合并。推荐的方案是 不要去改变原来的对象，而是导出一个新的实体来提供新的功能。\n\n> 假设 `Calculator.ts` 模块里定义了一个简单的计算器实现。这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。\n\n- `Calculator.ts`\n\n```typescript\nexport class Calculator {\n  private current = 0;\n  private memory = 0;\n  private operator: string;\n\n  protected static processDigit(digit: string, currentValue: number) {\n    if (digit >= \"0\" && digit <= \"9\") {\n      return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0));\n    }\n  }\n\n  protected static processOperator(operator: string) {\n    if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) >= 0) {\n      return operator;\n    }\n  }\n\n  protected evaluateOperator(operator: string, left: number, right: number): number {\n    switch (this.operator) {\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n    }\n  }\n\n  private evaluate() {\n    if (this.operator) {\n      this.memory = this.evaluateOperator(this.operator, this.memory, this.current);\n    } else {\n      this.memory = this.current;\n    }\n    this.current = 0;\n  }\n\n  public handleChar(char: string) {\n    if (char === \"=\") {\n      this.evaluate();\n      return;\n    } else {\n      let value = Calculator.processDigit(char, this.current);\n      if (value !== undefined) {\n        this.current = value;\n        return;\n      } else {\n        let value = Calculator.processOperator(char);\n        if (value !== undefined) {\n          this.evaluate();\n          this.operator = value;\n          return;\n        }\n      }\n    }\n    throw new Error(`Unsupported input: '${char}'`);\n  }\n\n  public getResult() {\n    return this.memory;\n  }\n}\n\nexport function test(c: Calculator, input: string) {\n  for (let i = 0; i < input.length; i++) {\n    c.handleChar(input[i]);\n  }\n  console.log(`result of '${input}' is '${c.getResult()}'`);\n}\n```\n\n- 下面使用导出的 `test` 函数来测试计算器\n- `TestCalculator.ts`\n\n```typescript\nimport { Calculator, test } from \"./Calculator\";\nlet c = new Calculator();\ntest(c, \"1+2*33/11=\"); // prints 9\n```\n\n- 现在扩展它，添加支持输入其它进制(十进制以外)。\n- `ProgrammerCalculator.ts`\n\n```typescript\nimport { Calculator } from \"./Calculator\";\nclass ProgrammerCalculator extends Calculator {\n  static digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n  constructor(public base: number) {\n    super();\n    const maxBase = ProgrammerCalculator.digits.length;\n    if (base <= 0 || base > maxBase) {\n      throw new Error(`base has to be within 0 to ${maxBase} inclusive`);\n    }\n  }\n  protected processDigit(digit: string, currentValue: number) {\n    if (ProgrammerCalculator.digits.indexOf(digit) >= 0) {\n      return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);\n    }\n  }\n}\nexport { ProgrammerCalculator as Calculator };\nexport { test } from \"./Calculator\";\n```\n\n> 新的 `ProgrammerCalculator` 模块导出的 API 与原先的 `Calculator` 模块很相似，但却没有改变原模块里的对象。\n\n- `TestProgrammerCalculator.ts`\n\n```typescript\nimport { Calculator, test } from \"./ProgrammerCalculator\";\nlet c = new Calculator(2);\ntest(c, \"001+010=\"); // prints 3\n```\n\n#### 15.10.7 模块里不要使用命名空间\n\n> 当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。记住这点，命名空间在使用模块时几乎没什么价值。\n\n> 在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型分组是很便利的。例如，在 `C\\#` 里，你会从 `System.Collections` 里找到所有集合的类型。通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。然而，模块本身已经存在于文件系统之中，这是必须的。我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。我们可以创建 `/collections/generic/` 文件夹，把相应模块放在这里。\n\n> 命名空间对解决全局作用域里命名冲突来说是很重要的。比如，你有一个 `My.Application.Customer.AddFrom` 和 `My.Application.Order.AddForm` `--` 两个类型的名字相同，但命名空间不同。然而，这对于模块来说却不是一个问题。在一个模块里，没有理由两个对象拥有同一个名字。从模块的使用角度来说，使用者会挑出它们用来引用模块的名字，所以也没有理由发声重名的情况。\n\n#### 15.10.8 危险信号\n\n> 以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间。\n\n1. 文件的顶层声明是 `export namespace Foo {...}` ( 删除 `Foo` 并把所有内容向上层移动一层)\n2. 文件只有一个 `export class` 或 `export function` (考虑使用 `export default`)\n3. 多个文件的顶层具有同样的 `export namespace Foo` {( 不要以为这些会合并到一个 `Foo` 中! )}\n\n## 十六、命名空间\n\n### 16.1 介绍\n\n> 这篇文章描述了如何在 `TypeScript` 里使用命名空间(之前叫做\"内部模块\")来组织你的代码。就像我们在术语说明里提到的那样，`\"内部模块\"` 现在叫做 `\"命名空间\"`。另外，任何使用 `module` 关键字来声明一个内部模块的地方都应该使用 `namespace` 关键字来替换。这就避免了让新的使用者被相似的名称所迷惑。\n\n- `第一步`\n\n> 我们先来写一段程序并将在整篇文章中都使用这个例子。我们定义几个简单的字符串验证器，\n\n> 假设你会使用它们来验证表单里的用户输入或验证外部数据。\n\n- `所有验证器都放在一个文件里`\n\n```typescript\ninterface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n\nlet letterRegExp = /^[A-Za-z]$/;\nlet numberRegExp = /^[0-9]+$/;\n\nclass LetterOnlyValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return letterRegExp.test(s);\n  }\n}\n\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return s.length === 5 && numberRegExp.test(s);\n  }\n}\n\nlet strings = [\"Hello\", \"98052\", \"101\"];\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters Only\"] = new LetterOnlyValidator();\n// show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    let isMatch = validators[name].isAcceptable(s);\n    console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\n```\n\n### 16.2 命名空间\n\n> 随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。因此，我们把验证器包裹到一个命名空间里内，而不是把它们放在全局空间下。\n\n> 下面的例子里，把所有与验证器相关的类型都放到一个叫做 `Validation` 的命名空间里。因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 `export`。相反的，变量 `LetterRegExp` 和 `numberRegExp` 是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。在文件末尾的测试代码里，由于是在命名空间之外访问的，因此需要限定类型的名称，比如 `Validation.LettersOnlyValidator`。\n\n- 使用命名空间的验证器\n\n```typescript\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n\n  const LetterRegExp = /^[A-Za-z]+$/;\n  const numberRegExp = /^[0-9]+$/;\n\n  export class LetterOnlyValidator implements StringValidator {\n    isAcceptable(s: string): boolean {\n      return LetterRegExp.test(s);\n    }\n  }\n\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string): boolean {\n      return s.length === 5 && numberRegExp.test(s);\n    }\n  }\n}\nlet strings = [\"Hello\", \"98052\", \"101\"];\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP Code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters Only\"] = new Validation.LetterOnlyValidator();\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(`'${s}' ${validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\n```\n\n### 16.3 分离到多文件\n\n> 当应用变得越来越大时，我们需要将代码分离到不同的文件中以方便维护。\n\n#### 16.3.1 多文件中的命名空间\n\n> 现在，我们把 `Validation` 命名空间分割成多个文件。尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。\n\n- `Validation.ts`\n\n```typescript\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\n```\n\n- `LetterOnlyValidator.ts`\n\n```typescript\n/// <reference path=\"Validation.ts\" />;\nnamespace Validation {\n  const lettersRegExp = /^[A-Za-z]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string): boolean {\n      return lettersRegExp.test(s);\n    }\n  }\n}\n```\n\n- `ZipCodeValidator.ts`\n\n```typescript\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const numberRegExp = /^[0-9]+$/;\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string): boolean {\n      return s.length === 5 && numberRegExp.test(s);\n    }\n  }\n}\n```\n\n- `Test.ts`\n\n```typescript\n/// <reference path=\"Validation.ts\" />\n/// <reference path=\"LettersOnlyValidator.ts\" />\n/// <reference path=\"ZipCodeValidator.ts\" />\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(`\"${s}\" - ${validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"} ${name}`);\n  }\n}\n```\n\n> 当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。我们有两种方式。\n\n1. 第一种方式，把所有的输入文件编译为一个输出文件，需要使用 `--outFile` 标记： `tsc --outFile sample.js Test.ts` 编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。 `tsc --outFile sample.js Validation.ts LetterOnlyValidator.ts ZipCodeValidator.ts Test.ts`\n2. 第二种方式，我们可以编写每一个文件(默认方式)，那么每个源文件都会对应生成一个 `JavaScript` 文件。然后，在页面上通过 `<script>` 标签把所有生成的 `JavaScript` 文件按正确的顺序引进来，比如：\n\n```html\nMyTestPage.html (excerpt)\n<script src=\"Validation.js\" type=\"text/javascript\" />\n<script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n<script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n<script src=\"Test.js\" type=\"text/javascript\" />\n```\n\n### 16.4 别名\n\n> 另一种简化命名空间操作的方法是用 `import q = x.y.z` 给常用的对象起一个短的名字。不要与用来加载模块的 `import x = require('name')` 语法弄混了，这里的语法是为指定的符号创建一个别名。你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。\n\n```typescript\nnamespace Shapes {\n  export namespace Polygons {\n    export class Triangle {}\n    export class Square {}\n  }\n}\nimport Polygons = Shapes.Polygons;\nlet sq = new Polygons.Square(); // Same as \"new Shapes.Polygons.Square()\"\n```\n\n> 注意：我们并没有使用 `require` 关键字，而是直接使用导入符号的限定名赋值。这与使用 `var` 相似，但它还适用于类型和导入的具有命名空间含义的符号。重要的是，对于值来讲，`import` 会生成与原始符号不同的引用，所以改变别名的 `var` 值并不会影响原始变量的值。\n\n### 16.5 使用其它的 JavaScript 库\n\n> 为了描述不是用 `TypeScript` 编写的类库的类型，我们需要声明类库导出的 `API`。由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。我们称其为声明是因为它不是外部程序的具体实现。我们通常在 `.d.ts` 里写这些声明。如果你熟悉 `C/C+`+，你可以把它们当作 `.h` 文件。\n\n> 外部命名空间 (`declare namespace =>`; 声明全局对象)\n\n> 流行的程序库 `D3` 在全局对象 `d3` 里定义它的功能。因为这个库通过一个`<script>` 标签加载 (不是通过模块加载器)，它的声明文件使用内部模块来定义它的类型。为了让 `TypeScript` 编译器识别它的类型，我们使用外部命名空间声明。\n\n- 比如，我们可以像下面这样写\n- `D3.d.ts`\n\n```typescript\ndeclare namespace D3 {\n  export interface Selectors {\n    select: {\n      (selector: string): Selection;\n      (element: EventTarget): Selection;\n    };\n  }\n\n  export interface Event {\n    x: number;\n    y: number;\n  }\n\n  export interface Base extends Selectors {\n    event: Event;\n  }\n}\ndeclare var d3: D3.Base;\n```\n\n## 十七、命名空间和模块\n\n### 17.1 介绍\n\n> 这篇文章将概括介绍在 `TypeScript` 里使用模块与命名空间来组织代码的方法。我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。\n\n### 17.2 使用命名空间\n\n> 命名空间是位于全局命名空间下的一个普通的带有名字的 `JavaScript` 对象。这令命名空间十分容易使用。它们可以在多文件中同时使用，并通过 `--outFile` 结合在一起。命名空间是帮你组织 `Web` 应用不错的方式，你可以把所有依赖都放在 `HTML` 页面的 `<script>` 标签里。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型应用中。\n\n### 17.3 使用模块\n\n1. 像命名空间一样，模块可以包含代码和声明。不同的模块可以声明它的依赖。\n2. 模块会把依赖添加到模块加载器上(像是 `CommonJS` / `RequireJS`)。对于小型的 JS 应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。\n3. 对于 `Node.js` 应用来说，模块是默认并推荐的组织代码的方式。\n4. 从 `ECMAScript 2015` 开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。\n\n> 因此，对于新项目来说推荐使用模块作为组织代码的方式。\n\n### 17.4 命名空间和模块的陷阱\n\n> 这部分我们会描述常见的命名空间和模块的使用陷阱和如何其避免它们。\n\n#### 17.4.1 对模块使用 `/// <reference>`\n\n> 一个常见的错误是使用 `/// <reference>` 引用模块文件，应该使用 `import`。要理解这之间的差别，我们首先应该弄清编译器是如何根据 `import` 路径(例如：`import x from \"...\"`；或 `import x = require(\"...\")` 里面的 `...`，等等)来定位模块的类型信息的。\n\n> 编译器首先尝试去查找相应路径下的 `.ts`，`.tsx` 再或者 `.d.ts`。如果这些文件都找不到，编译器会查找外部模块声明。回想一下，它们是在 `.d.ts` 文件里声明的。\n\n- `myModules.d.ts`\n\n```typescript\n// In a .d.ts file or .ts file that is not a module\ndeclare module \"SomeModule\" {\n  export function fn(): string;\n}\n```\n\n- `myOtherModule.ts`\n\n```typescript\n/// <reference path=\"myModules.d.ts\">\nimport * as m from \"SomeModule\";\n```\n\n> 这里的引用标签指定了外来模块的位置。这就是一些 `TypeScript` 例子中引用 `node.d.ts` 的方法。\n\n#### 17.4.2 不必要的命名空间\n\n> 如果你想把命名空间转换为模块，它可能会像下面这个文件一样。\n\n- `shapes.ts`\n\n```typescript\nexport namespace Shapes {\n  export class Triangle {\n    /* ... */\n  }\n  export class Square {\n    /* ... */\n  }\n}\n```\n\n> 顶层的模块 `Shapes` 包裹了 `Triangle` 和 `Square`。对于使用它的人来说这是令人迷惑和讨厌的。\n\n- `shapeConsumer.ts`\n\n```typescript\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n```\n\n> `TypeScript` 里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。再次重申，不应该对模块使用命名空间。使用命名空间是为了提供逻辑分组和避免命名冲突。模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。\n\n- 下面是改进的例子：\n- `shape.ts`\n\n```typescript\nexport class Triangle {\n  /* ... */\n}\nexport class Square {\n  /* ... */\n}\n```\n\n- `shapeConsumer.ts`\n\n```typescript\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Triangle();\n```\n\n#### 17.4.3 模块的取舍\n\n> 就像每个 `JS` 文件对应一个模块一样，`TypeScript` 里模块文件与生成的 `JS` 文件也是一一对应的。这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。例如当目标模块系统为 `commonjs` 或 `umd` 时，无法使用 `outFile` 选项，但是 `TypeScript 1.8` 以上的版本能够使用 `outFile` 当目标为 `amd` 或 `system`。\n\n## 十八、模块解析\n\n### 18.1 说明\n\n1. 模块解析是指编译器在查找导入模块内容时所遵循的流程。假设有一个导入语句 `import { a } from \"moduleA\"`; 为了去检查任何对 `a` 的使用，编译器需要准确的知道它表示什么，并且需要检查它的定义 `moduleA`。\n2. 这时候，编译器会有个疑问“ `moduleA` 的结构是怎样的？” 这听上去很简单，但 moduleA 可能在你写的某个 .ts/.tsx 文件里或者在你的代码所依赖的 `.d.ts` 里。\n3. 首先，编译器会尝试定位表示导入模块的文件。编译器会遵循以下二种策略之一： `Classic` 或 `Node`。这些策略会告诉编译器到哪里去查找 `moduleA`。\n4. 如果上面的解析失败了并且模块名是非相对的（且是在\" `moduleA` \"的情况下），编译器会尝试定位一个外部模块声明。我们接下来会讲到非相对导入。\n\n`5`. 最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为 `error TS2307: Cannot find module 'moduleA'.`\n\n### 18.2 相对 vs. 非相对模块导入\n\n> 根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。\n\n1. 相对导入是以 `/，./` 或 `../` 开头的。 下面是一些例子：\n\n```typescript\nimport Entry from \"./components/Entry\";\nimport { Default } from \"../constants/http\";\nimport \"/mod\";\n```\n\n2. 所有其它形式的导入被当作非相对的。下面是一些例子：\n\n```typescript\nimport * as $ from \"JQuery\";\nimport { Component } from \"@angular/core\";\n```\n\n> 相对导入在解析时是相对于导入它的文件，并不能解析为一个外部模块声明。你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。\n\n> 非相对模块的导入可以相对于 baseUrl 或 通过下文会讲到的路径映射来解析。它们还可以被解析成 外部模块声明。\n\n> 使用非相对路径来导入你的外部依赖。\n\n### 18.3 模块解析策略\n\n> 共有两种可用的模块解析策略：`Node` 和 `Classic`。 你可以使用 `--moduleResolution` 标记来指定使用哪种模块解析策略。若未指定，那么在使用了 -`-module AMD \\| System \\| ES2015` 时的默认值为 `Classic`，其它情况时则为 `Node`。\n\n#### 18.3.1 Classic\n\n> 这种策略在以前是 `TypeScript` 默认的解析策略。 现在，它存在的理由主要是为了向后兼容。\n\n> 相对导入的模块是相对于导入它的文件进行解析的。 因此 `/root/src/folder/A.ts` 文件里的 `import { b } from \"./moduleB\"` 会使用下面的查找流程：\n\n1. /root/src/folder/moduleB.ts``\n2. /root/src/folder/moduleB.d.ts``\n\n> 对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。\n\n- `比如：`\n\n> 有一个对 `moduleB` 的非相对导入 `import { b } from \"moduleB\"`，它是在 `/root/src/folder/A.ts` 文件里，会以如下的方式来定位\"`moduleB`\"：\n\n> 1. `/root/src/folder/moduleB.ts`\n> 2. `/root/src/folder/moduleB.d.ts`\n> 3. `/root/src/moduleB.ts`\n> 4. `/root/src/moduleB.d.ts`\n> 5. `/root/moduleB.ts`\n> 6. `/root/moduleB.d.ts`\n> 7. `/moduleB.ts`\n> 8. `/moduleB.d.ts`\n\n#### 18.3.2 Node\n\n> 这个解析策略试图在运行时模仿 `Node.js` 模块解析机制。完整的 `Node.js` 解析算法可以在 `Node.js module documentation` 找到。\n\n- Node.js 如何解析模块\n\n> 为了理解 `TypeScript` 编译依照的解析步骤，先弄明白`Node.js`模块是非常重要的。\n\n> 通常，在 `Node.js` 里导入是通过 `require` 函数调用进行的。 `Node.js` 会根据 `require` 是相对路径还是非相对路径做出不同的行为。\n\n> 相对路径很简单。 例如，假设有一个文件路径为 `/root/src/moduleA.js`，包含了一个导入 `var x = require(\"./moduleB\")`;\n\n- Node.js 以下面的顺序解析这个导入\n\n1. 检查 `/root/src/moduleB.js` 文件是否存在。\n2. 检查 `/root/src/moduleB` 目录是否包含一个 `package.json` 文件，且 `package.json` 文件指定了一个\"`main`\"模块。\n\n> 在我们的例子里，如果 `Node.js` 发现文件 `/root/src/moduleB/package.json` 包含了 `{ \"main\": \"lib/mainModule.js\" }`，那么 `Node.js` 会引用 `/root/src/moduleB/lib/mainModule.js`。\n\n3. 检查 `/root/src/moduleB` 目录是否包含一个 `index.js` 文件。 这个文件会被隐式地当作那个文件夹下的\"`main`\"模块。\n\n你可以阅读 `Node.js` 文档了解更多详细信息：[file modules](https://nodejs.org/api/modules.html#modules_file_modules) 和 [folder modules](https://nodejs.org/api/modules.html#modules_folders_as_modules)。\n\n> 但是，非相对模块名的解析是个完全不同的过程。`Node` 会在一个特殊的文件夹 `node\\_modules` 里查找你的模块。`node\\_modules` 可能与当前文件在同一级目录下，或者在上层目录里。`Node` 会向上级目录遍历，查找每个 `node\\_modules`直到它找到要加载的模块。\n> 还是用上面例子，但假设 `/root/src/moduleA.js` 里使用的是非相对路径导入 `var x = require(\"moduleB\")`;\n\n- `Node` 则会以下面的顺序去解析 `moduleB`，直到有一个匹配上。\n\n> 1.`/root/src/node_modules/moduleB.js` 2.`/root/src/node_modules/moduleB/package.json (如果指定了\"main\"属性)` 3.`/root/src/node_modules/moduleB/index.js` 4.`/root/node_modules/moduleB.js` 5.`/root/node_modules/moduleB/package.json (如果指定了\"main\"属性)` 6.`/root/node_modules/moduleB/index.js` 7.`/node_modules/moduleB.js` 8.`/node_modules/moduleB/package.json (如果指定了\"main\"属性)` 9.`/node_modules/moduleB/index.js`\n\n> 注意 `Node.js` 在步骤（`4`）和（`7`）会向上跳一级目录。\n> 你可以阅读 `Node.js` 文档了解更多详细信息：[loading modules from node_modules](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders)。\n\n- TypeScript 如何解析模块\n\n> `TypeScript` 是模仿 `Node.js` 运行时的解析策略来在编译阶段定位模块定义文件。因此，`TypeScript` 在 `Node` 解析逻辑基础上增加了 TypeScript 源文件的扩展名（ `.ts`，`.tsx` 和 `.d.ts`）。同时，`TypeScript` 在 `package.json` 里使用字段\"`types`\"来表示类似\"`main`\"的意义 `-` 编译器会使用它来找到要使用的\"`main`\"定义文件。\n\n> 比如，有一个导入语句 `import { b } from \"./moduleB\"` 在 `/root/src/moduleA.ts` 里，会以下面的流程来定位 `\"./moduleB\"` ：\n>\n> 1. `/root/src/moduleB.ts`\n> 2. `/root/src/moduleB.tsx`\n> 3. `/root/src/moduleB.d.ts`\n> 4. `/root/src/moduleB/package.json (如果指定了\"types\"属性)`\n> 5. `/root/src/moduleB/index.ts`\n> 6. `/root/src/moduleB/index.tsx`\n> 7. `/root/src/moduleB/index.d.ts`\n\n> 回想一下 `Node.js` 先查找 `moduleB.js` 文件，然后是合适的 `package.json`，再之后是 `index.js`。\n\n> 类似地，非相对的导入会遵循 `Node.js` 的解析逻辑，首先查找文件，然后是合适的文件夹。因此 `/root/src/moduleA.ts` 件里的 `import { b } from \"moduleB\"` 会以下面的查找顺序解析：\n>\n> 1. `/root/src/node_modules/moduleB.ts`\n> 2. `/root/src/node_modules/moduleB.tsx`\n> 3. `/root/src/node_modules/moduleB.d.ts`\n> 4. `/root/src/node_modules/moduleB/package.json (如果指定了\"types\"属性)`\n> 5. `/root/src/node_modules/moduleB/index.ts`\n> 6. `/root/src/node_modules/moduleB/index.tsx`\n> 7. `/root/src/node_modules/moduleB/index.d.ts`\n> 8. `/root/node_modules/moduleB.ts`\n> 9. `/root/node_modules/moduleB.tsx`\n> 10. `/root/node_modules/moduleB.d.ts`\n> 11. `/root/node_modules/moduleB/package.json (如果指定了\"types\"属性)`\n> 12. `/root/node_modules/moduleB/index.ts`\n> 13. `/root/node_modules/moduleB/index.tsx`\n> 14. `/root/node_modules/moduleB/index.d.ts`\n> 15. `/node_modules/moduleB.ts`\n> 16. `/node_modules/moduleB.tsx`\n> 17. `/node_modules/moduleB.d.ts`\n> 18. `/node_modules/moduleB/package.json (如果指定了\"types\"属性)`\n> 19. `/node_modules/moduleB/index.ts`\n> 20. `/node_modules/moduleB/index.tsx`\n> 21. `/node_modules/moduleB/index.d.ts`\n\n> 不要被这里步骤的数量吓到 `-` `TypeScript` 只是在步骤（`8`）和（`15`）向上跳了两次目录。 这并不比 `Node.js` 里的流程复杂。\n\n### 18.4 附加的模块解析标记\n\n> 1. 有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将 `.ts` 编译成 `.js`，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。\n> 2. `TypeScript` 编译器有一些额外的标记用来通知编译器在源码编译成最终输出的过程中都发生了哪个转换。\n> 3. 有一点要特别注意的是编译器不会进行这些转换操作；它只是利用这些信息来指导模块的导入。\n\n- `Base URL`\n\n> 在利用 `AMD` 模块加载器的应用里使用 `baseUrl` 是常见做法，它要求在运行时模块都被放到了一个文件夹里。这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。\n\n> 设置 `baseUrl` 来告诉编译器到哪里去查找模块。 所有 `非相对模块` 导入都会被当做相对于 `baseUrl`。\n\n- `baseUrl` 的值由以下两者之一决定：\n\n> 1. 命令行中 `baseUrl` 的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）\n> 2. `tsconfig.json`里的 `baseUrl` 属性（如果给定的路径是相对的，那么将相对于‘`tsconfig.json`’路径进行计算）\n\n> 注意相对模块的导入不会被设置的 `baseUrl` 所影响，因为它们总是相对于导入它们的文件。\n\n> 阅读更多关于 `baseUrl` 的信息 [RequireJS](https://requirejs.org/docs/api.html#config-baseUrl) 和 [`SystemJS`](https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl)。\n\n### 18.5 路径映射\n\n> 有时模块不是直接放在 `baseUrl` 下面。 比如，充分 \"`jquery`\"模块地导入，在运行时可能被解释为\"`node\\_modules/jquery/dist/jquery.slim.min.js`\"。 加载器使用映射配置来将模块名映射到运行时的文件，查看 [RequireJs documentation](https://requirejs.org/docs/api.html#config-paths) 和 [SystemJS documentation](https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths)。\n\n> `TypeScript` 编译器通过使用 `tsconfig.json` 文件里的 \"`paths`\" 来支持这样的声明映射。 下面是一个如何指定 `jquery` 的\"`paths`\"的例子。\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // This must be specified if \"paths\" is.\n    \"paths\": {\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"] // 此处映射是相对于\"baseUrl\"\n    }\n  }\n}\n```\n\n> 请注意\"`paths`\"是相对于\"`baseUrl`\"进行解析。 如果 \"`baseUrl`\" 被设置成了除\"`.`\"外的其它值，比如 `tsconfig.json` 所在的目录，那么映射必须要做相应的改变。如果你在上例中设置了 `\"baseUrl\": \"./src\"`，那么 `jquery` 应该映射到 `\"../node\\_modules/jquery/dist/jquery\"`。\n\n> 通过\"`paths`\"我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：\n\n```typescript\nprojectRoot\n├── folder1\n│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json\n```\n\n- 相应的 `tsconfig.json` 文件如下：\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"*\": [\"*\", \"generated/*\"]\n    }\n  }\n}\n```\n\n> 它告诉编译器所有匹配 `\"\\*\"`（所有的值）模式的模块导入会在以下两个位置查找：\n>\n> 1. `\"\\*\"`： 表示名字不发生改变，所以映射为  `=>` `/`\n> 2. \"`generated/`\"表示模块名添加了“`generated`”前缀，所以映射为 `<moduleName> => <baseUrl>/generated/<moduleName>`\n\n- `按照这个逻辑，编译器将会如下尝试解析这两个导入：`\n\n> (i). 导入`'folder1/file2'`\n>\n> 1. 匹配 `'\\*'` 模式且通配符捕获到整个名字。\n> 2. 尝试列表里的第一个替换：`'\\*' -> folder1/file2`。\n> 3. 替换结果为非相对名 - 与 `baseUrl` 合并 `-> projectRoot/folder1/file2.ts`。\n> 4. 文件存在。完成。\n>\n> (ii). 导入`'folder2/file3'`\n>\n> 1. 匹配 `'\\*'` 模式且通配符捕获到整个名字。\n> 2. 尝试列表里的第一个替换：`'\\*' -> folder2/file3`。\n> 3. 替换结果为非相对名 - 与 `baseUrl` 合并 `-> projectRoot/folder2/file3.ts`。\n> 4. 文件不存在，跳到第二个替换。\n> 5. 第二个替换：`'generated/' -> generated/folder2/file3`。\n> 6. 替换结果为非相对名 - 与 `baseUrl` 合并 `-&gt; projectRoot/generated/folder2/file3.ts`。\n> 7. 文件存在。完成。\n\n- 利用 `rootDirs` 指定虚拟目录\n\n> 有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。 利用 `rootDirs`，可以告诉编译器生成这个虚拟目录的 `roots`； 因此编译器可以在“虚拟”目录下解析相对模块导入，就好像它们被合并在了一起一样。\n\n> 比如，有下面的工程结构：\n\n```typescript\nsrc\n └── views\n     └── view1.ts (imports './template1')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports './view2')\n```\n\n> `src/views` 里的文件是用于控制 UI 的用户代码。 `generated/templates` 是 `UI` 模版，在构建时通过模版生成器自动生成。构建中的一步会将 `/src/views` 和 `/generated/templates/views` 的输出拷贝到同一个目录下。 在运行时，视图可以假设它的模版与它同在一个目录下，因此可以使用相对导入 `\"./template\"`。\n\n> 可以使用\"`rootDirs`\"来告诉编译器。\"`rootDirs`\"指定了一个 `roots` 列表，列表里的内容会在运行时被合并。\n\n> 因此，针对这个例子， `tsconfig.json` 如下：\n\n```json\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}\n```\n\n> 每当编译器在某一 `rootDirs` 的子目录下发现了相对模块导入，它就会尝试从每一个 `rootDirs` 中导入。\n\n> `rootDirs` 的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑( `bundles` )和运行时的特性，比如条件引入和工程特定的加载器插件。\n\n> 设想这样一个国际化的场景，构建工具自动插入特定的路径记号来生成针对不同区域的捆绑，比如将 `\\#{locale}` 做为相对模块路径 `./\\#{locale}/messages` 的一部分。在这个假定的设置下，工具会枚举支持的区域，将抽像的路径映射成 `./zh/messages`，`./de/messages` 等。\n\n> 假设每个模块都会导出一个字符串的数组。比如 `./zh/messages` 可能包含：\n\n```typescript\nexport default [\"您好吗\", \"很高兴认识你\"];\n```\n\n> 利用 `rootDirs` 我们可以让编译器了解这个映射关系，从而也允许编译器能够安全地解析 `./\\#{locale}/messages`，就算这个目录永远都不存在。比如，使用下面的 `tsconfig.json`：\n\n```json\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/zh\", \"src/de\", \"src/#{locale}\"]\n  }\n}\n```\n\n> 编译器现在可以将 `import messages from './#{locale}/messages'` 解析为 `import messages from './zh/messages'` 用做工具支持的目的，并允许在开发时不必了解区域信息。\n\n### 18.6 跟踪模块解析\n\n> 如之前讨论，编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过 `--traceResolution` 启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。\n\n> 假设我们有一个使用了 `typescript` 模块的简单应用。`app.ts` 里有一个这样的导入 `import * as ts from \"typescript\"`。\n\n```typescript\n│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts\n```\n\n> 使用 `--traceResolution` 调用编译器。\n\n```typescript\ntsc --traceResolution\n```\n\n> 输出结果如下：\n\n```typescript\n======== Resolving module 'typescript' from 'src/app.ts'. ========\nModule resolution kind is not specified, using 'NodeJs'.\nLoading module 'typescript' from 'node_modules' folder.\nFile 'src/node_modules/typescript.ts' does not exist.\nFile 'src/node_modules/typescript.tsx' does not exist.\nFile 'src/node_modules/typescript.d.ts' does not exist.\nFile 'src/node_modules/typescript/package.json' does not exist.\nFile 'node_modules/typescript.ts' does not exist.\nFile 'node_modules/typescript.tsx' does not exist.\nFile 'node_modules/typescript.d.ts' does not exist.\nFound 'package.json' at 'node_modules/typescript/package.json'.\n'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.\nFile 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.\n======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========\n```\n\n> 需要留意的地方：\n\n> 1. 导入的名字及位置 `======== Resolving module 'typescript' from 'src/app.ts'. ========`\n> 2. 编译器使用的策略 `Module resolution kind is not specified, using 'NodeJs'.`\n> 3. 从 `npm` 加载 `types` `'package.json' has 'types' field './lib/typescript.d.ts' that references 'node\\_modules/typescript/lib/typescript.d.ts'.`\n> 4. 最终结果 `======== Module name 'typescript' was successfully resolved to 'node\\_modules/typescript/lib/typescript.d.ts'. ========`\n\n- 使用 `--noResolve`\n\n> 正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件 `import`，这个文件被会加到一个文件列表里，以供编译器稍后处理。`--noResolve` 编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。\n\n> `比如`:\n\n- `app.ts`\n\n```typescript\nimport * as A from \"moduleA\"; // OK, moduleA passed on the command-line\nimport * as B from \"moduleB\"; // Error TS2307: Cannot find module 'moduleB'.\n```\n\n```typescript\ntsc app.ts moduleA.ts --noResolve\n```\n\n> 使用 `--noResolve` 编译 `app.ts`：\n\n> 1. 可能正确找到 `moduleA`，因为它在命令行上指定了。\n> 2. 找不到 `moduleB`，因为没有在命令行上传递。\n\n### 18.7 常见问题\n\n- 为什么在 `exclude` 列表里的模块还会被编译器使用\n\n> `tsconfig.json` 将文件夹转变一个“工程” 如果不指定任何 “`exclude`” 或 “`files`”，文件夹里的所有文件包括 `tsconfig.json` 和 所有的子目录 都会在编译列表里。 如果你想利用 “`exclude`”排除某些文件，甚至你想指定所有要编译的文件列表，请使用“`files`”。\n\n> 有些是被 `tsconfig.json` 自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。\n\n> 因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行 `import` 或使用了 `/// <reference path=\"...\" />` 指令的文件。\n\n## 十九、声明合并\n\n### 19.1 介绍\n\n> `TypeScript` 中有些独特的概念可以在类型层面上描述 `JavaScript` 对象的模型。这其中尤其独特的一个例子 \"声明合并\" 的概念。\n\n> 理解了这个概念，将有助于操作现有的 `JavaScript` 代码。同时，也会有助于理解更多高级抽象的概念。\n\n> 对本文件来讲，\"`声明合并`\" 是指编译器将针对同一个名字的两个独立声明合并为单一声明。合并后的声明同时拥有原先两个声明的特性。任何数量的声明都可被合并；不局限于两个声明。\n\n### 19.2 基础概念\n\n> `TypeScript` 中的声明会创建以下三种实体之一：`命名空间`，`类型` 或 `值`。创建命名空间的声明会新建一个命名空间，它包含了用(.)符号来访问时使用的名字。创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。\n> 最后，创建值的声明会创建在 `JavaScript` 输出中看到的值。\n\n| Declaration Type | Namespace | Type | Value |\n| :--------------- | :-------- | :--- | :---- |\n| `Namespace`      | X         |      | X     |\n| `Class`          |           | X    | X     |\n| `Enum`           |           | X    | X     |\n| `Interface`      |           | X    |       |\n| `Type Alias`     |           | X    |       |\n| `Function`       |           |      | X     |\n| `Variable`       |           |      | X     |\n\n> 理解每个声明创建了什么，有助于理解当声明合并时，有哪些东西被合并了。\n\n### 19.3 合并接口\n\n> 最简单最常见的声明合并类型是接口合并。从根本上说，合并的机制是把双方的成员放到一个同名的接口里。\n\n```typescript\ninterface Box {\n  height: number;\n  width: number;\n}\ninterface Box {\n  scale: number;\n}\nlet box: Box = { height: 5, width: 6, scale: 10 };\n```\n\n> 接口的非函数成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。\n\n> 对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。同时需要注意，当接口 `A` 与后来的接口 `A` 合并时，后面的接口具有更高的优先级。\n\n```typescript\n// 如下例所示：\ninterface Cloner {\n  clone(animal: Animal): Animal;\n}\ninterface Cloner {\n  clone(animal: Sheep): Sheep;\n}\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n// 这三个接口合并成一个声明：\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n> 注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前的位置。\n\n> 这个规则有一个例外是当出现特殊的函数签名时。如果签名里有一个参数的类型是单一的字符串字面量(比如，不是字符串字面量的联合类型)，那么它将会被提升到重载列表的最顶端。\n\n```typescript\n// 比如，下面的接口会合并到一起\ninterface Document {\n  createElement(tagName: any): ELement;\n}\ninterface Document {\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n}\ninterface Document {\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n}\n// 合并后的 Document 将会像下面这样:\ninterface Document {\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: any): Element;\n}\n```\n\n### 19.4 合并命名空间\n\n1. 与接口相似，同名的命名空间也会合并其成员。命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。\n2. 对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。\n3. 对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。\n\n```typescript\n// Animals 声明合并示例：\nnamespace Animals {\n  export class Zebra {}\n}\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Dog {}\n}\n// 等同于：\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Zebra {}\n  export class Dog {}\n}\n```\n\n> 除了这些合并外，你还需要了解非导出成员是如何处理的。非导出成员仅在其原有的(合并前的)命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。\n\n- 下面提供了清晰的说明：\n\n```typescript\nnamespace Animal {\n  let haveMuscles = true;\n  export function animalsHaveMuscles() {\n    return haveMuscles;\n  }\n}\nnamespace Animal {\n  export function doAnimalsHaveMuscles() {\n    return haveMuscles; // // Error, because haveMuscles is not accessible here\n  }\n}\n```\n\n> 因为 `haveMuscles` 并没有导出，只有 `animalsHaveMuscles` 函数共享了原始未合并的命名空间可以访问这个变量。\n> `doAnimalsHaveMuscles` 函数虽是合并命名空间的一部分，但是访问不了未导出的成员。\n\n### 19.5 命名空间与类和函数和枚举类型合并\n\n> 命名空间可以与其它类型的声明合并。只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。\n> `TypeScript` 使用这个功能去实现一些 `JavaScript` 里的设计模式。\n\n#### 19.5.1 合并命名空间和类\n\n> 这让我们可以表示内部类\n\n```typescript\nclass Album {\n  label: Album.AlbumLabel;\n}\n\nnamespace Album {\n  export class AlbumLabel {}\n}\n```\n\n> `合并规则` 与上面 `合并命名空间` 小节里讲的规则一致，我们必须导出 `AlbumLabel` 类，好让合并的类能访问。\n\n> `合并结果`是一个类并带有一个内部类。你也可以使用命名空间为类增加一些静态属性。\n\n> 除了内部类的模式，你在 `JavaScript` 里，创建一个函数稍后扩展它增加一些属性也是很常见的。`TypeScript` 使用声明合并来达到这个目的并保证类型安全。\n\n```typescript\nfunction buildLabel(name: string): string {\n  return buildLabel.prefix + name + buildLabel.suffix;\n}\nnamespace buildLabel {\n  export let suffix = \"\";\n  export let prefix = \"Hello, \";\n}\nconsole.log(buildLabel(\"Sam Smith\"));\n\n// 相似的，命名空间可以用来扩展枚举类型\nenum Color {\n  red = 1,\n  green = 2,\n  blue = 4\n}\nnamespace Color {\n  export function mixColor(colorName: string) {\n    if (colorName === \"yellow\") {\n      return Color.red + Color.green;\n    } else if (colorName === \"white\") {\n      return Color.red + Color.green + Color.blue;\n    } else if (colorName === \"magenta\") {\n      return Color.red + Color.blue;\n    } else if (colorName === \"cyan\") {\n      return Color.green + Color.blue;\n    }\n  }\n}\n```\n\n#### 19.5.2 非法的合并\n\n> `TypeScript` 并非允许所有的合并。目前，类不能与其它类或变量合并。想要了解如何模仿类的合并，请参照 [TypeScript 混入](https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/Mixins%E6%B7%B7%E5%85%A5/README.md)。\n\n### 19.6 模块扩展\n\n> 虽然 `JavaScript` 不支持合并，但你可以为导入的对象打补丁以更新它们。\n\n- 让我们考察一下这个玩具性的示例：\n\n```typescript\n// observable.js\nexport class Observable<T> {\n  // ... implementation left as an exercise for the reader...\n}\n\n// map.js\nimport { Observable } from \"./observable\";\nObservable.prototype.map = function () {\n  // ... another exercise for the reader\n};\n```\n\n> 它也可以很好地工作在 `TypeScript` 中，但编译器对 `Observable.prototype.map` 一无所知。你可以使用扩展模块来将它告诉编译器。\n\n```typescript\n// observable.ts stays the same\n// map.ts\nimport { Observable } from \"./observable\";\ndeclare module \"./observable\" {\n  interface Observable<T> {\n    map<U>(f: (x: T) => U): Observable<U>;\n  }\n}\nObservable.prototype.map = function (f) {\n  // ... another exercise for the reader\n};\n\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable<number>;\no.map(x => x.toFixed());\n```\n\n> 模块名的解析和用 `import / export` 解析模块标识符的方式是一致的。 更多信息请参考 [Modules](https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/%E6%A8%A1%E5%9D%97/README.md)。当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明(仅可以扩展模块中已经存在的声明)。\n\n### 19.7 全局扩展\n\n> 你也可以在模块内部添加声明到全局作用域中\n\n> `observable.ts`\n\n```typescript\nexport class Observable<T> {\n  // ... still no implementation ...\n}\ndeclare global {\n  interface Array<T> {\n    toObservable(): Observable<T>;\n  }\n}\nArray.prototype.toObservable = function () {\n  // ...\n};\n```\n\n> 全局扩展和与模块扩展的行为和限制是相同的。\n\n## 二十、JSX\n\n### 20.1 介绍\n\n> `JSX` 是一种嵌入式的类似 `XML` 的语法。它可以被转换成合法的 `JavaScript`，尽管转换的语义是根据不同的实现而定的。\n> `JSX` 因 `React` 框架而流行，但也存在其它的实现。`TypeScript` 支持内嵌，类型检查以及将 `JSX` 直接编译为 JavaScript。\n\n### 20.2 基本用法\n\n- 想要使用 `JSX` 必须做两件事：\n\n> 1. 给文件一个 `.tsx` 扩展名\n> 2. 启用 `jsx` 选项\n\n- `TypeScript` 具有三种 `JSX` 模式：`preserve`, `react` 和 `react-native`。这些模式只在代码生成阶段起作用 - 类型检查并不受影响。\n\n> 1. 在 `preserve` 模式下生成代码中会保留 `JSX` 以供后续的转换操作使用( `比如：Babel` )。另外，输出文件会带有 `.jsx` 扩展名。\n> 2. `react` 模式会生成 `React.createElement`，在使用前不需要再进行转换操作了，输出文件的扩展名为 `.js`。\n> 3. `react-native` 相当于 `preserve`，它也保留了所有的 `JSX`，但是输出文件的扩展名是 `.js`。\n\n| 模式         | 输入      | 输出                         | 输出文件扩展名 |\n| :----------- | :-------- | :--------------------------- | :------------- |\n| preserve     | `<div />` | `<div />`                    | `.js`          |\n| react        | `<div />` | `React.createElement(\"div\")` | `.js`          |\n| react-native | `<div />` | `<div />`                    | `.js`          |\n\n> 你可以通过在命令行里使用 `--jsx` 标记或 `tsconfig.json` 里的选项来指定模式。\n> 注意：`React` 标识符是写死的硬编码，所以你必须保证 `React`（大写的`R`）是可用的。\n\n### 20.3 as 操作符\n\n> 回想一下怎么写类型断言\n\n```typescript\nvar foo = <foo>bar;\n```\n\n> 这里断言 `bar` 变量是 `foo` 类型的。 因为 `TypeScript` 也使用尖括号来表示类型断言，在结合 `JSX` 的语法后将带来解析上的困难。因此，`TypeScript` 在 `.tsx` 文件里禁用了使用尖括号的类型断言。\n\n> 由于不能够在 `.tsx` 文件里使用上述语法，因此我们应该使用另一个类型断言操作符：`as`。\n\n- 上面的例子可以很容易地使用 `as` 操作符改写：\n\n```typescript\nvar foo = bar as foo;\n```\n\n> `as` 操作符在 `.ts` 和 `.tsx` 里都可用，并且与尖括号类型断言行为是等价的。\n\n### 20.4 类型检查\n\n> 为了理解 `JSX` 的类型检查，你必须首先理解 `固有元素` 与 `基于值的元素` 之间的区别。假设有这样一个 `JSX` 表达式 `<expr />`，`expr` 可能引用环境自带的某些东西(比如，在 `DOM` 环境里的 `div` 或 `span`)或者是你自定义的组件。这是非常重要的。原因有如下两点：\n\n1. 对于 `React`，固有元素会生成字符串 (`React.createElement(\"div\")` )，然后由你自定义的组件却不会生成( `React.createElement(MyComponent)`)。\n2. 传入 `JSX` 元素里的属性类型的查找方式不同。固有元素总以一个小写字母开头，基于值的元素总是以一个大写字母开头。\n\n#### 20.4.1 固有元素\n\n> 固有元素使用特殊的接口 `JSX.IntrinsicElements` 来查找。默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。然而，如果这个接口存在，那么固有元素的名字需要在 `JSX.IntrinsicElements` 接口的属性里查找。\n\n- 例如：\n\n```jsx\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        foo: any;\n    }\n}\n<foo />; // 正确\n<bar />; // 错误\n```\n\n> 在上例中，``没有问题，但是`会报错，因为它没在 JSX.IntrinsicElements` 里指定。\n\n> 注意：你也可以在 `JSX.IntrinsicElements` 上指定一个用来捕获所有字符串索引：\n\n```jsx\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        [elemName: string]: any;\n    }\n}\n```\n\n#### 20.4.2 基于值的元素\n\n> 基于值的元素会简单的在它所在的作用域里按标识符查找。\n\n```jsx\nimport MyComponent from \"./myComponent\";\n<MyComponent /> // 正确\n<SomeOtherComponent /> // 错误\n```\n\n> 有两种方式可以定义基于值的元素：\n>\n> 1. 无状态函数组件 (`SFC`)\n> 2. 类组件\n\n> 由于这两种基于值的元素在 `JSX` 表达式里无法区分，因此 `TypeScript` 首先会尝试将表达式作为无状态函数组件进行解析。如果解析成功，那么 `TypeScript` 就完成了表达式到其声明的解析操作。如果按照无状态函数组件解析失败，那么 `TypeScript` 会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。\n\n##### (1) 无状态函数组件\n\n> 正如其名，组件被定义成 `JavaScript` 函数，它的第一个参数是 `props` 对象。`TypeScript` 会强制它的返回值可以赋值给 `JSX.Element`。\n\n```jsx\ninterface FooProp {\n    name: string;\n    X: number;\n    Y: number;\n}\ndeclare function AnotherComponent(prop: { name: string });\nfunction ComponentFoo(prop: FooProp) {\n    return <AnotherComponent name={prop.name} />\n}\nconst Button = (prop: { value: string }, context: { color: string }) => <button>;\n```\n\n> 由于无状态函数组件是简单的 `JavaScript` 函数，所以我们还可以利用函数重载。\n\n```jsx\ninterface ClickableProps {\n    children: JSX.Element[] | JSX.Element;\n}\ninterface HomeProps extends ClickableProps {\n    home: JSX.Element;\n}\ninterface SlideProps extends ClickableProps {\n    side: JSX.Element | string;\n}\nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SlideProps): JSX.Element {\n    // ...\n}\n```\n\n##### (2) 类组件\n\n> 1. 我们可以定义类组件的类型。然而，我们首先最好弄懂两个新的术语：`元素类的类型` 和 `元素实例的类型`。\n> 2. 现在有 `<Expr />`，元素类的类型为 `Expr` 的类型。所以在上面的例子里，如果 `MyComponent` 是 `ES6` 的类，那么类类型就是类的构造函数和静态部分。如果 `MyComponent` 是个工厂函数，类类型为这个函数。\n> 3. 一旦建立起了类类型，实例类型由构造器或调用签名(如果存在的话)的返回值的联合构成。再次说明，在 `ES6` 类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。\n\n```jsx\nclass MyComponent {\n  render() {}\n}\n// 使用构造签名\nvar myComponent = new MyComponent();\n// 元素类的类型 => MyComponent;\n// 元素实例的类型 => { render: () => void }\n```\n\n```jsx\nfunction MyFactoryFunction() {\n  return {\n    render: () => {}\n  };\n}\n// 使用调用签名\nvar myComponent = MyFactoryFunction();\n// 元素类的类型 => FactoryFunction\n// 元素实例的类型 => { render: () => void }\n```\n\n> 元素的实例类型很有趣，因为它必须赋值给 `JSX.ElementClass` 或 `抛出一个错误`。默认的 `JSX.ElementClass` 为 `{}`，但是它可以被扩展用来限制 `JSX` 的类型以符合相应的接口。\n\n```jsx\ndeclare namespace JSX {\n    interface ElementClass {\n        render: any\n    }\n}\n\nclass MyComponent {\n    render() {}\n}\nfunction MyFactoryFunction() {\n    return {\n        render: () => {}\n    }\n}\n<MyComponent />; // 正确\n<MyFactoryFunction />; // 正确\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n    return {}\n}\n<NotAValidComponent />; // 错误\n<NotAValidFactoryFunction />; // 错误\n```\n\n### 20.5 属性类型检查\n\n1. 属性类型检查的第一步是 确定元素类型。这在 `固有元素` 和 `基于值的元素` 之间稍有不同。\n2. 对于固有元素，这是 `JSX.IntrinsicElements` 属性的类型。\n\n```jsx\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        foo: {\n            bar?: boolean;\n        }\n    }\n}\n// `foo` 的元素属性类型为 `{bar?: boolean}`\n<foo bar />;\n```\n\n3. 对于基于值的元素，就稍微复杂些。它取决于先前确定的在元素实例类型上的某个属性的类型。至于该使用哪个属性来确定类型取决于 `JSX.ElementAttributesProperty`。它应该使用单一的属性来定义。这个属性名之后会被使用。`TypeScript 2.8`，如果未指定 `JSX.ElementAttributesProperty`，那么将使用 `类元素构造函数` 或 `SFC` 调用的第一个参数类型。\n\n```jsx\ndeclare namespace JSX {\n  interface ElementAttributesProperty {\n      props; // 指定用来使用的属性名\n  }\n}\nclass MyComponent {\n  // 在元素实例上指定类型\n  props: {\n      foo?: string;\n  }\n}\n// `MyComponent` 的元素属性类型为 `{foo?: string}`\n<MyComponent foo=\"bar\" />;\n```\n\n4. 元素属性类型用于 `JSX` 里进行属性的类型检查。支持可选属性和必须属性\n\n```jsx\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        foo: {\n            requiredProp: string;\n            optionalProp?: number;\n        }\n    }\n}\n<foo requiredProp=\"bar\" />; // 正确\n<foo requiredProp=\"bar\" optionalProp={0} />; // 正确\n<foo />; // 错误，缺少requiredProp\n<foo requiredProp={0} />; // 错误，requiredProp 应该是字符串\n<foo requiredProp=\"bar\" unknownProp />; // 错误，unknownProp 属性不存在\n<foo requiredProp=\"bar\" some-unknown-prop />; // 正确，`some-unknown-prop` 不是合法的标识符\n```\n\n> 注意：如果一个属性名不是个合法的 `JS` 标识符(像 `data-\\*` 属性)，并且它没出现在元素属性类型里时不会当作一个错误。\n\n> 另外，`JSX` 还会使用 `JSX.IntrinsicAttributes` 接口来指定额外的属性，这些额外的属性通常不会被组件的 `props` 或 `arguments` 使用 - 比如 `React` 里的 `key`。还有，`JSX.IntrinsicClassAttributes<T>` 泛型类型也可以用来做同样的事情。这里的泛型参数表示类实例类型。在 `React` 里，它用来允许 `Ref<T>` 类型上的 `ref` 属性。通常来讲，这些接口上的所有属性都是可选的，除非你想要用户在每个 `JSX` 标签上都提供一些属性。\n\n> 延展操作符也可以使用\n\n```jsx\nvar props = { requiredProp: \"bar\" }; // 正确\nvar badProps = {};\n<foo {...badProps} />; // 错误\n```\n\n### 20.6 子孙类型检查\n\n> 从 `TypeScript 2.3` 开始，我们引入了 `children` 类型检查。`children` 是元素属性(`attribute`)类型的一个特殊属性(`property`)，子 `JSXExpression` 将会被插入到属性里。与使用 `JSX.ElementAttributesProperty` 来决定 `props` 名类似，我们可以利用 `JSX.ElementChildrenAttribute` 来决定 `children` 名。`JSX.ElementChildrenAttribute` 应该被声明在单一的属性(`property`)里。\n\n```typescript\ndeclare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {}; // specify children name to use\n  }\n}\n```\n\n> 如不特殊指定子孙的类型，我们将使用 `React typings` 里的默认类型\n\n```jsx\n<div>\n  <h1>Hello</h1>\n</div>;\n\n<div>\n  <h1>Hello</h1>\n  World\n</div>;\n\nconst CustomComp = (props) => <div>props.children</div>\n<CustomComp>\n  <div>Hello World</div>\n  {\"This is just a JS expression...\" + 1000}\n</CustomComp>\n```\n\n```jsx\ninterface PropsType {\n  children: JSX.Element;\n  name: string;\n}\nclass Component extends React.Component<PropsType, {}> {\n  render() {\n      return (\n          <h2>\n              {this.props.children}\n          </h2>\n      )\n  }\n}\n// Ok\n<Component>\n  <h1>Hello World</h1>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element\n<Component>\n  <h1>Hello World</h1>\n  <h2>Hello World</h2>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element or string.\n<Component>\n  <h1>Hello</h1>\n  World\n</Component>\n```\n\n### 20.7 JSX 结果类型\n\n> 默认地 `JSX` 表达式结果的类型为 `any`。你可以自定义这个类型，通过指定 `JSX.Element` 接口。然而，不能够从接口里检索元素，属性或 `JSX` 的子元素的类型信息。它是一个黑盒。\n\n### 20.8 嵌入的表达式\n\n> `JSX` 允许你使用 `{}` 标签来内嵌表达式\n\n```tsx\nvar a = (\n  <div>\n    {[\"foo\", \"bar\"].map(i => (\n      <span>{i / 2}</span>\n    ))}\n  </div>\n);\n// 上面的代码产生一个错误，因为你不能用数字来除以一个字符串。输出如下，若你使用了 preserve 选项\nvar a = (\n  <div>\n    {[\"foo\", \"bar\"].map(function (i) {\n      return <span>{i / 2}</span>;\n    })}\n  </div>\n);\n```\n\n### 20.9 react 整合\n\n> 要想一起使用 `JSX` 和 `React`，你应该使用 `React` 类型定义。这些类型声明定义了 `JSX` 合适命名空间来使用 `React`。\n\n```jsx\n/// <reference path=\"react.d.ts\" />\ninterface Props {\n  foo: string;\n}\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n<MyComponent foo=\"bar\" />; // 正确\n<MyComponent foo={0} />; // 错误\n```\n\n### 20.10 工厂函数\n\n> `jsx`：`react` 编译选项使用的工厂函数是可以配置的。可以使用 `jsxFactory` 命令行选项，或内联的 `@jsx` 注释指令在每个文件上设置。比如，给 `createElement` 设置 `jsxFactory`，`<div />` 会使用 `createElement(\"div\")` 来生成，而不是 `React.createElement(\"div\")`。\n\n```jsx\n// 注释指令可以像下面这样使用：(在 TypeScript 2.8 里)\nimport preact = require(\"preact\");\n/* @jsx preact.h */\nconst x = <div/>;\n\n// 生成\nconst preact = require(\"preact\");\nconst x = preact.h(\"div\", null);\n```\n\n> 工厂函数的选择同样会影响 `JSX` 命名空间的查找(类型检查)。如果工厂函数使用 `React.createElement` 定义(默认)，编译器会先检查 `React.JSX`，之后才检查全局的 `JSX`。如果工厂函数定义为 `h`，那么在检查全局的 `JSX` 之前先检查 `h.JSX`。\n\n## 二十一、装饰器\n\n### 21.1 介绍\n\n> 随着 `TypeScript` 和 `ES6` 里引入了类，在一些场景下我们需要额外的特定来支持标注或修改类及其成员。装饰器(`Decorators`)为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。`JavaScript` 里的装饰器目前处在 建议征集的第二阶段，但在 `TypeScript` 里已作为一项实验性特性予以支持。\n> 注意：装饰器是一项实验性特性，在未来的版本中可能会发生改变\n> 若要启用实验性的装饰器特性，你必须在命令行或 `tsconfig.json` 里启用 `experimentalDecorators` 编译器选项。\n> 命令行： `tsc --target ES5 --experimentalDecorators`\n\n- tsconfig.json\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n### 21.2 装饰器\n\n> 装饰器是一种特殊的声明，它能够被附加到 `类声明`、`方法`、`访问符`、`属性或参数上`。装饰器使用 `@expression` 这种形式，`expression` 求值后必须为一个函数，它会在运行时被调用，被装饰器的声明信息作为参数传入。\n> 例如，有一个 `@sealed` 装饰器，我们会这样定义 `sealed` 函数\n\n```typescript\nfunction sealed(target) {\n  // do something with target\n}\n```\n\n> 注意：后面类装饰器小节里有一个更加详细的例子。\n\n### 21.3 装饰器工厂\n\n> 如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。\n\n- 我们可以通过下面的方式来写一个装饰器工厂函数：\n\n```typescript\nfunction color(value: string) {\n  // 这是一个装饰器工厂\n  return function (target) {\n    // 这是装饰器\n    // do something with \"target\" and \"value\" ...\n  };\n}\n```\n\n> 注意：下面方法装饰器小节里有一个更加详细的例子。\n\n### 21.4 装饰器组合\n\n> 多个装饰器可以同时应用到一个声明上，就像下面的实例：\n\n1. 书写在同一行：\n\n```typescript\n@f @g x\n```\n\n2. 书写在多行上：\n\n```typescript\n@f\n@g\nx\n```\n\n> 当多个装饰器应用于一个声明上，它们求值方式与 复合函数 相似。在这个模型下，当复合 f 和 g 时，复合的结果 `\\(f∘g\\)\\(x\\)` 等同于 `f\\(g\\(x\\)\\)`。\n\n> 同样的，在 `TypeScript` 里，当多个装饰器应用在一个声明上时会进行如下步骤的操作： `1`. 由上至下依次对装饰器表达式求值 `2`. 求值的结果会被当作函数，由下至上依次被调用。\n\n```typescript\n// 如果我们使用 装饰器工厂 的话，可以通过下面的例子来观察它们求值的顺序：\nfunction f() {\n  console.log(\"f(): evaluated\");\n  return function (target, prototypeKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"f(): called\");\n  };\n}\nfunction g() {\n  console.log(\"g(): evaluated\");\n  return function (target, prototypeKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"g(): called\");\n  };\n}\nclass C {\n  @f()\n  @g()\n  method() {}\n}\n```\n\n```typescript\n// 在控制台里会打印出如下结果：\nf(): evaluated\ng(): evaluated\ng(): called\nf(): called\n```\n\n### 21.5 装饰器求值\n\n> 类中不同声明上的装饰器将按以下规定的顺序应用：\n\n- 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。\n- 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。\n- 参数装饰器应用到构造函数。\n- 类装饰器应用到类。\n\n### 21.6 类装饰器\n\n1.类装饰器在类声明之前被声明(紧靠着类声明)。类装饰器应用于类构造函数，可以用来监视修改或替换类定义。类装饰器不能用在声明文件中( `.d.ts` )，也不能用在任何外部上下文中(比如 `declare` 的类)。\n\n2. 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。\n3. 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。\n\n> 注意：如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。在运行时的装饰器调用逻辑中 不会为你做这些。\n> 下面是使用类装饰器( `@sealed` )的例子，应用在 `Greeter` 类：\n\n```typescript\n@sealed\nclass Greeter1 {\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n\n// 我们可以这样定义 @sealed 装饰器\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n```\n\n> 当 `@sealed` 被执行的时候，它将密闭此类的构造函数和原型。(注：参见 `Object.seal` )\n\n- 下面是一个重载构造函数的例子：\n\n```typescript\nfunction classDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {\n  return class extends constructor {\n    newProperty = \"new property\";\n    hello = \"override\";\n  };\n}\n\n@classDecorator\nclass Greeter2 {\n  property = \"property\";\n  hello: string;\n\n  constructor(m: string) {\n    this.hello = m;\n  }\n}\n\nconsole.log(new Greeter2(\"world\"));\n```\n\n### 21.7 方法装饰器\n\n> 方法装饰器声明在一个方法的声明之前(紧靠着方法声明)。它会被应用到方法的 `属性描述符` 上，可以用来监视，修改或者替换方法定义。方法装饰器不能用在声明文件 `.d.ts` 上，重载或者任何外部上下文(比如 `declare` 的类)中。\n\n> 方法装饰器表达式会在运行时当作函数被调用，传入下列 `3` 个参数：\n>\n> 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n> 2. 成员的名字\n> 3. 成员的属性修饰符\n\n> 注意：如果代码输出目标代码小于 `ES5`，属性描述符 将会是 `undefined`。\n\n> 如果方法装饰器返回一个值，它会被用作方法的 属性描述符。\n\n> 注意：如果代码输出目标版本小于 `ES5`，返回值会被忽略。\n\n- 下面是一个方法装饰器 (`@enumerable`) 的例子，应用于 `Greeter` 类的方法上。\n\n```typescript\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n```\n\n- 我们可以用下面的函数声明来定义 `@enumerable` 装饰器：\n\n```typescript\nfunction enumerable(value: boolean) {\n  return function (target: any, property: string, descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value;\n  };\n}\n```\n\n> 这里的 `@enumerable(false)` 是一个装饰器工厂，当装饰器 `@enumerable(false)` 被调用时，它会修改属性描述符的 `enumerable` 属性。\n\n### 21.8 访问器装饰器\n\n> 访问器装饰器声明在一个访问器的声明之前(紧靠着访问器声明)。访问器装饰器 应用于访问器的 `属性描述符` 并且可以用来监视，修改或替换一个访问器的定义。访问器装饰器不能用在声明文件中( `.d.ts` )，或者任何外部上下文(比如 `declare` 的类)里。\n\n> 注意：`TypeScript` 不允许同时装饰一个成员的 `get` 和 `set` 访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了 `get` 和 `set` 访问器，而不是分开声明的。\n\n> 访问器装饰器表达式会在运行时当作函数被调用，传入下列 `3` 个参数：\n>\n> 1. 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。\n> 2. 成员的名字\n> 3. 成员的属性描述符\n\n> 注意：如果代码输出目标版本小于 `ES5`，`Property Descriptor` 将会是 `undefined`。\n\n> 如果访问器装饰器返回一个值，它会被用作方法的 `属性描述符` 注意：如果代码输出目标版本小于 `ES5` 返回值会被忽略。\n\n- 下面是使用了访问器装饰器 (`@configurable`) 的例子，应用于 `Point` 类的成员上。\n\n```typescript\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n\n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\nlet p: Point = new Point(1, 2);\nconsole.log(p);\n```\n\n- 我们可以通过如下函数声明来定义 `@configurable` 装饰器：\n\n```typescript\nfunction configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n```\n\n### 21.9 属性装饰器\n\n> 属性装饰器声明在一个属性声明之前(紧靠着属性声明)。属性装饰器不能用在声明文件中（`.d.ts`），或者任何外部上下文（比如 `declare` 的类）里。\n\n> 属性装饰器表达式会在运行时当作函数被调用，传入下列 `2` 个参数：\n>\n> 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n> 2. 成员的名字。\n\n> 注意：`属性描述符` 不会作为参数传入属性装饰器，这与 `TypeScript` 是如何初始化属性装饰器有关。因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。\n\n- 我们可以用它来记录这个属性的元数据，如下例所示：\n\n```typescript\nclass Greeter {\n    @format(\"Hello, %s\")\n    greeting: string;\n>\n    constructor(message: string) {\n        this.greeting = message;\n    }\n>\n    greet() {\n        let formatString = getFormat(this, \"greeting\");\n        return formatString.replace(\"%s\", this.greeting);\n    }\n}\n>\nlet g: Greeter = new Greeter(\"鼓励\");\nconsole.log(g);\n>\n// 然后定义 @format 装饰器 和 getFormat 函数\nimport \"reflect-metadata\";\n>\nconst formatMetadataKey = Symbol(\"format\");\n>\nfunction format(formatString: string) {\n    return Reflect.metadata(formatMetadataKey, formatString);\n}\n>\nfunction getFormat(target: any, propertyKey: string) {\n    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\n> 这个 `@format(\"Hello, %s\")` 装饰器是个 `装饰器工厂`。当 `@format(\"Hello, %s\")` 被调用时，它添加一条这个属性的元数据，通过 `reflect-metadata` 库里的 `Reflect.metadata` 函数。当 `getFormat` 被调用时，它读取格式的元数据。\n\n> 注意：这个例子需要使用 `reflect-metadata` 库。查看 元数据 了解 `reflect-metadata` 库更详细的信息。\n\n### 21.10 参数装饰器\n\n> `参数装饰器` 声明在一个参数声明之前(紧靠着参数声明)。参数装饰器应用于 `类构造函数` 或 `方法声明`。参数装饰器 不能用在声明文件（`.d.ts`），重载或其它外部上下文（比如 `declare` 的类）里。\n> `参数装饰器` 表达式会在运行时当作函数被调用，传入下列 `3` 个参数：\n>\n> 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n> 2. 成员的名字\n> 3. 参数在函数参数列表的索引\n\n> 注意：参数装饰器只能用来监视一个方法的参数是否被传入。\n\n> 参数装饰器的返回值会被忽略\n\n- 下面定义了参数装饰器( `@required` )并应用于 `Greeter` 类方法的一个参数：\n\n```typescript\nclass Greeter {\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @validate\n  greet(@required name: string) {\n    return \"Hello \" + name + \", \" + this.greeting;\n  }\n}\n```\n\n- 然后我们使用下面的函数定义 `@required` 和 `@validate` 装饰器\n\n```typescript\nimport \"reflect-metadata\";\n\nconst requiredMetadataKey = Symbol(\"required\");\n\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {\n  let method = descriptor.value;\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n```\n\n> `@required` 装饰器添加了元数据实体把参数标记为必须的。\n> `@validate` 装饰器把 `greet` 方法包裹在一个函数里，在调用原先的函数前验证函数参数。\n> `注意：`这个例子使用了 `reflect-metadata` 库。 查看 元数据 了解 `reflect-metadata` 库的更多信息。\n\n### 21.11 元数据\n\n> 一部分例子使用了 `reflect-metadata` 库来支持实现性的 `metadata API`。这个库还不是 `ECMAScript\\( JavaScript \\)` 标准的一部分。然而，当装饰器被 `ECMAScript` 官方标准采纳后，这些扩展也将被推荐给 `ECMAScript` 以采纳。\n\n- 你可以通过 `npm` 安装这个库\n\n```bash\nnpm i reflect-metadata --save\n```\n\n> `TypeScript` 支持为带有装饰器的声明生成元数据。你需要在 `命令行` 或 `tsconfig.json` 里启用 `emitDecoratorMetadata` 编译器选项。\n\n- 命令行：\n\n```bash\ntsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n```\n\n- `tsconfig.json`\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\n> 当启用了，只要 `reflect-metadata` 库被引入了，设计阶段添加的类型信息可以在运行时使用。\n\n- 如下例所示：\n\n```typescript\nimport \"reflect-metadata\";\n\nclass Point {\n  x: number;\n  y: number;\n}\n\nclass Line {\n  private _p0: Point;\n  private _p1: Point;\n\n  @validate\n  set p0(value: Point) {\n    this._p0 = value;\n  }\n\n  get p0() {\n    return this._p0;\n  }\n\n  @validate\n  set p1(value: Point) {\n    this._p1 = value;\n  }\n\n  get p1() {\n    return this._p1;\n  }\n}\n\nfunction validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {\n  let set = descriptor.set;\n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n    if (!(value instanceof type)) {\n      throw new TypeError(\"Invalid type.\");\n    }\n    set(value);\n  };\n}\n```\n\n- `TypeScript` 编译器可以通过 `@Reflect.metadata` 装饰器注入设计阶段的类型信息。你可以认为它相当于下面的 `TypeScript：`\n\n```typescript\nclass Line1 {\n  private _p0: Point;\n  private _p1: Point;\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set p0(value: Point) {\n    this._p0 = value;\n  }\n\n  get p0() {\n    return this._p0;\n  }\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set p1(value: Point) {\n    this._p1 = value;\n  }\n\n  get p1() {\n    return this._p1;\n  }\n}\n```\n\n> 注意： 装饰器元数据是个实验性的特性并且可能在以后的版本中发声破坏性的改变。\n\n### 21.12 Reflect-metadata 库\n\n```typescript\nnamespace Reflect {\n    // 用于装饰器\n    metadata(k, v): (target, property?) => void\n    // 在对象上面定义元数据\n    defineMetadata(k, v, o, p?): void\n    // 是否存在元数据\n    hasMetadata(k, o, p?): boolean\n    hasOwnMetadata(k, o, p?): boolean\n    // 获取元数据\n    getMetadata(k, o, p?): any\n    getOwnMetadata(k, o, p?): any\n    // 获取所有元数据的 Key\n    getMetadataKeys(o, p?): any[]\n    getOwnMetadataKeys(o, p?): any[]\n    // 删除元数据\n    deleteMetadata(k, o, p?): boolean\n}\n```\n\n#### 21.12.1 安装\n\n##### Metadata Reflection API\n\n- [Detailed proposal][metadata-spec]\n\n1. Installation\n\n```bash\nnpm install reflect-metadata\n```\n\n2. Background\n\n- Decorators add the ability to augment a class and its members as the class is defined, through a declarative syntax.\n- Traceur attaches annotations to a static property on the class.\n- Languages like C# (.NET), and Java support attributes or annotations that add metadata to types, along with a reflective API for reading metadata.\n\n3. Goals\n\n- A number of use cases (Composition/Dependency Injection, Runtime Type Assertions, Reflection/Mirroring, Testing) want the ability to add additional metadata to a class in a consistent manner.\n- A consistent approach is needed for various tools and libraries to be able to reason over metadata.\n- Metadata-producing decorators (nee. \"Annotations\") need to be generally composable with mutating decorators.\n- Metadata should be available not only on an object but also through a Proxy, with related traps.\n- Defining new metadata-producing decorators should not be arduous or over-complex for a developer.\n- Metadata should be consistent with other language and runtime features of ECMAScript.\n\n4. Syntax\n\n- Declarative definition of metadata:\n\n```javascript\nclass C {\n  @Reflect.metadata(metadataKey, metadataValue)\n  method() {}\n}\n```\n\n- Imperative definition of metadata:\n\n```javascript\nReflect.defineMetadata(metadataKey, metadataValue, C.prototype, \"method\");\n```\n\n- Imperative introspection of metadata:\n\n```javascript\nlet obj = new C();\nlet metadataValue = Reflect.getMetadata(metadataKey, obj, \"method\");\n```\n\n5. Semantics\n\n- Object has a new [[Metadata]] internal property that will contain a Map whose keys are property keys (or `undefined` ) and whose values are Maps of metadata keys to metadata values.\n- Object will have a number of new internal methods for [[DefineOwnMetadata]], [[GetOwnMetadata]], [[HasOwnMetadata]], etc.\n  - These internal methods can be overridden by a Proxy to support additional traps.\n  - These internal methods will by default call a set of abstract operations to define and read metadata.\n- The Reflect object will expose the MOP operations to allow imperative access to metadata.\n- Metadata defined on class declaration _C_ is stored in _C_.[[Metadata]], with `undefined` as the key.\n- Metadata defined on static members of class declaration _C_ are stored in _C_.[[Metadata]], with the property key as the key.\n- Metadata defined on instance members of class declaration _C_ are stored in _C_.prototype.[[Metadata]], with the property key as the key.\n\n1. API\n\n```javascript\n// define metadata on an object or property\nReflect.defineMetadata(metadataKey, metadataValue, target);\nReflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);\n\n// check for presence of a metadata key on the prototype chain of an object or property\nlet result = Reflect.hasMetadata(metadataKey, target);\nlet result = Reflect.hasMetadata(metadataKey, target, propertyKey);\n\n// check for presence of an own metadata key of an object or property\nlet result = Reflect.hasOwnMetadata(metadataKey, target);\nlet result = Reflect.hasOwnMetadata(metadataKey, target, propertyKey);\n\n// get metadata value of a metadata key on the prototype chain of an object or property\nlet result = Reflect.getMetadata(metadataKey, target);\nlet result = Reflect.getMetadata(metadataKey, target, propertyKey);\n\n// get metadata value of an own metadata key of an object or property\nlet result = Reflect.getOwnMetadata(metadataKey, target);\nlet result = Reflect.getOwnMetadata(metadataKey, target, propertyKey);\n\n// get all metadata keys on the prototype chain of an object or property\nlet result = Reflect.getMetadataKeys(target);\nlet result = Reflect.getMetadataKeys(target, propertyKey);\n\n// get all own metadata keys of an object or property\nlet result = Reflect.getOwnMetadataKeys(target);\nlet result = Reflect.getOwnMetadataKeys(target, propertyKey);\n\n// delete metadata from an object or property\nlet result = Reflect.deleteMetadata(metadataKey, target);\nlet result = Reflect.deleteMetadata(metadataKey, target, propertyKey);\n\n// apply metadata via a decorator to a constructor\n@Reflect.metadata(metadataKey, metadataValue)\nclass C {\n  // apply metadata via a decorator to a method (property)\n  @Reflect.metadata(metadataKey, metadataValue)\n  method() {}\n}\n```\n\n7. Alternatives\n\n- Use properties rather than a separate API.\n  - Obvious downside is that this can be a lot of code:\n\n```javascript\nfunction ParamTypes(...types) {\n  return (target, propertyKey) => {\n    const symParamTypes = Symbol.for(\"design:paramtypes\");\n    if (propertyKey === undefined) {\n      target[symParamTypes] = types;\n    } else {\n      const symProperties = Symbol.for(\"design:properties\");\n      let properties, property;\n      if (Object.prototype.hasOwnProperty.call(target, symProperties)) {\n        properties = target[symProperties];\n      } else {\n        properties = target[symProperties] = {};\n      }\n      if (Object.prototype.hasOwnProperty.call(properties, propertyKey)) {\n        property = properties[propertyKey];\n      } else {\n        property = properties[propertyKey] = {};\n      }\n      property[symParamTypes] = types;\n    }\n  };\n}\n```\n\n8. Notes\n\n- Though it may seem counterintuitive, the methods on Reflect place the parameters for the metadata key and metadata value before the target or property key. This is due to the fact that the property key is the only optional parameter in the argument list. This also makes the methods easier to curry with Function#bind. This also helps reduce the overall footprint and complexity of a metadata-producing decorator that could target both a class or a property:\n\n```javascript\nfunction ParamTypes(...types) {\n  // as propertyKey is effectively optional, its easier to use here\n  return (target, propertyKey) => {\n    Reflect.defineMetadata(\"design:paramtypes\", types, target, propertyKey);\n  };\n\n  // vs. having multiple overloads with the target and key in the front:\n  //\n  // return (target, propertyKey) => {\n  //    if (propertyKey === undefined) {\n  //      Reflect.defineMetadata(target, \"design:paramtypes\", types);\n  //    }\n  //    else {\n  //      Reflect.defineMetadata(target, propertyKey, \"design:paramtypes\", types);\n  //    }\n  // }\n  //\n  // vs. having a different methods for the class or a property:\n  //\n  // return (target, propertyKey) => {\n  //    if (propertyKey === undefined) {\n  //      Reflect.defineMetadata(target, \"design:paramtypes\", types);\n  //    }\n  //    else {\n  //      Reflect.definePropertyMetadata(target, propertyKey, \"design:paramtypes\", types);\n  //    }\n  // }\n}\n```\n\n- To enable experimental support for metadata decorators in your TypeScript project, you must add `\"experimentalDecorators\": true` to your tsconfig.json file.\n- To enable experimental support for auto-generated type metadata in your TypeScript project, you must add `\"emitDecoratorMetadata\": true` to your tsconfig.json file.\n  - Please note that auto-generated type metadata may have issues with circular or forward references for types.\n\n9. Issues\n\n- A poorly written mutating decorator for a class constructor could cause metadata to become lost if the prototype chain is not maintained. Though, not maintaining the prototype chain in a mutating decorator for a class constructor would have other negative side effects as well. [@rbuckton ](/rbuckton)\n  - This is mitigated if the mutating decorator returns a class expression that extends from the target, or returns a proxy for the decorator. [@rbuckton ](/rbuckton)\n- Metadata for a method is attached to the class (or prototype) via the property key. It would not then be available if trying to read metadata on the function of the method (e.g. \"tearing-off\" the method from the class). [@rbuckton ](/rbuckton)\n\n[Metadata-Spec]: [https://rbuckton.github.io/reflect-metadata](https://rbuckton.github.io/reflect-metadata)\n\n## 二十二、Mixins 混入\n\n### 22.1 介绍\n\n> 除了传统的面向对象继承方式，还流行一种通用可重用组件创建类的方式，就是联合另一个简单类的代码。\n> 你可能在 `Scala` 等语言里对 `mixins` 及其特性已经很熟悉了，但它在 `JavaScript` 中也是很流行的。\n\n### 22.2 混入示例\n\n> 下面的代码演示了如何在 `TypeScript` 里使用混入。后面我们还会解释这段代码是如何工作的。\n\n```typescript\n// Disposable Mixin\nclass Disposable {\n  isDisposed: boolean;\n  dispose() {\n    this.isDisposed = true;\n  }\n}\n\n// Activatable Mixin\nclass Activatable {\n  isActive: boolean;\n  activate() {\n    this.isActive = true;\n  }\n  deactivate() {\n    this.isActive = false;\n  }\n}\n\nclass SmartObject implements Disposable, Activatable {\n  constructor() {\n    setInterval(() => console.log(this.isActive + \":\" + this.isDisposed), 500);\n  }\n\n  interact() {\n    this.activate();\n  }\n\n  // Disposable\n  isDisposed: boolean = false;\n  dispose: () => void;\n  // Activatable\n  isActive: boolean = false;\n  activate: () => void;\n  deactivate: () => void;\n}\n\napplyMixins(SmartObject, [Disposable, Activatable]);\nlet smartObj = new SmartObject();\nsetTimeout(() => smartObj.interact(), 1000);\n\n////////////////////////////////////////\n// In your runtime library somewhere\n////////////////////////////////////////\n\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      derivedCtor.prototype[name] = baseCtor.prototype[name];\n    });\n  });\n}\n```\n\n### 22.3 理解这个例子\n\n1. 代码里首先定义了两个类，它们将做为 `mixins`。可以看到每个类都只定义了一个特定的行为或功能。稍后我们使用它们来创建一个新类，同时具有这两种功能。\n\n```typescript\n// Disposable Mixin\nclass Disponsable {\n  isDisponsed: boolean;\n  dispose() {\n    this.isDisponsed = true;\n  }\n}\n\n// Activatable Mixin\nclass Activatable {\n  isActive: boolean;\n  activate() {\n    this.isActive = true;\n  }\n  deactivate() {\n    this.isActive = false;\n  }\n}\n```\n\n2. 下面创建一个类，结合了这两个 `mixins`。 下面来看一下具体是怎么操作的：\n\n```typescript\nclass SmartObject implements Disposable, Activatable {}\n```\n\n3. 首先应该注意到的是，没使用 `extends` 而是使用 `implements`。 把类当成了接口，仅使用 `Disposable` 和 `Activatable` 的类型而非其实现。 这意味着我们需要在类里面实现接口。但是这是我们在用 `mixin` 时想避免的。\n4. 我们可以这么做来达到目的，为将要 `mixin` 进来的属性方法创建出占位属性。这告诉编译器这些成员在运行时是可用的。 这样就能使用 `mixin` 带来的便利，虽说需要提前定义一些占位属性。\n\n```typescript\n// Disposable\n  isDisposed: boolean = false;\n  dispose: () => void;\n// Activatable\n  isActive: boolean = false;\n  activate: () => void;\n  deactivate: () => void;\n```\n\n5. 最后，把 `mixins` 混入定义的类，完成全部实现部分。\n\n```typescript\napplyMixins(SmartObject, [Disposable, Activatable]);\n```\n\n6. 最后，创建这个帮助函数，帮我们做混入操作。 它会遍历 `mixins` 上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\n\n```typescript\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      derivedCtor.prototype[name] = baseCtor.prototype[name];\n    });\n  });\n}\n```\n\n## 二十三、三斜线指令\n\n- 三斜线指令是包含单个 `XML` 标签的单行注释。注释内容会做为编译器指令使用。\n- 三斜线指令仅可放在包含它的文件最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。如果它们出现在一个语句或声明之后，那么它们会被当作普通的单行注释，并且不具有特殊的含义。\n\n```typescript\n/// <reference path=\"...\" />\n/// <reference path=\"...\" /> 指令是三斜线指令中最常见的一种。 它用于声明文件间的 依赖。\n```\n\n- 三斜线引用告诉编译器在编译过程中要引入的额外文件。\n- 当使用 `--out` 或 `--outFile` 时，它也可以做为调整输出内容顺序的一种方法。文件在输出文件内容中的位置与经过预处理后的输入顺序一致。\n\n### 23.1 预处理输入文件\n\n> 编译器会对输入文件进行预处理来解析所有三斜线引用指令。在这个过程中，额外的文件会加到编译过程中。\n> 这个过程会以一些根文件开始；它们是在命令行中指定的文件或是在 `tsconfig.json` 中的 `\"files\"` 列表里的文件。这些根文件按指定的顺序进行预处理。在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。\n>   一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。\n\n### 23.2 错误\n\n> 引用不存在的文件会报错。一个文件用三斜线指令引用自己会报错。\n\n### 23.3 使用 `--noResolve`\n\n> 如果指定了 `--noResolve` 编译选项，三斜线指令会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。\n\n```typescript\n/// <reference types=\"...\" />\n```\n\n- 与 `/// <reference path=\"...\" />` 指令相似，这个指令是用来声明依赖的；一个 `/// <reference types=\"...\" />` 指令则声明了对某个包的依赖。\n- 对这些包的名字的解析与在 `import` 语句里对模块名的解析类似。可以简单地把三斜线类型引用指令当做 `import` 声明的包。\n- 例如，把 `/// <reference types=\"node\" />`引入到声明文件，表明这个文件使用了`@types/node/index.d.ts` 里面声明的名字；并且，这个包需要在编译阶段与声明文件一起被包含进来。\n- 仅当在你需要写一个 `.d.ts` 文件时才使用这个指令。\n- 对于那些在编译阶段生成的声明文件，编译器会自动地添加 `/// <reference types=\"...\" />`；当且仅当结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加  `/// <reference types=\"...\" />` 语句。\n- 若要在 `.ts` 文件里声明一个对 `@types` 包的依赖，使用 `--types` 命令行选项 或在 `tsconfig.json` 里指定。查看 在 `tsconfig.json` 里使用 `@types`，`typeRoots` 和 `types` 了解详情。\n- `/// <reference no-default-lib=\"true\"/>` 这个指令把一个文件标记成默认库。你会在 `lib.d.ts` 文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中不要包含这个默认库（比如，`lib.d.ts`）。 这与在命令行上使用 -`-noLib` 相似。\n- 还要注意，当传递了 `--skipDefaultLibCheck` 时，编译器只会忽略检查带有 `/// <reference no-default-lib=\"true\"/>` 的文件。\n\n### 23.4 `<amd-module />`\n\n> 默认情况下生成的 `AMD` 模块 都是匿名的。但是，当一些工具需要处理生成的模块时会产生问题，比如 `r.js。amd-module` 指令允许给编译器传入一个可选的模块名：\n\n- `amdModule.ts`\n\n```typescript\n/// <amd-module name=\"NamedModule\" />\nexport class C {}\n```\n\n> 这会将 `NamedModule` 传入到 `AMD define` 函数里：\n\n- `amdModule.js`\n\n```typescript\ndefine(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\n  var C = (function () {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});\n```\n\n### 23.5 `<amd-dependency />`\n\n- 注意：这个指令被废弃了。使用 `import \"moduleName\";` 语句代替。\n\n```typescript\n/// <amd-dependency path=\"x\" />\n\n// 告诉编译器有一个非 TypeScript 模块依赖需要被注入，做为目标模块 require 调用的一部分。\n```\n\n- `amd-dependency` 指令也可以带一个可选的 `name` 属性；它允许我们为 `amd-dependency` 传入一个可选名字：\n\n```typescript\n/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>\ndeclare var moduleA: MyType;\nmoduleA.callStuff();\n```\n\n- 生成的 `JavaScript` 代码：\n\n```typescript\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (require, exports, moduleA) {\n  moduleA.callStuff();\n});\n```\n\n## 二十四、JavaScript 文件类型检查\n\n### 24.1 JavaScript 文件类型检查\n\n> `TypeScript 2.3` 以后的版本支持使用 `--checkJs` 对 `.js` 文件进行类型检查和错误提示。\n\n> 你可以通过添加 `// @ts-nocheck` 注释来忽略类型检查；相反，你可以通过去掉 `--checkJs` 设置并添加一个 `// @ts-nocheck` 注释来选择检查某些 `.js` 文件。你还可以用 `// @ts-ignore` 来忽略本行的错误。如果你使用了 `tsconfig.json`，`JS` 检查将遵照一些严格检查标记，如 `noImplicitAny`，`strictNullChecks` 等。但因为 `JS` 检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。\n\n- 对比 `.js`文件和 `.ts` 文件在类型检查上的差异，有如下几点需要注意\n\n#### (1) 用 `JSDoc` 类型表示类型信息\n\n> `.js` 文件里，类型可以和在 `.ts` 文件里一样被推断出来。同样地，当类型不能被推断时，它们可以通过 `JSDoc` 来指定，就好比在 `.ts` 文件里那样。如同 `TypeScript`，`--noImplicitAny` 会在编译器无法推断类型的位置报错。（除了对象字面量的情况；后面会详细介绍）`JSDoc` 注解修饰的声明会被设置为这个声明的类型。比如：\n\n```typescript\n/** @type {number} */\nvar x;\nx = 0; // OK\nx = false; // Error: boolean is not assignable to number\n```\n\n> 你可以在这里找到所有 `JSDoc` 支持的模式，[JSDoc 文档](https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript)。\n\n#### (2) 属性的推断来自于类内的赋值语句\n\n> `ES2015` 没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。在 `.js` 文件里，编译器从类内部的属性赋值语句来推断属性类型。属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是 `undefined` 或 `null`。若是这种情况，类型将会是所有赋值的类型的联合类型。在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。\n\n```typescript\nclass C {\n  constructor() {\n    this.constructorOnly = 0;\n    this.constructorUnknown = undefined;\n  }\n  method() {\n    this.constructorOnly = false; // error, constructorOnly is a number\n    this.constructorUnknown = \"plunkbat\"; // ok, constructorUnknown is string | undefined\n    this.methodOnly = \"ok\"; // ok, but y could also be undefined\n  }\n  method2() {\n    this.methodOnly = true; // also, ok, y's type is string | boolean | undefined\n  }\n}\n```\n\n> 如果一个属性从没在类内设置过，它们会被当成未知的。\n\n> 如果类的属性只是读取用的，那么就在构造函数里用 `JSDoc` 声明它的类型。如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：\n\n```typescript\nclass C {\n  constructor() {\n    /** @type {name | undefined} */\n    this.prop = undefined;\n    /** @type {number | undefined} */\n    this.count;\n  }\n}\nlet c = new C();\nc.prop = 0; // Ok\nc.count = \"string\"; // Error: string is not assignable to number | undefined\n```\n\n#### (3) 构造函数等同于类\n\n> `ES2015` 以前，`Javascript` 使用构造函数代替类。编译器支持这种模式并能够将构造函数识别为 `ES2015` 的类。属性类型推断机制和上面介绍的一致。\n\n```typescript\nfunction C() {\n  this.constructorOnly = 0;\n  this.constructorUnknown = undefined;\n}\nC.prototype.method = function () {\n  this.constructorOnly = false; // error\n  this.constructorUnknown = \"plunkbat\"; // OK, the type is string | undefined\n};\n```\n\n#### (4) 支持 `CommonJS` 模块\n\n> 在 `.js` 文件里，`TypeScript` 能识别出 `CommonJS` 模块。对 `exports` 和 `module.exports` 的赋值被识别为导出声明。相似地，`require` 函数调用被识别为模块导入。例如：\n\n```typescript\n// same as `import module 'fs'`\nconst fs = require(\"fs\");\n// same as `export function readFile`\nmodule.exports.readFile = function (f) {\n  return fs.readFileSync(f);\n};\n```\n\n> 对 `JavaScript` 文件里模块语法的支持比在 `TypeScript` 里宽泛多了。 大部分的赋值和声明方式都是允许的。\n\n#### (5) 类，函数和对象字面量是命名空间\n\n```typescript\n// .js 文件里的类是命名空间。它可以用于嵌套类，比如：\nclass C {}\nC.D = class {};\n// ES2015 之前的代码，它可以用来模拟静态方法。\nfunction Outer() {\n  this.y = 2;\n}\nOuter.Inner = function () {\n  this.yy = 2;\n};\n// 它还可以用于创建简单的命名空间：\nvar ns = {};\nns.C = class {};\nns.func = function () {};\n// 同时还支持其它的变化\n// 立即调用的函数表达式\nvar ns = (function (n) {\n  return n | {};\n})();\nns.COUNT = 1;\n\n// defaulting to global\nvar assign =\n  assign ||\n  function () {\n    // code goes here\n  };\nassign.extra = 1;\n```\n\n#### (6) 对象字面量是开放的\n\n- `.ts` 文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。这个规则在 `.js` 文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：\n\n```typescript\nvar obj = { a: 1 };\nobj.b = 2; // Allowed\n```\n\n- 对象字面量的表现就好比具有一个默认的索引签名 `\\[x:string\\]: any`，它们可以被当成开放的映射而不是封闭的对象。\n- 与其它 `JS` 检查行为相似，这种行为可以通过指定 `JSDoc` 类型来改变，例如：\n\n```typescript\n/** @type {{ a: number }} */\nvar obj = { a: 1 };\nobj.b = 2; // Error, type {a: number} does not have property b\n```\n\n#### (7) null undefined 和 空数组的类型是 any 或 any[]\n\n> 任何用 `null`，`undefined` 初始化的变量，参数或属性，它们的类型是 `any`，就算是在严格 `null` 检查模式下。任何用 `[]` 初始化的变量，参数或属性，它们的类型是 `any[]`，就算是在严格 `null` 检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。\n\n```typescript\nfunction Foo(i = null) {\n  if (!i) i = 1;\n  var j = undefined;\n  j = 2;\n  this.l = [];\n}\nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push(\"end\");\n```\n\n#### (8) 函数参数是默认可选的\n\n> 由于在 `ES2015` 之前无法指定可选参数，因此 `.js` 文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。\n\n> 需要注意的一点是，使用过多的参数调用函数会得到一个错误。\n\n- 例如：\n\n```typescript\nfunction bar(a, b) {\n  console.log(a + \" \" + b);\n}\nbar(1); // OK, second argument considered optional\nbar(1, 2);\nbar(1, 2, 3); // Error, too many arguments\n```\n\n- 使用 `JSDoc` 注解的函数会被从这条规则里移除。使用 `JSDoc` 可选参数语法来表示可选性。\n\n```typescript\n// 比如：\n/**\n * @param {string} [somebody] - Somebody's name.\n */\nfunction sayHello(somebody) {\n  if (!somebody) {\n    somebody = \"John Doe\";\n  }\n  console.log(\"Hello \" + somebody);\n}\nsayHello();\n```\n\n#### (9) 由 `arguments` 推断出的 `var-args` 参数声明\n\n> 如果一个函数的函数体内有对 `arguments` 的引用，那么这个函数会隐式地被认为具有一个 `var-arg` 参数（比如: `(...arg: any[]) =>; any)`）。使用 `JSDoc` 的 `var-arg` 语法来指定 `arguments` 的类型。\n\n```typescript\n/** @param {...number} args */\nfunction sum(/* numbers */) {\n  var total = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n```\n\n#### (10) 未指定的类型参数默认为 `any`\n\n> 由于 `JavaScript` 里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为 `any`。\n\n#### (11) 在 `extends` 语句中：\n\n> 例如，`React.Component` 被定义成具有两个类型参数，`Props` 和 `State`。 在一个 `.js` 文件里，没有一个合法的方式在 `extends` 语句里指定它们。默认地参数类型为 `any`：\n\n```typescript\nimport { Component } from \"react\";\n\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Allowed, since this.props is of type any\n  }\n}\n```\n\n> 使用 `JSDoc` 的 `@augments` 来明确地指定类型。\n\n- 例如：\n\n```typescript\nimport { Component } from \"react\";\n/**\n * @augments {Component<{a: number}, State>}\n */\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Error: b does not exist on {a:number}\n  }\n}\n```\n\n#### (12) 在 JSDoc 引用中\n\n```typescript\n/** @type{Array} */\nvar x = [];\n\nx.push(1); // OK\nx.push(\"string\"); // OK, x is of type Array<any>\n\n/** @type{Array.<number>} */\nvar y = [];\n\ny.push(1); // OK\ny.push(\"string\"); // Error, string is not assignable to number\n```\n\n#### (13) 在函数调用中\n\n> 泛型函数的调用使用 `arguments` 来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为 `any`。\n\n```typescript\n// 例如：\nvar p = new Promise((resolve, reject) => {\n  reject();\n});\np; // Promise<any>;\n```\n\n### 24.2 支持的 JSDoc\n\n> 面的列表列出了当前所支持的 `JSDoc` 注解，你可以用它们在 `JavaScript` 文件里添加类型信息。 注意，没有在下面列出的标记（例如 `@async`）都是还不支持的。\n\n```typescript\n1.  @type\n2.  @param (or @arg or @argument)\n3.  @returns (or @return)\n4.  @typedef\n5.  @callback\n6.  @template\n7.  @class (or @constructor)\n8.  @this\n9.  @extends (or @augments)\n10. @enum\n```\n\n> 它们代表的意义与 `usejsdoc.org` 上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。\n\n#### (1) [@type ](/type)\n\n> 可以使用 `@type` 标记并引用一个类型名称（原始类型，`TypeScript` 里声明的类型，或在 `JSDoc` 里 `@typedef` 标记指定的）可以使用任何 `TypeScript` 类型和大多数 `JSDoc` 类型。\n\n```typescript\n/** @type {string} */\nvar s;\n\n/** @type {Window} */\nvar win;\n\n/** @type {PromiseLike<string>} */\nvar promisedString;\n\n// You can specify an HTML Element with DOM properties\n/** @type {HTMLElement} */\n\nvar myElement = document.querySelector(selector);\nelement.dataset.myData = \"\";\n```\n\n- `@type` 可以指定联合类型—例如，`string` 和 `boolean` 类型的联合。\n\n```typescript\n/** @type {{string | boolean}} */\nvar sb;\n```\n\n- 注意：括号是可选的\n\n```typescript\n/** @type {string | boolean} */\nvar sb;\n```\n\n- 有多种方式来指定数组类型\n\n```typescript\n/** @type {number[]} */\nvar ns;\n/** @type {Array.<number>} */\nvar nds;\n/** @type {Array<number>} */\nvar nas;\n```\n\n- 还可以指定对象字面量类型。例如，一个带有 `a(字符串)` 和 `b(数字)` 属性的对象，使用下面的语法：\n\n```typescript\n/** @type {{a: string, b: number}} */\nvar var9;\n```\n\n- 可以使用字符串和数字索引签名来指定 `map-like` 和 `array-like` 的对象，使用标准的 `JSDoc` 语法或者 `TypeScript` 语法。\n\n```typescript\n/**\n * A map-like object that maps arbitrary `string` properties to `number`s.\n *\n * @type {Object.<string, number>}\n * */\nvar stringToNumber;\n/** @type {Object.<number, object>} */\nvar arrayLike;\n```\n\n- 这两个类型与 `TypeScript` 里的 `{ [x: string]: number }` 和 `{ [x: number]: any }` 是等同的。 编译器能识别出这两种语法。\n- 可以使用 `TypeScript` 或 `Closure` 语法指定函数类型。\n\n```typescript\n/** @type {function(string, boolean): number} Closure syntax */\nvar sbn;\n/** @type {(s: string, b: boolean) => number} Typescript syntax */\nvar sbn2;\n```\n\n- 或者直接使用未指定的 `Function` 类型：\n\n```typescript\n/** @type {Function} */\nvar fn7;\n/** @type {function} */\nvar fn6;\n```\n\n- `Closure` 的其它类型也可以使用：\n\n```typescript\n/** @type {*} - can be 'any' type */\nvar star;\n/** @type {?} - unknown type (same as 'any') */\nvar question;\n```\n\n#### (2) 转换\n\n> `TypeScript` 借鉴了 `Closure` 里的转换语法。在括号表达式前面使用 `@type` 标记，可以将一种类型转换成另一种类型\n\n```typescript\n/**\n * @type {number | string}\n */\nvar numberOrString = Math.random() < 0.5 ? \"hello\" : 100;\nvar typeAssertedNumber = /** @type {number} */ numberOrString;\n```\n\n#### (3) 导入类型\n\n> 可以使用导入类型从其它文件中导入声明。 这个语法是 `TypeScript` 特有的，与 `JSDoc` 标准不同：\n\n```typescript\n/**\n * @param p { import(\"./a\").Pet }\n */\nfunction walk(p) {\n  console.log(`Walking ${p.name}...`);\n}\n```\n\n> 导入类型也可以使用在类型别名声明中：\n\n```typescript\n/**\n * @typedef Pet { import(\"./a\").Pet }\n */\n\n/**\n * @type {Pet}\n */\nvar myPet;\nmyPet.name;\n```\n\n> 导入类型可以用在从模块中得到一个值的类型。\n\n```typescript\n/**\n * @type {typeof import(\"./a\").x }\n */\nvar x = require(\"./a\").x;\n```\n\n#### (4) [@param ](/param) 和 [@returns ](/returns)\n\n> `@param` 语法 和 `@type` 相同，但增加了一个参数名。 使用 `[]` 可以把参数声明为可选的：\n\n```typescript\n// Parameters may be declared in a variety of syntactic forms\n/**\n * @param {string}  p1 - A string param.\n * @param {string=} p2 - An optional param (Closure syntax)\n * @param {string} [p3] - Another optional param (JSDoc syntax).\n * @param {string} [p4=\"test\"] - An optional param with a default value\n * @return {string} This is the result\n */\nfunction stringsStringStrings(p1, p2, p3, p4) {\n  // TODO\n}\n```\n\n> 函数的返回值类型也是类似的：\n\n```typescript\n/**\n * @return {PromiseLike<string>}\n */\nfunction ps() {}\n\n/**\n * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'\n */\nfunction ab() {}\n```\n\n#### (5) @typedef, @callback, 和 [@param ](/param)\n\n> `@typedef` 可以用来声明复杂类型。和 `@param` 类似的语法。\n\n```typescript\n/**\n * @typedef {Object} SpecialType - creates a new type named 'SpecialType'\n * @property {string} prop1 - a string property of SpecialType\n * @property {number} prop2 - a number property of SpecialType\n * @property {number=} prop3 - an optional number property of SpecialType\n * @prop {number} [prop4] - an optional number property of SpecialType\n * @prop {number} [prop5=42] - an optional number property of SpecialType with default\n */\n/** @type {SpecialType} */\nvar specialTypeObject;\n```\n\n> 可以在第一行上使用 `object` 或 `Object`。\n\n```typescript\n/**\n * @typedef {object} SpecialType1 - creates a new type named 'SpecialType'\n * @property {string} prop1 - a string property of SpecialType\n * @property {number} prop2 - a number property of SpecialType\n * @property {number=} prop3 - an optional number property of SpecialType\n */\n/** @type {SpecialType1} */\nvar specialTypeObject1;\n```\n\n> `@param` 允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：\n\n```typescript\n/**\n * @param {Object} options - The shape is the same as SpecialType above\n * @param {string} options.prop1\n * @param {number} options.prop2\n * @param {number=} options.prop3\n * @param {number} [options.prop4]\n * @param {number} [options.prop5=42]\n */\nfunction special(options) {\n  return (options.prop4 || 1001) + options.prop5;\n}\n```\n\n> `@callback` 与 `@typedef` 相似，但它指定函数类型而不是对象类型：\n\n```typescript\n/**\n * @callback Predicate\n * @param {string} data\n * @param {number} [index]\n * @returns {boolean}\n */\n/** @type {Predicate} */\nconst ok = s => !(s.length % 2);\n```\n\n> 当然，所有这些类型都可以使用 `TypeScript` 的语法 `@typedef` 在一行上声明：\n\n```typescript\n/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n/** @typedef {(data: string, index?: number) => boolean} Predicate */\n```\n\n#### (6) [@template ](/template)\n\n> 使用 `@template` 声明泛型：\n\n```typescript\n/**\n * @template T\n * @param {T} p1 - A generic parameter that flows through to the return type\n * @return {T}\n */\nfunction id(x) {\n  return x;\n}\n```\n\n> 用逗号或多个标记来声明多个类型参数：\n\n```typescript\n/**\n * @template T,U,V\n * @template W,X\n */\n```\n\n> 还可以在参数名前指定类型约束。只有列表的第一项类型参数会被约束:\n\n```typescript\n/**\n * @template {string} K - K must be a string or string literal\n * @template {{ serious(): string }} Seriousalizable - must have a serious method\n * @param {K} key\n * @param {Seriousalizable} object\n */\nfunction seriousalize(key, object) {\n  // ????\n}\n```\n\n#### (7) [@constructor ](/constructor)\n\n> 编译器通过 `this` 属性的赋值来推断构造函数, 但你可以让检查更严格提示更友好, 你可以添加一个 `@constructor` 标记:\n\n```typescript\n/**\n * @constructor\n * @param {number} data\n */\nfunction C(data) {\n  this.size = 0;\n  this.initialize(data); // Should error, initializer expects a string\n}\n/**\n * @param {string} s\n */\nC.prototype.initialize = function (s) {\n  this.size = s.length;\n};\n\nvar c = new C(0);\nvar result = C(1); // C should only be called with new\n```\n\n> 通过 `@constructor`, `this` 将在构造函数`C`里被检查，因此你在 `initialize` 方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用`C`而不是构造它，也会得到一个错误。\n\n> 不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用 `@constructor`。\n\n#### (8) [@this ](/this)\n\n> 编译器通常可以通过上下文来推断出 `this` 的类型。但你可以使用 `@this` 来明确指定它的类型：\n\n```typescript\n/**\n * @this {HTMLElement}\n * @param {*} e\n */\nfunction callbackForLater(e) {\n  this.clientHeight = parseInt(e); // should be fine!\n}\n```\n\n#### (9) [@extends ](/extends)\n\n> 当 `JavaScript` 类继承了一个基类, 无处指定类型参数的类型, 而 `@extends` 标记提供了这样一种方式:\n\n```typescript\n/**\n * @template T\n * @extends {Set<T>}\n */\nclass SortableSet extends Set {\n  // ...\n}\n```\n\n> 注意 `@extends` 只作用于类。当前，无法实现构造函数继承类的情况。\n\n#### (10) [@enum ](/enum)\n\n> `@enum` 标记允许你创建一个对象字面量, 它的成员都有确定的类型。不同于 `JavaScript` 里大多数的对象字面量，它不允许添加额外成员。\n\n```typescript\n/** @enum {number} */\nconst JSDocState = {\n  BeginningOfLine: 0,\n  SawAsterisk: 1,\n  SavingComments: 2\n};\n```\n\n> 注意 `@enum` 与 `TypeScript` 的 `@enum` 大不相同, 它更加简单。然而，不同于 `TypeScript` 的枚举, `@enum` 可以是任何类型:\n\n```typescript\n/** @enum {function(number): number} */\nconst Math = {\n  add1: n => n + 1,\n  id: n => -n,\n  sub1: n => n - 1\n};\n```\n\n#### (11) 更多示例\n\n```tsx\nvar someObj = {\n  /**\n   * @param {string} param1 - Docs on property assignments work\n   */\n  x: function (param1) {}\n};\n\n/**\n * As do docs on variable assignments\n * @return {Window}\n */\nlet someFunc = function () {};\n\n/**\n * And class methods\n * @param {string} greeting The greeting to use\n */\nFoo.prototype.sayHi = greeting => console.log(\"Hi!\");\n\n/**\n * And arrow functions expressions\n * @param {number} x - A multiplier\n */\nlet myArrow = x => x * x;\n\n/**\n * Which means it works for stateless function components in JSX too\n * @param {{a: string, b: number}} test - Some param\n */\nvar sfc = test => <div>{test.a.charAt(0)}</div>;\n\n/**\n * A parameter can be a class constructor, using Closure syntax.\n *\n * @param {{new(...args: any[]): object}} C - The class to register\n */\nfunction registerClass(C) {}\n\n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn10(p1) {}\n\n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn9(p1) {\n  return p1.join();\n}\n```\n\n#### (12) 已知不支持的模式\n\n> 在值空间中将对象视为类型是不可以的, 除非对象创建了类型, 如构造函数。\n\n```typescript\nfunction aNormalFunction() {}\n/**\n * @type {aNormalFunction}\n */\nvar wrong;\n/**\n * Use 'typeof' instead:\n * @type {typeof aNormalFunction}\n */\nvar right;\n```\n\n> 对象字面量属性上的 `=` 后缀不能指定这个属性是可选的:\n\n```typescript\n/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * Use postfix question on the property name instead:\n * @type {{ a: string, b?: number }}\n */\nvar right;\n```\n\n> `Nullable` 类型只在启用了 `strictNullChecks` 检查时才启作用:\n\n```typescript\n/**\n * @type {?number}\n * With strictNullChecks: true -- number | null\n * With strictNullChecks: off  -- number\n */\nvar nullable;\n```\n\n> `Non-nullable` 类型没有意义, 以其原类型对待:\n\n```typescript\n/**\n * @type {!number}\n * Just has type number\n */\nvar normal;\n```\n\n> 不同于 `JSDoc` 类型系统, `TypeScript` 只允许将类型标记为包不包含 `null`。`Non-nullable` -- 如果启用了 `strictNullChecks`，那么 `number` 是 `非null` 的。 如果没有启用，那么 `number` 是可以为 `null` 的。\n","source":"_posts/前端/TypeScript 文档.md","raw":"---\ntitle: TypeScript 文档\ndate: 2020-09-10\ncategories: [前端, ts]\ntags:\n  - 文档\n---\n\n## 一、 基础类型\n\n### 1.1 类型断言\n\n> 有时候你会遇到这样的情况，你会比 `TypeScript` 更了解某个值的详细信息。通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。类型断言好比其它语言里的类型转换，但是不尽兴特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。\n\n- 类型断言有两种形式\n\n- 第一种：尖括号语法 (当在 `TypeScript` 里使用 `JSX` 时，只有 `as` 语言断言是被允许的)\n\n```typescript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n```\n\n- 第二种：`as` 语法\n\n```typescript\nlet _someValue: any = \"this is a string\";\nlet _strLength: number = (_someValue as string).length;\n```\n\n### 1.2 基础类型\n\n#### 1.2.1 布尔值\n\n```typescript\nlet isDone: boolean = false;\n```\n\n#### 1.2.2 数字\n\n> 与 `javascript` 一样，`TypeScript` 里的所有数字都是浮点数。这些浮点数的类型是 `number`。 除了支持十进制和十六进制字面量， `TypeScript` 还支持 `ECMA2015` 中引入的二进制和八进制字面量。\n\n```typescript\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\nlet binaryLiteral: number = 0b1010;\nlet octalLiteral: number = 0o744;\n```\n\n#### 1.2.3 字符串\n\n```typescript\nlet strName: string = \"bob\";\n```\n\n#### 1.2.4 数组\n\n> `TypeScript` 像 `JavaScript` 一样可以操作数组元素。有两种方法定义数组。\n\n- 第一种：可以在元素类型后面接上 `[]`;\n\n```typescript\nlet list1: number[] = [1, 2, 3];\n```\n\n- 第二种：使用数组泛型, `Array<元素类型>`\n\n```typescript\nlet list2: Array<number> = [1, 2, 3];\n```\n\n#### 1.2.5 元组 Tuple\n\n- 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。\n\n```typescript\nlet x: [string, number];\nx = [\"hello\", 10]; // => Ok\nx = [10, \"hello\"]; // => Error\n```\n\n- 当访问一个已知索引的元素，会得到正确的类型\n\n```typescript\nconsole.log(x[0].substr(1)); // => Ok\nconsole.log(x[1].substr(1)); // => Error\n```\n\n- 当访问一个越界的元素，会使用联合类型替代\n\n```typescript\nx[3] = \"world\"; // Ok, 字符串可以赋值给(string | number)类型\nconsole.log(x[5].toString()); // Ok, \"string\"和\"number\"都有toString方法\nx[6] = true; // Error, 布尔不是(string | number)类型\n```\n\n#### 1.2.6 枚举\n\n- `enum` 类型是对 `JavaScript` 标准数据类型的一个补充。像 `C#` 等其他语言一样，使用枚举类型可以为一组数值赋予友好的名字\n\n```typescript\nenum Color {\n  Red,\n  Green,\n  Blue\n}\nlet c: Color = Color.Green;\n```\n\n- 默认情况下，从 `0` 开始为元素编号。你也可以手动的指定成员的数值。\n\n```typescript\nenum Color1 {\n  Red = 1,\n  Green,\n  Blue\n}\nlet c1: Color1 = Color1.Green;\n```\n\n- 或者全部采用赋值\n\n```typescript\nenum Color2 {\n  Red = 1,\n  Green = 2,\n  Blue = 4\n}\nlet c2: Color2 = Color2.Green;\n```\n\n- 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。\n\n```typescript\nenum Color3 {\n  Red = 1,\n  Green,\n  Blue\n}\nlet colorName: string = Color3[2];\nconsole.log(colorName);\n```\n\n#### 1.2.7 Any\n\n- 有时候，我们想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自于动态的内容，比如来自用户输入或第三方库。这种情况下，我们不希望类型检查器对这些值进行检查而是让它们通过编译阶段的检查。那么我们可以使用 `any` 类型来标记这些变量\n\n```typescript\nlet notSure: any = 4;\nnotSure = \"maybe a string instead\";\nnotSure = false; // Ok\n```\n\n- 在对现有代码进行改写的时候，`any` 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。你可能认为 `Object` 有相似的作用，就像在其他语言中那样。但是 `Object` 类型的变量只是允许你给他赋任意值，但是却不能够在它上面调用任意的方法，即使它真有这些方法。\n\n```typescript\nlet notSure1: any = 4;\nnotSure1.ifItExists(); // Ok\nnotSure1.toFixed(); // Ok\nlet prettySure: Object = 4;\n// prettySure.toFixed(); // Error, Property 'toFixed' doesn't exist on type 'Object'.\n```\n\n- 当你只知道一部分数据类型时，`any` 类型也是有用的。\n\n```typescript\nlet list: any[] = [1, true, \"free\"];\nlist[1] = 100;\n```\n\n#### 1.2.8 Void\n\n- 某种程度上来说，`void` 类型像是与 `any` 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 `void`。\n\n```typescript\nfunction warnUser(): void {\n  console.log(\"This is my warning message\");\n}\n```\n\n- 声明一个 `void` 类型的变量没有什么大用，因为你只能为它赋予 `undefined` 和 `null`\n\n```typescript\nlet unusbale: void = undefined;\n```\n\n#### 1.2.9 Null 和 Undefined\n\n- `TypeScript` 里，`undefined` 和 `null` 两者各有自己的类型分别叫做 `undefined` 和 `null`。和 `void` 相似，它们本身的类型用处不是很大。\n\n```typescript\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n- 默认情况下 `null` 和 `undefined` 是所有类型的子类型。就是说你可以把 `null` 和 `undefined` 赋值给 `number` 类型的变量。\n- 然而，当你指定了一个 `--strictNullChecks` 标记，`null` 和 `undefined` 只能赋值给 `void` 和它们各自。这能避免很多常见的问题。也许在某处你想传入一个 `string` 或 `null` 或 `undefined`，你可以使用联合类型 `string | null | undefined`。\n\n#### 1.2.10 Never\n\n- `never` 类型表示的是那些永不存在的值的类型。例如：`never` 类型是那些总会抛出异常或根本不会有返回值的函数表达式或箭头函数表达式的返回值类型；\n- 变量也可能是 `never` 类型，当它们被永不为真的类型保护所约束时。\n- `never` 类型是任何类型的子类型，也可以赋值给任何类型；\n\n> 然而，没有类型是 `never` 的子类型或可以赋值给 `never` 类型(除了 `never` 本身之外)。即使 `any` 也不可以赋值给 `never`。\n\n```typescript\n// 返回 never 的函数必须存在无法达到的终点\nfunction error(message: string): never {\n  throw new Error(message);\n}\n// 推断的返回值类型为never\nfunction fail() {\n  return error(\"Something failed\");\n}\n// 返回 never 的函数必须存在法达到的终点\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n```\n\n#### 1.2.11 Object\n\n- `Object` 表示非原始类型，也就是除 `number`, `string`, `boolean`, `symbol`, `null` 或 `undefined` 之外的类型。\n- 使用 `Object` 类型，就可以更好的表示像 `Object.create` 这样的 `API`。\n\n```typescript\ndeclare function create(o: object | null): void;\ncreate({ prop: 0 }); // Ok\ncreate(null); // Ok\ncreate(42); //Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\n```\n\n## 二、变量声明\n\n### 2.1 介绍\n\n> `let` 和 `const` 是 `JavaScript` 里相对较新的变量声明方式。 像我们之前提到过的， `let` 在很多方面与 `var` 是相似的，但是可以帮助大家避免在 `JavaScript` 里常见一些问题。 `const` 是对 `let` 的一个增强，它能阻止对一个变量再次赋值。\n> 因为 `TypeScript` 是 `JavaScript` 的超集，所以它本身就支持 `let` 和 `const` 。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 `var`。\n> 如果你之前使用 `JavaScript` 时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 `var` 声明的怪异之处了如指掌，那么你可以轻松地略过这节。\n\n### 2.2 var 声明\n\n> 一直以来我们都是通过 `var` 关键字定义 `JavaScript` 变量。\n\n```typescript\nvar a = 10;\n```\n\n> 大家都能理解，这里定义了一个名为 `a` 值为 `10` 的变量。\n> 我们也可以在函数内部定义变量：\n\n```typescript\nfunction f() {\n  var message = \"Hello, world!\";\n  return message;\n}\n```\n\n> 并且我们也可以在其它函数内部访问相同的变量。\n\n```typescript\nfunction f() {\n  var a = 10;\n  return function g() {\n    var b = a + 1;\n    return b;\n  };\n}\n\nvar g = f();\ng(); // returns 11;\n```\n\n> 上面的例子里，`g` 可以获取到 `f` 函数里定义的 `a` 变量。 每当 `g` 被调用时，它都可以访问到 `f` 里的 `a` 变量。 即使当 `g` 在 `f` 已经执行完后才被调用，它仍然可以访问及修改 `a`。\n\n```typescript\nfunction f() {\n  var a = 1;\n\n  a = 2;\n  var b = g();\n  a = 3;\n\n  return b;\n\n  function g() {\n    return a;\n  }\n}\n\nf(); // returns 2\n```\n\n### 2.3 作用域规则\n\n> 对于熟悉其它语言的人来说，`var` 声明有些奇怪的作用域规则。 看下面的例子：\n\n```typescript\nfunction f(shouldInitialize: boolean) {\n  if (shouldInitialize) {\n    var x = 10;\n  }\n  return x;\n}\n\nf(true); // returns '10'\nf(false); // returns 'undefined'\n```\n\n> 有些读者可能要多看几遍这个例子。 变量 `x` 是定义在 `if` 语句里面\\_，但是我们却可以在语句的外面访问它。 这是因为 `var` 声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为 `var` 作用域或函数作用域。函数参数也使用函数作用域。\n> 这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n  var sum = 0;\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n```\n\n> 这里很容易看出一些问题，里层的 `for` 循环会覆盖变量 `i`，因为所有 `i` 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。\n\n### 2.4 捕获变量怪异之处\n\n> 快速的猜一下下面的代码会返回什么：\n\n```typescript\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\n> 介绍一下，`setTimeout` 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。\n> 好吧，看一下结果：\n\n```typescript\n10;\n10;\n10;\n10;\n10;\n10;\n10;\n10;\n10;\n10;\n```\n\n> 很多 `JavaScript` 程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：\n\n```typescript\n0;\n1;\n2;\n3;\n4;\n5;\n6;\n7;\n8;\n9;\n```\n\n> 还记得我们上面提到的捕获变量吗？\n> 我们传给 `setTimeout` 的每一个函数表达式实际上都引用了相同作用域里的同一个 `i`。\n> 让我们花点时间思考一下这是为什么。 `setTimeout` 在若干毫秒后执行一个函数，并且是在 `for` 循环结束后。 `for` 循环结束后，`i` 的值为 `10`。 所以当函数被调用的时候，它会打印出 `10！`\n> 一个通常的解决方法是使用立即执行的函数表达式（`IIFE`）来捕获每次迭代时 `i` 的值：\n\n```typescript\nfor (var i = 0; i < 10; i++) {\n  // capture the current state of 'i'\n  // by invoking a function with its current value\n  (function (i) {\n    setTimeout(function () {\n      console.log(i);\n    }, 100 * i);\n  })(i);\n}\n```\n\n> 这种奇怪的形式我们已经司空见惯了。 参数 `i` 会覆盖 `for` 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 `for` 循环体里的代码。\n\n### 2.5 let 声明\n\n> 现在你已经知道了 `var` 存在一些问题，这恰好说明了为什么用 `let` 语句来声明变量。 除了名字不同外， let 与 `var` 的写法一致。\n\n```typescript\nlet hello = \"Hello!\";\n```\n\n> 主要的区别不在语法上，而是语义，我们接下来会深入研究。\n\n### 2.6 块作用域\n\n> 当用 `let` 声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 `var` 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 `for` 循环之外是不能访问的。\n\n```typescript\nfunction f(input: boolean) {\n  let a = 100;\n  if (input) {\n    // Still okay to reference 'a'\n    let b = a + 1;\n    return b;\n  }\n\n  // Error: 'b' doesn't exist here\n  return b;\n}\n```\n\n> 这里我们定义了`2`个变量 `a` 和 `b` 。 `a` 的作用域是 `f` 函数体内，而 `b` 的作用域是 `if` 语句块里。\n> 在 `catch` 语句里声明的变量也具有同样的作用域规则。\n\n```typescript\ntry {\n  throw \"oh no!\";\n} catch (e) {\n  console.log(\"Oh well.\");\n}\n\n// Error: 'e' doesn't exist here\nconsole.log(e);\n```\n\n> 拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 `let` 语句之前访问它们，幸运的是 `TypeScript` 可以告诉我们这些信息。\n\n```typescript\na++; // illegal to use 'a' before it's declared;\nlet a;\n```\n\n> 注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 `ES2015`，现代的运行时会抛出一个错误；然而，现今 `TypeScript` 是不会报错的。\n\n```typescript\nfunction foo() {\n  // okay to capture 'a'\n  return a;\n}\n\n// 不能在'a'被声明前调用'foo'\n// 运行时应该抛出错误\nfoo();\n\nlet a;\n```\n\n> 关于暂时性死区的更多信息，查看这里 [Mozilla Developer Network.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let)\n\n### 2.7 重定义及屏蔽\n\n> 我们提过使用 `var` 声明时，它不在乎你声明多少次；你只会得到 `1` 个。\n\n```typescript\nfunction f(x) {\n  var x;\n  var x;\n  if (true) {\n    var x;\n  }\n}\n```\n\n> 在上面的例子里，所有 `x` 的声明实际上都引用一个相同的 `x`，并且这是完全有效的代码。 这经常会成为`bug` 的来源。 好的是， `let` 声明就不会这么宽松了。\n\n```typescript\nlet x = 10;\nlet x = 20; // 错误，不能在1个作用域里多次声明`x\n```\n\n> 并不是要求两个均是块级作用域的声明 `TypeScript` 才会给出一个错误的警告。\n\n```typescript\nfunction f(x) {\n  let x = 100; // error: interferes with parameter declaration\n}\n\nfunction g() {\n  let x = 100;\n  var x = 100; // error: can't have both declarations of 'x'\n}\n```\n\n> 并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。\n\n```typescript\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100;\n    return x;\n  }\n  return x;\n}\n\nf(false, 0); // returns 0\nf(true, 0); // returns 100\n```\n\n> 在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 `let` 重写之前的 `sumMatrix` 函数。\n\n```typescript\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0;\n  for (let i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n```\n\n> 这个版本的循环能得到正确的结果，因为内层循环的 i 可以屏蔽掉外层循环的 `i`。\n> 通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。\n\n### 2.8 块级作用域变量的获取\n\n> 在我们最初谈及获取用 `var` 声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。\n\n```typescript\nfunction theCityThatAlwaysSleeps() {\n  let getCity;\n  if (true) {\n    let city = \"Seattle\";\n    getCity = function () {\n      return city;\n    };\n  }\n  return getCity();\n}\n```\n\n> 因为我们已经在 `city` 的环境里获取到了 `city` ，所以就算 if 语句执行结束后我们仍然可以访问它。\n> 回想一下前面 `setTimeout` 的例子，我们最后需要使用立即执行的函数表达式来获取每次 `for` 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 `TypeScript` 里这样做了。\n> 当 `let` 声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 `setTimeout` 例子里我们仅使用 `let` 声明就可以了。\n\n```typescript\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n```\n\n> 会输出与预料一致的结果：\n\n```typescript\n0;\n1;\n2;\n3;\n4;\n5;\n6;\n7;\n8;\n9;\n```\n\n### 2.9 const 声明\n\n> `const` 声明是声明变量的另一种方式。\n\n```typescript\nconst numLivesForCat = 9;\n```\n\n> 它们与 `let` 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 `let` 相同的作用域规则，但是不能对它们重新赋值。\n> 这很好理解，它们引用的值是不可变的。\n\n```typescript\nconst numLivesForCat = 9;\nconst kitty = {\n  name: \"Aurora\",\n  numLives: numLivesForCat\n};\n\n// Error\nkitty = {\n  name: \"Danielle\",\n  numLives: numLivesForCat\n};\n\n// all \"okay\"\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;\n```\n\n> 除非你使用特殊的方法去避免，实际上 `const` 变量的内部状态是可修改的。 幸运的是，`TypeScript` 允许你将对象的成员设置成只读的。 接口一章有详细说明。\n\n### 2.10 let vs. const\n\n> 现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。\n> 使用最小特权原则，所有变量除了你计划去修改的都应该使用 `const`。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 `const` 也可以让我们更容易的推测数据的流动。\n> 跟据你的自己判断，如果合适的话，与团队成员商议一下。\n> 这个手册大部分地方都使用了 `let` 声明。\n\n### 2.11 解构\n\n> `Another TypeScript` 已经可以解析其它 `ECMAScript 2015` 特性了。 完整列表请参见 [the article on the Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。 本章，我们将给出一个简短的概述。\n\n#### 2.11.1 解构数组\n\n> 最简单的解构莫过于数组的解构赋值了：\n\n```typescript\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n```\n\n> 这创建了 `2` 个命名变量 `first` 和 `second`。 相当于使用了索引，但更为方便：\n\n```typescript\nfirst = input[0];\nsecond = input[1];\n```\n\n> 解构作用于已声明的变量会更好：\n\n```typescript\n// swap variables\n[first, second] = [second, first];\n```\n\n> 作用于函数参数：\n\n```typescript\nfunction f([first, second]: [number, number]) {\n  console.log(first);\n  console.log(second);\n}\nf(input);\n```\n\n> 你可以在数组里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n```\n\n> 当然，由于是 `JavaScript`, 你可以忽略你不关心的尾随元素：\n\n```typescript\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n```\n\n> 或其它元素：\n\n```typescript\nlet [, second, , fourth] = [1, 2, 3, 4];\n```\n\n#### 2.11.2 对象解构\n\n> 你也可以解构对象：\n\n```typescript\nlet o = {\n  a: \"foo\",\n  b: 12,\n  c: \"bar\"\n};\nlet { a, b } = o;\n```\n\n> 这通过 `o.a and o.b` 创建了 `a` 和 `b` 。 注意，如果你不需要 `c` 你可以忽略它。\n> 就像数组解构，你可以用没有声明的赋值：\n\n```typescript\n({ a, b } = { a: \"baz\", b: 101 });\n```\n\n> 注意，我们需要用括号将它括起来，因为 `Javascript` 通常会将以 `{` 起始的语句解析为一个块。\n> 你可以在对象里使用 `...` 语法创建剩余变量：\n\n```typescript\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\n```\n\n#### 2.11.3 属性重命名\n\n> 你也可以给属性以不同的名字：\n\n```typescript\nlet { a: newName1, b: newName2 } = o;\n```\n\n> 这里的语法开始变得混乱。 你可以将 `a: newName1` 读做 \"`a` 作为 `newName1`\"。 方向是从左到右，好像你写成了以下样子：\n\n```typescript\nlet newName1 = o.a;\nlet newName2 = o.b;\n```\n\n> 令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。\n\n```typescript\nlet { a, b }: { a: string; b: number } = o;\n```\n\n#### 2.11.4 默认值\n\n> 默认值可以让你在属性为 `undefined` 时使用缺省值：\n\n```typescript\nfunction keepWholeObject(wholeObject: { a: string; b?: number }) {\n  let { a, b = 1001 } = wholeObject;\n}\n```\n\n> 现在，即使 `b` 为 `undefined` ， `keepWholeObject` 函数的变量 `wholeObject` 的属性 `a` 和 `b` 都会有值。\n\n#### 2.11.5 函数声明\n\n> 解构也能用于函数声明。 看以下简单的情况：\n\n```typescript\ntype C = { a: string; b?: number };\nfunction f({ a, b }: C): void {\n  // ...\n}\n```\n\n> 但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。\n\n```typescript\nfunction f({ a = \"\", b = 0 } = {}): void {\n  // ...\n}\nf();\n```\n\n> 上面的代码是一个类型推断的例子，将在本手册后文介绍。\n> 其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 `C` 的定义有一个 `b` 可选属性：\n\n```typescript\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n  // ...\n}\nf({ a: \"yes\" }); // ok, default b = 0\nf(); // ok, default to {a: \"\"}, which then defaults b = 0\nf({}); // error, 'a' is required if you supply an argument\n```\n\n> 要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。\n\n#### 2.11.6 展开\n\n> 展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：\n\n```typescript\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n```\n\n> 这会令 `bothPlus` 的值为 `[0, 1, 2, 3, 4, 5]`。 展开操作创建了 `first` 和 `second` 的一份浅拷贝。 它们不会被展开操作所改变。\n> 你还可以展开对象：\n\n```typescript\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { ...defaults, food: \"rich\" };\n```\n\n> `search` 的值为 `{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }`。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：\n\n```typescript\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { food: \"rich\", ...defaults };\n```\n\n> 那么，`defaults` 里的 `food` 属性会重写 `food: \"rich\"`，在这里这并不是我们想要的结果。\n> 对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 [自身的可枚举属性](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)。 大体上是说当你展开一个对象实例时，你会丢失其方法：\n\n```typescript\nclass C {\n  p = 12;\n  m() {}\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n```\n\n> 其次，`TypeScript` 编译器不允许展开泛型函数上的类型参数。 这个特性会在 `TypeScript` 的未来版本中考虑实现。\n\n## 三、接口\n\n### 3.1 实现一个简单的接口\n\n```typescript\ninterface LabelledValue {\n  label: string;\n}\nfunction printLabel(labelledObj: LabelledValue) {\n  console.log(labelledObj.label);\n}\nlet myObj = { size: 10, label: \"size 10 Object\" };\nprintLabel(myObj);\n```\n\n### 3.2 可选属性\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\nfunction createConfig(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: \"white\", area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\nlet mySquare = createConfig({ color: \"black\", width: 20 });\nconsole.log(mySquare);\n```\n\n### 3.3 只读属性\n\n```typescript\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n}\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error! 因为属性是只读的\n```\n\n### 3.4 额外的属性检查\n\n> 问题：将\" _可选属性_ \"与\" `option bags` \"模式相结合而引发\n\n```typescript\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\nfunction createConfig(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: \"white\", area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n```\n\n> `let mySquare = createConfig({ colour: \"red\", width: 100 }); //报错`\n\n- 解决方案一：采用类型断言\n\n```typescript\nlet mySquare = createConfig({ width: 100, opacity: 0.5 } as SquareConfig);\n```\n\n- 解决方案二：采用添加一个字符串索引签名(最佳方案)\n\n```typescript\ninterface _SquareConfig {\n  color?: string;\n  width?: number;\n  [propName: string]: any;\n}\n```\n\n- 解决方案三：变量赋值\n\n### 3.5 函数类型\n\n#### 3.5.1 函数类型\n\n```typescript\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\nlet mySearch: SearchFunc;\nmySearch = function (source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n};\n```\n\n#### 3.5.2 函数类型\n\n```typescript\nlet add: (baseValue: number, increment: number) => number = (x, y) => x + y;\n\nlet add2 = (x: number, y: number): number => x + y;\n\nlet buildNameFun: (fname: string, ...rest: Array<string>) => string = (firstName: string, ...restOfName: Array<string>) => `${firstName}, ${restOfName.join(\" \")}`;\n\nlet fn = (a: number, b: number): number => a + b;\n```\n\n#### 3.5.3 函数类型\n\n```typescript\ninterface func {\n  (x: string, y: string): boolean;\n}\nlet func: func = (x: string, y: string) => {\n  return x.search(y) > -1;\n};\n```\n\n### 3.6 可索引类型\n\n- 例如：`a[10]` 或 `ageMap[\"daniel\"]`\n- 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型\n\n```typescript\ninterface StringArray {\n  [index: number]: string;\n}\nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\nlet myStr: string = myArray[0];\nconsole.log(myStr);\n```\n\n> `Ts` 支持两种索引签名：字符串 和 数字。可以同时使用两种类型的索引，但数字索引的返回值必须是字符串索引返回值类型的子类型。\n\n### 3.7 类类型\n\n> 接口描述了类的公共部分，而不是类的公有和私有两部分。它不会帮你检查类是否具有某些私有成员\n\n```typescript\ninterface ClockInterface {\n  currentTime: Date;\n  setTime(d: Date); // 在接口中描述的方法\n}\n\nclass Clock implements ClockInterface {\n  currentTime: Date;\n  setTime(d: Date) {\n    // 在类中的具体实现\n    this.currentTime = d;\n  }\n  constructor(h: number, m: number) {}\n}\n```\n\n> 当操作类的时候，我们需要知道类是具有两个类型的：_静态部分的类型_ 和 _实例的类型_。\n> 当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误。\n> 因为当一个类实现了一个接口时，只对其实例部分进行类型检查。`constructor` 存在于类的静态部分，所以不在检查的范围内。\n\n- 因此应当直接操作 _类的静态部分_\n\n```typescript\ninterface err_ClockConstructor {\n  new (hour: number, minute: number);\n}\nclass err_Clock implements err_ClockConstructor {\n  currentTime: Date;\n  constructor(h: number, m: number) {}\n}\n```\n\n- 下面是实现对 _静态类型_ 的检查工作\n\n> 因为 `createClock` 的第一个参数是 `ClockConstructor` 类型，在 `createClock(AnalogClock, 7, 32)` 里，会检查 `AnalogClock` 是否符合构造函数签名\n\n```typescript\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n\ninterface ClockInterface {\n  tick();\n}\n\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {\n  return new ctor(hour, minute);\n}\n\nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n\n  tick() {\n    console.log(\"beep beep\");\n  }\n}\n\nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n\n  tick() {\n    console.log(\"tick tick\");\n  }\n}\n\nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\nconsole.log(digital);\nconsole.log(analog);\n```\n\n### 3.8 接口继承\n\n- 和类一样，接口也可以相互继承。可以灵活地将接口分割到可重用的模块里。\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface Square extends Shape {\n  sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\n```\n\n- 一个接口可以继承多个接口，创建出多个接口的合成接口\n\n```typescript\ninterface Shape {\n  color: string;\n}\n\ninterface PenStroke {\n  penWidth: number;\n}\n\ninterface Square extends Shape, PenStroke {\n  sideLength: number;\n}\n\nlet square = <Square>{};\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\n```\n\n- 目的: `=>` 灵活地将接口分割到可重用的模块中\n\n```typescript\ninterface Lamp {\n  lampOn(): void;\n\n  lampOff(): void;\n}\n\ninterface wx {\n  wxNumber: number;\n\n  showWxNumber(): string;\n}\n\ninterface Photo extends Lamp, wx {\n  photo(): string;\n}\n\nclass HuaWeiPhone implements Photo {\n  public wxNumber: number;\n\n  photo(): string {\n    return \"华为手机\";\n  }\n\n  lampOn(): void {}\n\n  lampOff(): void {}\n  constructor(wxNumber: number) {\n    this.wxNumber = wxNumber;\n  }\n\n  showWxNumber(): string {\n    return \"我的微信号：123\";\n  }\n}\nlet huaWeiPhone = new HuaWeiPhone(12345678910);\nconsole.log(huaWeiPhone.showWxNumber());\nconsole.log(huaWeiPhone.photo());\n```\n\n### 3.9 混合类型\n\n> 一个对象可以同时做为函数和对象使用，并带有额外的属性\n\n```typescript\ninterface Counter {\n  (start: number): string;\n\n  interval: number;\n\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = <Counter>function (start: number) {\n    // return start + 'string';\n  };\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.interval = 5.0;\nc.reset();\n```\n\n### 3.10 接口继承类\n\n1. 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。\n2. 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。\n3. 接口同样会继承到类的 `private` 和 `protected` 成员。\n4. 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现( `implement` )。\n5. 当你有一个庞大的继承接口时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。这个子类除了继承至基类外与基类没有任何关系。\n\n```typescript\nclass Control {\n  private state: any;\n}\n\ninterface SelectableControl extends Control {\n  select(): void;\n}\n\nclass Button extends Control implements SelectableControl {\n  select(): void {}\n}\n\nclass TextBox extends Control {\n  select(): void {}\n}\n\n// 错误：\"Image\"类型缺少\"state\"属性\nclass Image implements SelectableControl {\n  select(): void {}\n}\nclass Location {}\n```\n\n> 在上面的例子中，`SelectableControl` 包含了 `Control` 的所有成员。包括私有成员 `state`。因为 `state` 是私有成员，所以只能够是 `Control` 的子类们才能实现 `SelectableControl` 接口，因为只有 `Control` 的子类才能够拥有一个声明于 `Control` 的私有成员 `state`，这对私有成员的兼容性是必需的。\n> 在 `Control` 类内部，是允许通过 `SelectableControl` 的实例来访问私有成员 `state` 的。实际上，`SelectableControl` 接口和拥有 `select` 方法的 `Control` 类是一样的。`Button` 和 `TextBox` 类是 `SelectableControl` 的子类(因为它们都继承自 `Control` 并有 `select` 方法，但 `Image` 和 `Location` 类并不是这样的。)\n\n### 3.11 接口继承接口\n\n> 目的: `=>` 灵活地将接口分割到可重用的模块中\n\n```typescript\ninterface Lamp {\n  lampOn(): void;\n  lampOff(): void;\n}\ninterface wx {\n  wxNumber: number;\n  showWxNumber(): string;\n}\n\ninterface Photo extends Lamp, wx {\n  photo(): string;\n}\n\nclass HuaWeiPhone implements Photo {\n  public wxNumber: number;\n  photo(): string {\n    return \"华为手机\";\n  }\n  lampOn() {}\n  lampOff() {}\n  constructor(wxNumber: number) {\n    this.wxNumber = wxNumber;\n  }\n  showWxNumber() {\n    return \"我的微信号是：123\";\n  }\n}\n\nlet huaWeiPhone = new HuaWeiPhone(13100970071);\nconsole.log(huaWeiPhone.showWxNumber());\nconsole.log(huaWeiPhone.photo());\n```\n\n### 3.12 类接口实现\n\n> 手机类是一个大类\n> 华为是手机类下的一个类\n> 华为手机有拍照和闪光灯功能，照相机也有拍照和闪光灯功能\n> 因此华为手机和照相机的公共特性就是拍照和闪光灯\n> 所以通过关键字 `implements` 来标识提取出来的接口\n\n```typescript\n// 拍照\ninterface Photo {\n  photo(): string;\n}\n// 闪光灯\ninterface Lamp {\n  lampOn(): void;\n  lampOff(): void;\n}\n\nclass Phone {}\n\nclass HuaWei extends Phone implements Photo, Lamp {\n  photo(): string {\n    return \"华为拍照\";\n  }\n  lampOn() {}\n  lampOff() {}\n}\n\nclass DigitalCamera implements Photo, Lamp {\n  photo(): string {\n    return \"照相机拍照\";\n  }\n  lampOn() {}\n  lampOff() {}\n}\n```\n\n## 四、类\n\n### 4.1 创建一个基本类\n\n```typescript\nclass Gretter {\n  public gretting: string;\n  constructor(message: string) {\n    this.gretting = message;\n  }\n  public greet() {\n    return `Hello, ${this.gretting}`;\n  }\n}\n\nlet gretter: Gretter = new Gretter(\"world!\");\nconsole.log(gretter);\n```\n\n### 4.2 继承\n\n```typescript\nclass Animal {\n  name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n  move(distanceInMeters: number = 0) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n\nclass Snake extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  move(distanceInMeters = 5) {\n    console.log(\"Slithering...\");\n    super.move(distanceInMeters);\n  }\n}\n\nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  move(distanceInMeters = 45) {\n    console.log(\"Galloping\");\n    super.move(distanceInMeters);\n  }\n}\n\nlet sam = new Snake(\"Sammy the Python\");\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\n\nsam.move();\ntom.move(34);\n```\n\n### 4.3 public 关键字\n\n> 默认为 `public`\n> 在 `TypeScript` 中,成员都默认为 `public`\n\n```typescript\nclass Animal_public {\n  public name: string;\n  public constructor(theName: string) {\n    this.name = theName;\n  }\n  public move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n```\n\n### 4.4 private 关键字\n\n> 理解 `private`\n>\n> 1. 当成员被标记成 `private` 时，它就不能在声明它的类的外部访问\n> 2. 如果其中一个类型里包含一个 `private` 成员，那么只有当另外一个类型中也存在这样一个 `private` 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。\n\n```typescript\nclass Animal_private {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\nconst cat = new Animal_private(\"Cat\");\n// cat.name; // 错误：'name'是私有的\n\nclass Animal_private_1 {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\nclass Rhino extends Animal_private_1 {\n  constructor() {\n    super(\"Rhino\");\n  }\n}\nclass Employee {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\nlet animal = new Animal_private_1(\"Goat\");\nlet rhino = new Rhino();\nlet employee = new Employee(\"Bob\");\n\nanimal = rhino;\n// animal = employee; //错误：Animal与Employee不兼容\n```\n\n### 4.5 protected 关键字\n\n- 理解 `protected`\n\n> `protected` 修饰符与 `private` 修饰符的行为很相似，但是有一点不同，`protected` 成员在派生类中仍然可以访问。\n\n```typescript\nclass Person {\n  protected name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nclass _Employee extends Person {\n  private department: string;\n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}`;\n  }\n}\nlet howard = new _Employee(\"Howard\", \"Sales\");\nconsole.log(howard.getElevatorPitch());\n// console.log(howard.name); // 错误，因为 name 无法在外部访问，但是可以在派生类中访问\n```\n\n- 构造函数也可以被标记成 `protected`\n\n> 这意味着这个类不能在包含它的类外被实例化。但是能被继承。\n\n```typescript\nclass __Person {\n  protected name: string;\n  protected constructor(theName: string) {\n    this.name = theName;\n  }\n}\n// __Employee 能够继承 Person\nclass __Employee extends __Person {\n  private department: string;\n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n  }\n}\nlet __howard = new __Employee(\"Howard\", \"Sales\");\n// let __join = new __Person(\"John\");// 错误：'Person'的构造函数是被保护的\n```\n\n### 4.6 readonly 修饰符\n\n- 你可以使用 `readonly` 关键字将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化\n\n```typescript\nclass Octopus {\n  readonly name: string;\n  readonly numberOfLegs: number = 8;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\nlet dad = new Octopus(\"Man with the 8 strong legs\");\n// dad.name = \"Man with the 3-piece suit\";// 错误，name是只读的\n```\n\n- 参数属性\n\n> 1. 参数属性可以方便地让我们在一个地方定义并初始化一个成员。\n> 2. 参数属性通过给构造函数参数前面添加一个访问限定符来声明。\n> 3. 使用 `private` 限定一个参数属性会声明并初始化一个私有成员；对于 `public` 和 `protected` 来说也是一样。\n\n```typescript\nclass _Octopus {\n  readonly numberOfLegs: number = 9;\n  constructor(readonly name: string) {}\n}\n```\n\n### 4.7 存取器 get & set\n\n> 存取器 支持 `es5+`，不支持 `es3`\n\n1. `TypeScript` 支持通过 `getters/setters` 来截取对对象成员的访问。它能帮助你有效的控制对对象成员的访问。\n2. 没有存取器的例子\n\n```typescript\nclass _Employee {\n  fullName: string;\n}\nlet _employee = new _Employee();\n_employee.fullName = \"Bob Smith\";\nif (_employee.fullName) {\n  console.log(_employee.fullName);\n}\n```\n\n3. 拥有存取器的例子\n\n> 1. 我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。\n> 2. 只带有 `get` 不带有 `set` 的存取器自动被推断为 `readonly`。\n> 3. 这在从代码生成 `.d.ts` 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。\n\n```typescript\nlet passcode = \"secret passcode\";\nclass Employee {\n  private _fullName: string;\n\n  get fullName(): string {\n    return this._fullName;\n  }\n\n  set fullName(newName: string) {\n    if (passcode && passcode === \"secret passcode\") {\n      this._fullName = newName;\n    } else {\n      console.log(\"Error: Unauthorized update of employee!\");\n    }\n  }\n}\nlet employee = new Employee();\nemployee.fullName = \"Bob smith\";\nif (employee.fullName) {\n  console.log(employee.fullName);\n}\n```\n\n### 4.8 静态属性\n\n> 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。\n\n```typescript\nclass Gird {\n  public static origin = { x: 0, y: 0 };\n  public calculateDistanceFromOrigin(point: { x: number; y: number }) {\n    let xDist = point.x - Gird.origin.x;\n    let yDist = point.y - Gird.origin.y;\n    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n  }\n  public constructor(public scale: number) {}\n}\nconsole.log(Gird.origin.x);\nlet grid1 = new Gird(1.0);\nlet gird2 = new Gird(5.0);\nconsole.log(grid1.calculateDistanceFromOrigin({ x: 10, y: 10 }));\nconsole.log(gird2.calculateDistanceFromOrigin({ x: 10, y: 10 }));\n```\n\n### 4.9 抽象类\n\n1. 抽象类作为其他派生类的基类使用，它们一般不会直接被实例化。\n2. 不同于接口，抽象类可以包含成员的实现细节\n3. `abstract` 关键字是用于定义抽象类和在抽象类内部定义抽象方法\n\n```typescript\nabstract class Animal {\n  abstract makeSound(): void;\n  move(): void {\n    console.log(\"roaming the earth ...\");\n  }\n}\n```\n\n4. 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。\n5. 抽象方法的语法于接口方法相似，二者都是定义方法签名但不包含方法体。然而抽象方法必须包含 `abstract` 关键字并且可以包含访问修饰符\n\n```typescript\nabstract class Department {\n  constructor(public name: string) {}\n  printName(): void {\n    console.log(`Department name: ${this.name}`);\n  }\n  abstract printMeeting(): void; // 必须在派生类中实现\n}\nclass AccountingDepartment extends Department {\n  constructor() {\n    super(\"Accounting and Auditing\");\n  }\n  printMeeting(): void {\n    console.log(\"The Accounting Department meets each Monday at 10am.\");\n  }\n  generateReports(): void {\n    console.log(\"Generating accounting reports...\");\n  }\n}\nlet department: Department; // 允许创建一个对抽象类的引用\n// department = new Departmemnt(); // 错误，不能创建一个抽象类的实例\ndepartment = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值\ndepartment.printName();\ndepartment.printMeeting();\n// department.generateReports(); // 错误，方法在声明的抽象类中不存在\n```\n\n### 4.10 高级技巧(构造函数)\n\n> 当在 `TypeScript` 里声明了一个类的时候，实际上声明了很多东西。首先就是类的实例类型\n\n```typescript\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    return \"Hello,\" + this.greeting;\n  }\n}\nlet greeter: Greeter; // =>意思：Greeter类的实例的类型是Greeter\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet());\n```\n\n> 可以认为类具有 _实例部分_ 与 _静态部分_\n\n```typescript\nclass _Greeter {\n  static standardGreeting = \"Hello, there\";\n  greeting: string;\n  greet() {\n    if (this.greeting) {\n      return \"Hello,\" + this.greeting;\n    } else {\n      return _Greeter.standardGreeting;\n    }\n  }\n}\nlet _greeter: _Greeter;\n_greeter = new _Greeter();\nconsole.log(_greeter.greet());\n```\n\n> 此处创建了一个 `greeterMaker` 的变量，这个变量保存了这个 _类_ 或者说保存了 _类构造函数_。然后使用 `typeof _Greeter`，意思是取 `Greeter` 类的类型，而不是实例的类型。或者更确切的说，\"告诉我 `Greeter` 标识符的类型\"，也就是构造函数的类型。这个类型包含了类的所有静态成员和构造函数。\n\n```typescript\nlet _greeterMaker: typeof _Greeter = _Greeter;\n_greeterMaker.standardGreeting = \"Hey there!\";\nlet _greeter2: _Greeter = new _greeterMaker();\nconsole.log(_greeter2.greet());\n```\n\n### 4.11 高级技巧(把类当作接口使用)\n\n> 类定义会创建两个东西：_类的实例类型_ 和 _一个构造函数_。\n> 因为类可以创建出类型，所以能够在允许使用接口的地方使用类\n\n```typescript\nclass Point {\n  x: number;\n  y: number;\n}\n\ninterface Point3d extends Point {\n  z: number;\n}\n\nlet point3d: Point3d = { x: 1, y: 2, z: 4 };\n```\n\n## 五、函数\n\n### 5.1 介绍\n\n> 函数是 `JavaScript` 应用程序的基础。它帮助你实现抽象层，模拟层，信息隐藏和模块。在 `TypeScript` 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。`TypeScript` 为 `JavaScript` 函数添加了额外的功能，让我们可以更容易的使用。\n\n### 5.2 函数类型\n\n#### 5.2.1 为函数定义类型\n\n> 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。\n\n> `TypeScript` 能够根据返回语句自动推断出返回值类型，因此我们通常省略它。\n\n```typescript\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n\nlet myAdd = function (x: number, y: number): number {\n  return x + y;\n};\n```\n\n#### 5.2.2 书写完整的函数类型\n\n```typescript\nlet myAdd1: (x: number, y: number) => number = function (x: number, y: number): number {\n  return x + y;\n};\n```\n\n> 函数类型分为两个部分：_参数类型_ 和 _返回值类型_。当写出完整函数类型的时候，这两部分都是需要的。我们以参数列表的形式写出参数类型，为每一个参数指定一个名字和类型。这个名字只是为了增加可读性。\n\n> 1. 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。\n> 2. 第二部分是返回值类型。对于返回值，我们在函数和返回值类型之间使用 `=>` 符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 `void`,而不能留空。\n\n> 函数的类型只是由参数类型和返回值组成的。函数中使用的捕获变量不会体现在类型里。实际上，这些变量是函数的隐藏状态并不是组成 `API` 的一部分。\n\n- 我们也可以这么写：\n\n```typescript\nlet myAdd2: (baseValue: number, increment: number) => number = function (x: number, y: number): number {\n  return x + y;\n};\n```\n\n#### 5.2.3 推断类型\n\n> 在尝试下面这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型。这叫做：\"按上下文归类\"，是类型推论的一种。它帮助我们更好地为程序指定类型。\n\n```typescript\n// myAdd has the full function type\nlet myAdd3 = function(x: number, y: number): number { return x + y };\n// The parameters `x` and `y` have the type number\nlet myAdd4: (baseValue: number, increment: number) =number = function (x, y) {\n  return x + y;\n};\n```\n\n### 5.3 可选参数和默认参数\n\n> `TypeScript` 里的每个函数参数都是必须的。这不是指不能传递 `null` 或 `undefined` 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。\n\n1. 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。\n\n```typescript\nfunction buildName(firstName: string, lastName: string) {\n  return firstName + \" \" + lastName;\n}\n// let result1 =  buildName(\"Bob\"); // error\n// let result2 = buildName(\"Bob\", \"Jack\", \"Sr.\"); // error\nlet result3 = buildName(\"Bob\", \"Jack\");\n```\n\n2. `JavaScript`里，每个参数都是可选的，可传可不传。没传参的时候，它的值就是 `undefined`。在 `TypeScript` 里我们可以在参数旁边使用 `?` 实现可选参数的功能。\n3. 注意：可选参数必须跟在必选参数后面，不能放在前面\n\n```typescript\nfunction buildName1(firstName: string, lastName?: string) {\n  if (lastName) {\n    return firstName + \" \" + lastName;\n  } else {\n    return firstName;\n  }\n}\nlet result_1 = buildName1(\"Bob\");\nlet result_2 = buildName1(\"Bob\", \"Jack\");\n// let result_3 = buildName1(\"Bob\", \"Jack\", \"Sr.\"); // error\n```\n\n4. 可以设置默认初始化的参数\n5. 在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。也就是说，可选参数与末尾的默认参数共享参数类型。\n\n```typescript\nfunction buildName2(firstName: string, lastName = \"Smith\") {\n  return firstName + \" \" + lastName;\n}\n```\n\n6. 与普通可选参数参数不同的是，带默认值的参数不需要放在必须参数的后面。如果带默认值的参数出现在必须参数的前面，用户必须明确的传入 `undefined` 值来获得默认值。\n\n```typescript\nfunction buildName3(firstName = \"Will\", lastName: string) {\n  return firstName + \" \" + lastName;\n}\n// let result__1 = buildName3(\"Bob\"); // error\n// let result__2 = buildName3(\"Bob\", \"Jack\", \"Sr.\"); // error\nlet result__3 = buildName3(\"Bob\", \"Jack\");\nlet result__4 = buildName3(undefined, \"Jack\");\n```\n\n### 5.4 剩余参数\n\n> 必要参数，默认参数 和 可选参数 有个共同点：它们表示某一个参数。有时，你想同时操作多个参数，或者你并不知道会有多少参数传进来。在 `JavaScript` 里，你可以使用 `arguments` 来访问所有传入的参数。在 `TypeScript` 里，你可以把所有参数收集到一个变量里\n\n```typescript\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + \" \" + restOfName.join(\" \");\n}\n\nlet employeeName = buildName(\"Jose\", \"Smith\", \"Bob\", \"Alice\");\n```\n\n> 剩余参数会被当作个数不限的可选参数。可以一个都没有，也可以有任意个。编译器创建参数数组，名字是你在省略号后面给定的名字，你可以在函数体内使用这个数组。\n\n```typescript\nfunction buildName1(firstName: string, ...restOfName: string[]) {\n  return firstName + \" \" + restOfName.join(\" \");\n}\n\nlet buildNameFun: (fName: string, ...rest: string[]) => string = buildName1;\n```\n\n> `this` 参数。在使用了 `--noImplicitThis` 标记之后，`this` 类型可能会是 `any`。此时需要提供一个显示的 `this` 参数。\n\n```typescript\ninterface Card {\n  suit: string;\n  card: number;\n}\n\ninterface Deck {\n  suits: string[];\n  cards: number[];\n\n  createCardPicker(this: Deck): () => Card;\n}\n\nlet deck: Deck = {\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n  cards: Array(52),\n  createCardPicker(): (this: Deck) => Card {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n\n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  }\n};\nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\nconsole.log(`card: ${pickedCard.card} of ${pickedCard.suit}`);\n```\n\n## 六、泛型\n\n### 6.1 介绍\n\n> 在软件工程中，我们不仅要创建一致的定义良好的 `API`，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。\n> 在像 `C#` 和 `Java` 这样的语言中，可以使用 `泛型` 来创建可重用组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。\n> 除了泛型接口，我们还可以创建泛型类。注意，无法创建泛型枚举和泛型命名空间。\n\n### 6.2 泛型之 hello world\n\n> 创建一个 `identity` 函数，这个函数会返回任何传入它的值。\n\n- 如果不使用泛型，函数可能是：\n\n```typescript\nfunction identity(arg: number): number {\n  return arg;\n}\n```\n\n- 也可以使用 `any` 类型定义函数，但是这样可能会导致传入的类型与返回的类型不相同。\n\n```typescript\nfunction identity1(arg: any): any {\n  return arg;\n}\n```\n\n> 因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。\n\n- 这里我们使用了类型变量，它是一种特殊的变量，只能用于表示类型而不是值。\n\n```typescript\nfunction identity2<T>(arg: T): T {\n  return arg;\n}\n```\n\n- 使用方式一：传入所有的参数，包括类型参数\n\n```typescript\nlet output = identity2<string>(\"myString\");\n```\n\n- 使用方式二(更普遍)：利用了类型推论-即编译器会根据传入的参数自动地帮助我们确定 `T` 的类型。\n\n```typescript\nlet output2 = identity2(\"myString\");\n```\n\n### 6.3 使用泛型变量\n\n> 使用泛型创建像 `identity` 这样的函数时，编译器要求你在函数体必须正确的使用这个通用的类型。换句话说，你必须把这些参数当作是任意或所有类型。\n\n- 如果我们想打印出 `arg` 的长度，也许会这样做。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length); // 错误，T 类型也许不会有.length属性\n  return arg;\n}\n```\n\n- 如果我们像操作 `T` 类型的数组\n\n```typescript\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length);\n  return arg;\n}\nfunction loggingIdentity2<T>(arg: Array<T>): Array<T> {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n### 6.4 泛型类型(泛型接口)\n\n1. 泛型函数的类型和非泛型函数的类型一样，首先列出类型参数，类似于函数声明。\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity: <T>(arg: T) => T = identity;\n```\n\n2. 我们也可以为类型中的泛型类型参数使用不同的名称，只要在数量上和使用方式上能对应上就可以。\n\n```typescript\nfunction identity1<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity1: <U>(arg: U) => U = identity;\n```\n\n3. 我们还可以使用带有调用签名的对象字面量来定义泛型函数：\n\n```typescript\nfunction identity2<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity2: { <T>(arg: T): T } = identity;\n```\n\n4. 这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：\n\n```typescript\ninterface GenericIdentityFn {\n  <T>(arg: T): T;\n}\n\nfunction identity3<T>(arg: T): T {\n  return arg;\n}\n\nlet myIdentity3: GenericIdentityFn = identity3;\n```\n\n5. 我们可能想把泛型参数当作整个接口的一个参数。这样我们就能清楚的知道使用的具体是哪个泛型类型(比如：`Dictionary<string>` 而不只是 `Dictionary`)。这样接口里的其它成员也能知道这个参数的类型了。\n\n```typescript\ninterface _GenericIdentityFn<T> {\n  (arg: T): T;\n}\n\nfunction _identity<T>(arg: T): T {\n  return arg;\n}\n\nlet _myIdentity: _GenericIdentityFn<number> = _identity;\n```\n\n> 注意，我们的示例做了少许改动。不再描述泛型函数，而是把非泛型函数签名作为泛型类型的一部分。\n\n> 当我们使用 `GenericIdentityFn` 的时候，还得传入一个类型参数来指定泛型类型(这里是：`number`)，从而锁定之后代码里使用的类型。\n\n> 对于描述哪部分类型属于泛型部分来说，理解何时把参数 \"放在调用签名里\" 和何时 \"放在接口上\" 是很有帮助的。\n\n### 6.5 泛型类\n\n> 泛型类和泛型接口差不多。泛型类使用 `<>` 括起泛型类型，跟在类名后面。类分为两部分：静态部分 和 实例部分。泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。\n\n> `enericNumber` 类的使用是非常直观的，并没有什么去限制它只能使用 `number` 类型。\n\n- 也可以使用字符串或其它更复杂的类型。\n\n```typescript\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = (x, y) => x + y;\n```\n\n> 与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。\n\n```typescript\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \" \";\nstringNumeric.add = (x, y) => x + y;\nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\n```\n\n### 6.6 泛型约束\n\n> 我们应该记得之前的一个例子，我们有时候想要操作某类型的一组值，并且我们知道这组值具有什么样的属性。\n\n> 在 `loggingIdentity` 例子中，我们想访问 `arg` 的 `length` 属性，但是编译器并不能证明每种类型都有 length 属性。\n\n```typescript\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n> 相比与操作 `any` 所有类型，我们想要限制函数去处理任意带有 `.length` 属性的所有类型。只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 `T` 的约束要求。\n\n> 为此，我们需要定义一个接口来描述约束条件。创建一个包含 `.length` 属性的接口，使用这个接口和 `extends` 关键字来实现约束。\n\n```typescript\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n```\n\n- 此时这个泛型函数被定义了约束。因此它不再适用于任意类型：\n\n```typescript\nloggingIdentity(3); // error\n```\n\n- 我们需要传入符合约束类型的值，必须包含的属性。\n\n```typescript\nloggingIdentity({ length: 10, value: 3 });\n```\n\n### 6.7 在泛型约束中使用类型参数\n\n> 你可以声明一个类型参数，且它被另一个类型参数所约束。例如，现在我们需想要用属性名从对象里获取这个属性。并且我们想要确保这个属性存在于对象 `obj` 上，因此我们需要在这两个类型之间使用约束。\n\n```typescript\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key];\n}\nlet x = { a: 1, b: 2, c: 3, d: 4 };\ngetProperty(x, \"a\");\ngetProperty(x, \"m\"); // error\n```\n\n### 6.8 在泛型里使用类类型\n\n> 在 `TypeScript` 使用泛型创建工厂函数时，需要引用构造函数的类类型。\n\n```typescript\nfunction create<T>(c: { new (): T }): T {\n  return new c();\n}\n```\n\n> 下面是一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。\n\n```typescript\nclass BeeKeeper {\n  hasMask: boolean;\n}\n\nclass ZooKeeper {\n  nameTag: string;\n}\n\nclass Animal {\n  numLegs: number;\n}\n\nclass Bee extends Animal {\n  keeper: BeeKeeper;\n}\n\nclass Lion extends Animal {\n  keeper: ZooKeeper;\n}\n\nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n\ncreateInstance(Lion).keeper.nameTag;\ncreateInstance(Bee).keeper.hasMask;\n```\n\n### 6.9 多个类型变量\n\n```typescript\nfunction info<S, N>(name: S, age: N): [S, N] {\n  return [name, age];\n}\n\nconsole.log(info(\"pr\", 10));\nconsole.log(info<string, number>(\"pr\", 18));\n```\n\n## 七、枚举\n\n### 7.1 介绍\n\n> 使用枚举我们可以定义一些带有名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。`TypeScript` 支持数字的和基于字符串的枚举。\n\n### 7.2 数字枚举\n\n```typescript\nenum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right\n}\n```\n\n> 如上，我们定义了一个数字枚举，`Up`使用初始化为 `1`，其余成员会从 `1` 开始自动增长。 换句话说，`Direction.Up` 的值为 `1`，`Down` 值为 `2`，`Left` 值为 `3`，`Right` 值为 `4`。\n\n1. 我们还可以完全不使用初始化器\n\n```typescript\nenum Direction2 {\n  Up,\n  Down,\n  Left,\n  Right\n}\n```\n\n> 现在，`Up` 的值为 `0`，`Down` 的值为 `1` 等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。\n\n2. 使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：\n\n```typescript\nenum _Response {\n  No = 0,\n  Yes = 1\n}\n\nfunction respond(recipient: string, message: _Response): void {}\n\nrespond(\"Princess Caroline\", _Response.Yes);\n```\n\n3. 数字枚举可以被混入到计算过的和常量成员（如下所示）。\n\n> 简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。换句话说，下面的情况是不被允许的：\n\n```typescript\nenum E {\n  A = getSomeValue(),\n  B // error! 'A' is not constant-initialized, so 'B' needs an initializer\n}\n```\n\n### 7.3 字符串枚举\n\n> 字符串枚举的概念很简单，但是有细微的运行时的差别。在一个字符串枚举里，每个成员都必须使用字符串字面量，或另外一个字符串枚举成员进行初始化。\n\n```typescript\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\"\n}\n```\n\n> 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。\n\n### 7.4 异构枚举\n\n> 从技术的角度来说，枚举可以混合字符串和数字成员，但是你似乎并不会这么做：\n\n```typescript\nenum BooleanLikeHeterogeneousEnum {\n  No = 0,\n  Yes = \"YES\"\n}\n```\n\n> 除非你真的想要利用 `JavaScript` 运行时的行为，否则我们不建议这样做。\n\n### 7.5 计算的和常量成员\n\n> 每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当作是常量\n\n1. 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 `0`：\n\n```typescript\nenum E {\n  X\n}\n```\n\n2. 它不带有初始化器且它之前的枚举成员是一个数字常量。这种情况下，当前枚举成员的值为它上一个枚举成员的值加 `1`。\n\n```typescript\nenum E1 {\n  X,\n  Y,\n  Z\n}\nenum E2 {\n  A = 1,\n  B,\n  C\n}\n```\n\n3. 枚举成员使用 常量枚举表达式进行初始化。常量枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。\n\n> 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：\n>\n> 1. 一个枚举表达式字面量（主要是字符串字面量或数字字面量）\n> 2. 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）\n> 3. 带括号的常量枚举表达式\n> 4. 一元运算符 +，-，～ 其中之一应用在了常量枚举表达式\n> 5. 常量枚举表达式作为二元运算符 `+，-，*，/，%，<<，>>，>>>，&，|，^` 的操作对象\n\n> 若常量枚举表达式求值后为 `NaN` 或 `Infinity`，则会在编译阶段报错。\n\n> 所有其它情况的枚举成员被当作是需要计算得出的值\n\n```typescript\nenum FileAccess {\n  // constant numbers\n  None,\n  Read = 1 << 1,\n  White = 1 << 2,\n  ReadWhite = Read | White,\n  // computed number\n  G = \"123\".length\n}\n```\n\n### 7.6 联合枚举与枚举成员的类型\n\n> 存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员，或者是被初始化为：\n>\n> 1. 任何字符串字面量(例如：`\"foo\", \"bar\", \"baz\"`)\n> 2. 任何数字字面量(例如：`1, 100`)\n> 3. 应用了一元 - 符号的数字字面量(例如：`-1, -100`) 当所有枚举成员都拥有字面量枚举值时，它就有了一种特殊的含义。\n\n> 首先，枚举成员成为了类型！例如，我们可以说某些成员只能是枚举成员的值：\n\n```typescript\nenum ShapeKind {\n  Circle,\n  Square\n}\n\ninterface Circle {\n  kind: ShapeKind.Circle;\n  radius: number;\n}\n\ninterface Square {\n  kind: ShapeKind.Square;\n  sideLength: number;\n}\n\nlet c: Circle = {\n  kind: ShapeKind.Square, // error\n  radius: 100\n};\n```\n\n> 另一个变化是枚举类型本身变成了每个枚举成员的联合。虽然我们还没有讨论 联合类型 。但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。因此，`TypeScript` 能够捕获在比较值的时候犯的愚蠢的错误。例如：\n\n```typescript\nenum E {\n  Foo,\n  Bar\n}\nfunction f(x: E) {\n  if (x !== E.Foo || x !== E.Bar) {\n    // // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.\n  }\n}\n```\n\n> 这个例子里，我们先检查 `x` 是否不是 `E.Foo`。 如果通过了这个检查，然后 `||` 会发生短路效果，\n> `if` 语句体里的内容会被执行。 然而，这个检查没有通过，那么 x 则只能为 `E.Foo`，因此没理由再去检查它是否为 `E.Bar`。\n\n### 7.7 运行时的枚举\n\n- 枚举是在运行时真正存在的对象。\n\n```typescript\nenum E {\n  X,\n  Y,\n  Z\n}\n```\n\n- 可以传递给函数么？\n\n```typescript\nfunction f(obj: { X: number }) {\n  return obj.X;\n}\n```\n\n- 没问题，因为 `\"E\"` 包含一个数值型属性 `\"X\"`\n\n```typescript\nf(E);\n```\n\n### 7.8 编译时的枚举\n\n> 尽管一个枚举是在运行时真正存在的对象，但 `keyof` 关键字的行为与其作用在对象上时有所不同。应该使用 `keyof` `typeof` 来获取一个表示枚举里所有字符串 `key` 的类型。\n\n```typescript\nenum LogLevel {\n  ERROR,\n  WARN,\n  INFO,\n  DEBUG\n}\n```\n\n- 等同于：\n\n```typescript\ntype LogLevelStrings = \"ERROR\" | \"WARN\" | \"INFO\" | \"DEBUG\";\ntype LogLevelStrings = keyof typeof LogLevel;\n```\n\n```typescript\nfunction printImportant(key: LogLevelStrings, message: string) {\n  const num = LogLevel[key];\n  if (num <= LogLevel.WARN) {\n    console.log(\"Log Level key is: \", key);\n    console.log(\"Log Level value is: \", num);\n    console.log(\"Log Level message is \", message);\n  }\n}\nprintImportant(\"ERROR\", \"This is a message\");\n```\n\n### 7.9 反向映射\n\n> 除了创建一个以属性名作为对象成员的对象外，数字枚举成员还具有了反向映射，从枚举值到枚举名字。\n\n- 例如在下面的例子中：\n\n```typescript\nenum _Enum {\n  A\n}\nlet _a = _Enum.A;\nlet _nameOfA = _Enum[_a]; // \"A\"\n```\n\n- `TypeScript` 可能会将这段代码编译为下面的 `JavaScript`：\n\n```typescript\nvar Enum;\n(function (Enum) {\n  Enum[(Enum[\"A\"] = 0)] = \"A\";\n})(Enum || (Enum = {}));\nvar a = Enum.A;\nvar nameOfA = Enum[a]; // \"A\"\n```\n\n> 生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（`name -> value`）和反向映射（`value -> name`）。\n\n> 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。\n\n> 要注意的是不会为字符串枚举成员生成反向映射。\n\n### 7.10 const 枚举\n\n> 大多数情况下，枚举是十分有效的方案。然而在某些情况下需求很严格。为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 `const` 枚举。\n\n> 常量枚举通过在枚举上使用 `const` 修饰符来定义。\n\n```typescript\nconst enum Enum {\n  A = 1,\n  B = A * 2\n}\n```\n\n> 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。\n\n```typescript\nconst enum Directions {\n  Up,\n  Down,\n  Left,\n  Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n// 生成后的代码为：\nvar directions1 = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n```\n\n### 7.11 外部枚举\n\n> 外部枚举 用来描述已经存在的枚举类型的形状。\n\n```typescript\ndeclare enum Enum {\n  A = 1,\n  B,\n  C = 2\n}\n```\n\n> 外部枚举 和 非外部枚举 之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。\n\n> 对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。\n\n## 八、类型别名\n\n### 8.1 类型别名\n\n1. 创建别名需要使用关键字 `type`\n2. 使用别名通常用在有 联合类型 的场景下\n\n> 注意：不要混淆了 `TypeScript` 中的 `=>`; 和 `ES6` 中的 `=>` 在 `TypeScript` 的类型定义中，`=>` 用来表示函数的定义。(左边是输入类型，需要用括号扩起来，右边是输出类型)；在 `ES6` 中，`=>` 叫做箭头函数。\n\n```typescript\ntype Name = string;\ntype ShowName = () => string;\ntype NameOrShowName = Name | ShowName;\n\nconst getName = (name: NameOrShowName) => {\n  if (typeof name === \"string\") {\n    return name;\n  }\n  return name();\n};\n\nlet showName = () => \"pr is a boy\";\nconsole.log(getName(\"pr\"));\nconsole.log(getName(showName()));\n```\n\n### 8.2 字符串字面量类型\n\n```typescript\ntype EventNames = \"click\" | \"scroll\" | \"mousemove\";\nconst handleEvent: (a: Element, b: EventNames) => string = (ele: Element, event: EventNames) => {\n  return `${ele} ${event}`;\n};\nhandleEvent(document.getElementById(\"header\"), \"scroll\");\nhandleEvent(document.getElementById(\"footer\"), \"click\");\n```\n\n## 九、类型推论\n\n### 9.1 基础\n\n> 在 `TypeScript` 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子：\n\n```typescript\nlet x = 3;\n```\n\n> 变量 `x` 的类型被推断为数字。这种推断发生在初始化变量和成员，设置默认参数和决定函数返回值时。\n\n> 大多数情况下，类型推论是直接了当地。\n\n### 9.2 最佳通用类型\n\n> 当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断出一个最合适的通用类型。\n\n```typescript\nlet x = [0, 1, null];\n```\n\n> 为了推断 `x` 的类型，我们必须考虑所有元素的类型。这里有两种选择: `number` 和 `null`。计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。\n\n> 由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。\n\n```typescript\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n```\n\n> 这里，我们想让 `zoo` 被推断为 `Animal[]` 类型，但是这个数组里没有对象是 `Animal` 类型的，因此不能推断出这个结果。\n\n> 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：\n\n```typescript\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n```\n\n> 如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，`(Rhino | Elephant | Snake)[]`。\n\n### 9.3 上下文归类\n\n1. `TypeScript` 类型推论也可能按照相反的方向进行，这被叫做\"上下文归类\"。按上下文归类会发生在表达式类型与所处的位置相关时。\n\n> 在下面这个例子里，`TypeScript` 类型检查器会使用 `Window.onmousedown` 函数的类型来推断右边函数表达式的类型。所以它能够推断出 `mouseEvent` 参数的类型中包含了 `button` 属性而不包含 `kangaroo` 属性。\n\n```typescript\nwindow.onmousedown = function (mouseEvent) {\n  console.log(mouseEvent.button); // <- Ok\n  console.log(mouseEvent.kangaroo); // <- error\n};\n```\n\n2. `TypeScript` 还能够很好地推断出其它上下文中的类型。\n\n```typescript\nwindow.onscroll = function (uiEvent) {\n  console.log(uiEvent.button); // Error\n};\n```\n\n> 上面的函数被赋给 ` window.onscroll``，TypeScript ` 能够知道 `uiEvent` 是 `UIEvent`，而不是 `MouseEvent。UIEvent` 对象不包含 `button` 属性，因此 `TypeScript` 会报错。\n\n1. 如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为 `any` 类型，而且也不会报错(除非你开启了 `--noImplicitAny` 选项)\n\n```typescript\nconst handler = function (uiEvent) {\n  console.log(uiEvent.button); // <- Ok\n};\n```\n\n- 我们也可以明确地为函数参数类型赋值来覆写上下文类型：\n\n```typescript\nwindow.onscroll = function (uiEvent: any) {\n  console.log(uiEvent.button); // <- Now, no error is given\n};\n```\n\n> 但这段代码会打印 `undefined`，因为 `uiEvent` 并不包含 `button` 属性。\n\n> 上下文归类会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。\n\n- 上下文类型也会做为最佳通用类型的候选类型。比如：\n\n```typescript\nfunction createZoo(): Animal[] {\n  return [new Rhino(), new Elephant(), new Snake()];\n}\n```\n\n> 上面这个例子里，最佳通用类型有 `4` 个候选者：`Animal, Rhino, Elephant, Snake`。当然，`Animal` 会被作为最佳通用类型。\n\n## 十、类型兼容性\n\n### 10.1 介绍\n\n> `TypeScript` 里的兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。它正好与名义( `nominal` )类型形成对比。(译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。)看下面的例子：\n\n```typescript\ninterface Named {\n  name: string;\n}\n\nclass Person {\n  name: string;\n}\n\nlet p: Named;\n// Ok, because of structural typing\np = new Person();\n```\n\n> 在使用基于名义类型的断言，比如 `C#` 或 `Java` 中，这段代码会报错， 因为 `Person` 类没有明确说明其实现了 `Named` 接口。\n> `TypeScript` 的结构性子类型是根据 `JavaScript` 代码的典型写法来设计的。 因为 `JavaScript` 里广泛地使用匿名对象，例如函数表达式和对象字面量， 所以使用结构类型系统来描述这些类型比使用名义类型系统更好。\n\n### 10.2 关于可靠性的注意事项\n\n> `TypeScript` 的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript 允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。\n\n### 10.3 开始\n\n- `TypeScript` 结构化类型系统的基本规则是，如果 `x` 要兼容 `y`，那么 `y` 至少具有与 `x` 相同的属性。比如：\n\n```typescript\ninterface Named {\n  name: string;\n}\n\nlet x: Named;\n// y's inferred type is { name: string; location: string }\nlet y = { name: \"Alice\", location: \"Seattle\" };\nx = y;\n```\n\n> 这里要检查 `y` 是否能赋值给 `x`，编译器检查 `x` 中的每个属性，看是否能在 `y` 中也找到对应属性。\n\n> 在这个例子中，`y` 必须包含名字是 `name` 的 `string` 类型成员。`y` 满足条件，因此赋值正确。\n\n- 检查函数参数时使用相同的规则\n\n```typescript\nfunction greet(n: Named) {\n  console.log(\"Hello, \" + n.name);\n}\n\ngreet(y); // OK\n```\n\n> 注意，`y` 有个额外的 `location` 属性，但这不会引发错误。\n> 只有目标类型（这里是 `Named`）的成员会被一一检查是否兼容。\n> 这个比较过程是递归进行的，检查每个成员及子成员。\n\n### 10.4 比较两个函数\n\n1. 相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。\n\n- 下面我们从两个简单的函数入手，它们仅是参数列表略有不同：\n\n```typescript\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\n\ny = x; // <- Ok\n// x = y; // <- Error\n```\n\n> 要查看 `x` 是否能赋值给 `y`，首先看它们的参数列表。 `x` 的每个参数必须能在 `y` 里找到对应类型的参数。注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，`x` 的每个参数在 `y` 中都能找到对应的参数，所以允许赋值。第二个赋值错误，因为 `y` 有个必需的第二个参数，但是 `x` 并没有，所以不允许赋值。\n> 你可能会疑惑为什么允许忽略参数，像例子 `y = x` 中那样。 原因是忽略额外的参数在 `JavaScript` 里是很常见的。\n> 例如，`Array.forEach` 给回调函数传 `3` 个参数：数组元素，索引 和 整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：\n\n```typescript\nlet items = [1, 2, 3];\n// Don't force these extra arguments\nitems.forEach((item, index, array) => console.log(item));\n// Should be Ok\nitems.forEach(item => console.log(item));\n```\n\n2. 下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数。\n\n```typescript\nlet x1 = () => ({ name: \"Alice\" });\nlet y1 = () => ({ name: \"Alice\", location: \"Seattle\" });\n\nx1 = y1; // Ok\ny1 = x1; // Error, because x() lacks a location property\n```\n\n3. 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。\n\n### 10.5 函数参数双向协变\n\n> 当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。实际上，这极少会发声错误，并且能够实现很多 `JavaScript` 里的常见模式。\n\n- 例如：\n\n```typescript\nenum EventType {\n  Mouse,\n  Keyboard\n}\n\ninterface Event {\n  timestamp: number;\n}\n\ninterface MouseEvent extends Event {\n  x1: number;\n  y1: number;\n}\n\ninterface keyEvent extends Event {\n  keyCode: number;\n}\n\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n  /* …… */\n}\n\n// Unsound, but useful and common 不完整，但是常用常见\nlistenEvent(EventType.Mouse, (e: MouseEvent) => console.log(`${e.x1},${e.y1}`));\n\n// Undesirable alternatives in presence of soundness 完整但是不受欢迎\nlistenEvent(EventType.Mouse, (e: Event) => console.log(`${(<MouseEvent>e).x1},${(<MouseEvent>e).y1}`));\n\nlistenEvent(EventType.Mouse, <(e: Event) => void>((e: MouseEvent) => console.log(`${e.x1},${e.y1}`)));\n// Still disallowed (clear error). Type safety enforced for wholly incompatible types\n// 仍然不允许（清除错误）。完全不兼容类型所强制规定的类型安全\n// listenEvent(EventType.Mouse, (e: number) => console.log(e));\n```\n\n### 10.6 可选参数和剩余参数\n\n1. 比较函数兼容性的时候，可选参数与必须参数是可互换的。源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。\n2. 当一个函数有剩余参数时，它被当做无限个可选参数。\n3. 这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些 undefined 。\n\n> 有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数 但对类型系统来说是不确定的参数来调用：\n\n```typescript\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n  /* ... Invoke callback with 'args' ... 通过args调用callback */\n}\n\n// Unsound - invokeLater \"might\" provide any number of arguments\n// 不健全的是 - 被调用时候可能会提供任意数量的参数\ninvokeLater([1, 2], (x, y) => console.log(x + \",\" + y));\n\n// Confusing (x and y are actually required) and unrecoverable\n// 令我们困惑(是否需要 x 和 y) 并且 不可恢复\ninvokeLater([1, 2], (x?, y?) => console.log(x + \",\" + y));\n```\n\n### 10.7 函数重载\n\n> 对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。这确保了目标函数可以在所有源函数可调用的地方调用。\n\n### 10.8 枚举\n\n> 枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。\n\n- 比如：\n\n```typescript\nenum Status {\n  Ready,\n  Waiting\n}\n\nenum Color {\n  Red,\n  Blue,\n  Green\n}\n\nlet _status = Status.Ready;\n// _status = Color.Green; // Error\n```\n\n### 10.9 类\n\n> 类与对象字面量和接口差不多，但是有一点不同：类的静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。静态成员和构造函数不在比较的范围内。\n\n```typescript\nclass Animal {\n  feet: number;\n\n  constructor(name: string, numFeet: number, c: boolean) {}\n}\n\nclass Size {\n  feet: number;\n\n  constructor(numFeet: number) {}\n}\n\nlet a: Animal;\nlet s: Size;\na = s; //Ok\ns = a; //Ok\n\n/*  */\n```\n\n### 10.10 类的私有和受保护成员\n\n> 类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。\n\n### 10.11 泛型\n\n> 因为 `TypeScript` 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。\n\n- 比如\n\n```typescript\ninterface Empty<T> {}\n\nlet x: Empty<number>;\nlet y: Empty<string>;\n\nx = y; // Ok, because y matches structure of x\n```\n\n> 上面代码里，`x` 和 `y` 是兼容的，因为它们的结构使用类型参数时，并没有什么不同。\n\n- 把这个例子改变一下，增加一个成员，就能看出是如何工作的了。\n\n```typescript\ninterface NotEmpty<T> {\n  data: T;\n}\n\nlet x1: NotEmpty<number>;\nlet y1: NotEmpty<string>;\nx1 = y1; // Error，because x and y are not compatible\n```\n\n> 在这里，泛型类型在使用时就好比不是一个泛型类型。\n\n> 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 `any` 比较。然后用结果类型进行比较，就像上面第一个例子。\n\n- 比如：\n\n```typescript\nlet identity = function <T>(x: T): T {\n  // ...\n  return;\n};\nlet reverse = function <U>(y: U): U {\n  // ...\n  return;\n};\nidentity = reverse; // Ok, because (x: any) => any matches (y: any) => any\n```\n\n### 10.12 高级主题\n\n- 子类型和赋值\n\n> 目前为止，我们使用了\"兼容性\"，它在语言规范里没有定义，在 `TypeScript` 里，有两种兼容性：子类型 和 赋值。它们的不同点在于：赋值扩展了子类型兼容性，增加了一些规则，允许和 `any` 来回赋值，以及 enum 和对应数字值之间的来回赋值。\n> 语言里的不同地方分别使用了它们之中的机制。实际上，类型兼容性是由赋值兼容性来控制的，即使在 `implements` 和 `extends` 语句也不例外。\n\n## 十一、高级类型\n\n### 11.1 交叉类型\n\n> 交叉类型 是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。例如，`Person & Serializable & Loggable` 同时是 `Person` 和 `Serializable` 和 `Loggable`。就是说这个类型的对象同时拥有了这三种类型的成员。\n> 我们大多数是在混入( `mixins` )或其它不适合典型面向对象模型的地方看到交叉类型的使用。(在 `JavaScript` 里发生这种情况的场合很多！)\n\n#### 11.1.1 `ReadOnly` 的实现\n\n```typescript\ntype ReadOnly<T> = {\n    readOnly [P in keyof T]: T[P];\n}\n```\n\n#### 11.1.2 `Partial` 的实现\n\n```typescript\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n#### 11.1.3 `Pick` 的实现\n\n```typescript\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n```\n\n#### 11.1.4 `Record` 的实现\n\n```typescript\ntype Record<K extends string, T> = {\n  [P in K]: T;\n};\n```\n\n> 下面是如何创建混入的一个简单的例子(`\"target\": \"es5\"`):\n\n```typescript\nfunction extend<First, Second>(first: First, second: Second): First & Second {\n    const result: Partial<First & Second>= {};\n    for (const prop in first) {\n        if (first.hasOwnProperty(prop)) {\n            (<First>result)[prop] = first[prop];\n        }\n    }\n    for (const prop in second) {\n        if (second.hasOwnProperty(prop)) {\n            (<Second>result)[prop] = second[prop];\n        }\n    }\n    return <First & Second>result;\n}\n>\nclass Person {\n    constructor(public name: string) {\n    }\n}\ninterface Loggable {\n    log(name: string): void;\n}\nclass ConsoleLogger implements Loggable {\n    log(name) {\n        console.log(`Hello, I'm ${name}`)\n    }\n}\nconst jim = extend(new Person(\"Jim\"), ConsoleLogger.prototype);\nlet c = jim.log(jim.name);\nconsole.log(c);\n```\n\n### 11.2 联合类型\n\n> 联合类型 和 交叉类型 很有关联，但是使用上却完全不同。偶尔你会遇到这种情况，一个代码库希望传入 `number` 或 `string` 类型的参数。例如下面的函数：\n\n```typescript\n/**\n * Takes a string and adds \"padding\" to the left.\n * If 'padding' is a string, then 'padding' is appended to the left side.\n * If 'padding' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft(value: string, padding: any) {\n  if (typeof padding === \"number\") {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  if (typeof padding === \"string\") {\n    return padding + value;\n  }\n  throw new Error(`Expected string or number, got '${padding}'.`);\n}\n\npadLeft(\"Hello World\", 4);\n```\n\n> `padLeft` 存在一个问题，`padding` 参数的类型指定成了 `any`。这就是说我们可以传入一个既不是 `number` 也不是 `string` 类型的参数，但是 `TypeScript` 却不会报错。\n>\n> ```typescript\n> let indentedString = padLeft(\"Hello World\", true); // 编译阶段通过，运行时报错。\n> ```\n\n````\n>  在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。这么做显然是非常清晰的，但同时也存在了过度设计。`padLeft` 原始版本的好处之一就是允许我们传入原始类型。这样做的话使用起来既简单又方便。如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。代替 `any`，我们可以使用 联合类型 作为 `padding` 的参数。\n\n\n\n```typescript\n/**\n * Takes a string and adds \"padding\" to the left.\n * If 'padding' is a string, then 'padding' is appended to the left side.\n * If 'padding' is a number, then that number of spaces is added to the left side.\n */\nfunction padLeft1(value: string, padding: string | number) {\n    // ...\n}\n\n// let indentedString1 = padLeft1(\"Hello world\", true); // errors during compilation\n````\n\n> 联合类型 表示一个值可以是几种类型之一。我们使用竖线(`|`)分隔每个类型，所以 `number | string | boolean` 表示一个值可能是 `number`, `string`, `boolean`\n\n```typescript\ninterface Bird {\n  fly();\n\n  lagEggs();\n}\n\ninterface Fish {\n  swim();\n\n  layEggs();\n}\n\nfunction getSmallPet(): Fish | Bird {\n  // ...\n}\nlet pet = getSmallPet();\npet.layEggs(); // <- ok\n// pet.swim(); // <- errors\n```\n\n> 这里的联合类型可能有点复杂，但是你很容易就习惯了。如果一个值的类型是 `A | B`，我们能够确定的是它包含了 `A` 和 `B` 中共有的成员。这个例子里，`Bird` 具有一个 `fly` 成员。我们不能确定一个 `Bird | Fish` 类型的变量是否有 `fly` 方法。如果变量在运行时是 `Fish` 类型，那么调用 `pet.fly()` 就出错了。\n\n### 11.3 类型守卫与类型区分\n\n> 联合类型适用于那些值可以为不同类型的情况。但当我们想确切地了解是否为 `Fish` 时怎么办？`JavaScript` 里常用来区分 `2` 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。\n\n```typescript\ninterface Fish {\n  swim();\n  layEggs();\n}\ninterface Bird {\n  fly();\n  layEggs();\n}\nfunction getSmallPet(): Fish | Bird {\n  return;\n}\nlet pet = getSmallPet();\n```\n\n> 每一个访问的成员都会报错\n\n```typescript\nif (pet.swim) {\n  pet.swim();\n} else if (pet.fly) {\n  pet.fly();\n}\n```\n\n> 为了让这段代码工作，我们需要使用类型断言\n\n```typescript\nif ((<Fish>pet).swim) {\n  (<Fish>pet).swim();\n} else if ((<Bird>pet).fly) {\n  (<Bird>pet).fly();\n}\n```\n\n### 11.4 用户自定义的类型守卫\n\n> 这里我们注意到不得不多次使用类型断言。假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 `pet` 的类型的话就好了。\n\n> `TypeScript` 里的类型守卫机制让它成为了现实。类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。要想定义一个类型守卫，我们只需要简单地定义一个函数，它的返回值是一个类型谓词：\n\n```typescript\ninterface Fish {\n  swim();\n\n  layEggs();\n}\n\ninterface Bird {\n  fly();\n\n  layEggs();\n}\n\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (<Fish>pet).swim !== undefined;\n}\n```\n\n> 在这个例子里，`pet is Fish` 就是类型谓词。谓词为 `parameterName is Type` 这种形式， `parameterName` 必须是来自于当前函数签名里的一个参数名。\n> 每当使用一些变量调用 `isFish` `时，TypeScript` 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的\n> `swim` 和 `fly` 的调用都没有问题了\n\n```typescript\nif (isFish(pet)) {\n  pet.swim();\n} else {\n  pet.fly();\n}\n```\n\n> 注意 `TypeScript` 不仅知道在 `if` 分支里 `pet` 是 `Fish` 类型；它还清楚在 `else` 分之里，一定不是 `Fish` 类型，一定是 Bird 类型。\n\n### 11.5 typeof 类型守卫\n\n> 现在我们回过头来看看怎么使用联合类型书写 `padLeft` 代码。 我们可以像下面这样利用类型断言来写：\n\n```typescript\nfunction isNumber(x: any): x is number {\n  return typeof x === \"number\";\n}\n\nfunction isString(x: any): x is string {\n  return typeof x === \"string\";\n}\n\nfunction padLeft(value: string, padding: string | number) {\n  if (isNumber(padding)) {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  if (isString(padding)) {\n    return padding + value;\n  }\n  throw new Error(`Expected string or number, go ${padding}.`);\n}\n```\n\n> 然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。幸运的是，现在我们不必将 `typeof x === \"number\"` 抽象成一个函数，因为 `TypeScript` 可以将它识别为一个类型守卫。也就是说，我们可以直接在代码里检查类型了。\n\n```typescript\nfunction newPadLeft(value: string, padding: string | number) {\n  if (typeof padding === \"number\") {\n    return Array(padding + 1).join(\" \") + value;\n  }\n  if (typeof padding === \"string\") {\n    return padding + value;\n  }\n  throw new Error(`Expected string or number, go ${padding}.`);\n}\n```\n\n> 这些 `typeof` 类型守卫只有两种形式能被识别：`typeof v === \"typename\"` 和 `typeof v !== \"typename\"`, `\"typename\"` 必须是 `\"number\"`, `\"string\"`, `\"boolean\"` 或 `\"symbol\"`。但是 `TypeScript` 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。\n\n### 11.6 instanceof 类型守卫\n\n> `instanceof` 类型守卫是通过构造函数来细化类型的一种方式。比如，我们借鉴一下之前字符串填充的例子：\n\n```typescript\ninterface Padder {\n  getPaddingString(): string;\n}\n\nclass SpaceRepeatingPadder implements Padder {\n  constructor(private numSpaces: number) {}\n\n  getPaddingString() {\n    return Array(this.numSpaces + 1).join(\" \");\n  }\n}\n\nclass StringPadder implements Padder {\n  constructor(private value: string) {}\n\n  getPaddingString() {\n    return this.value;\n  }\n}\n\nfunction getRandomPadder() {\n  return Math.random() < 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(\" \");\n}\n\n// 类型为 SpaceRepeatingPadder | StringPadder\nlet padder: Padder = getRandomPadder();\n\nif (padder instanceof SpaceRepeatingPadder) {\n  padder; // 类型细化为 'SpaceRepeatingPadder'\n}\nif (padder instanceof StringPadder) {\n  padder; // 类型细化为 'StringPadder'\n}\n```\n\n> `instanceof` 的右侧要求是一个构造函数，`TypeScript` 将细化为:\n\n1. 此构造函数的 `prototype` 属性的类型，如果它的类型不为 `any` 的话\n2. 标签签名所返回的类型的联合\n\n> 以此顺序。\n\n### 11.7 可为 null 的类型\n\n> `TypeScript` 具有两种特殊的类型，`null` 和 `undefined` ，它们分别具有值 `null` 和 `undefined`。默认情况下，类型检查器会认为 `null` 和 `undefined` 可以赋值给任何类型。`null` 和 `undefined` 是所有其它类型的一个有效值。这意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。\n\n> `--strictNullChecks` 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 `null` 或 `undefined`。\n\n- 你可以使用联合类型明确的包含它们：```typescript\n  let s = \"foo\";\n  s = null; // --strictNullChecks 模式下 错误， 'null' 不能赋值给 'string'\n  let sn: string | null = \"bar\";\n  sn = null; // Ok\n  sn = undefined; // --strictNullChecks 模式下 error, 因为'undefined'不能赋值给'string | null'\n\n````\n\n\n\n\n>  注意：按照 `JavaScript` `的语义，TypeScript` 会把 `null` 和 `undefined` 区别对待。\n\n\n\n> `string | null`，`string | undefined` 和 `string | undefined | null` 是不同的类型。\n\n\n\n### 11.8 可选参数和可选属性\n\n\n- 使用了 `--strictNullChecks` ，可选参数会被自动地加上 `| undefined`:\n\n\n\n```typescript\nfunction f(x: number, y?: number) {\n    return x + (y || 0);\n}\nf(1, 2);\nf(1);\nf(1, undefined);\nf(1, null); // error, 'null' is not assignable to 'number | undefined'\n````\n\n- 可选属性也会有同样的处理\n\n```typescript\nclass C {\n  a: number;\n  b?: number;\n}\nlet c = new C();\nc.a = 12;\nc.a = undefined; // error, 'undefined' is not assignable to 'number'\nc.b = 13;\nc.b = undefined; // Ok\nc.b = null; // error, 'null' is not assignable to 'number | undefined'\n```\n\n### 11.9 类型守卫和类型断言\n\n> 由于可以为 `null` 的类型是通过联合类型实现，那么你需要使用类型守卫来去除 `null`。幸运地是这与在 `JavaScript` 里写的代码一致：\n\n```typescript\nfunction f(sn: string | null): string {\n  if (sn == null) {\n    return \"default\";\n  } else {\n    return sn;\n  }\n}\n```\n\n> 这里很明显地去除了 `null`, 你也可以使用短路运算符:\n\n```typescript\nfunction f1(sn: string | null): string {\n  return sn || \"default\";\n}\n```\n\n> 如果编译器不能够去除 `null` 或 `undefined`，你可以使用类型断言手动去除。语法是添加 `!` 后缀：`identifier!` 从 `identifier` 的类型里去除了 `null` 和 `undefined`：\n\n```typescript\nfunction broken(name: string | null): string {\n  function postfix(epihet: string) {\n    return name.charAt(0) + \". the\" + epihet; // error, 'name' is possibly null\n  }\n  name = name || \"Bob\";\n  return postfix(\"great\");\n}\n\nfunction fixed(name: string | null): string {\n  function postfix(epihet: string) {\n    return name!.charAt(0) + \". the\" + epihet; // Ok\n  }\n  name = name || \"Bob\";\n  return postfix(\"great\");\n}\n```\n\n> 本例使用了嵌套函数，因为编译器无法去除嵌套函数的 `null` (除非是立即调用的函数表达式)。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数作为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 `name` 的类型。\n\n### 11.10 类型别名\n\n1. 类型别名会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于 原始值，联合类型，元组 以及其它任何你需要手写的类型。\n\n```typescript\ntype Name = string;\ntype NameResolver = () => string;\ntype NameOrResolver = Name | NameResolver;\n\nfunction getName(n: NameOrResolver): Name {\n  if (typeof n === \"string\") {\n    return n;\n  } else {\n    return n();\n  }\n}\n```\n\n2. 起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。\n\n3.给原始类型起别名通常没有什么用，尽管可以作为文档的一种形式使用。\n\n4. 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入。\n\n```typescript\ntype Container<T> = { value: T };\n```\n\n5. 我们也可以使用类型别名来在属性里引用自己：\n\n```typescript\ntype Tree<T> = {\n  value: T;\n  left: Tree<T>;\n  right: Tree<T>;\n};\n```\n\n6. 与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型\n\n```typescript\ntype LinkedList<T> = T & { next: LinkedList<T> };\n\ninterface Person {\n  name: string;\n}\n\nvar people: LinkedList<Person>;\nvar s = people.name;\nvar s = people.next.name;\nvar s = people.next.next.name;\nvar s = people.next.next.next.name;\n```\n\n> 然而，类型别名不能出现在声明右侧的任何地方\n\n```typescript\n// type Yikes = Array<Yikes>; // error\n```\n\n### 11.11 接口 vs 类型别名\n\n> 像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。\n\n1. 接口创建了一个新的名字，可以在其它任何地方使用。类型别名并不创建新名字 - 比如，错误信息就不会使用别名。\n\n> 在下面的示例代码里，在编译器中将鼠标悬停在 `interfaced` 上，显示它返回的是 `Interface`，但悬停在 `aliased` 上时，显示的却是对象字面量类型。\n\n```typescript\ntype Alias = { num: number };\n\ninterface Interface {\n  num: number;\n}\n\ndeclare function aliased(arg: Alias): Alias;\n\ndeclare function interfaced(arg: Interface): Interface;\n```\n\n2. 另一个重要区别是类型别名不能被 `extends` 和 `implements` (自己也不能 `extends` 和 `implements` 其它类型)。因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。\n3. 另一方面，如果你无法通过接口来描述一个类型并且需要使用 联合类型 或 元组类型，这时通常会使用类型别名。\n\n### 11.12 字符串字面量类型\n\n> 字符串字面量类型允许你指定字符串必须的固定值。在实际应用中，字符串字面量类型可以与联合类型，类型守卫和类型别名很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。\n\n```typescript\ntype Easing = \"ease-in\" | \"ease-out\" | \"ease-in-out\";\n\nclass UIElement {\n  animate(dx: number, dy: number, easing: Easing) {\n    if (easing === \"ease-in\") {\n      // ...\n    } else if (easing === \"ease-out\") {\n      // ...\n    } else if (easing === \"ease-in-out\") {\n      // ...\n    } else {\n      // error! should not pass null or undefined.\n    }\n  }\n}\n\nlet button = new UIElement();\nbutton.animate(0, 0, \"ease-in\");\n// button.animate(0, 0,\"uneasy\"); // error: \"uneasy\" is not allowed here\n```\n\n- 你只能从三种允许的字符中选择其一来作为参数传递，传入其它值则会产生错误。\n\n```typescript\n// Argument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\n```\n\n- 字符串字面量类型还可以用于区分函数重载\n\n```typescript\nfunction createElement(tagName: \"img\"): HTMLImageElement;\nfunction createELement(tagName: \"input\"): HTMLInputElement;\n// ... more overloads ...\nfunction createElement(tagName: \"string\"): Element {\n  // ... code goes here ...\n}\n```\n\n### 11.13 数字字面量类型\n\n- `TypeScript` 还具有数字字面量类型\n\n```typescript\nfunction rollDice(): 1 | 2 | 3 | 4 | 5 | 6 {\n  // ...\n}\n```\n\n- 我们很少直接这样使用，但它们可以用在缩小范围调试 `bug` 的时候。\n\n```typescript\nfunction foo(x: number) {\n  if (x !== 1 || x !== 2) {\n    // ~~~~~~\n    // Operator '!==' cannot be applied to types '1' and '2'\n  }\n}\n```\n\n> 换句话说，当 `x` 与 `2` 进行比较的时候，它的值必须为 `1`，这就意味着上面的比较检查是非法的。\n\n### 11.14 枚举成员类型\n\n> 如我们在枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。在我们谈及“单例类型”的时候，多数是指 枚举成员类型 和 数字/字符串 字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。\n\n### 11.15 可辨识联合\n\n> 你可以合并 单例类型，联合类型，类型守卫 和 类型别名 来创建一个叫做 可辨识联合 的高级模式，它也称作 标签联合 或 代数数据类型。可辨识联合 在函数式编程里很有用处。一些语言会自动地为你辨识联合；而 `TypeScript` 则基于已有的 `JavaScript` 模式，。它具有 `3` 个要素：\n\n1. 具有普通的单例类型属性 - 可辨识的特征\n2. 一个类型别名包含了那些类型的联合 - 联合。\n3. 此属性上的类型守卫\n\n```typescript\ninterface Square {\n  kind: \"square\";\n  size: number;\n}\n\ninterface Rectangle {\n  kind: \"rectangle\";\n  width: number;\n  height: number;\n}\n\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n```\n\n> 首先我们声明了将要联合的接口。每个接口都有 `kind` 属性但有不同的字符串字面量类型。`kind` 属性称作 可辨识的特征或标签。其它的属性则特定于各个接口。注意，目前各个接口间是没有联系的。\n\n- 下面我们将它们联合到一起。\n\n```typescript\ntype Shape = Square | Rectangle | Circle;\n```\n\n- 现在我们使用可辨识联合\n\n```typescript\nfunction area(s: Shape) {\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.width * s.height;\n    case \"circle\":\n      return Math.PI * s.radius ** 2;\n  }\n}\nlet areaSquare = area({ kind: \"square\", size: 12 });\nlet areaRectangle = area({ kind: \"rectangle\", width: 14, height: 13 });\nlet areaCircle = area({ kind: \"circle\", radius: 5 });\nconsole.log(areaSquare, areaRectangle, areaCircle);\n```\n\n### 11.16 完整性检查\n\n> 当没有涵盖所有 可辨识联合 的变化时，我们想让编译器可以通知我们。比如，如果我们添加了 `Triangle` 和 `Shape`，我们同时还需要更新 `area`：\n\n```typescript\ninterface Square {\n  kind: \"square\";\n  size: number;\n}\n\ninterface Rectangle {\n  kind: \"rectangle\";\n  width: number;\n  height: number;\n}\n\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\n\n// interface Triangle { kind: \"triangle\", bottom: number, height: number }\n\ntype Shape = Square | Rectangle | Circle;\n\nfunction area(s: Shape) {\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.width * s.height;\n    case \"circle\":\n      return Math.PI * s.radius ** 2;\n  }\n  // should error here - we didn't handle case \"triangle\"\n}\n```\n\n- 有两种方式可以实现。\n\n1. 首先是启用 `--strictNullChecks` 并且指定一个返回值类型:\n\n```typescript\nfunction area1(s: Shape): number {\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.height * s.width;\n    case \"circle\":\n      return Math.PI * s.radius ** 2;\n  }\n}\n```\n\n> 因为 `switch` 没有包含所有情况，所以 `TypeScript` 认为这个函数有时候会返回 `undefined`。如果你明确地指定了返回值类型为 `number`，那么你会看到一个错误，因为实际上返回值类型为 `number | undefined`。然而，这种方法存在些微妙之处且 `--strictNullChecks` 对旧代码支持不好。\n\n2. 第二种方法使用 `never` 类型，编译器用它来进行完整性检查\n\n```typescript\nfunction assertNever(x: never): never {\n throw new Error(\"Unexpected object: \" + x);\n}\n>\nfunction area2(s: Shape) {\n switch (s.kind) {\n     case \"square\":\n         return s.size * s.size;\n     case \"rectangle\":\n         return s.width * s.height;\n     case \"circle\":\n         return Math.PI * s.radius ** 2;\n     default:\n         return assertNever(s); // error here if there are missing cases\n }\n}\n```\n\n> 这里，`assertNever` 检查 `s` 是否为 `never` 类型 - 即为除去所有可能情况后剩下的类型。如果你忘记了某个 `case`，那么 `s` 将具有一个真实的类型并且你会得到一个错误。这种方式需要你定义一个额外的函数，但是在你忘记某个 `case` 的时候也更加明显。\n\n### 11.17 多态的 this 类型\n\n> 多态的 `this` 类型表示的是某个包含类或接口的子类型。这被称作是 `F-bounded` 多态性。它能很容易的表现连贯接口间的继承。\n\n- 比如，在计算器的例子里，在每个操作之后都返回 `this` 类型。\n\n```typescript\nclass BasicCalculator {\n  public constructor(protected value: number = 0) {}\n\n  public currentValue(): number {\n    return this.value;\n  }\n\n  public add(operand: number): this {\n    this.value += operand;\n    return this;\n  }\n\n  public multiply(operand: number): this {\n    this.value *= operand;\n    return this;\n  }\n\n  //...other operations go here...\n}\n\nlet v = new BasicCalculator(2).multiply(5).add(1).currentValue();\nconsole.log(v);\n```\n\n> 由于这个类使用了 `this` 类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何改变。\n\n```typescript\nclass ScientificCalculator extends BasicCalculator {\n  public constructor(value = 0) {\n    super(value);\n  }\n\n  public sin() {\n    this.value = Math.sin(this.value);\n    return this;\n  }\n\n  // ... other operations go here ...\n}\n\nlet v1 = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();\nconsole.log(v1);\n```\n\n> 如果没有 `this` 类型，`ScientificCalculator` 就不能够在继承 `BasicCalculator` 的同时还保持接口的连贯性。`multiply` 将会返回 `BasicCalculator`，它并没有 `sin` 方法。然而，使用 `this` 类型，`multiply` 会返回 `this`，在这里就是 `ScientificCalculator`。\n\n### 11.18 索引类型\n\n> 使用索引类型，编译器就能够检查使用了动态属性名的代码。\n\n- 例如，一个常见的 `JavaScript` 模式是从对象中选取属性的子集。\n\n```typescript\nfunction js_pluck(o, names) {\n  return names.map(n => o[n]);\n}\n```\n\n- 下面是如何在 `TypeScript` 里使用此函数，通过 索引类型查询和 索引访问 操作符：\n\n```typescript\nfunction pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {\n  return names.map(n => o[n]);\n}\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\nlet person: Person = {\n  name: \"Jarid\",\n  age: 35\n};\nlet strings: string[] = pluck(person, [\"name\"]);\nconsole.log(strings);\n```\n\n> 编译器会检查 `name` 是否真的是 `Person` 的一个属性。本例还引入了几个新的类型操作符。\n\n#### 11.18.1 首先是 `keyof T`，索引类型查询操作符。\n\n> 对于任何类型 `T` ，`keyof T` 的结果为 `T` 上已知的公共属性名的联合。\n\n- 例如：\n\n```typescript\nlet personProps: keyof Person; // 'name' | 'age'\n```\n\n> `keyof Person` 是完全可以与 `'name' \\| 'age'` 互相替换的。不同的是如果你添加了其它的属性到 `Person`, 例如 `address: string`，那么`keyof Person` 会自动变为 `'name' | 'age' | 'address'`。你可以像 `pluck` 函数这类上下文里使用 `keyof` ，因为在使用之前你并不清楚可能出现的属性名。但编译器会检查你是否传入了正确的属性名给 `pluck`：\n\n```typescript\n// pluck(person, ['age', 'unknown']); // error, 'unknown' is not in 'name' | 'age'\n```\n\n#### 11.18.2 第二个操作符是 `T[K]`, 索引访问操作符。\n\n> 在这里，类型语法反应了表达式语法。这意味着 `person['name']` 具有类型 `Person['name']` -- 在我们的例子里则为 `string` 类型。然而，就像索引类型查询一样，你可以在普通的上下文里使用 `T[K]`，这正是它的强大所在。你只要确保类型变量 `K extends keyof T` 就可以了。\n\n- 例如下面 `getProperty` 函数的例子：\n\n```typescript\nfunction getProperty<T, K extends keyof T>(o: T, name: K): T[K] {\n  return o[name]; // o[name] is of type T[K]\n}\n```\n\n> `getProperty` 里的 `o: T` 和 `name: K`，意味着 `o[name]: T[K]`。当你返回 `T[K]` 的结果，\n\n> 编译器会是实例化键的真实类型，因此 `getProperty` 的返回值类型会随着你需要的属性改变。\n\n```typescript\nlet _name: string = getProperty(person, \"name\");\nlet _age: number = getProperty(person, \"age\");\n// let unknown = getProperty(person, \"unknown\"); // error, 'unknown' is not in 'name' | 'age'\nconsole.log(_name, \" \", _age);\n```\n\n### 11.19 索引类型和字符串索引签名\n\n> `keyof` 和 `T[K]` 与字符串索引签名进行交互。如果你有一个带有字符串索引签名的类型，那么 `keyof T` 会是 `string`。并且 `T[string]` 为索引签名的类型。\n\n```typescript\ninterface Dictionary<T> {\n  [key: string]: T;\n}\nlet keys: keyof Dictionary<number>; // string\nlet value: Dictionary<number>[\"foo\"]; // number\n```\n\n### 11.20 映射类型\n\n- 一个常见的任务是将一个已知的类型每个属性都变为可选的。\n\n```typescript\ninterface PersonPartial {\n  name?: string;\n  age?: number;\n}\n```\n\n- 或者我们只想要一个只读版本\n\n```typescript\ninterface PersonReadonly {\n  readonly name: string;\n  readonly age: number;\n}\n```\n\n> 这在 `JavaScript` 里经常出现。`TypeScript` 提供了从旧类型中创建新类型的一种方式 `--` 映射类型。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。假如，你可以令每个属性成为 `readonly` 类型或可选的。\n\n- 下面是一些例子：\n\n```typescript\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n```\n\n- 像下面这样使用\n\n```typescript\ninterface Person {}\ntype PersonPartial = Partial;\ntype PersonReadonly = Readonly;\n```\n\n> 需要注意的是，这个语法描述的是类型而非成员。若想添加额外的成员，则可以使用 交叉类型。\n\n- 这样使用\n\n```typescript\ntype PartialWithNewMember<T> = {\n  [P in keyof T]?: T[P];\n} & { newMember: boolean };\n```\n\n- 不要这样使用\n\n```typescript\ntype PartialWithNewMember<T> = {\n  [P in keyof T]?: T[P];\n  newMember: boolean;\n}\n```\n\n> 下面来看看最简单的映射类型和它的组成部分\n\n```typescript\ntype Keys = \"option1\" | \"option2\";\ntype Flags = { [K in Keys]: boolean };\n```\n\n> 它的语法与索引签名的语法类型，内部使用了 `for...in`。具有三个部分：\n\n1. 类型变量 `K`，它会依次绑定到每个属性。\n2. 字符串字面量联合的 `Keys`，它包含了要迭代的属性名的集合。\n3. 属性的结果类型。\n\n> 在上面这个简单的例子里，`Keys` 是硬编码的属性列表并且属性类型永远是 `boolean`，因此这个映射类型\n\n- 等同于：\n\n```typescript\ntype _FLags = {\n  option1: boolean;\n  option2: boolean;\n};\n```\n\n> 在真正的应用里，可能不同于上面的 `Readonly` 或 `Partial`。它们会基于一些已存在的类型，且按照一定的方式转换字段。这就是 `keyof` 和 `索引访问类型` 要做的事情。\n\n```typescript\ntype NullablePerson = { [P in keyof Person]: Person[P] | null };\ntype PartialPerson = { [P in keyof Person]?: Person[P] };\n```\n\n> 但它更有用的地方是可以有一些通用版本。\n\n```typescript\ntype Nullable<T> = { [P in keyof T]: T[P] | null };\ntype Partial1<T> = { [P in keyof T]?: T[P] };\n```\n\n> 在这些例子里，属性列表是 `keyof T` 且结果类型是 `T[P]` 的变体。这是使用通用映射类型的一个好模版。因为这类转换是同态的，映射只作用于 `T` 的属性而没有其它的。编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。假如，假设 `Person.name` 是只读的，那么 `Partial1<Person>.name` 也将是只读的且为可选的。\n\n> 下面是另一个例子，`T[P]` 被包装在 `Proxy<T>` 类里：\n\n```typescript\ntype Proxy<T> = {\n  get(): T;\n  set(value: T): void;\n};\ntype Proxify<T> = {\n  [P in keyof T]: Proxy<T[P]>;\n};\nfunction proxify<T>(o: T): Proxify<T> {\n  // ...wrap proxies\n}\nlet proxyProps = proxify(props);\n```\n\n> 注意 `Readonly<T>` 和 `Partial<T>` 用处不小，因此它们于 `pick` 和 `Record` 一同被包含进了 `TypeScript` 的标准库里：\n\n```typescript\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\ntype Record<K extends keyof any, T> = {\n  [P in K]: T;\n};\n```\n\n> `Readonly`, `Partial` 和 `Pick` 是同态的，但 `Record` 不是。因为 `Record` 并不需要输入类型来拷贝属性，所以它不属于同态：\n\n```typescript\ntype ThreeStringProps = Record<\"prop1\" | \"prop2\" | \"prop3\", string>;\n```\n\n> 非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。\n\n### 11.21 由映射类型进行判断\n\n> 现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。其实这也非常容易：\n\n```typescript\ntype Proxify<T> = {\n  get(): T;\n  set(value: T): void;\n};\n\nfunction unproxify<T>(t: Proxify<T>): T {\n  let result = {} as T;\n  for (const k in t) {\n    result[k] = t[k].get();\n  }\n  return result;\n}\n// let originalProps = unproxify(proxyProps);\n```\n\n> 注意这个拆包推断只适用于同态的映射类型。如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。\n\n### 11.22 有条件类型\n\n> `TypeScript 2.8` 引入了有条件类型，它能够表示非统一的类型。有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：\n\n```typescript\nT extends U ? X : Y\n```\n\n> 上面的类型意思是：若 `T` 能够赋值给 `U`，那么类型是 `X`，否则为 `Y`\n\n> 有条件的类型 `T extends U ? X : Y` 或者解析为 `X`，或者解析为 `Y`，再或者延迟解析，因为它可能依赖一个或多个类型变量。若 `T` 或 `U` 包含类型参数，那么是否解析为 `X` 或 `Y` 或推迟，取决于类型系统是否有足够的信息来确定 `T` 总是可以赋值给 `U`。\n\n- 下面是一些类型可以被立即解析的例子：\n\n```typescript\ndeclare function f<T extends boolean>(x: T): T extends true ? string : number;\n\n// Type is 'string' | 'number'\nlet x = f(Math.random() < 0.5);\n```\n\n> 另外一个例子涉及 `TypeName` 类型别名，它使用了嵌套了有条件类型\n\n```typescript\ntype TypeName<T> = T extends string ? \"string\" : T extends number ? \"number\" : T extends boolean ? \"boolean\" : T extends undefined ? \"undefined\" : T extends Function ? \"function\" : \"object\";\n\ntype T0 = TypeName<string>; // \"string\"\ntype T1 = TypeName<\"a\">; // \"string\"\ntype T2 = TypeName<true>; // \"boolean\"\ntype T3 = TypeName<() => void>; // \"function\"\ntype T4 = TypeName<string[]>; // \"object\"\n```\n\n- 下面是一个有条件类型被推迟解析的例子\n\n```typescript\ninterface Foo {\n  propA: boolean;\n  propB: boolean;\n}\ndeclare function f<T>(x: T): T extends Foo ? string : number;\nfunction foo<U>(x: U) {\n  // Has type 'U extends Foo ? string : number'\n  let a = f(x);\n  // This assignment is allowed though!\n  let b: string | number = a;\n}\n```\n\n> 这里，`a` 变量含有未确定的有条件类型。当有另一段代码调用 `foo`，它会用其它类型替换 `U`，`TypeScript` 将重新计算有条件类型，决定它是否可以选择一个分支。与此同时，我们可以将有条件类型赋值给其它类型，只要有条件类型的每个分支，都可以赋值给目标类型。因此在我们的例子里，我们可以将 `U extends Foo ? string : number` 赋值给 `string | number`，因为不管这个有条件类型最终结果是什么，它只能是 `string | number`。\n\n### 11.23 分布式有条件类型\n\n> 如果有条件类型里待检查的类型是 `naked type parameter` ，那么它也被称为\"分布式有条件类型\"。分布式有条件类型在实例化时会自动分发成联合类型。例如：实例化 `T extends U ? X : Y`，`T` 的类型为 `A | B | C`，会被解析为 `(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)`。\n\n- 例子：```typescript\n  type TypeName<T> =\n  T extends string ? \"string\" :\n  T extends number ? \"number\" :\n  T extends boolean ? \"boolean\" :\n  T extends undefined ? \"undefined\" :\n  T extends Function ? \"function\" : \"object\";\n  type T10 = TypeName<string | (() => void)>; // \"string\" | \"function\"\n  type T11 = TypeName<string | string[] | undefined>; // \"string\" | \"object\" | \"undefined\"\n  type T12 = TypeName<string[] | number[]>; // \"object\"\n\n````\n\n\n\n\n>  在 `T extends U ? X : Y` 的实例化里，对 `T` 的引用被解析为联合类型的一部分(比如，`T` 指向某一单个部分，在有条件类型分布到联合类型之后)。此外，在 `X` 内对 `T` 的引用有一个附加的类型参数约束 `U`(例如，`T` 被当成在 `X` 内可赋值给 `U`)。\n\n\n\n- 例子：\n\n\n\n```typescript\ntype BoxedValue<T> = { value: T };\ntype BoxedArray<T> = { array: T[] };\ntype Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;\n\ntype T20 = Boxed<string>; // BoxedValue<string>;\ntype T21 = Boxed<number[]>; // BoxedArray<number>;\ntype T22 = Boxed<string | number[]>; // BoxedValue<string> | BoxedArray<number>;\n````\n\n#### 11.23.1 有条件类型的分布式的属性可以方便地用来过滤联合类型：\n\n```typescript\ntype Diff<T, U> = T extends U ? never : T; // Remove types from T that are assignable to U(从 T 中删除可分配给 U 的类型)\ntype Filter<T, U> = T extends U ? T : never; // Remove types from T that are not assignable to U(从 T 中删除不可赋值给 U 的类型)\n\ntype T30 = Diff<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"b\" | \"d\"\ntype T31 = Filter<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"\ntype T32 = Diff<string | number | (() => void), Function>; // string | number\ntype T33 = Filter<string | number | (() => void), Function>; // () => void\n\ntype _NonNullable<T> = Diff<T, null | undefined>; // Remove null and undefined from T\n\ntype T34 = _NonNullable<string | number | undefined>; // string | number\ntype T35 = _NonNullable<string | string[] | null | undefined>; // string | string[]\n\nfunction f1<T>(x: T, y: _NonNullable<T>) {\n  x = y; // Ok\n  // y = x ;// Error\n}\nfunction f2<T extends string | undefined>(x: T, y: _NonNullable<T>) {\n  x = y; // Ok\n  // y = x; //Error\n  // let s1: string = x; // Error\n  let s2: string = y; // Ok\n}\n```\n\n#### 11.23.2 有条件类型与映射类型结合时特别有用\n\n```typescript\ntype FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T];\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\n\ntype NonFunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? never : K }[keyof T];\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\ninterface Part {\n  id: number;\n  name: string;\n  subparts: Part[];\n  updatePart(newName: string): void;\n}\n\ntype T40 = FunctionPropertyNames<Part>; // \"updatePart\"\ntype T41 = NonFunctionPropertyNames<Part>; // \"id\" | \"name\" | \"subparts\"\ntype T42 = FunctionProperties<Part>; // { updatePart(newName: string): void }\ntype T43 = NonFunctionProperties<Part>; // { id: number, name: string, suparts: Part[] }\n```\n\n#### 11.23.3 与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。\n\n- 比如下面的错误：\n\n```typescript\n// type ElementType<T> = T extends any[] ? ElementType<T[number]>: T; // Error\n```\n\n### 11.24 有条件类型中的类型推断\n\n> 现在有条件类型的 `extends` 子语句中，允许出现 `infer` 声明，它会引入一个待推断的类型变量。这个推断的类型变量可以在有条件类型的 `true` 分支中被引用。允许出现多个同类型变量的 `infer`。\n\n> 例如：下面代码会提取函数类型的返回值\n\n```typescript\ntype _ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n> 有条件类型 可以嵌套来构成一系列的匹配模式，按顺序进行求值：\n\n```typescript\ntype Unpacked<T> = T extends (infer U)[] ? U : T extends (...args: any[]) => infer U ? U : T extends Promise<infer U> ? U : T;\n\ntype T0 = Unpacked<string>; // string\ntype T1 = Unpacked<string[]>; // string\ntype T2 = Unpacked<() => string>; // string\ntype T3 = Unpacked<Promise<string>>; // string\ntype T4 = Unpacked<Promise<string>[]>; // Promise<string>\ntype T5 = Unpacked<Unpacked<Promise<string>[]>>; // string\n```\n\n> 下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：\n\n```typescript\ntype Foo<T> = T extends { a: infer U; b: infer U } ? U : never;\ntype T10 = Foo<{ a: string; b: string }>; // string\ntype T11 = Foo<{ a: string; b: number }>; // string | number\n```\n\n> 相似地，在抗变位置上同一个类型变量的多个候选类型会被推断为交叉类型：\n>\n> ```typescript\n> type Bar<T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void } ? U : never;\n> type T20 = Bar<{ a: (x: string) => void; b: (x: string) => void }>; // string\n> type T21 = Bar<{ a: (x: string) => void; b: (x: number) => void }>; // string & number\n> ```\n\n````\n\n\n\n> 当推断具有多个调用签名(例如函数重载类型)的类型时，用最后的签名(大概是最自由的包含所有情况的签名) 进行推断。无法根据参数类型列表来进行解析重载。\n\n\n\n```typescript\ndeclare function foo(x: string): number;\ndeclare function foo(x: number): string;\ndeclare function foo(x: string | number): string | number;\n\ntype T30 = ReturnType<typeof foo>; // string | number\n````\n\n> 无法在正常类型参数的约束子语句中使用 `infer` 声明：\n\n```typescript\n// type ReturnType1<T extends (...args: any[]) => infer R> = R; // Error\n```\n\n> 但是，可以这样达到同样的效果，在约束里删掉类型变量，用 有条件类型 来替换：\n\n```typescript\ntype AnyFunction = (...args: any[]) => any;\ntype ReturnType2<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any;\n```\n\n> 实际上，就是 `ReturnType`\n\n```typescript\ntype __ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : never;\n```\n\n### 11.25 预定义的有条件类型\n\n> `TypeScript 2.8` 在 `lib.d.ts` 里增加了一些预定义的有条件类型\n\n> 1. `Exclude<T, U>` -- 从 `T` 中剔除可以赋值给 `U` 的类型\n> 2. `Extract<T, U>` -- 提取 `T` 中可以赋值给 `U` 的类型\n> 3. `NonNullable<T>` -- 从 `T` 中剔除 `null` 和 `undefined`\n> 4. `ReturnType<T>` -- 获取函数返回值类型\n> 5. `InstanceType<T>` -- 获取构造函数类型的实例类型\n\n- `Example`:\n\n```typescript\ntype T00 = Exclude<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"b\" | \"d\"\ntype T01 = Extract<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"\n\ntype T02 = Exclude<string | number | (() => void), Function>; // \"string\" | \"number\"\ntype T03 = Extract<string | number | (() => void), Function>; // () => void\n\ntype T04 = NonNullable<string | number | undefined>; // string | number\ntype T05 = NonNullable<(() => string) | string[] | null | undefined>; // (() => string) | string[]\n\nfunction f1(s: string) {\n  return { a: 1, b: s };\n}\n\nclass C {\n  x = 0;\n  y = 0;\n}\n\ntype T10 = ReturnType<() => string>; // string\ntype T11 = ReturnType<(s: string) => void>; // void\ntype T12 = ReturnType<<T>() => T>; // {}\ntype T13 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]\ntype T14 = ReturnType<typeof f1>; // { a: number, b: string }\ntype T15 = ReturnType<any>; // any\ntype T16 = ReturnType<never>; // never\n// type T17 = ReturnType<string>; // Error\n// type T18 = ReturnType<Function>; // Error\n\ntype T20 = InstanceType<typeof C>; // C\ntype T21 = InstanceType<any>; // any\ntype T22 = InstanceType<never>; // never\n// type T23 = InstanceType<string>; // Error\n// type T24 = InstanceType<Function>; // Error\n```\n\n> 注意：`Exclude` 类型是建议的 `Diff` 类型的一种实现，我们使用 `Exclude` 这个名字是为了避免破坏已经定义了的 `Diff` 的代码，并且我们感觉这个名字能更好地表达类型的语义。我们没有增加 `Omit<T, K>` 类型，因为它可以很容易的用 `Pick<T, Exclude<keyof T, K>>` 来表示\n\n## 十二、实用工具类型\n\n> `TypeScript` 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的。\n\n### 12.1 Partial 局部的\n\n> 构造类型 `T`, 并将它所有的属性设置成可选的，它的返回类型表示输入类型的所有子类型。\n\n- 例子：\n\n```typescript\ninterface PartialTodo {\n  title: string;\n  description: string;\n}\n\nfunction updateTodo(todo: PartialTodo, fieldsToUpdate: Partial<PartialTodo>) {\n  return { ...todo, ...fieldsToUpdate };\n}\n\nconst partialTodo1 = {\n  title: \"organize desk\",\n  description: \"clear clutter\"\n};\n\nconst partialTodo2 = updateTodo(partialTodo1, {\n  description: \"throw out trash\"\n});\n```\n\n### 12.2 Readonly 只读的\n\n> 构造类型 T**，并将它所有的属性设置为** readonly**，也就是说构造出的类型的属性不能被再次赋值**\n\n- 例子：\n\n```typescript\ninterface ReadonlyTodo {\n  title: string;\n}\n\nconst readonlyTodo: Readonly<ReadonlyTodo> = {\n  title: \"Delete inactive users\"\n};\n\nreadonlyTodo.title = \"Hello\"; // Error: cannot reassign a readonly property\n\n// Object.freeze\nfunction freeze<T>(obj: T): Readonly<T>;\n```\n\n### 12.3 Record<T, K> 记录\n\n> 构造一个类型，其属性名的类型为 `K`，属性值的类型为 `T`。这个工具可用来将某个类型的属性映射到另一个类型上。\n\n- 例子：\n\n```typescript\ninterface PageInfo {\n  title: string;\n}\n\ntype Page = \"home\" | \"about\" | \"contact\";\n\nconst x: Record<Page, PageInfo> = {\n  about: { title: \"about\" },\n  contact: { title: \"concat\" },\n  home: { title: \"home\" }\n};\n```\n\n### 12.4 Pick<T, K> 挑选\n\n> 从类型 `T` 中挑选部分属性 `K` 来构造类型\n\n```typescript\ninterface PickTodo {\n  title: string;\n  description: string;\n  completed: boolean;\n}\n\ntype TodoPreview = Pick<PickTodo, \"title\" | \"completed\">;\n\nconst pickTodo: TodoPreview = {\n  title: \"Clean room\",\n  completed: false\n};\n```\n\n### 12.5 Exclude<T, U> 剔除\n\n> 从类型 `T` 中剔除所有可以赋值给 `U` 的属性，然后构造一个类型。\n\n- 例子：\n\n```typescript\ntype T0 = Exclude<\"a\" | \"b\" | \"c\", \"a\">; // \"b\" | \"c\"\ntype T1 = Exclude<\"a\" | \"b\" | \"c\", \"a\" | \"b\">; // \"c\"\ntype T2 = Exclude<string | number | (() => void), Function>; // string | number\n```\n\n### 12.6 Extract<T, U> 提取\n\n> 从类型 `T` 中提取所有可以赋值给 `U` 的类型，然后构造一个类型。\n\n```typescript\ntype T01 = Extract<\"a\" | \"b\" | \"c\", \"a\" | \"f\">; // \"a\"\ntype T02 = Extract<string | number | (() => void), Function>; // () => void\n```\n\n### 12.7 NonNullable\n\n> 从类型 `T` 中剔除 `null` 和 `undefined`，然后构造一个类型\n\n- 例子：\n\n```typescript\ntype T10 = NonNullable<string | number | undefined>; // string | number\ntype T11 = NonNullable<string[] | null | undefined>; // string[]\n```\n\n### 12.8 ReturnType 返回值类型\n\n> 由函数类型 `T` 的返回值类型构造一个类型\n\n- 例子：\n\n```typescript\nfunction f1(s: string) {\n  return { a: 1, b: s };\n}\n\ntype _T0 = ReturnType<() => string>; // string\ntype _T1 = ReturnType<(s: string) => void>; // void\ntype _T2 = ReturnType<<T>() => T>; // {}\ntype _T3 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]\ntype _T4 = ReturnType<typeof f1>; // { a: number, b: string }\ntype _T5 = ReturnType<any>; // any\ntype _T6 = ReturnType<never>; // never\ntype _T7 = ReturnType<string>; // Error\ntype _T8 = ReturnType<Function>; // Error\n```\n\n### 12.9 InstanceType 构造函数 实例类型\n\n> 由构造函数类型 `T` 的实例类型构造一个类型。\n\n- 例子：\n\n```typescript\nclass C {\n  x = 0;\n  y = 0;\n}\n\ntype _T01 = InstanceType<typeof C>; // C\ntype _T02 = InstanceType<any>; // any\ntype _T03 = InstanceType<never>; // never\ntype _T04 = InstanceType<string>; // Error\ntype _T05 = InstanceType<Function>; // Error\n```\n\n### 12.10 Required\n\n> 构造一个类型，使类型 `T` 的所有属性为 `required`\n\n- 例子：\n\n```typescript\ninterface Props {\n  a?: number;\n  b?: string;\n}\n\nconst obj: Props = { a: 5 }; // Ok\nconst obj2: Required<Props> = { a: 5 }; // Error, property 'b' missing\n```\n\n### 12.11 ThisType this\n\n> 这个工具不会返回一个转换后的类型。它作为上下文的 `this` 类型的一个标记。\n> 注意：若想要使用此类型，必须启用 `--noImplicitThis`\n\n- 例子：\n\n```typescript\n// Compile with --noImplicitThis\ntype ObjectDescriptor<D, M> = {\n  data?: D;\n  methods?: M & ThisType<D & M>; // Type of 'this' in methods is D & M\n};\n\nfunction makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {\n  let data: object = desc.data || {};\n  let methods: object = desc.methods || {};\n  return { ...data, ...methods } as D & M;\n}\n\nlet _obj = makeObject({\n  data: { x: 0, y: 0 },\n  methods: {\n    moveBy(dx: number, dy: number) {\n      this.x += dx; // Strongly typed this\n      this.y += dy; // Strongly typed this\n    }\n  }\n});\n_obj.x = 10;\n_obj.y = 10;\n_obj.moveBy(5, 5);\n```\n\n> 上面例子中，`makeObject` 参数里的 `methods` 对象具有一个上下文类型 `ThisType<D & M>`，因此 `methods` 对象的方法里 this 的类型为 `{ x: number, y: number } & { moveBy(dx: number, dy: number): number }`。\n> 在 `lib.d.ts` 里，`ThisType<T>` 标识接口是个简单的空接口声明。除了在被识别为对象字面量的上下文类型之外，这个接口与一般的空接口没有什么不同。\n\n## 十三、Symbols\n\n> 介绍：自 `ECMAScript 2015` 起，`symbol` 成为了一种新的原生类型，就像 `number` 和 `string` 一样。\n\n### 13.1 `symbol` 类型的值是通过 `Symbol` 构造函数创建的。\n\n```typescript\nlet sym1 = Symbol();\nlet sym2 = Symbol(\"key\"); // 可选的字符串 key\n```\n\n### 13.2 `Symbols` 是不可改变且唯一的\n\n```typescript\nlet sym3 = Symbol(\"key\");\nlet sym4 = Symbol(\"key\");\nsym3 === sym4; // false symbols 是唯一的\n```\n\n### 13.3 像字符串一样，`symbols` 也可以被用作对象属性的键。\n\n```typescript\nconst sym = Symbol();\nlet obj = {\n  [sym]: \"value\"\n};\nconsole.log(obj[sym]); // \"value\"\n```\n\n### 13.4 `Symbols` 也可以与计算出的属性名相结合来声明对象的属性和类成员。\n\n```typescript\nconst getClassNameSymbol = Symbol();\n\nclass C {\n  [getClassNameSymbol]() {\n    return \"C\";\n  }\n}\n\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"\n```\n\n### 13.5 众所周知的 `Symbols`\n\n> 除了用户定义的 `Symbols`，还有一些已经众所周知的内置 `symbols`。内置 `symbols` 用来表示语言内部的行为。\n> 以下为这些 `symbols` 的列表：\n\n- `Symbol.hasInstance`\n\n> 该方法会被 `instanceof` 运算符调用。构造器对象用来识别一个对象是否是其实例。\n\n- `Symbol.isConcatSpreadable`\n\n> 布尔值，表示当在一个对象上调用 `Array.prototype.concat` 时，这个对象的数组元素是否可展开。\n\n- `Symbol.iterator`\n\n> 方法，被 `for-of` 语句调用，。返回对象的默认迭代器\n\n- `Symbol.match`\n\n> 方法，被 `String.prototype.match` 调用。正则表达式用来匹配字符串\n\n- `Symbol.replace`\n\n> 方法，被 `String.prototype.replac`e 调用。正则表达式用来替换字符串中匹配的子串。\n\n- `Symbol.search`\n\n> 方法，被 `String.prototype.search` 调用。正则表达式返回被匹配部分在字符串中的索引。\n\n- `Symbol.species`\n\n> 函数值，为一个构造函数。用来创建派生对象。\n\n- `Symbol.split`\n\n> 方法，被 `String.prototype.split` 调用。正则表达式用来分割字符串。\n\n- `Symbol.toPrimitive`\n\n> 方法，被 `ToPrimitive` 抽象操作调用。把对象转换为相应的原始值。\n\n- `Symbol.toStringTag`\n\n> 方法，被内置方法 `Object.prototype.toString` 调用。返回创建对象时默认的字符串描述。\n\n- `Symbol.unscopables`\n\n> 对象，它自己拥有的属性会被 `with` 作用域排除在外。\n\n## 十四、迭代器和生成器\n\n- 可迭代性\n\n> 当一个对象实现了 `Symbol.iterator` 属性时，我们认为它是可迭代的。一些内置的类型如 `Array`，`Map`，`Set`，`String`，`Int32Array`，`Uint32Array` 等都已经实现了各自的 `Symbol.iterator`。对象上的 `Symbol.iterator` 函数负责返回供迭代的值。\n\n### 14.1 for ... of 语句\n\n> `for ... of` 会遍历可迭代对象，调用对象上的 `Symbol.iterator` 方法。\n\n- 下面是在数组上使用 `for ... of` 的简单例子\n\n```typescript\nlet someArray = [1, \"string\", false];\n\nfor (let entry of someArray) {\n  console.log(entry); // 1, \"string\", false\n}\n```\n\n### 14.2 for ... of Vs for ... in 语句\n\n> `for ... of` 和 `for ... in` 均可迭代一个列表；但是用于迭代的值却不同，`for ... in` 迭代的是对象的 `键` 的列表，而 `for ... of` 则迭代对象的键对应的值。\n\n- 下面的例子展示了两者之间的区别：\n\n```typescript\nlet list = [4, 5, 6];\nfor (let i in list) {\n  console.log(i); // \"0\" \"1\" \"2\"\n}\nfor (let i of list) {\n  console.log(i); // \"4\" \"5\" \"6\"\n}\n```\n\n> 另一个区别是 `for ... in` 可以操作任何对象；它提供了查看对象属性的一种方法。但是 `for ... of` 关注于迭代对象的值。内置对象 `Map` 和 `Set` 已经实现了 `Symbol.iterator` 方法，让我们可以访问它们保存的值。\n\n```typescript\nlet pets = new Set([\"Cat\", \"Dog\", \"Hamster\"]);\npets[\"species\"] = \"mammals\";\nfor (let pet in pets) {\n  console.log(pet);\n}\nfor (let pet of pets) {\n  console.log(pet); // \"Cat\", \"Dog\", \"Hamster\"\n}\n```\n\n### 14.3 代码生成目标为 `ES5` 和 `ES3`\n\n> 当生成目标为 `ES5` 或 `ES3`，迭代器只允许在 `Array` 类型上使用。在非数组值上使用 `for ... of` 语句会得到一个错误，就算这些非数组值已经实现了 `Symbol.iterator` 属性。\n\n> 编译器会生成一个简单的 `for` 循环做为 `for ... of` 循环，比如：\n\n```typescript\nlet numbers = [1, 2, 3];\nfor (let num of numbers) {\n  console.log(num);\n}\n// 生成的代码为：\nvar number = [1, 2, 3];\nfor (var _i = 0; _i < numbers.length; _i++) {\n  var num = numbers[_i];\n  console.log(num);\n}\n```\n\n### 14.4 目标为 `ECMAScript 2015` 或更高\n\n> 当目标为兼容 `ECMAScript 2015` 的引擎时，编译器会生成相应引擎的 `for ... of` 内置迭代器实现方式。\n\n## 十五、模块\n\n### 15.1 关于术语的一点说明\n\n> 请务必注意一点：`TypeScript 1.5` 里术语名已经发生了变化。\"`内部模块`\" 现在被称作 \"`命名空间`\"。\"`外部模块`\" 现在则简称为 \"`模块`\"。这是为了与 `ECMAScript 2015` 里的术语保持已一致， (也就是说 `module X` { 相当于现在推荐的写法 `namespace X` })\n\n### 15.2 介绍\n\n1. 从 `ECMAScript 2015` 开始，`JavaScript` 引入了模块的概念。`TypeScript` 也沿用这个概念。\n2. 模块在其自身的作用域里执行，而不是在全局作用域；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用 `export` 形式之一导出它们。相反，如果想使用其它模块导出的 `变量`，`函数`，`类`，`接口` 等的时候，你必须要导入它们，可以使用 `import` 形式之一。\n3. 模块是自声明的；两个模块之间的关系是通过在文件级别上使用 `import` 和 `exports` 建立的。\n4. 模块使用模块加载器去导入其它的模块。在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。大家最熟知的 `JavaScript` 模块加载器是服务与 `Node.js` 的 `CommonJS` 和 服务于 `Web` 应用的 `Require.js`。\n5. `TypeScript` 和 `ECMAScript 2015` 一样，任何包含顶级 `import` 或者 `export` 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 `import` 或者 `export` 声明，那么它的内容将被视为全局可见的 (因此对模块也是可见的)。\n\n### 15.3 导出\n\n#### 15.3.1. 导出声明\n\n> 任何声明( 比如 `变量`，`函数`，`类`，`类型别名` 或 `接口` )都能够通过添加 `export` 关键字来导出。\n\n```typescript\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\nexport const numberRegexp = /^[0-9]+$/;\nexport class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n```\n\n#### 15.3.2 导出语句\n\n> 导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：\n\n```typescript\nclass ZipCodeValidator1 implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\nexport { ZipCodeValidator1 };\nexport { ZipCodeValidator1 as mainValidator };\n```\n\n#### 15.3.3 重新导出\n\n> 我们经常会去扩展其它模块，并且只导出那个模块的那部分内容。\n\n> 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。\n\n```typescript\nexport class ParseIntBasedZipCodeValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && parseInt();\n  }\n}\n// 导出原先的验证器但做了重命名\nexport { ZipCodeValidator as RegExpBasedZipCodeValidator } from \"./ZipCodeValidator\";\n```\n\n> 或者一个模块可以包裹多个模块，并把它们导出的内容联合在一起，通过语法：`export * from \"module\"`\n\n```typescript\nexport * from \"./StringValidator\";\nexport * from \"./LetterOnlyValidator\";\nexport * from \"./ZipCodeValidator\";\n```\n\n### 15.4 导入\n\n> 模块的导入操作与导出一样简单，可以使用以下 `import` 形式之一来导入其它模块中的导出内容。\n\n#### 15.4.1 导入一个模块中的某个导出内容\n\n```typescript\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nlet myValidator = new ZipCodeValidator();\n```\n\n> 可以对导入内容重命名\n\n```typescript\nimport { ZipCodeValidator as ZCV } from \"./ZipCodeValidator\";\nlet myValidator = new ZCV();\n```\n\n#### 15.4.2 将整个模块导入到一个变量，并通过它来访问模块的导出部分\n\n```typescript\nimport * as validator from \"./ZipCodeValidator\";\nlet myValidator = new validator.ZipCodeValidator();\n```\n\n#### 15.4.3 具有副作用的导入模块\n\n> 尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。这些模块可能没有任何的导出或用户根本\n\n> 就不关注它的导出。使用下面的方法来导入这些模块。\n\n```typescript\nimport \"./my-module.js\";\n```\n\n### 15.5 默认导出\n\n> 每个模块都可以有一个 `default` 导出。默认导出使用 `default` 关键字标记；并且一个模块只能够有一个 `default` 导出。需要使用 一种特殊的导入形式来导入 `default` 导出。\n\n> `default` 导出十分便利。比如，像 `JQuery` 这样的类库可能有一个默认导出 `jQuery` 或 `$`，并且我们基本上也会使用同样的名字 `jQuery` 或 `$` 导出 `JQuery`。\n\n- `JQuery.d.ts`\n\n```typescript\ndeclare let $: JQuery;\nexport default $;\n```\n\n- `App.ts`\n\n```typescript\nimport $ from \"JQuery\";\n$(\"button.continue\").html(\"Next step ...\");\n```\n\n> 类和函数声明可以直接被标记为默认导出。标记为默认导出的类和函数的名字是可以省略的。\n\n- `ZipCodeValidator.ts`\n\n```typescript\nexport default class ZipCodeValidator {\n  static numberRegExp = /^[0-9]+$/;\n  isAcceptable(s: string) {\n    return s.length === 5 && ZipCodeValidator.numberRegExp.test(s);\n  }\n}\n```\n\n- `Test.ts`\n\n```typescript\nimport validator from \"./ZipCodeValidator\";\nlet myValidator = new validator();\n```\n\n> `或者`\n\n- `StaticZipCodeValidator.ts`\n\n```typescript\nconst numberRegExp = /^[0-9]+$/;\nexport default function (s: string) {\n  return s.length === 5 && numberRegExp.test(s);\n}\n```\n\n- `Test.ts`\n\n```typescript\nimport validate from \"./StaticZipCodeValidator\";\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// use function validate\nstrings.forEach(s => {\n  console.log(`\"${s}\" ${validate(s)} ? \" matches\" : \" does not match\"`);\n});\n```\n\n> `default` 导出也可以是一个值\n\n- `OneTwoThree.ts`\n\n```typescript\nexport default \"123\";\n```\n\n- `Log.ts`\n\n```typescript\nimport num from \"./OneTwoThree\";\nconsole.log(num); // 123\n```\n\n> `export =` 和 `import = require()`\n\n1. `CommonJS` 和 `AMD` 的环境里都有一个 `exports` 变量，这个变量包含了一个模块的所有导出内容。\n2. `CommonJS` 和 `AMD` 的 `exports` 都可以被赋值为一个对象，这种情况下其作用就类似于 es6 语法里的默认导出，即 `export default` 语法了。虽然作用相似，但是 `export default` 语法并不能兼容 `CommonJS` 和 `AMD` 的 `exports`。\n3. 为了支持 `CommonJS` 和 `AMD` 的 `exports`，`TypeScript` 提供了 `export =` 语法。\n4. `export =` 语法定义一个模块的导出对象。这里的对象一词指的是类，接口，命名空间，函数或枚举。\n5. 若使用 `export =` 导出一个模块，则必须使用 `TypeScript` 的特定语法 `import module = require('module')` 来导入此模块。\n\n- `ZipCodeValidator.ts`\n\n```typescript\nlet numberRegExp = /^[0-9]+$/;\n\nclass ZipCodeValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegExp.test(s);\n  }\n}\n\nexport = ZipCodeValidator; // 重点\n```\n\n- `Test.ts`\n\n```typescript\nimport zip = require(\"./ZipCodeValidator\"); // 重点\n\nlet strings = [\"Hello\", \"98502\", \"101\"];\nlet validator = new zip();\nstrings.forEach(s => {\n  console.log(`\"${s}\" - ${validator.isAcceptable(s) ? \"matches\" : \"does not match\"}`);\n});\n```\n\n### 15.6 生成模块代码\n\n> 根据编译时指定的模块目标参数，编译器会生成相应的供 `Node.js\\(CommonJS\\)，Require.js\\(AMD\\)`，`UMD`，`SystemJS` 或 `ECMAScript 2015 native module\\(ES6\\)` 模块加载系统使用的代码。\n\n> 想要了解生成代码中 `define`，`require` 和 `register` 的意义，需要参考相应的模块加载器的文档。\n\n- `SimpleModule.ts`\n\n```typescript\nimport m = require(\"mod\");\nexport let t = m.something + 1;\n```\n\n- `AMD / RequireJS SimpleModule.js`\n\n```typescript\ndefine([\"require\", \"exports\", \"./mod\"], function (require, exports, mod_1) {\n  exports.t = mod_1.something + 1;\n});\n```\n\n- `CommonJS / Node SimpleModule.js`\n\n```typescript\nimport mod_1 = require(\"./mod\");\nexports.t = mod_1.something + 1;\n```\n\n- `UMD SimpleModule.js`\n\n```typescript\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    let v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define([\"require\", \"exports\", \"./mod\"], factory);\n  }\n})(function (require, exports) {\n  let mod_1 = require(\"./mod\");\n  exports.t = mod_1.something + 1;\n});\n```\n\n- `System SimpleModule.js`\n\n```typescript\nSystem.register([\"./mod\"], function (exports_1) {\n  let mod_1;\n  let t;\n  return {\n    setters: [\n      function (mod_1_1) {\n        mod_1 = mod_1_1;\n      }\n    ],\n    execute: function () {\n      exports_1(\"t\", (t = mod_1.something + 1));\n    }\n  };\n});\n```\n\n- `Native ECMAScript 2015 modules SimpleModule.js`\n\n```typescript\nimport { something } from \"./mod\";\nexport let t = something + 1;\n```\n\n### 15.7 简单示例\n\n> 下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。\n\n> 为了编译，我们必须要在命令行上指定一个模块目标。对于 `Node.js` 来说，使用 `--module commonjs`；对于 `Require.js` 来说，使用 `--module amd`。\n\n- 比如：\n\n```typescript\ntsc --module commonjs Test.ts\n```\n\n> 编译完成后，每个模块会生成一个单独的 `.js` 文件。好比使用了 `reference` 标签，编译器会根据 `import` 语句编译相应的文件。\n\n- `Validation.ts`\n\n```typescript\nexport interface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n```\n\n- `LetterOnlyValidator.ts`\n\n```typescript\nimport { StringValidator } from \"./Validation\";\nconst lettersRegExp = /^[A-Za-z]+$/;\n\nexport class LetterOnlyValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return lettersRegExp.test(s);\n  }\n}\n```\n\n- `ZipCodeValidator.ts`\n\n```typescript\nimport { StringValidator } from \"./Validation\";\nconst numberRegExp = /^[0-9]+$/;\n\nexport class ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return s.length === 5 && numberRegExp.test(s);\n  }\n}\n```\n\n- `Test.ts`\n\n```typescript\nimport { StringValidator } from \"./Validation\";\nimport { ZipCodeValidator } from \"./ZipCodeValidator\";\nimport { LetterOnlyValidator } from \"./LetterOnlyValidator\";\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LetterOnlyValidator();\n\n// Show whether each string passed each validator\nstrings.forEach(s => {\n  for (let name in validators) {\n    console.log(`\"${s}\" - ${validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"} ${name}`);\n  }\n});\n```\n\n### 15.8 可选的模块加载和其它高级加载场景\n\n1. 有时候，你只想在某种条件下才加载某个模块。在 `TypeScript` 里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且保证类型完全。\n2. 编译器会检测是否每个模块都会在生成的 `JavaScript` 中用到。如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 `require` 这个模块的代码。省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。\n3. 这种模式的核心是 `import id = require(\"...\")` 语句可以让我们访问模块导出的类型。模块加载器会被动态调用(通过 `require`)，就像下面的 `if` 代码块里那样。它利用了省略引用的优化，所以模块只在被需要时加载。为了让这个模块工作，一定要注意 `import` 定义的标识符只能在表示类型处使用(不能在会转换成 `JavaScript` 的地方。)\n4. 为了确保类型安全性，我们可以使用 `typeof` 关键字。`typeof` 关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。\n\n- `示例 1`. `Node.js` 里的动态模块加载\n\n```typescript\ndeclare function require(moduleName: string): any;\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\nif (needZipValidator) {\n  let ZipCodeValidator: typeof Zip = require(\"./ZipCodeValidator\");\n  let validator = new ZipCodeValidator();\n  if (validator.isAcceptable(\"...\")) {\n    /!* ... *!/;\n  }\n}\n```\n\n- `示例 2`. `require.js` 里的动态模块加载\n\n```typescript\ndeclare function require(moduleNames: string[], onLoad: (...args: any[]) => void): void;\nimport * as Zip from \"./ZipCodeValidator\";\nif (needZipValidator) {\n  require([\"./ZipCodeValidator\"], (ZipCodeValidator: typeof Zip) => {\n    let validator = new ZipCodeValidator.ZipCodeValidator();\n    if (validator.isAcceptable(\"...\")) {\n      /!* ... *!/;\n    }\n  });\n}\n```\n\n- `示例 3`. `System.js` 里的动态模块加载\n\n```typescript\ndeclare const System: any;\nimport { ZipCodeValidator as Zip } from \"./ZipCodeValidator\";\nif (needZipValidator) {\n  System.import(\"./ZipCodeValidator\").then((ZipCodeValidator: typeof Zip) => {\n    var x = new ZipCodeValidator();\n    if (x.isAcceptable(\"...\")) {\n      /!*...*!/;\n    }\n  });\n}\n```\n\n### 15.9 使用其它的 JavaScript 库\n\n> 要想描述非 `TypeScript` 编写的类库的类型，我们需要声明类库所暴露的 `API`。\n\n> 我们叫它声明因为它不是'外部程序'的具体实现，它们通常是在 `.d.ts` 文件里定义的。类似于 `C/C++` 里的 `.h` 文件。\n\n#### 15.9.1 外部模块\n\n> 在 `Node.js` 里大部分工作是通过加载一个或多个模块实现的。我们可以使用顶级的 `export` 声明来为每个模块都定义一个 `.d.ts` 文件，但最好还是写在一个大的 `.d.ts` 文件里。我们使用与构造一个外部命名空间相似的方法，但是这里使用 `module` 关键字并且把名字用引号括起来，方便之后 `import`。\n\n- `例如：`\n- `node.d.ts(simplified except)`\n\n```typescript\ndeclare module \"url\" {\n  export interface Url {\n    protocol?: string;\n    hostname?: string;\n    pathname?: string;\n  }\n\n  export function parse(urlStr: string, parseQueryString?, slashesDenoteHost?): Url;\n}\n\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export let sep: string;\n}\n```\n\n> 现在我们可以 `/// <reference> node.d.ts` 并且使用 `import url = require('url')`；或 `import * as URl from \"url\"` 加载模块。`\n\n```typescript\n/// <reference path=\"node.d.ts\">\nimport * as URL from \"url\";\n\nlet myUrl = URL.parse(\"http://www.typescriptlang.org\");\n```\n\n#### 15.9.2 外部模块简写\n\n> 假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。\n\n> `declarations.d.ts`\n\n```typescript\ndeclare module \"hot-new-module\";\n```\n\n- 简写模块里所有导出类型将是 `any`\n\n```typescript\nimport x, { y } from \"hot-new-module\";\nx(y);\n```\n\n#### 15.9.3 模块声明通配符\n\n> 某些模块加载器如 `SystemJS` 和 `AMD` 支持导入非 `JavaScript` 内容。它们通常会使用一个前缀或后缀来表示特殊的加载语法，模块声明通配符可以用来表示这些情况。\n\n```typescript\ndeclare module \"*!text\" {\n  const content: string;\n  export default content;\n}\n```\n\n- `some do it the other way around`\n\n```typescript\ndeclare module \"json!*\" {\n  const value: any;\n  export default value;\n}\n```\n\n- 现在你可以就导入匹配 `\"!text\"` 或 `\"json!\"` 的内容了。\n\n```typescript\nimport fileContent from \"./xyz.txt!txt\";\nimport data from \"json!http://example.com/data.json\";\nconsole.log(data, fileContent);\n```\n\n#### 15.9.4 `UMD` 模块\n\n> 有些模块被设计成兼容多个模块加载器，或者不使用模块加载器(全局变量)。它们以 `UMD` 模块为代表。这些库可以通过导入的形式或全局变量的形式访问。\n\n- `例如：`\n- `math-lib.d.ts`\n\n```typescript\nexport function isPrime(x: number): boolean;\nexport as namespace mathLib;\n```\n\n- 之后，这个库可以在某个模块里通过导入来使用:\n\n```typescript\nimport { isPrime } from \"math-lib\";\nisPrime(2);\nmathLib.isPrime(2);\n```\n\n- 它同样可以通过全局变量的形式使用，但只能在某个脚本(指不带有模块导入或导出的脚本文件)里。\n\n```typescript\nmathLib.isPrime(2);\n```\n\n### 15.10 创建模块结构指导\n\n#### 15.10.1 尽可能地在顶层导出\n\n1. 用户应该更容易地使用你模块导出的内容。嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。\n2. 从你的模块中导出一个命名空间就是一个增加嵌套的例子。虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。这对用户来说是很不方便的并且通常是多余的。\n3. 导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。除非它能方便地表述或便于清晰使用，否则请考虑直接导出一个辅助方法。\n\n#### 15.10.2 如果仅导出单个 `class` 或 `function`，使用 `export default`\n\n> 就像\" `在顶层导出` \"帮助减少用户使用的难度，一个默认的导出也能起到这个效果。如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。这会令模块的导入和使用变得些许简单，比如：\n\n- `MyClass.ts`\n\n```typescript\nexport default class SomeType {\n  constructor() {\n    /!* ... *!/;\n  }\n}\n```\n\n- `MyFunc.ts`\n\n```typescript\nexport default function getThing() {\n  return \"thing\";\n}\n```\n\n- `Consumer.ts`\n\n```typescript\nimport t from \"./MyClass\";\nimport f from \"./MyFunc\";\nlet x = new t();\nconsole.log(f());\n```\n\n> 对用户来说这是最理想的。他们可以随意命名导入模块的类型 (本例为 `t` ) 并且不需要多余的 ( `.` ) 来找到相关对象。\n\n#### 15.10.3 如果要导出多个对象，把它们放在顶层里导出\n\n- `MyThings.ts`\n\n```typescript\nexport class SomeType {/!*...*!/}\nexport function someFunc() {\n    /*...*/\n}\n```\n\n#### 15.10.4 (相反地，当导入的时候)明确地列出导入的名字。\n\n- `Consumer.ts`\n\n```typescript\nimport { SomeType, someFunc } from \"./MyThings\";\nlet x = new SomeType();\nlet y = someFunc();\n```\n\n#### 15.10.5 使用命名空间导入模式当你要导出大量内容的时候\n\n- `MyLargeModule.ts`\n\n```typescript\nexport class Dog {}\nexport class Cat {}\nexport class Tree {}\nexport class Flower {}\n```\n\n- `Consumer.ts`\n\n```typescript\nimport * as myLargeModule from \"./MyLargeModule.ts\";\nlet x = new myLargeModule.Dog();\n```\n\n#### 15.10.6 使用重新导出进行扩展\n\n> 你可能经常需要扩展一个模块的功能。`JS` 里常用的一个模式是 `JQuery` 那样去扩展原对象。如我们之前提到的，模块不会像全局命名空间那样去合并。推荐的方案是 不要去改变原来的对象，而是导出一个新的实体来提供新的功能。\n\n> 假设 `Calculator.ts` 模块里定义了一个简单的计算器实现。这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。\n\n- `Calculator.ts`\n\n```typescript\nexport class Calculator {\n  private current = 0;\n  private memory = 0;\n  private operator: string;\n\n  protected static processDigit(digit: string, currentValue: number) {\n    if (digit >= \"0\" && digit <= \"9\") {\n      return currentValue * 10 + (digit.charCodeAt(0) - \"0\".charCodeAt(0));\n    }\n  }\n\n  protected static processOperator(operator: string) {\n    if ([\"+\", \"-\", \"*\", \"/\"].indexOf(operator) >= 0) {\n      return operator;\n    }\n  }\n\n  protected evaluateOperator(operator: string, left: number, right: number): number {\n    switch (this.operator) {\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n    }\n  }\n\n  private evaluate() {\n    if (this.operator) {\n      this.memory = this.evaluateOperator(this.operator, this.memory, this.current);\n    } else {\n      this.memory = this.current;\n    }\n    this.current = 0;\n  }\n\n  public handleChar(char: string) {\n    if (char === \"=\") {\n      this.evaluate();\n      return;\n    } else {\n      let value = Calculator.processDigit(char, this.current);\n      if (value !== undefined) {\n        this.current = value;\n        return;\n      } else {\n        let value = Calculator.processOperator(char);\n        if (value !== undefined) {\n          this.evaluate();\n          this.operator = value;\n          return;\n        }\n      }\n    }\n    throw new Error(`Unsupported input: '${char}'`);\n  }\n\n  public getResult() {\n    return this.memory;\n  }\n}\n\nexport function test(c: Calculator, input: string) {\n  for (let i = 0; i < input.length; i++) {\n    c.handleChar(input[i]);\n  }\n  console.log(`result of '${input}' is '${c.getResult()}'`);\n}\n```\n\n- 下面使用导出的 `test` 函数来测试计算器\n- `TestCalculator.ts`\n\n```typescript\nimport { Calculator, test } from \"./Calculator\";\nlet c = new Calculator();\ntest(c, \"1+2*33/11=\"); // prints 9\n```\n\n- 现在扩展它，添加支持输入其它进制(十进制以外)。\n- `ProgrammerCalculator.ts`\n\n```typescript\nimport { Calculator } from \"./Calculator\";\nclass ProgrammerCalculator extends Calculator {\n  static digits = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\"];\n  constructor(public base: number) {\n    super();\n    const maxBase = ProgrammerCalculator.digits.length;\n    if (base <= 0 || base > maxBase) {\n      throw new Error(`base has to be within 0 to ${maxBase} inclusive`);\n    }\n  }\n  protected processDigit(digit: string, currentValue: number) {\n    if (ProgrammerCalculator.digits.indexOf(digit) >= 0) {\n      return currentValue * this.base + ProgrammerCalculator.digits.indexOf(digit);\n    }\n  }\n}\nexport { ProgrammerCalculator as Calculator };\nexport { test } from \"./Calculator\";\n```\n\n> 新的 `ProgrammerCalculator` 模块导出的 API 与原先的 `Calculator` 模块很相似，但却没有改变原模块里的对象。\n\n- `TestProgrammerCalculator.ts`\n\n```typescript\nimport { Calculator, test } from \"./ProgrammerCalculator\";\nlet c = new Calculator(2);\ntest(c, \"001+010=\"); // prints 3\n```\n\n#### 15.10.7 模块里不要使用命名空间\n\n> 当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。记住这点，命名空间在使用模块时几乎没什么价值。\n\n> 在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型分组是很便利的。例如，在 `C\\#` 里，你会从 `System.Collections` 里找到所有集合的类型。通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。然而，模块本身已经存在于文件系统之中，这是必须的。我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。我们可以创建 `/collections/generic/` 文件夹，把相应模块放在这里。\n\n> 命名空间对解决全局作用域里命名冲突来说是很重要的。比如，你有一个 `My.Application.Customer.AddFrom` 和 `My.Application.Order.AddForm` `--` 两个类型的名字相同，但命名空间不同。然而，这对于模块来说却不是一个问题。在一个模块里，没有理由两个对象拥有同一个名字。从模块的使用角度来说，使用者会挑出它们用来引用模块的名字，所以也没有理由发声重名的情况。\n\n#### 15.10.8 危险信号\n\n> 以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间。\n\n1. 文件的顶层声明是 `export namespace Foo {...}` ( 删除 `Foo` 并把所有内容向上层移动一层)\n2. 文件只有一个 `export class` 或 `export function` (考虑使用 `export default`)\n3. 多个文件的顶层具有同样的 `export namespace Foo` {( 不要以为这些会合并到一个 `Foo` 中! )}\n\n## 十六、命名空间\n\n### 16.1 介绍\n\n> 这篇文章描述了如何在 `TypeScript` 里使用命名空间(之前叫做\"内部模块\")来组织你的代码。就像我们在术语说明里提到的那样，`\"内部模块\"` 现在叫做 `\"命名空间\"`。另外，任何使用 `module` 关键字来声明一个内部模块的地方都应该使用 `namespace` 关键字来替换。这就避免了让新的使用者被相似的名称所迷惑。\n\n- `第一步`\n\n> 我们先来写一段程序并将在整篇文章中都使用这个例子。我们定义几个简单的字符串验证器，\n\n> 假设你会使用它们来验证表单里的用户输入或验证外部数据。\n\n- `所有验证器都放在一个文件里`\n\n```typescript\ninterface StringValidator {\n  isAcceptable(s: string): boolean;\n}\n\nlet letterRegExp = /^[A-Za-z]$/;\nlet numberRegExp = /^[0-9]+$/;\n\nclass LetterOnlyValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return letterRegExp.test(s);\n  }\n}\n\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string): boolean {\n    return s.length === 5 && numberRegExp.test(s);\n  }\n}\n\nlet strings = [\"Hello\", \"98052\", \"101\"];\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters Only\"] = new LetterOnlyValidator();\n// show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    let isMatch = validators[name].isAcceptable(s);\n    console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\n```\n\n### 16.2 命名空间\n\n> 随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。因此，我们把验证器包裹到一个命名空间里内，而不是把它们放在全局空间下。\n\n> 下面的例子里，把所有与验证器相关的类型都放到一个叫做 `Validation` 的命名空间里。因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 `export`。相反的，变量 `LetterRegExp` 和 `numberRegExp` 是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。在文件末尾的测试代码里，由于是在命名空间之外访问的，因此需要限定类型的名称，比如 `Validation.LettersOnlyValidator`。\n\n- 使用命名空间的验证器\n\n```typescript\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n\n  const LetterRegExp = /^[A-Za-z]+$/;\n  const numberRegExp = /^[0-9]+$/;\n\n  export class LetterOnlyValidator implements StringValidator {\n    isAcceptable(s: string): boolean {\n      return LetterRegExp.test(s);\n    }\n  }\n\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string): boolean {\n      return s.length === 5 && numberRegExp.test(s);\n    }\n  }\n}\nlet strings = [\"Hello\", \"98052\", \"101\"];\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP Code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters Only\"] = new Validation.LetterOnlyValidator();\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(`'${s}' ${validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\n```\n\n### 16.3 分离到多文件\n\n> 当应用变得越来越大时，我们需要将代码分离到不同的文件中以方便维护。\n\n#### 16.3.1 多文件中的命名空间\n\n> 现在，我们把 `Validation` 命名空间分割成多个文件。尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。\n\n- `Validation.ts`\n\n```typescript\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\n```\n\n- `LetterOnlyValidator.ts`\n\n```typescript\n/// <reference path=\"Validation.ts\" />;\nnamespace Validation {\n  const lettersRegExp = /^[A-Za-z]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string): boolean {\n      return lettersRegExp.test(s);\n    }\n  }\n}\n```\n\n- `ZipCodeValidator.ts`\n\n```typescript\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const numberRegExp = /^[0-9]+$/;\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string): boolean {\n      return s.length === 5 && numberRegExp.test(s);\n    }\n  }\n}\n```\n\n- `Test.ts`\n\n```typescript\n/// <reference path=\"Validation.ts\" />\n/// <reference path=\"LettersOnlyValidator.ts\" />\n/// <reference path=\"ZipCodeValidator.ts\" />\n\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(`\"${s}\" - ${validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"} ${name}`);\n  }\n}\n```\n\n> 当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。我们有两种方式。\n\n1. 第一种方式，把所有的输入文件编译为一个输出文件，需要使用 `--outFile` 标记： `tsc --outFile sample.js Test.ts` 编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。 `tsc --outFile sample.js Validation.ts LetterOnlyValidator.ts ZipCodeValidator.ts Test.ts`\n2. 第二种方式，我们可以编写每一个文件(默认方式)，那么每个源文件都会对应生成一个 `JavaScript` 文件。然后，在页面上通过 `<script>` 标签把所有生成的 `JavaScript` 文件按正确的顺序引进来，比如：\n\n```html\nMyTestPage.html (excerpt)\n<script src=\"Validation.js\" type=\"text/javascript\" />\n<script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n<script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n<script src=\"Test.js\" type=\"text/javascript\" />\n```\n\n### 16.4 别名\n\n> 另一种简化命名空间操作的方法是用 `import q = x.y.z` 给常用的对象起一个短的名字。不要与用来加载模块的 `import x = require('name')` 语法弄混了，这里的语法是为指定的符号创建一个别名。你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。\n\n```typescript\nnamespace Shapes {\n  export namespace Polygons {\n    export class Triangle {}\n    export class Square {}\n  }\n}\nimport Polygons = Shapes.Polygons;\nlet sq = new Polygons.Square(); // Same as \"new Shapes.Polygons.Square()\"\n```\n\n> 注意：我们并没有使用 `require` 关键字，而是直接使用导入符号的限定名赋值。这与使用 `var` 相似，但它还适用于类型和导入的具有命名空间含义的符号。重要的是，对于值来讲，`import` 会生成与原始符号不同的引用，所以改变别名的 `var` 值并不会影响原始变量的值。\n\n### 16.5 使用其它的 JavaScript 库\n\n> 为了描述不是用 `TypeScript` 编写的类库的类型，我们需要声明类库导出的 `API`。由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。我们称其为声明是因为它不是外部程序的具体实现。我们通常在 `.d.ts` 里写这些声明。如果你熟悉 `C/C+`+，你可以把它们当作 `.h` 文件。\n\n> 外部命名空间 (`declare namespace =>`; 声明全局对象)\n\n> 流行的程序库 `D3` 在全局对象 `d3` 里定义它的功能。因为这个库通过一个`<script>` 标签加载 (不是通过模块加载器)，它的声明文件使用内部模块来定义它的类型。为了让 `TypeScript` 编译器识别它的类型，我们使用外部命名空间声明。\n\n- 比如，我们可以像下面这样写\n- `D3.d.ts`\n\n```typescript\ndeclare namespace D3 {\n  export interface Selectors {\n    select: {\n      (selector: string): Selection;\n      (element: EventTarget): Selection;\n    };\n  }\n\n  export interface Event {\n    x: number;\n    y: number;\n  }\n\n  export interface Base extends Selectors {\n    event: Event;\n  }\n}\ndeclare var d3: D3.Base;\n```\n\n## 十七、命名空间和模块\n\n### 17.1 介绍\n\n> 这篇文章将概括介绍在 `TypeScript` 里使用模块与命名空间来组织代码的方法。我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。\n\n### 17.2 使用命名空间\n\n> 命名空间是位于全局命名空间下的一个普通的带有名字的 `JavaScript` 对象。这令命名空间十分容易使用。它们可以在多文件中同时使用，并通过 `--outFile` 结合在一起。命名空间是帮你组织 `Web` 应用不错的方式，你可以把所有依赖都放在 `HTML` 页面的 `<script>` 标签里。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型应用中。\n\n### 17.3 使用模块\n\n1. 像命名空间一样，模块可以包含代码和声明。不同的模块可以声明它的依赖。\n2. 模块会把依赖添加到模块加载器上(像是 `CommonJS` / `RequireJS`)。对于小型的 JS 应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。\n3. 对于 `Node.js` 应用来说，模块是默认并推荐的组织代码的方式。\n4. 从 `ECMAScript 2015` 开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。\n\n> 因此，对于新项目来说推荐使用模块作为组织代码的方式。\n\n### 17.4 命名空间和模块的陷阱\n\n> 这部分我们会描述常见的命名空间和模块的使用陷阱和如何其避免它们。\n\n#### 17.4.1 对模块使用 `/// <reference>`\n\n> 一个常见的错误是使用 `/// <reference>` 引用模块文件，应该使用 `import`。要理解这之间的差别，我们首先应该弄清编译器是如何根据 `import` 路径(例如：`import x from \"...\"`；或 `import x = require(\"...\")` 里面的 `...`，等等)来定位模块的类型信息的。\n\n> 编译器首先尝试去查找相应路径下的 `.ts`，`.tsx` 再或者 `.d.ts`。如果这些文件都找不到，编译器会查找外部模块声明。回想一下，它们是在 `.d.ts` 文件里声明的。\n\n- `myModules.d.ts`\n\n```typescript\n// In a .d.ts file or .ts file that is not a module\ndeclare module \"SomeModule\" {\n  export function fn(): string;\n}\n```\n\n- `myOtherModule.ts`\n\n```typescript\n/// <reference path=\"myModules.d.ts\">\nimport * as m from \"SomeModule\";\n```\n\n> 这里的引用标签指定了外来模块的位置。这就是一些 `TypeScript` 例子中引用 `node.d.ts` 的方法。\n\n#### 17.4.2 不必要的命名空间\n\n> 如果你想把命名空间转换为模块，它可能会像下面这个文件一样。\n\n- `shapes.ts`\n\n```typescript\nexport namespace Shapes {\n  export class Triangle {\n    /* ... */\n  }\n  export class Square {\n    /* ... */\n  }\n}\n```\n\n> 顶层的模块 `Shapes` 包裹了 `Triangle` 和 `Square`。对于使用它的人来说这是令人迷惑和讨厌的。\n\n- `shapeConsumer.ts`\n\n```typescript\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n```\n\n> `TypeScript` 里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。再次重申，不应该对模块使用命名空间。使用命名空间是为了提供逻辑分组和避免命名冲突。模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。\n\n- 下面是改进的例子：\n- `shape.ts`\n\n```typescript\nexport class Triangle {\n  /* ... */\n}\nexport class Square {\n  /* ... */\n}\n```\n\n- `shapeConsumer.ts`\n\n```typescript\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Triangle();\n```\n\n#### 17.4.3 模块的取舍\n\n> 就像每个 `JS` 文件对应一个模块一样，`TypeScript` 里模块文件与生成的 `JS` 文件也是一一对应的。这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。例如当目标模块系统为 `commonjs` 或 `umd` 时，无法使用 `outFile` 选项，但是 `TypeScript 1.8` 以上的版本能够使用 `outFile` 当目标为 `amd` 或 `system`。\n\n## 十八、模块解析\n\n### 18.1 说明\n\n1. 模块解析是指编译器在查找导入模块内容时所遵循的流程。假设有一个导入语句 `import { a } from \"moduleA\"`; 为了去检查任何对 `a` 的使用，编译器需要准确的知道它表示什么，并且需要检查它的定义 `moduleA`。\n2. 这时候，编译器会有个疑问“ `moduleA` 的结构是怎样的？” 这听上去很简单，但 moduleA 可能在你写的某个 .ts/.tsx 文件里或者在你的代码所依赖的 `.d.ts` 里。\n3. 首先，编译器会尝试定位表示导入模块的文件。编译器会遵循以下二种策略之一： `Classic` 或 `Node`。这些策略会告诉编译器到哪里去查找 `moduleA`。\n4. 如果上面的解析失败了并且模块名是非相对的（且是在\" `moduleA` \"的情况下），编译器会尝试定位一个外部模块声明。我们接下来会讲到非相对导入。\n\n`5`. 最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为 `error TS2307: Cannot find module 'moduleA'.`\n\n### 18.2 相对 vs. 非相对模块导入\n\n> 根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。\n\n1. 相对导入是以 `/，./` 或 `../` 开头的。 下面是一些例子：\n\n```typescript\nimport Entry from \"./components/Entry\";\nimport { Default } from \"../constants/http\";\nimport \"/mod\";\n```\n\n2. 所有其它形式的导入被当作非相对的。下面是一些例子：\n\n```typescript\nimport * as $ from \"JQuery\";\nimport { Component } from \"@angular/core\";\n```\n\n> 相对导入在解析时是相对于导入它的文件，并不能解析为一个外部模块声明。你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。\n\n> 非相对模块的导入可以相对于 baseUrl 或 通过下文会讲到的路径映射来解析。它们还可以被解析成 外部模块声明。\n\n> 使用非相对路径来导入你的外部依赖。\n\n### 18.3 模块解析策略\n\n> 共有两种可用的模块解析策略：`Node` 和 `Classic`。 你可以使用 `--moduleResolution` 标记来指定使用哪种模块解析策略。若未指定，那么在使用了 -`-module AMD \\| System \\| ES2015` 时的默认值为 `Classic`，其它情况时则为 `Node`。\n\n#### 18.3.1 Classic\n\n> 这种策略在以前是 `TypeScript` 默认的解析策略。 现在，它存在的理由主要是为了向后兼容。\n\n> 相对导入的模块是相对于导入它的文件进行解析的。 因此 `/root/src/folder/A.ts` 文件里的 `import { b } from \"./moduleB\"` 会使用下面的查找流程：\n\n1. /root/src/folder/moduleB.ts``\n2. /root/src/folder/moduleB.d.ts``\n\n> 对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。\n\n- `比如：`\n\n> 有一个对 `moduleB` 的非相对导入 `import { b } from \"moduleB\"`，它是在 `/root/src/folder/A.ts` 文件里，会以如下的方式来定位\"`moduleB`\"：\n\n> 1. `/root/src/folder/moduleB.ts`\n> 2. `/root/src/folder/moduleB.d.ts`\n> 3. `/root/src/moduleB.ts`\n> 4. `/root/src/moduleB.d.ts`\n> 5. `/root/moduleB.ts`\n> 6. `/root/moduleB.d.ts`\n> 7. `/moduleB.ts`\n> 8. `/moduleB.d.ts`\n\n#### 18.3.2 Node\n\n> 这个解析策略试图在运行时模仿 `Node.js` 模块解析机制。完整的 `Node.js` 解析算法可以在 `Node.js module documentation` 找到。\n\n- Node.js 如何解析模块\n\n> 为了理解 `TypeScript` 编译依照的解析步骤，先弄明白`Node.js`模块是非常重要的。\n\n> 通常，在 `Node.js` 里导入是通过 `require` 函数调用进行的。 `Node.js` 会根据 `require` 是相对路径还是非相对路径做出不同的行为。\n\n> 相对路径很简单。 例如，假设有一个文件路径为 `/root/src/moduleA.js`，包含了一个导入 `var x = require(\"./moduleB\")`;\n\n- Node.js 以下面的顺序解析这个导入\n\n1. 检查 `/root/src/moduleB.js` 文件是否存在。\n2. 检查 `/root/src/moduleB` 目录是否包含一个 `package.json` 文件，且 `package.json` 文件指定了一个\"`main`\"模块。\n\n> 在我们的例子里，如果 `Node.js` 发现文件 `/root/src/moduleB/package.json` 包含了 `{ \"main\": \"lib/mainModule.js\" }`，那么 `Node.js` 会引用 `/root/src/moduleB/lib/mainModule.js`。\n\n3. 检查 `/root/src/moduleB` 目录是否包含一个 `index.js` 文件。 这个文件会被隐式地当作那个文件夹下的\"`main`\"模块。\n\n你可以阅读 `Node.js` 文档了解更多详细信息：[file modules](https://nodejs.org/api/modules.html#modules_file_modules) 和 [folder modules](https://nodejs.org/api/modules.html#modules_folders_as_modules)。\n\n> 但是，非相对模块名的解析是个完全不同的过程。`Node` 会在一个特殊的文件夹 `node\\_modules` 里查找你的模块。`node\\_modules` 可能与当前文件在同一级目录下，或者在上层目录里。`Node` 会向上级目录遍历，查找每个 `node\\_modules`直到它找到要加载的模块。\n> 还是用上面例子，但假设 `/root/src/moduleA.js` 里使用的是非相对路径导入 `var x = require(\"moduleB\")`;\n\n- `Node` 则会以下面的顺序去解析 `moduleB`，直到有一个匹配上。\n\n> 1.`/root/src/node_modules/moduleB.js` 2.`/root/src/node_modules/moduleB/package.json (如果指定了\"main\"属性)` 3.`/root/src/node_modules/moduleB/index.js` 4.`/root/node_modules/moduleB.js` 5.`/root/node_modules/moduleB/package.json (如果指定了\"main\"属性)` 6.`/root/node_modules/moduleB/index.js` 7.`/node_modules/moduleB.js` 8.`/node_modules/moduleB/package.json (如果指定了\"main\"属性)` 9.`/node_modules/moduleB/index.js`\n\n> 注意 `Node.js` 在步骤（`4`）和（`7`）会向上跳一级目录。\n> 你可以阅读 `Node.js` 文档了解更多详细信息：[loading modules from node_modules](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders)。\n\n- TypeScript 如何解析模块\n\n> `TypeScript` 是模仿 `Node.js` 运行时的解析策略来在编译阶段定位模块定义文件。因此，`TypeScript` 在 `Node` 解析逻辑基础上增加了 TypeScript 源文件的扩展名（ `.ts`，`.tsx` 和 `.d.ts`）。同时，`TypeScript` 在 `package.json` 里使用字段\"`types`\"来表示类似\"`main`\"的意义 `-` 编译器会使用它来找到要使用的\"`main`\"定义文件。\n\n> 比如，有一个导入语句 `import { b } from \"./moduleB\"` 在 `/root/src/moduleA.ts` 里，会以下面的流程来定位 `\"./moduleB\"` ：\n>\n> 1. `/root/src/moduleB.ts`\n> 2. `/root/src/moduleB.tsx`\n> 3. `/root/src/moduleB.d.ts`\n> 4. `/root/src/moduleB/package.json (如果指定了\"types\"属性)`\n> 5. `/root/src/moduleB/index.ts`\n> 6. `/root/src/moduleB/index.tsx`\n> 7. `/root/src/moduleB/index.d.ts`\n\n> 回想一下 `Node.js` 先查找 `moduleB.js` 文件，然后是合适的 `package.json`，再之后是 `index.js`。\n\n> 类似地，非相对的导入会遵循 `Node.js` 的解析逻辑，首先查找文件，然后是合适的文件夹。因此 `/root/src/moduleA.ts` 件里的 `import { b } from \"moduleB\"` 会以下面的查找顺序解析：\n>\n> 1. `/root/src/node_modules/moduleB.ts`\n> 2. `/root/src/node_modules/moduleB.tsx`\n> 3. `/root/src/node_modules/moduleB.d.ts`\n> 4. `/root/src/node_modules/moduleB/package.json (如果指定了\"types\"属性)`\n> 5. `/root/src/node_modules/moduleB/index.ts`\n> 6. `/root/src/node_modules/moduleB/index.tsx`\n> 7. `/root/src/node_modules/moduleB/index.d.ts`\n> 8. `/root/node_modules/moduleB.ts`\n> 9. `/root/node_modules/moduleB.tsx`\n> 10. `/root/node_modules/moduleB.d.ts`\n> 11. `/root/node_modules/moduleB/package.json (如果指定了\"types\"属性)`\n> 12. `/root/node_modules/moduleB/index.ts`\n> 13. `/root/node_modules/moduleB/index.tsx`\n> 14. `/root/node_modules/moduleB/index.d.ts`\n> 15. `/node_modules/moduleB.ts`\n> 16. `/node_modules/moduleB.tsx`\n> 17. `/node_modules/moduleB.d.ts`\n> 18. `/node_modules/moduleB/package.json (如果指定了\"types\"属性)`\n> 19. `/node_modules/moduleB/index.ts`\n> 20. `/node_modules/moduleB/index.tsx`\n> 21. `/node_modules/moduleB/index.d.ts`\n\n> 不要被这里步骤的数量吓到 `-` `TypeScript` 只是在步骤（`8`）和（`15`）向上跳了两次目录。 这并不比 `Node.js` 里的流程复杂。\n\n### 18.4 附加的模块解析标记\n\n> 1. 有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将 `.ts` 编译成 `.js`，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。\n> 2. `TypeScript` 编译器有一些额外的标记用来通知编译器在源码编译成最终输出的过程中都发生了哪个转换。\n> 3. 有一点要特别注意的是编译器不会进行这些转换操作；它只是利用这些信息来指导模块的导入。\n\n- `Base URL`\n\n> 在利用 `AMD` 模块加载器的应用里使用 `baseUrl` 是常见做法，它要求在运行时模块都被放到了一个文件夹里。这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。\n\n> 设置 `baseUrl` 来告诉编译器到哪里去查找模块。 所有 `非相对模块` 导入都会被当做相对于 `baseUrl`。\n\n- `baseUrl` 的值由以下两者之一决定：\n\n> 1. 命令行中 `baseUrl` 的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）\n> 2. `tsconfig.json`里的 `baseUrl` 属性（如果给定的路径是相对的，那么将相对于‘`tsconfig.json`’路径进行计算）\n\n> 注意相对模块的导入不会被设置的 `baseUrl` 所影响，因为它们总是相对于导入它们的文件。\n\n> 阅读更多关于 `baseUrl` 的信息 [RequireJS](https://requirejs.org/docs/api.html#config-baseUrl) 和 [`SystemJS`](https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl)。\n\n### 18.5 路径映射\n\n> 有时模块不是直接放在 `baseUrl` 下面。 比如，充分 \"`jquery`\"模块地导入，在运行时可能被解释为\"`node\\_modules/jquery/dist/jquery.slim.min.js`\"。 加载器使用映射配置来将模块名映射到运行时的文件，查看 [RequireJs documentation](https://requirejs.org/docs/api.html#config-paths) 和 [SystemJS documentation](https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths)。\n\n> `TypeScript` 编译器通过使用 `tsconfig.json` 文件里的 \"`paths`\" 来支持这样的声明映射。 下面是一个如何指定 `jquery` 的\"`paths`\"的例子。\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\", // This must be specified if \"paths\" is.\n    \"paths\": {\n      \"jquery\": [\"node_modules/jquery/dist/jquery\"] // 此处映射是相对于\"baseUrl\"\n    }\n  }\n}\n```\n\n> 请注意\"`paths`\"是相对于\"`baseUrl`\"进行解析。 如果 \"`baseUrl`\" 被设置成了除\"`.`\"外的其它值，比如 `tsconfig.json` 所在的目录，那么映射必须要做相应的改变。如果你在上例中设置了 `\"baseUrl\": \"./src\"`，那么 `jquery` 应该映射到 `\"../node\\_modules/jquery/dist/jquery\"`。\n\n> 通过\"`paths`\"我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：\n\n```typescript\nprojectRoot\n├── folder1\n│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json\n```\n\n- 相应的 `tsconfig.json` 文件如下：\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"*\": [\"*\", \"generated/*\"]\n    }\n  }\n}\n```\n\n> 它告诉编译器所有匹配 `\"\\*\"`（所有的值）模式的模块导入会在以下两个位置查找：\n>\n> 1. `\"\\*\"`： 表示名字不发生改变，所以映射为  `=>` `/`\n> 2. \"`generated/`\"表示模块名添加了“`generated`”前缀，所以映射为 `<moduleName> => <baseUrl>/generated/<moduleName>`\n\n- `按照这个逻辑，编译器将会如下尝试解析这两个导入：`\n\n> (i). 导入`'folder1/file2'`\n>\n> 1. 匹配 `'\\*'` 模式且通配符捕获到整个名字。\n> 2. 尝试列表里的第一个替换：`'\\*' -> folder1/file2`。\n> 3. 替换结果为非相对名 - 与 `baseUrl` 合并 `-> projectRoot/folder1/file2.ts`。\n> 4. 文件存在。完成。\n>\n> (ii). 导入`'folder2/file3'`\n>\n> 1. 匹配 `'\\*'` 模式且通配符捕获到整个名字。\n> 2. 尝试列表里的第一个替换：`'\\*' -> folder2/file3`。\n> 3. 替换结果为非相对名 - 与 `baseUrl` 合并 `-> projectRoot/folder2/file3.ts`。\n> 4. 文件不存在，跳到第二个替换。\n> 5. 第二个替换：`'generated/' -> generated/folder2/file3`。\n> 6. 替换结果为非相对名 - 与 `baseUrl` 合并 `-&gt; projectRoot/generated/folder2/file3.ts`。\n> 7. 文件存在。完成。\n\n- 利用 `rootDirs` 指定虚拟目录\n\n> 有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。 利用 `rootDirs`，可以告诉编译器生成这个虚拟目录的 `roots`； 因此编译器可以在“虚拟”目录下解析相对模块导入，就好像它们被合并在了一起一样。\n\n> 比如，有下面的工程结构：\n\n```typescript\nsrc\n └── views\n     └── view1.ts (imports './template1')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports './view2')\n```\n\n> `src/views` 里的文件是用于控制 UI 的用户代码。 `generated/templates` 是 `UI` 模版，在构建时通过模版生成器自动生成。构建中的一步会将 `/src/views` 和 `/generated/templates/views` 的输出拷贝到同一个目录下。 在运行时，视图可以假设它的模版与它同在一个目录下，因此可以使用相对导入 `\"./template\"`。\n\n> 可以使用\"`rootDirs`\"来告诉编译器。\"`rootDirs`\"指定了一个 `roots` 列表，列表里的内容会在运行时被合并。\n\n> 因此，针对这个例子， `tsconfig.json` 如下：\n\n```json\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}\n```\n\n> 每当编译器在某一 `rootDirs` 的子目录下发现了相对模块导入，它就会尝试从每一个 `rootDirs` 中导入。\n\n> `rootDirs` 的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑( `bundles` )和运行时的特性，比如条件引入和工程特定的加载器插件。\n\n> 设想这样一个国际化的场景，构建工具自动插入特定的路径记号来生成针对不同区域的捆绑，比如将 `\\#{locale}` 做为相对模块路径 `./\\#{locale}/messages` 的一部分。在这个假定的设置下，工具会枚举支持的区域，将抽像的路径映射成 `./zh/messages`，`./de/messages` 等。\n\n> 假设每个模块都会导出一个字符串的数组。比如 `./zh/messages` 可能包含：\n\n```typescript\nexport default [\"您好吗\", \"很高兴认识你\"];\n```\n\n> 利用 `rootDirs` 我们可以让编译器了解这个映射关系，从而也允许编译器能够安全地解析 `./\\#{locale}/messages`，就算这个目录永远都不存在。比如，使用下面的 `tsconfig.json`：\n\n```json\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/zh\", \"src/de\", \"src/#{locale}\"]\n  }\n}\n```\n\n> 编译器现在可以将 `import messages from './#{locale}/messages'` 解析为 `import messages from './zh/messages'` 用做工具支持的目的，并允许在开发时不必了解区域信息。\n\n### 18.6 跟踪模块解析\n\n> 如之前讨论，编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过 `--traceResolution` 启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。\n\n> 假设我们有一个使用了 `typescript` 模块的简单应用。`app.ts` 里有一个这样的导入 `import * as ts from \"typescript\"`。\n\n```typescript\n│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts\n```\n\n> 使用 `--traceResolution` 调用编译器。\n\n```typescript\ntsc --traceResolution\n```\n\n> 输出结果如下：\n\n```typescript\n======== Resolving module 'typescript' from 'src/app.ts'. ========\nModule resolution kind is not specified, using 'NodeJs'.\nLoading module 'typescript' from 'node_modules' folder.\nFile 'src/node_modules/typescript.ts' does not exist.\nFile 'src/node_modules/typescript.tsx' does not exist.\nFile 'src/node_modules/typescript.d.ts' does not exist.\nFile 'src/node_modules/typescript/package.json' does not exist.\nFile 'node_modules/typescript.ts' does not exist.\nFile 'node_modules/typescript.tsx' does not exist.\nFile 'node_modules/typescript.d.ts' does not exist.\nFound 'package.json' at 'node_modules/typescript/package.json'.\n'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.\nFile 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.\n======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========\n```\n\n> 需要留意的地方：\n\n> 1. 导入的名字及位置 `======== Resolving module 'typescript' from 'src/app.ts'. ========`\n> 2. 编译器使用的策略 `Module resolution kind is not specified, using 'NodeJs'.`\n> 3. 从 `npm` 加载 `types` `'package.json' has 'types' field './lib/typescript.d.ts' that references 'node\\_modules/typescript/lib/typescript.d.ts'.`\n> 4. 最终结果 `======== Module name 'typescript' was successfully resolved to 'node\\_modules/typescript/lib/typescript.d.ts'. ========`\n\n- 使用 `--noResolve`\n\n> 正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件 `import`，这个文件被会加到一个文件列表里，以供编译器稍后处理。`--noResolve` 编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。\n\n> `比如`:\n\n- `app.ts`\n\n```typescript\nimport * as A from \"moduleA\"; // OK, moduleA passed on the command-line\nimport * as B from \"moduleB\"; // Error TS2307: Cannot find module 'moduleB'.\n```\n\n```typescript\ntsc app.ts moduleA.ts --noResolve\n```\n\n> 使用 `--noResolve` 编译 `app.ts`：\n\n> 1. 可能正确找到 `moduleA`，因为它在命令行上指定了。\n> 2. 找不到 `moduleB`，因为没有在命令行上传递。\n\n### 18.7 常见问题\n\n- 为什么在 `exclude` 列表里的模块还会被编译器使用\n\n> `tsconfig.json` 将文件夹转变一个“工程” 如果不指定任何 “`exclude`” 或 “`files`”，文件夹里的所有文件包括 `tsconfig.json` 和 所有的子目录 都会在编译列表里。 如果你想利用 “`exclude`”排除某些文件，甚至你想指定所有要编译的文件列表，请使用“`files`”。\n\n> 有些是被 `tsconfig.json` 自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。\n\n> 因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行 `import` 或使用了 `/// <reference path=\"...\" />` 指令的文件。\n\n## 十九、声明合并\n\n### 19.1 介绍\n\n> `TypeScript` 中有些独特的概念可以在类型层面上描述 `JavaScript` 对象的模型。这其中尤其独特的一个例子 \"声明合并\" 的概念。\n\n> 理解了这个概念，将有助于操作现有的 `JavaScript` 代码。同时，也会有助于理解更多高级抽象的概念。\n\n> 对本文件来讲，\"`声明合并`\" 是指编译器将针对同一个名字的两个独立声明合并为单一声明。合并后的声明同时拥有原先两个声明的特性。任何数量的声明都可被合并；不局限于两个声明。\n\n### 19.2 基础概念\n\n> `TypeScript` 中的声明会创建以下三种实体之一：`命名空间`，`类型` 或 `值`。创建命名空间的声明会新建一个命名空间，它包含了用(.)符号来访问时使用的名字。创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。\n> 最后，创建值的声明会创建在 `JavaScript` 输出中看到的值。\n\n| Declaration Type | Namespace | Type | Value |\n| :--------------- | :-------- | :--- | :---- |\n| `Namespace`      | X         |      | X     |\n| `Class`          |           | X    | X     |\n| `Enum`           |           | X    | X     |\n| `Interface`      |           | X    |       |\n| `Type Alias`     |           | X    |       |\n| `Function`       |           |      | X     |\n| `Variable`       |           |      | X     |\n\n> 理解每个声明创建了什么，有助于理解当声明合并时，有哪些东西被合并了。\n\n### 19.3 合并接口\n\n> 最简单最常见的声明合并类型是接口合并。从根本上说，合并的机制是把双方的成员放到一个同名的接口里。\n\n```typescript\ninterface Box {\n  height: number;\n  width: number;\n}\ninterface Box {\n  scale: number;\n}\nlet box: Box = { height: 5, width: 6, scale: 10 };\n```\n\n> 接口的非函数成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。\n\n> 对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。同时需要注意，当接口 `A` 与后来的接口 `A` 合并时，后面的接口具有更高的优先级。\n\n```typescript\n// 如下例所示：\ninterface Cloner {\n  clone(animal: Animal): Animal;\n}\ninterface Cloner {\n  clone(animal: Sheep): Sheep;\n}\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n}\n// 这三个接口合并成一个声明：\ninterface Cloner {\n  clone(animal: Dog): Dog;\n  clone(animal: Cat): Cat;\n  clone(animal: Sheep): Sheep;\n  clone(animal: Animal): Animal;\n}\n```\n\n> 注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前的位置。\n\n> 这个规则有一个例外是当出现特殊的函数签名时。如果签名里有一个参数的类型是单一的字符串字面量(比如，不是字符串字面量的联合类型)，那么它将会被提升到重载列表的最顶端。\n\n```typescript\n// 比如，下面的接口会合并到一起\ninterface Document {\n  createElement(tagName: any): ELement;\n}\ninterface Document {\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n}\ninterface Document {\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n}\n// 合并后的 Document 将会像下面这样:\ninterface Document {\n  createElement(tagName: \"canvas\"): HTMLCanvasElement;\n  createElement(tagName: \"div\"): HTMLDivElement;\n  createElement(tagName: \"span\"): HTMLSpanElement;\n  createElement(tagName: string): HTMLElement;\n  createElement(tagName: any): Element;\n}\n```\n\n### 19.4 合并命名空间\n\n1. 与接口相似，同名的命名空间也会合并其成员。命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。\n2. 对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。\n3. 对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。\n\n```typescript\n// Animals 声明合并示例：\nnamespace Animals {\n  export class Zebra {}\n}\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Dog {}\n}\n// 等同于：\nnamespace Animals {\n  export interface Legged {\n    numberOfLegs: number;\n  }\n  export class Zebra {}\n  export class Dog {}\n}\n```\n\n> 除了这些合并外，你还需要了解非导出成员是如何处理的。非导出成员仅在其原有的(合并前的)命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。\n\n- 下面提供了清晰的说明：\n\n```typescript\nnamespace Animal {\n  let haveMuscles = true;\n  export function animalsHaveMuscles() {\n    return haveMuscles;\n  }\n}\nnamespace Animal {\n  export function doAnimalsHaveMuscles() {\n    return haveMuscles; // // Error, because haveMuscles is not accessible here\n  }\n}\n```\n\n> 因为 `haveMuscles` 并没有导出，只有 `animalsHaveMuscles` 函数共享了原始未合并的命名空间可以访问这个变量。\n> `doAnimalsHaveMuscles` 函数虽是合并命名空间的一部分，但是访问不了未导出的成员。\n\n### 19.5 命名空间与类和函数和枚举类型合并\n\n> 命名空间可以与其它类型的声明合并。只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。\n> `TypeScript` 使用这个功能去实现一些 `JavaScript` 里的设计模式。\n\n#### 19.5.1 合并命名空间和类\n\n> 这让我们可以表示内部类\n\n```typescript\nclass Album {\n  label: Album.AlbumLabel;\n}\n\nnamespace Album {\n  export class AlbumLabel {}\n}\n```\n\n> `合并规则` 与上面 `合并命名空间` 小节里讲的规则一致，我们必须导出 `AlbumLabel` 类，好让合并的类能访问。\n\n> `合并结果`是一个类并带有一个内部类。你也可以使用命名空间为类增加一些静态属性。\n\n> 除了内部类的模式，你在 `JavaScript` 里，创建一个函数稍后扩展它增加一些属性也是很常见的。`TypeScript` 使用声明合并来达到这个目的并保证类型安全。\n\n```typescript\nfunction buildLabel(name: string): string {\n  return buildLabel.prefix + name + buildLabel.suffix;\n}\nnamespace buildLabel {\n  export let suffix = \"\";\n  export let prefix = \"Hello, \";\n}\nconsole.log(buildLabel(\"Sam Smith\"));\n\n// 相似的，命名空间可以用来扩展枚举类型\nenum Color {\n  red = 1,\n  green = 2,\n  blue = 4\n}\nnamespace Color {\n  export function mixColor(colorName: string) {\n    if (colorName === \"yellow\") {\n      return Color.red + Color.green;\n    } else if (colorName === \"white\") {\n      return Color.red + Color.green + Color.blue;\n    } else if (colorName === \"magenta\") {\n      return Color.red + Color.blue;\n    } else if (colorName === \"cyan\") {\n      return Color.green + Color.blue;\n    }\n  }\n}\n```\n\n#### 19.5.2 非法的合并\n\n> `TypeScript` 并非允许所有的合并。目前，类不能与其它类或变量合并。想要了解如何模仿类的合并，请参照 [TypeScript 混入](https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/Mixins%E6%B7%B7%E5%85%A5/README.md)。\n\n### 19.6 模块扩展\n\n> 虽然 `JavaScript` 不支持合并，但你可以为导入的对象打补丁以更新它们。\n\n- 让我们考察一下这个玩具性的示例：\n\n```typescript\n// observable.js\nexport class Observable<T> {\n  // ... implementation left as an exercise for the reader...\n}\n\n// map.js\nimport { Observable } from \"./observable\";\nObservable.prototype.map = function () {\n  // ... another exercise for the reader\n};\n```\n\n> 它也可以很好地工作在 `TypeScript` 中，但编译器对 `Observable.prototype.map` 一无所知。你可以使用扩展模块来将它告诉编译器。\n\n```typescript\n// observable.ts stays the same\n// map.ts\nimport { Observable } from \"./observable\";\ndeclare module \"./observable\" {\n  interface Observable<T> {\n    map<U>(f: (x: T) => U): Observable<U>;\n  }\n}\nObservable.prototype.map = function (f) {\n  // ... another exercise for the reader\n};\n\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable<number>;\no.map(x => x.toFixed());\n```\n\n> 模块名的解析和用 `import / export` 解析模块标识符的方式是一致的。 更多信息请参考 [Modules](https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/%E6%A8%A1%E5%9D%97/README.md)。当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明(仅可以扩展模块中已经存在的声明)。\n\n### 19.7 全局扩展\n\n> 你也可以在模块内部添加声明到全局作用域中\n\n> `observable.ts`\n\n```typescript\nexport class Observable<T> {\n  // ... still no implementation ...\n}\ndeclare global {\n  interface Array<T> {\n    toObservable(): Observable<T>;\n  }\n}\nArray.prototype.toObservable = function () {\n  // ...\n};\n```\n\n> 全局扩展和与模块扩展的行为和限制是相同的。\n\n## 二十、JSX\n\n### 20.1 介绍\n\n> `JSX` 是一种嵌入式的类似 `XML` 的语法。它可以被转换成合法的 `JavaScript`，尽管转换的语义是根据不同的实现而定的。\n> `JSX` 因 `React` 框架而流行，但也存在其它的实现。`TypeScript` 支持内嵌，类型检查以及将 `JSX` 直接编译为 JavaScript。\n\n### 20.2 基本用法\n\n- 想要使用 `JSX` 必须做两件事：\n\n> 1. 给文件一个 `.tsx` 扩展名\n> 2. 启用 `jsx` 选项\n\n- `TypeScript` 具有三种 `JSX` 模式：`preserve`, `react` 和 `react-native`。这些模式只在代码生成阶段起作用 - 类型检查并不受影响。\n\n> 1. 在 `preserve` 模式下生成代码中会保留 `JSX` 以供后续的转换操作使用( `比如：Babel` )。另外，输出文件会带有 `.jsx` 扩展名。\n> 2. `react` 模式会生成 `React.createElement`，在使用前不需要再进行转换操作了，输出文件的扩展名为 `.js`。\n> 3. `react-native` 相当于 `preserve`，它也保留了所有的 `JSX`，但是输出文件的扩展名是 `.js`。\n\n| 模式         | 输入      | 输出                         | 输出文件扩展名 |\n| :----------- | :-------- | :--------------------------- | :------------- |\n| preserve     | `<div />` | `<div />`                    | `.js`          |\n| react        | `<div />` | `React.createElement(\"div\")` | `.js`          |\n| react-native | `<div />` | `<div />`                    | `.js`          |\n\n> 你可以通过在命令行里使用 `--jsx` 标记或 `tsconfig.json` 里的选项来指定模式。\n> 注意：`React` 标识符是写死的硬编码，所以你必须保证 `React`（大写的`R`）是可用的。\n\n### 20.3 as 操作符\n\n> 回想一下怎么写类型断言\n\n```typescript\nvar foo = <foo>bar;\n```\n\n> 这里断言 `bar` 变量是 `foo` 类型的。 因为 `TypeScript` 也使用尖括号来表示类型断言，在结合 `JSX` 的语法后将带来解析上的困难。因此，`TypeScript` 在 `.tsx` 文件里禁用了使用尖括号的类型断言。\n\n> 由于不能够在 `.tsx` 文件里使用上述语法，因此我们应该使用另一个类型断言操作符：`as`。\n\n- 上面的例子可以很容易地使用 `as` 操作符改写：\n\n```typescript\nvar foo = bar as foo;\n```\n\n> `as` 操作符在 `.ts` 和 `.tsx` 里都可用，并且与尖括号类型断言行为是等价的。\n\n### 20.4 类型检查\n\n> 为了理解 `JSX` 的类型检查，你必须首先理解 `固有元素` 与 `基于值的元素` 之间的区别。假设有这样一个 `JSX` 表达式 `<expr />`，`expr` 可能引用环境自带的某些东西(比如，在 `DOM` 环境里的 `div` 或 `span`)或者是你自定义的组件。这是非常重要的。原因有如下两点：\n\n1. 对于 `React`，固有元素会生成字符串 (`React.createElement(\"div\")` )，然后由你自定义的组件却不会生成( `React.createElement(MyComponent)`)。\n2. 传入 `JSX` 元素里的属性类型的查找方式不同。固有元素总以一个小写字母开头，基于值的元素总是以一个大写字母开头。\n\n#### 20.4.1 固有元素\n\n> 固有元素使用特殊的接口 `JSX.IntrinsicElements` 来查找。默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。然而，如果这个接口存在，那么固有元素的名字需要在 `JSX.IntrinsicElements` 接口的属性里查找。\n\n- 例如：\n\n```jsx\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        foo: any;\n    }\n}\n<foo />; // 正确\n<bar />; // 错误\n```\n\n> 在上例中，``没有问题，但是`会报错，因为它没在 JSX.IntrinsicElements` 里指定。\n\n> 注意：你也可以在 `JSX.IntrinsicElements` 上指定一个用来捕获所有字符串索引：\n\n```jsx\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        [elemName: string]: any;\n    }\n}\n```\n\n#### 20.4.2 基于值的元素\n\n> 基于值的元素会简单的在它所在的作用域里按标识符查找。\n\n```jsx\nimport MyComponent from \"./myComponent\";\n<MyComponent /> // 正确\n<SomeOtherComponent /> // 错误\n```\n\n> 有两种方式可以定义基于值的元素：\n>\n> 1. 无状态函数组件 (`SFC`)\n> 2. 类组件\n\n> 由于这两种基于值的元素在 `JSX` 表达式里无法区分，因此 `TypeScript` 首先会尝试将表达式作为无状态函数组件进行解析。如果解析成功，那么 `TypeScript` 就完成了表达式到其声明的解析操作。如果按照无状态函数组件解析失败，那么 `TypeScript` 会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。\n\n##### (1) 无状态函数组件\n\n> 正如其名，组件被定义成 `JavaScript` 函数，它的第一个参数是 `props` 对象。`TypeScript` 会强制它的返回值可以赋值给 `JSX.Element`。\n\n```jsx\ninterface FooProp {\n    name: string;\n    X: number;\n    Y: number;\n}\ndeclare function AnotherComponent(prop: { name: string });\nfunction ComponentFoo(prop: FooProp) {\n    return <AnotherComponent name={prop.name} />\n}\nconst Button = (prop: { value: string }, context: { color: string }) => <button>;\n```\n\n> 由于无状态函数组件是简单的 `JavaScript` 函数，所以我们还可以利用函数重载。\n\n```jsx\ninterface ClickableProps {\n    children: JSX.Element[] | JSX.Element;\n}\ninterface HomeProps extends ClickableProps {\n    home: JSX.Element;\n}\ninterface SlideProps extends ClickableProps {\n    side: JSX.Element | string;\n}\nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SlideProps): JSX.Element {\n    // ...\n}\n```\n\n##### (2) 类组件\n\n> 1. 我们可以定义类组件的类型。然而，我们首先最好弄懂两个新的术语：`元素类的类型` 和 `元素实例的类型`。\n> 2. 现在有 `<Expr />`，元素类的类型为 `Expr` 的类型。所以在上面的例子里，如果 `MyComponent` 是 `ES6` 的类，那么类类型就是类的构造函数和静态部分。如果 `MyComponent` 是个工厂函数，类类型为这个函数。\n> 3. 一旦建立起了类类型，实例类型由构造器或调用签名(如果存在的话)的返回值的联合构成。再次说明，在 `ES6` 类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。\n\n```jsx\nclass MyComponent {\n  render() {}\n}\n// 使用构造签名\nvar myComponent = new MyComponent();\n// 元素类的类型 => MyComponent;\n// 元素实例的类型 => { render: () => void }\n```\n\n```jsx\nfunction MyFactoryFunction() {\n  return {\n    render: () => {}\n  };\n}\n// 使用调用签名\nvar myComponent = MyFactoryFunction();\n// 元素类的类型 => FactoryFunction\n// 元素实例的类型 => { render: () => void }\n```\n\n> 元素的实例类型很有趣，因为它必须赋值给 `JSX.ElementClass` 或 `抛出一个错误`。默认的 `JSX.ElementClass` 为 `{}`，但是它可以被扩展用来限制 `JSX` 的类型以符合相应的接口。\n\n```jsx\ndeclare namespace JSX {\n    interface ElementClass {\n        render: any\n    }\n}\n\nclass MyComponent {\n    render() {}\n}\nfunction MyFactoryFunction() {\n    return {\n        render: () => {}\n    }\n}\n<MyComponent />; // 正确\n<MyFactoryFunction />; // 正确\n\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n    return {}\n}\n<NotAValidComponent />; // 错误\n<NotAValidFactoryFunction />; // 错误\n```\n\n### 20.5 属性类型检查\n\n1. 属性类型检查的第一步是 确定元素类型。这在 `固有元素` 和 `基于值的元素` 之间稍有不同。\n2. 对于固有元素，这是 `JSX.IntrinsicElements` 属性的类型。\n\n```jsx\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        foo: {\n            bar?: boolean;\n        }\n    }\n}\n// `foo` 的元素属性类型为 `{bar?: boolean}`\n<foo bar />;\n```\n\n3. 对于基于值的元素，就稍微复杂些。它取决于先前确定的在元素实例类型上的某个属性的类型。至于该使用哪个属性来确定类型取决于 `JSX.ElementAttributesProperty`。它应该使用单一的属性来定义。这个属性名之后会被使用。`TypeScript 2.8`，如果未指定 `JSX.ElementAttributesProperty`，那么将使用 `类元素构造函数` 或 `SFC` 调用的第一个参数类型。\n\n```jsx\ndeclare namespace JSX {\n  interface ElementAttributesProperty {\n      props; // 指定用来使用的属性名\n  }\n}\nclass MyComponent {\n  // 在元素实例上指定类型\n  props: {\n      foo?: string;\n  }\n}\n// `MyComponent` 的元素属性类型为 `{foo?: string}`\n<MyComponent foo=\"bar\" />;\n```\n\n4. 元素属性类型用于 `JSX` 里进行属性的类型检查。支持可选属性和必须属性\n\n```jsx\ndeclare namespace JSX {\n    interface IntrinsicElements {\n        foo: {\n            requiredProp: string;\n            optionalProp?: number;\n        }\n    }\n}\n<foo requiredProp=\"bar\" />; // 正确\n<foo requiredProp=\"bar\" optionalProp={0} />; // 正确\n<foo />; // 错误，缺少requiredProp\n<foo requiredProp={0} />; // 错误，requiredProp 应该是字符串\n<foo requiredProp=\"bar\" unknownProp />; // 错误，unknownProp 属性不存在\n<foo requiredProp=\"bar\" some-unknown-prop />; // 正确，`some-unknown-prop` 不是合法的标识符\n```\n\n> 注意：如果一个属性名不是个合法的 `JS` 标识符(像 `data-\\*` 属性)，并且它没出现在元素属性类型里时不会当作一个错误。\n\n> 另外，`JSX` 还会使用 `JSX.IntrinsicAttributes` 接口来指定额外的属性，这些额外的属性通常不会被组件的 `props` 或 `arguments` 使用 - 比如 `React` 里的 `key`。还有，`JSX.IntrinsicClassAttributes<T>` 泛型类型也可以用来做同样的事情。这里的泛型参数表示类实例类型。在 `React` 里，它用来允许 `Ref<T>` 类型上的 `ref` 属性。通常来讲，这些接口上的所有属性都是可选的，除非你想要用户在每个 `JSX` 标签上都提供一些属性。\n\n> 延展操作符也可以使用\n\n```jsx\nvar props = { requiredProp: \"bar\" }; // 正确\nvar badProps = {};\n<foo {...badProps} />; // 错误\n```\n\n### 20.6 子孙类型检查\n\n> 从 `TypeScript 2.3` 开始，我们引入了 `children` 类型检查。`children` 是元素属性(`attribute`)类型的一个特殊属性(`property`)，子 `JSXExpression` 将会被插入到属性里。与使用 `JSX.ElementAttributesProperty` 来决定 `props` 名类似，我们可以利用 `JSX.ElementChildrenAttribute` 来决定 `children` 名。`JSX.ElementChildrenAttribute` 应该被声明在单一的属性(`property`)里。\n\n```typescript\ndeclare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {}; // specify children name to use\n  }\n}\n```\n\n> 如不特殊指定子孙的类型，我们将使用 `React typings` 里的默认类型\n\n```jsx\n<div>\n  <h1>Hello</h1>\n</div>;\n\n<div>\n  <h1>Hello</h1>\n  World\n</div>;\n\nconst CustomComp = (props) => <div>props.children</div>\n<CustomComp>\n  <div>Hello World</div>\n  {\"This is just a JS expression...\" + 1000}\n</CustomComp>\n```\n\n```jsx\ninterface PropsType {\n  children: JSX.Element;\n  name: string;\n}\nclass Component extends React.Component<PropsType, {}> {\n  render() {\n      return (\n          <h2>\n              {this.props.children}\n          </h2>\n      )\n  }\n}\n// Ok\n<Component>\n  <h1>Hello World</h1>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element\n<Component>\n  <h1>Hello World</h1>\n  <h2>Hello World</h2>\n</Component>\n\n// Error: children is of type JSX.Element not array of JSX.Element or string.\n<Component>\n  <h1>Hello</h1>\n  World\n</Component>\n```\n\n### 20.7 JSX 结果类型\n\n> 默认地 `JSX` 表达式结果的类型为 `any`。你可以自定义这个类型，通过指定 `JSX.Element` 接口。然而，不能够从接口里检索元素，属性或 `JSX` 的子元素的类型信息。它是一个黑盒。\n\n### 20.8 嵌入的表达式\n\n> `JSX` 允许你使用 `{}` 标签来内嵌表达式\n\n```tsx\nvar a = (\n  <div>\n    {[\"foo\", \"bar\"].map(i => (\n      <span>{i / 2}</span>\n    ))}\n  </div>\n);\n// 上面的代码产生一个错误，因为你不能用数字来除以一个字符串。输出如下，若你使用了 preserve 选项\nvar a = (\n  <div>\n    {[\"foo\", \"bar\"].map(function (i) {\n      return <span>{i / 2}</span>;\n    })}\n  </div>\n);\n```\n\n### 20.9 react 整合\n\n> 要想一起使用 `JSX` 和 `React`，你应该使用 `React` 类型定义。这些类型声明定义了 `JSX` 合适命名空间来使用 `React`。\n\n```jsx\n/// <reference path=\"react.d.ts\" />\ninterface Props {\n  foo: string;\n}\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n<MyComponent foo=\"bar\" />; // 正确\n<MyComponent foo={0} />; // 错误\n```\n\n### 20.10 工厂函数\n\n> `jsx`：`react` 编译选项使用的工厂函数是可以配置的。可以使用 `jsxFactory` 命令行选项，或内联的 `@jsx` 注释指令在每个文件上设置。比如，给 `createElement` 设置 `jsxFactory`，`<div />` 会使用 `createElement(\"div\")` 来生成，而不是 `React.createElement(\"div\")`。\n\n```jsx\n// 注释指令可以像下面这样使用：(在 TypeScript 2.8 里)\nimport preact = require(\"preact\");\n/* @jsx preact.h */\nconst x = <div/>;\n\n// 生成\nconst preact = require(\"preact\");\nconst x = preact.h(\"div\", null);\n```\n\n> 工厂函数的选择同样会影响 `JSX` 命名空间的查找(类型检查)。如果工厂函数使用 `React.createElement` 定义(默认)，编译器会先检查 `React.JSX`，之后才检查全局的 `JSX`。如果工厂函数定义为 `h`，那么在检查全局的 `JSX` 之前先检查 `h.JSX`。\n\n## 二十一、装饰器\n\n### 21.1 介绍\n\n> 随着 `TypeScript` 和 `ES6` 里引入了类，在一些场景下我们需要额外的特定来支持标注或修改类及其成员。装饰器(`Decorators`)为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。`JavaScript` 里的装饰器目前处在 建议征集的第二阶段，但在 `TypeScript` 里已作为一项实验性特性予以支持。\n> 注意：装饰器是一项实验性特性，在未来的版本中可能会发生改变\n> 若要启用实验性的装饰器特性，你必须在命令行或 `tsconfig.json` 里启用 `experimentalDecorators` 编译器选项。\n> 命令行： `tsc --target ES5 --experimentalDecorators`\n\n- tsconfig.json\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true\n  }\n}\n```\n\n### 21.2 装饰器\n\n> 装饰器是一种特殊的声明，它能够被附加到 `类声明`、`方法`、`访问符`、`属性或参数上`。装饰器使用 `@expression` 这种形式，`expression` 求值后必须为一个函数，它会在运行时被调用，被装饰器的声明信息作为参数传入。\n> 例如，有一个 `@sealed` 装饰器，我们会这样定义 `sealed` 函数\n\n```typescript\nfunction sealed(target) {\n  // do something with target\n}\n```\n\n> 注意：后面类装饰器小节里有一个更加详细的例子。\n\n### 21.3 装饰器工厂\n\n> 如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。\n\n- 我们可以通过下面的方式来写一个装饰器工厂函数：\n\n```typescript\nfunction color(value: string) {\n  // 这是一个装饰器工厂\n  return function (target) {\n    // 这是装饰器\n    // do something with \"target\" and \"value\" ...\n  };\n}\n```\n\n> 注意：下面方法装饰器小节里有一个更加详细的例子。\n\n### 21.4 装饰器组合\n\n> 多个装饰器可以同时应用到一个声明上，就像下面的实例：\n\n1. 书写在同一行：\n\n```typescript\n@f @g x\n```\n\n2. 书写在多行上：\n\n```typescript\n@f\n@g\nx\n```\n\n> 当多个装饰器应用于一个声明上，它们求值方式与 复合函数 相似。在这个模型下，当复合 f 和 g 时，复合的结果 `\\(f∘g\\)\\(x\\)` 等同于 `f\\(g\\(x\\)\\)`。\n\n> 同样的，在 `TypeScript` 里，当多个装饰器应用在一个声明上时会进行如下步骤的操作： `1`. 由上至下依次对装饰器表达式求值 `2`. 求值的结果会被当作函数，由下至上依次被调用。\n\n```typescript\n// 如果我们使用 装饰器工厂 的话，可以通过下面的例子来观察它们求值的顺序：\nfunction f() {\n  console.log(\"f(): evaluated\");\n  return function (target, prototypeKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"f(): called\");\n  };\n}\nfunction g() {\n  console.log(\"g(): evaluated\");\n  return function (target, prototypeKey: string, descriptor: PropertyDescriptor) {\n    console.log(\"g(): called\");\n  };\n}\nclass C {\n  @f()\n  @g()\n  method() {}\n}\n```\n\n```typescript\n// 在控制台里会打印出如下结果：\nf(): evaluated\ng(): evaluated\ng(): called\nf(): called\n```\n\n### 21.5 装饰器求值\n\n> 类中不同声明上的装饰器将按以下规定的顺序应用：\n\n- 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。\n- 参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。\n- 参数装饰器应用到构造函数。\n- 类装饰器应用到类。\n\n### 21.6 类装饰器\n\n1.类装饰器在类声明之前被声明(紧靠着类声明)。类装饰器应用于类构造函数，可以用来监视修改或替换类定义。类装饰器不能用在声明文件中( `.d.ts` )，也不能用在任何外部上下文中(比如 `declare` 的类)。\n\n2. 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。\n3. 如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。\n\n> 注意：如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。在运行时的装饰器调用逻辑中 不会为你做这些。\n> 下面是使用类装饰器( `@sealed` )的例子，应用在 `Greeter` 类：\n\n```typescript\n@sealed\nclass Greeter1 {\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n\n// 我们可以这样定义 @sealed 装饰器\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n```\n\n> 当 `@sealed` 被执行的时候，它将密闭此类的构造函数和原型。(注：参见 `Object.seal` )\n\n- 下面是一个重载构造函数的例子：\n\n```typescript\nfunction classDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {\n  return class extends constructor {\n    newProperty = \"new property\";\n    hello = \"override\";\n  };\n}\n\n@classDecorator\nclass Greeter2 {\n  property = \"property\";\n  hello: string;\n\n  constructor(m: string) {\n    this.hello = m;\n  }\n}\n\nconsole.log(new Greeter2(\"world\"));\n```\n\n### 21.7 方法装饰器\n\n> 方法装饰器声明在一个方法的声明之前(紧靠着方法声明)。它会被应用到方法的 `属性描述符` 上，可以用来监视，修改或者替换方法定义。方法装饰器不能用在声明文件 `.d.ts` 上，重载或者任何外部上下文(比如 `declare` 的类)中。\n\n> 方法装饰器表达式会在运行时当作函数被调用，传入下列 `3` 个参数：\n>\n> 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n> 2. 成员的名字\n> 3. 成员的属性修饰符\n\n> 注意：如果代码输出目标代码小于 `ES5`，属性描述符 将会是 `undefined`。\n\n> 如果方法装饰器返回一个值，它会被用作方法的 属性描述符。\n\n> 注意：如果代码输出目标版本小于 `ES5`，返回值会被忽略。\n\n- 下面是一个方法装饰器 (`@enumerable`) 的例子，应用于 `Greeter` 类的方法上。\n\n```typescript\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @enumerable(false)\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n```\n\n- 我们可以用下面的函数声明来定义 `@enumerable` 装饰器：\n\n```typescript\nfunction enumerable(value: boolean) {\n  return function (target: any, property: string, descriptor: PropertyDescriptor) {\n    descriptor.enumerable = value;\n  };\n}\n```\n\n> 这里的 `@enumerable(false)` 是一个装饰器工厂，当装饰器 `@enumerable(false)` 被调用时，它会修改属性描述符的 `enumerable` 属性。\n\n### 21.8 访问器装饰器\n\n> 访问器装饰器声明在一个访问器的声明之前(紧靠着访问器声明)。访问器装饰器 应用于访问器的 `属性描述符` 并且可以用来监视，修改或替换一个访问器的定义。访问器装饰器不能用在声明文件中( `.d.ts` )，或者任何外部上下文(比如 `declare` 的类)里。\n\n> 注意：`TypeScript` 不允许同时装饰一个成员的 `get` 和 `set` 访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了 `get` 和 `set` 访问器，而不是分开声明的。\n\n> 访问器装饰器表达式会在运行时当作函数被调用，传入下列 `3` 个参数：\n>\n> 1. 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。\n> 2. 成员的名字\n> 3. 成员的属性描述符\n\n> 注意：如果代码输出目标版本小于 `ES5`，`Property Descriptor` 将会是 `undefined`。\n\n> 如果访问器装饰器返回一个值，它会被用作方法的 `属性描述符` 注意：如果代码输出目标版本小于 `ES5` 返回值会被忽略。\n\n- 下面是使用了访问器装饰器 (`@configurable`) 的例子，应用于 `Point` 类的成员上。\n\n```typescript\nclass Point {\n  private _x: number;\n  private _y: number;\n  constructor(x: number, y: number) {\n    this._x = x;\n    this._y = y;\n  }\n\n  @configurable(false)\n  get x() {\n    return this._x;\n  }\n\n  @configurable(false)\n  get y() {\n    return this._y;\n  }\n}\nlet p: Point = new Point(1, 2);\nconsole.log(p);\n```\n\n- 我们可以通过如下函数声明来定义 `@configurable` 装饰器：\n\n```typescript\nfunction configurable(value: boolean) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    descriptor.configurable = value;\n  };\n}\n```\n\n### 21.9 属性装饰器\n\n> 属性装饰器声明在一个属性声明之前(紧靠着属性声明)。属性装饰器不能用在声明文件中（`.d.ts`），或者任何外部上下文（比如 `declare` 的类）里。\n\n> 属性装饰器表达式会在运行时当作函数被调用，传入下列 `2` 个参数：\n>\n> 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n> 2. 成员的名字。\n\n> 注意：`属性描述符` 不会作为参数传入属性装饰器，这与 `TypeScript` 是如何初始化属性装饰器有关。因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。\n\n- 我们可以用它来记录这个属性的元数据，如下例所示：\n\n```typescript\nclass Greeter {\n    @format(\"Hello, %s\")\n    greeting: string;\n>\n    constructor(message: string) {\n        this.greeting = message;\n    }\n>\n    greet() {\n        let formatString = getFormat(this, \"greeting\");\n        return formatString.replace(\"%s\", this.greeting);\n    }\n}\n>\nlet g: Greeter = new Greeter(\"鼓励\");\nconsole.log(g);\n>\n// 然后定义 @format 装饰器 和 getFormat 函数\nimport \"reflect-metadata\";\n>\nconst formatMetadataKey = Symbol(\"format\");\n>\nfunction format(formatString: string) {\n    return Reflect.metadata(formatMetadataKey, formatString);\n}\n>\nfunction getFormat(target: any, propertyKey: string) {\n    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);\n}\n```\n\n> 这个 `@format(\"Hello, %s\")` 装饰器是个 `装饰器工厂`。当 `@format(\"Hello, %s\")` 被调用时，它添加一条这个属性的元数据，通过 `reflect-metadata` 库里的 `Reflect.metadata` 函数。当 `getFormat` 被调用时，它读取格式的元数据。\n\n> 注意：这个例子需要使用 `reflect-metadata` 库。查看 元数据 了解 `reflect-metadata` 库更详细的信息。\n\n### 21.10 参数装饰器\n\n> `参数装饰器` 声明在一个参数声明之前(紧靠着参数声明)。参数装饰器应用于 `类构造函数` 或 `方法声明`。参数装饰器 不能用在声明文件（`.d.ts`），重载或其它外部上下文（比如 `declare` 的类）里。\n> `参数装饰器` 表达式会在运行时当作函数被调用，传入下列 `3` 个参数：\n>\n> 1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。\n> 2. 成员的名字\n> 3. 参数在函数参数列表的索引\n\n> 注意：参数装饰器只能用来监视一个方法的参数是否被传入。\n\n> 参数装饰器的返回值会被忽略\n\n- 下面定义了参数装饰器( `@required` )并应用于 `Greeter` 类方法的一个参数：\n\n```typescript\nclass Greeter {\n  greeting: string;\n\n  constructor(message: string) {\n    this.greeting = message;\n  }\n\n  @validate\n  greet(@required name: string) {\n    return \"Hello \" + name + \", \" + this.greeting;\n  }\n}\n```\n\n- 然后我们使用下面的函数定义 `@required` 和 `@validate` 装饰器\n\n```typescript\nimport \"reflect-metadata\";\n\nconst requiredMetadataKey = Symbol(\"required\");\n\nfunction required(target: Object, propertyKey: string | symbol, parameterIndex: number) {\n  let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];\n  existingRequiredParameters.push(parameterIndex);\n  Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);\n}\n\nfunction validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {\n  let method = descriptor.value;\n  descriptor.value = function () {\n    let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);\n    if (requiredParameters) {\n      for (let parameterIndex of requiredParameters) {\n        if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {\n          throw new Error(\"Missing required argument.\");\n        }\n      }\n    }\n    return method.apply(this, arguments);\n  };\n}\n```\n\n> `@required` 装饰器添加了元数据实体把参数标记为必须的。\n> `@validate` 装饰器把 `greet` 方法包裹在一个函数里，在调用原先的函数前验证函数参数。\n> `注意：`这个例子使用了 `reflect-metadata` 库。 查看 元数据 了解 `reflect-metadata` 库的更多信息。\n\n### 21.11 元数据\n\n> 一部分例子使用了 `reflect-metadata` 库来支持实现性的 `metadata API`。这个库还不是 `ECMAScript\\( JavaScript \\)` 标准的一部分。然而，当装饰器被 `ECMAScript` 官方标准采纳后，这些扩展也将被推荐给 `ECMAScript` 以采纳。\n\n- 你可以通过 `npm` 安装这个库\n\n```bash\nnpm i reflect-metadata --save\n```\n\n> `TypeScript` 支持为带有装饰器的声明生成元数据。你需要在 `命令行` 或 `tsconfig.json` 里启用 `emitDecoratorMetadata` 编译器选项。\n\n- 命令行：\n\n```bash\ntsc --target ES5 --experimentalDecorators --emitDecoratorMetadata\n```\n\n- `tsconfig.json`\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES5\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true\n  }\n}\n```\n\n> 当启用了，只要 `reflect-metadata` 库被引入了，设计阶段添加的类型信息可以在运行时使用。\n\n- 如下例所示：\n\n```typescript\nimport \"reflect-metadata\";\n\nclass Point {\n  x: number;\n  y: number;\n}\n\nclass Line {\n  private _p0: Point;\n  private _p1: Point;\n\n  @validate\n  set p0(value: Point) {\n    this._p0 = value;\n  }\n\n  get p0() {\n    return this._p0;\n  }\n\n  @validate\n  set p1(value: Point) {\n    this._p1 = value;\n  }\n\n  get p1() {\n    return this._p1;\n  }\n}\n\nfunction validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) {\n  let set = descriptor.set;\n  descriptor.set = function (value: T) {\n    let type = Reflect.getMetadata(\"design:type\", target, propertyKey);\n    if (!(value instanceof type)) {\n      throw new TypeError(\"Invalid type.\");\n    }\n    set(value);\n  };\n}\n```\n\n- `TypeScript` 编译器可以通过 `@Reflect.metadata` 装饰器注入设计阶段的类型信息。你可以认为它相当于下面的 `TypeScript：`\n\n```typescript\nclass Line1 {\n  private _p0: Point;\n  private _p1: Point;\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set p0(value: Point) {\n    this._p0 = value;\n  }\n\n  get p0() {\n    return this._p0;\n  }\n\n  @validate\n  @Reflect.metadata(\"design:type\", Point)\n  set p1(value: Point) {\n    this._p1 = value;\n  }\n\n  get p1() {\n    return this._p1;\n  }\n}\n```\n\n> 注意： 装饰器元数据是个实验性的特性并且可能在以后的版本中发声破坏性的改变。\n\n### 21.12 Reflect-metadata 库\n\n```typescript\nnamespace Reflect {\n    // 用于装饰器\n    metadata(k, v): (target, property?) => void\n    // 在对象上面定义元数据\n    defineMetadata(k, v, o, p?): void\n    // 是否存在元数据\n    hasMetadata(k, o, p?): boolean\n    hasOwnMetadata(k, o, p?): boolean\n    // 获取元数据\n    getMetadata(k, o, p?): any\n    getOwnMetadata(k, o, p?): any\n    // 获取所有元数据的 Key\n    getMetadataKeys(o, p?): any[]\n    getOwnMetadataKeys(o, p?): any[]\n    // 删除元数据\n    deleteMetadata(k, o, p?): boolean\n}\n```\n\n#### 21.12.1 安装\n\n##### Metadata Reflection API\n\n- [Detailed proposal][metadata-spec]\n\n1. Installation\n\n```bash\nnpm install reflect-metadata\n```\n\n2. Background\n\n- Decorators add the ability to augment a class and its members as the class is defined, through a declarative syntax.\n- Traceur attaches annotations to a static property on the class.\n- Languages like C# (.NET), and Java support attributes or annotations that add metadata to types, along with a reflective API for reading metadata.\n\n3. Goals\n\n- A number of use cases (Composition/Dependency Injection, Runtime Type Assertions, Reflection/Mirroring, Testing) want the ability to add additional metadata to a class in a consistent manner.\n- A consistent approach is needed for various tools and libraries to be able to reason over metadata.\n- Metadata-producing decorators (nee. \"Annotations\") need to be generally composable with mutating decorators.\n- Metadata should be available not only on an object but also through a Proxy, with related traps.\n- Defining new metadata-producing decorators should not be arduous or over-complex for a developer.\n- Metadata should be consistent with other language and runtime features of ECMAScript.\n\n4. Syntax\n\n- Declarative definition of metadata:\n\n```javascript\nclass C {\n  @Reflect.metadata(metadataKey, metadataValue)\n  method() {}\n}\n```\n\n- Imperative definition of metadata:\n\n```javascript\nReflect.defineMetadata(metadataKey, metadataValue, C.prototype, \"method\");\n```\n\n- Imperative introspection of metadata:\n\n```javascript\nlet obj = new C();\nlet metadataValue = Reflect.getMetadata(metadataKey, obj, \"method\");\n```\n\n5. Semantics\n\n- Object has a new [[Metadata]] internal property that will contain a Map whose keys are property keys (or `undefined` ) and whose values are Maps of metadata keys to metadata values.\n- Object will have a number of new internal methods for [[DefineOwnMetadata]], [[GetOwnMetadata]], [[HasOwnMetadata]], etc.\n  - These internal methods can be overridden by a Proxy to support additional traps.\n  - These internal methods will by default call a set of abstract operations to define and read metadata.\n- The Reflect object will expose the MOP operations to allow imperative access to metadata.\n- Metadata defined on class declaration _C_ is stored in _C_.[[Metadata]], with `undefined` as the key.\n- Metadata defined on static members of class declaration _C_ are stored in _C_.[[Metadata]], with the property key as the key.\n- Metadata defined on instance members of class declaration _C_ are stored in _C_.prototype.[[Metadata]], with the property key as the key.\n\n1. API\n\n```javascript\n// define metadata on an object or property\nReflect.defineMetadata(metadataKey, metadataValue, target);\nReflect.defineMetadata(metadataKey, metadataValue, target, propertyKey);\n\n// check for presence of a metadata key on the prototype chain of an object or property\nlet result = Reflect.hasMetadata(metadataKey, target);\nlet result = Reflect.hasMetadata(metadataKey, target, propertyKey);\n\n// check for presence of an own metadata key of an object or property\nlet result = Reflect.hasOwnMetadata(metadataKey, target);\nlet result = Reflect.hasOwnMetadata(metadataKey, target, propertyKey);\n\n// get metadata value of a metadata key on the prototype chain of an object or property\nlet result = Reflect.getMetadata(metadataKey, target);\nlet result = Reflect.getMetadata(metadataKey, target, propertyKey);\n\n// get metadata value of an own metadata key of an object or property\nlet result = Reflect.getOwnMetadata(metadataKey, target);\nlet result = Reflect.getOwnMetadata(metadataKey, target, propertyKey);\n\n// get all metadata keys on the prototype chain of an object or property\nlet result = Reflect.getMetadataKeys(target);\nlet result = Reflect.getMetadataKeys(target, propertyKey);\n\n// get all own metadata keys of an object or property\nlet result = Reflect.getOwnMetadataKeys(target);\nlet result = Reflect.getOwnMetadataKeys(target, propertyKey);\n\n// delete metadata from an object or property\nlet result = Reflect.deleteMetadata(metadataKey, target);\nlet result = Reflect.deleteMetadata(metadataKey, target, propertyKey);\n\n// apply metadata via a decorator to a constructor\n@Reflect.metadata(metadataKey, metadataValue)\nclass C {\n  // apply metadata via a decorator to a method (property)\n  @Reflect.metadata(metadataKey, metadataValue)\n  method() {}\n}\n```\n\n7. Alternatives\n\n- Use properties rather than a separate API.\n  - Obvious downside is that this can be a lot of code:\n\n```javascript\nfunction ParamTypes(...types) {\n  return (target, propertyKey) => {\n    const symParamTypes = Symbol.for(\"design:paramtypes\");\n    if (propertyKey === undefined) {\n      target[symParamTypes] = types;\n    } else {\n      const symProperties = Symbol.for(\"design:properties\");\n      let properties, property;\n      if (Object.prototype.hasOwnProperty.call(target, symProperties)) {\n        properties = target[symProperties];\n      } else {\n        properties = target[symProperties] = {};\n      }\n      if (Object.prototype.hasOwnProperty.call(properties, propertyKey)) {\n        property = properties[propertyKey];\n      } else {\n        property = properties[propertyKey] = {};\n      }\n      property[symParamTypes] = types;\n    }\n  };\n}\n```\n\n8. Notes\n\n- Though it may seem counterintuitive, the methods on Reflect place the parameters for the metadata key and metadata value before the target or property key. This is due to the fact that the property key is the only optional parameter in the argument list. This also makes the methods easier to curry with Function#bind. This also helps reduce the overall footprint and complexity of a metadata-producing decorator that could target both a class or a property:\n\n```javascript\nfunction ParamTypes(...types) {\n  // as propertyKey is effectively optional, its easier to use here\n  return (target, propertyKey) => {\n    Reflect.defineMetadata(\"design:paramtypes\", types, target, propertyKey);\n  };\n\n  // vs. having multiple overloads with the target and key in the front:\n  //\n  // return (target, propertyKey) => {\n  //    if (propertyKey === undefined) {\n  //      Reflect.defineMetadata(target, \"design:paramtypes\", types);\n  //    }\n  //    else {\n  //      Reflect.defineMetadata(target, propertyKey, \"design:paramtypes\", types);\n  //    }\n  // }\n  //\n  // vs. having a different methods for the class or a property:\n  //\n  // return (target, propertyKey) => {\n  //    if (propertyKey === undefined) {\n  //      Reflect.defineMetadata(target, \"design:paramtypes\", types);\n  //    }\n  //    else {\n  //      Reflect.definePropertyMetadata(target, propertyKey, \"design:paramtypes\", types);\n  //    }\n  // }\n}\n```\n\n- To enable experimental support for metadata decorators in your TypeScript project, you must add `\"experimentalDecorators\": true` to your tsconfig.json file.\n- To enable experimental support for auto-generated type metadata in your TypeScript project, you must add `\"emitDecoratorMetadata\": true` to your tsconfig.json file.\n  - Please note that auto-generated type metadata may have issues with circular or forward references for types.\n\n9. Issues\n\n- A poorly written mutating decorator for a class constructor could cause metadata to become lost if the prototype chain is not maintained. Though, not maintaining the prototype chain in a mutating decorator for a class constructor would have other negative side effects as well. [@rbuckton ](/rbuckton)\n  - This is mitigated if the mutating decorator returns a class expression that extends from the target, or returns a proxy for the decorator. [@rbuckton ](/rbuckton)\n- Metadata for a method is attached to the class (or prototype) via the property key. It would not then be available if trying to read metadata on the function of the method (e.g. \"tearing-off\" the method from the class). [@rbuckton ](/rbuckton)\n\n[Metadata-Spec]: [https://rbuckton.github.io/reflect-metadata](https://rbuckton.github.io/reflect-metadata)\n\n## 二十二、Mixins 混入\n\n### 22.1 介绍\n\n> 除了传统的面向对象继承方式，还流行一种通用可重用组件创建类的方式，就是联合另一个简单类的代码。\n> 你可能在 `Scala` 等语言里对 `mixins` 及其特性已经很熟悉了，但它在 `JavaScript` 中也是很流行的。\n\n### 22.2 混入示例\n\n> 下面的代码演示了如何在 `TypeScript` 里使用混入。后面我们还会解释这段代码是如何工作的。\n\n```typescript\n// Disposable Mixin\nclass Disposable {\n  isDisposed: boolean;\n  dispose() {\n    this.isDisposed = true;\n  }\n}\n\n// Activatable Mixin\nclass Activatable {\n  isActive: boolean;\n  activate() {\n    this.isActive = true;\n  }\n  deactivate() {\n    this.isActive = false;\n  }\n}\n\nclass SmartObject implements Disposable, Activatable {\n  constructor() {\n    setInterval(() => console.log(this.isActive + \":\" + this.isDisposed), 500);\n  }\n\n  interact() {\n    this.activate();\n  }\n\n  // Disposable\n  isDisposed: boolean = false;\n  dispose: () => void;\n  // Activatable\n  isActive: boolean = false;\n  activate: () => void;\n  deactivate: () => void;\n}\n\napplyMixins(SmartObject, [Disposable, Activatable]);\nlet smartObj = new SmartObject();\nsetTimeout(() => smartObj.interact(), 1000);\n\n////////////////////////////////////////\n// In your runtime library somewhere\n////////////////////////////////////////\n\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      derivedCtor.prototype[name] = baseCtor.prototype[name];\n    });\n  });\n}\n```\n\n### 22.3 理解这个例子\n\n1. 代码里首先定义了两个类，它们将做为 `mixins`。可以看到每个类都只定义了一个特定的行为或功能。稍后我们使用它们来创建一个新类，同时具有这两种功能。\n\n```typescript\n// Disposable Mixin\nclass Disponsable {\n  isDisponsed: boolean;\n  dispose() {\n    this.isDisponsed = true;\n  }\n}\n\n// Activatable Mixin\nclass Activatable {\n  isActive: boolean;\n  activate() {\n    this.isActive = true;\n  }\n  deactivate() {\n    this.isActive = false;\n  }\n}\n```\n\n2. 下面创建一个类，结合了这两个 `mixins`。 下面来看一下具体是怎么操作的：\n\n```typescript\nclass SmartObject implements Disposable, Activatable {}\n```\n\n3. 首先应该注意到的是，没使用 `extends` 而是使用 `implements`。 把类当成了接口，仅使用 `Disposable` 和 `Activatable` 的类型而非其实现。 这意味着我们需要在类里面实现接口。但是这是我们在用 `mixin` 时想避免的。\n4. 我们可以这么做来达到目的，为将要 `mixin` 进来的属性方法创建出占位属性。这告诉编译器这些成员在运行时是可用的。 这样就能使用 `mixin` 带来的便利，虽说需要提前定义一些占位属性。\n\n```typescript\n// Disposable\n  isDisposed: boolean = false;\n  dispose: () => void;\n// Activatable\n  isActive: boolean = false;\n  activate: () => void;\n  deactivate: () => void;\n```\n\n5. 最后，把 `mixins` 混入定义的类，完成全部实现部分。\n\n```typescript\napplyMixins(SmartObject, [Disposable, Activatable]);\n```\n\n6. 最后，创建这个帮助函数，帮我们做混入操作。 它会遍历 `mixins` 上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。\n\n```typescript\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      derivedCtor.prototype[name] = baseCtor.prototype[name];\n    });\n  });\n}\n```\n\n## 二十三、三斜线指令\n\n- 三斜线指令是包含单个 `XML` 标签的单行注释。注释内容会做为编译器指令使用。\n- 三斜线指令仅可放在包含它的文件最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。如果它们出现在一个语句或声明之后，那么它们会被当作普通的单行注释，并且不具有特殊的含义。\n\n```typescript\n/// <reference path=\"...\" />\n/// <reference path=\"...\" /> 指令是三斜线指令中最常见的一种。 它用于声明文件间的 依赖。\n```\n\n- 三斜线引用告诉编译器在编译过程中要引入的额外文件。\n- 当使用 `--out` 或 `--outFile` 时，它也可以做为调整输出内容顺序的一种方法。文件在输出文件内容中的位置与经过预处理后的输入顺序一致。\n\n### 23.1 预处理输入文件\n\n> 编译器会对输入文件进行预处理来解析所有三斜线引用指令。在这个过程中，额外的文件会加到编译过程中。\n> 这个过程会以一些根文件开始；它们是在命令行中指定的文件或是在 `tsconfig.json` 中的 `\"files\"` 列表里的文件。这些根文件按指定的顺序进行预处理。在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。\n>   一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。\n\n### 23.2 错误\n\n> 引用不存在的文件会报错。一个文件用三斜线指令引用自己会报错。\n\n### 23.3 使用 `--noResolve`\n\n> 如果指定了 `--noResolve` 编译选项，三斜线指令会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。\n\n```typescript\n/// <reference types=\"...\" />\n```\n\n- 与 `/// <reference path=\"...\" />` 指令相似，这个指令是用来声明依赖的；一个 `/// <reference types=\"...\" />` 指令则声明了对某个包的依赖。\n- 对这些包的名字的解析与在 `import` 语句里对模块名的解析类似。可以简单地把三斜线类型引用指令当做 `import` 声明的包。\n- 例如，把 `/// <reference types=\"node\" />`引入到声明文件，表明这个文件使用了`@types/node/index.d.ts` 里面声明的名字；并且，这个包需要在编译阶段与声明文件一起被包含进来。\n- 仅当在你需要写一个 `.d.ts` 文件时才使用这个指令。\n- 对于那些在编译阶段生成的声明文件，编译器会自动地添加 `/// <reference types=\"...\" />`；当且仅当结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加  `/// <reference types=\"...\" />` 语句。\n- 若要在 `.ts` 文件里声明一个对 `@types` 包的依赖，使用 `--types` 命令行选项 或在 `tsconfig.json` 里指定。查看 在 `tsconfig.json` 里使用 `@types`，`typeRoots` 和 `types` 了解详情。\n- `/// <reference no-default-lib=\"true\"/>` 这个指令把一个文件标记成默认库。你会在 `lib.d.ts` 文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中不要包含这个默认库（比如，`lib.d.ts`）。 这与在命令行上使用 -`-noLib` 相似。\n- 还要注意，当传递了 `--skipDefaultLibCheck` 时，编译器只会忽略检查带有 `/// <reference no-default-lib=\"true\"/>` 的文件。\n\n### 23.4 `<amd-module />`\n\n> 默认情况下生成的 `AMD` 模块 都是匿名的。但是，当一些工具需要处理生成的模块时会产生问题，比如 `r.js。amd-module` 指令允许给编译器传入一个可选的模块名：\n\n- `amdModule.ts`\n\n```typescript\n/// <amd-module name=\"NamedModule\" />\nexport class C {}\n```\n\n> 这会将 `NamedModule` 传入到 `AMD define` 函数里：\n\n- `amdModule.js`\n\n```typescript\ndefine(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\n  var C = (function () {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});\n```\n\n### 23.5 `<amd-dependency />`\n\n- 注意：这个指令被废弃了。使用 `import \"moduleName\";` 语句代替。\n\n```typescript\n/// <amd-dependency path=\"x\" />\n\n// 告诉编译器有一个非 TypeScript 模块依赖需要被注入，做为目标模块 require 调用的一部分。\n```\n\n- `amd-dependency` 指令也可以带一个可选的 `name` 属性；它允许我们为 `amd-dependency` 传入一个可选名字：\n\n```typescript\n/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>\ndeclare var moduleA: MyType;\nmoduleA.callStuff();\n```\n\n- 生成的 `JavaScript` 代码：\n\n```typescript\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (require, exports, moduleA) {\n  moduleA.callStuff();\n});\n```\n\n## 二十四、JavaScript 文件类型检查\n\n### 24.1 JavaScript 文件类型检查\n\n> `TypeScript 2.3` 以后的版本支持使用 `--checkJs` 对 `.js` 文件进行类型检查和错误提示。\n\n> 你可以通过添加 `// @ts-nocheck` 注释来忽略类型检查；相反，你可以通过去掉 `--checkJs` 设置并添加一个 `// @ts-nocheck` 注释来选择检查某些 `.js` 文件。你还可以用 `// @ts-ignore` 来忽略本行的错误。如果你使用了 `tsconfig.json`，`JS` 检查将遵照一些严格检查标记，如 `noImplicitAny`，`strictNullChecks` 等。但因为 `JS` 检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。\n\n- 对比 `.js`文件和 `.ts` 文件在类型检查上的差异，有如下几点需要注意\n\n#### (1) 用 `JSDoc` 类型表示类型信息\n\n> `.js` 文件里，类型可以和在 `.ts` 文件里一样被推断出来。同样地，当类型不能被推断时，它们可以通过 `JSDoc` 来指定，就好比在 `.ts` 文件里那样。如同 `TypeScript`，`--noImplicitAny` 会在编译器无法推断类型的位置报错。（除了对象字面量的情况；后面会详细介绍）`JSDoc` 注解修饰的声明会被设置为这个声明的类型。比如：\n\n```typescript\n/** @type {number} */\nvar x;\nx = 0; // OK\nx = false; // Error: boolean is not assignable to number\n```\n\n> 你可以在这里找到所有 `JSDoc` 支持的模式，[JSDoc 文档](https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript)。\n\n#### (2) 属性的推断来自于类内的赋值语句\n\n> `ES2015` 没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。在 `.js` 文件里，编译器从类内部的属性赋值语句来推断属性类型。属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是 `undefined` 或 `null`。若是这种情况，类型将会是所有赋值的类型的联合类型。在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。\n\n```typescript\nclass C {\n  constructor() {\n    this.constructorOnly = 0;\n    this.constructorUnknown = undefined;\n  }\n  method() {\n    this.constructorOnly = false; // error, constructorOnly is a number\n    this.constructorUnknown = \"plunkbat\"; // ok, constructorUnknown is string | undefined\n    this.methodOnly = \"ok\"; // ok, but y could also be undefined\n  }\n  method2() {\n    this.methodOnly = true; // also, ok, y's type is string | boolean | undefined\n  }\n}\n```\n\n> 如果一个属性从没在类内设置过，它们会被当成未知的。\n\n> 如果类的属性只是读取用的，那么就在构造函数里用 `JSDoc` 声明它的类型。如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：\n\n```typescript\nclass C {\n  constructor() {\n    /** @type {name | undefined} */\n    this.prop = undefined;\n    /** @type {number | undefined} */\n    this.count;\n  }\n}\nlet c = new C();\nc.prop = 0; // Ok\nc.count = \"string\"; // Error: string is not assignable to number | undefined\n```\n\n#### (3) 构造函数等同于类\n\n> `ES2015` 以前，`Javascript` 使用构造函数代替类。编译器支持这种模式并能够将构造函数识别为 `ES2015` 的类。属性类型推断机制和上面介绍的一致。\n\n```typescript\nfunction C() {\n  this.constructorOnly = 0;\n  this.constructorUnknown = undefined;\n}\nC.prototype.method = function () {\n  this.constructorOnly = false; // error\n  this.constructorUnknown = \"plunkbat\"; // OK, the type is string | undefined\n};\n```\n\n#### (4) 支持 `CommonJS` 模块\n\n> 在 `.js` 文件里，`TypeScript` 能识别出 `CommonJS` 模块。对 `exports` 和 `module.exports` 的赋值被识别为导出声明。相似地，`require` 函数调用被识别为模块导入。例如：\n\n```typescript\n// same as `import module 'fs'`\nconst fs = require(\"fs\");\n// same as `export function readFile`\nmodule.exports.readFile = function (f) {\n  return fs.readFileSync(f);\n};\n```\n\n> 对 `JavaScript` 文件里模块语法的支持比在 `TypeScript` 里宽泛多了。 大部分的赋值和声明方式都是允许的。\n\n#### (5) 类，函数和对象字面量是命名空间\n\n```typescript\n// .js 文件里的类是命名空间。它可以用于嵌套类，比如：\nclass C {}\nC.D = class {};\n// ES2015 之前的代码，它可以用来模拟静态方法。\nfunction Outer() {\n  this.y = 2;\n}\nOuter.Inner = function () {\n  this.yy = 2;\n};\n// 它还可以用于创建简单的命名空间：\nvar ns = {};\nns.C = class {};\nns.func = function () {};\n// 同时还支持其它的变化\n// 立即调用的函数表达式\nvar ns = (function (n) {\n  return n | {};\n})();\nns.COUNT = 1;\n\n// defaulting to global\nvar assign =\n  assign ||\n  function () {\n    // code goes here\n  };\nassign.extra = 1;\n```\n\n#### (6) 对象字面量是开放的\n\n- `.ts` 文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。这个规则在 `.js` 文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：\n\n```typescript\nvar obj = { a: 1 };\nobj.b = 2; // Allowed\n```\n\n- 对象字面量的表现就好比具有一个默认的索引签名 `\\[x:string\\]: any`，它们可以被当成开放的映射而不是封闭的对象。\n- 与其它 `JS` 检查行为相似，这种行为可以通过指定 `JSDoc` 类型来改变，例如：\n\n```typescript\n/** @type {{ a: number }} */\nvar obj = { a: 1 };\nobj.b = 2; // Error, type {a: number} does not have property b\n```\n\n#### (7) null undefined 和 空数组的类型是 any 或 any[]\n\n> 任何用 `null`，`undefined` 初始化的变量，参数或属性，它们的类型是 `any`，就算是在严格 `null` 检查模式下。任何用 `[]` 初始化的变量，参数或属性，它们的类型是 `any[]`，就算是在严格 `null` 检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。\n\n```typescript\nfunction Foo(i = null) {\n  if (!i) i = 1;\n  var j = undefined;\n  j = 2;\n  this.l = [];\n}\nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push(\"end\");\n```\n\n#### (8) 函数参数是默认可选的\n\n> 由于在 `ES2015` 之前无法指定可选参数，因此 `.js` 文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。\n\n> 需要注意的一点是，使用过多的参数调用函数会得到一个错误。\n\n- 例如：\n\n```typescript\nfunction bar(a, b) {\n  console.log(a + \" \" + b);\n}\nbar(1); // OK, second argument considered optional\nbar(1, 2);\nbar(1, 2, 3); // Error, too many arguments\n```\n\n- 使用 `JSDoc` 注解的函数会被从这条规则里移除。使用 `JSDoc` 可选参数语法来表示可选性。\n\n```typescript\n// 比如：\n/**\n * @param {string} [somebody] - Somebody's name.\n */\nfunction sayHello(somebody) {\n  if (!somebody) {\n    somebody = \"John Doe\";\n  }\n  console.log(\"Hello \" + somebody);\n}\nsayHello();\n```\n\n#### (9) 由 `arguments` 推断出的 `var-args` 参数声明\n\n> 如果一个函数的函数体内有对 `arguments` 的引用，那么这个函数会隐式地被认为具有一个 `var-arg` 参数（比如: `(...arg: any[]) =>; any)`）。使用 `JSDoc` 的 `var-arg` 语法来指定 `arguments` 的类型。\n\n```typescript\n/** @param {...number} args */\nfunction sum(/* numbers */) {\n  var total = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\n```\n\n#### (10) 未指定的类型参数默认为 `any`\n\n> 由于 `JavaScript` 里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为 `any`。\n\n#### (11) 在 `extends` 语句中：\n\n> 例如，`React.Component` 被定义成具有两个类型参数，`Props` 和 `State`。 在一个 `.js` 文件里，没有一个合法的方式在 `extends` 语句里指定它们。默认地参数类型为 `any`：\n\n```typescript\nimport { Component } from \"react\";\n\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Allowed, since this.props is of type any\n  }\n}\n```\n\n> 使用 `JSDoc` 的 `@augments` 来明确地指定类型。\n\n- 例如：\n\n```typescript\nimport { Component } from \"react\";\n/**\n * @augments {Component<{a: number}, State>}\n */\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Error: b does not exist on {a:number}\n  }\n}\n```\n\n#### (12) 在 JSDoc 引用中\n\n```typescript\n/** @type{Array} */\nvar x = [];\n\nx.push(1); // OK\nx.push(\"string\"); // OK, x is of type Array<any>\n\n/** @type{Array.<number>} */\nvar y = [];\n\ny.push(1); // OK\ny.push(\"string\"); // Error, string is not assignable to number\n```\n\n#### (13) 在函数调用中\n\n> 泛型函数的调用使用 `arguments` 来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为 `any`。\n\n```typescript\n// 例如：\nvar p = new Promise((resolve, reject) => {\n  reject();\n});\np; // Promise<any>;\n```\n\n### 24.2 支持的 JSDoc\n\n> 面的列表列出了当前所支持的 `JSDoc` 注解，你可以用它们在 `JavaScript` 文件里添加类型信息。 注意，没有在下面列出的标记（例如 `@async`）都是还不支持的。\n\n```typescript\n1.  @type\n2.  @param (or @arg or @argument)\n3.  @returns (or @return)\n4.  @typedef\n5.  @callback\n6.  @template\n7.  @class (or @constructor)\n8.  @this\n9.  @extends (or @augments)\n10. @enum\n```\n\n> 它们代表的意义与 `usejsdoc.org` 上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。\n\n#### (1) [@type ](/type)\n\n> 可以使用 `@type` 标记并引用一个类型名称（原始类型，`TypeScript` 里声明的类型，或在 `JSDoc` 里 `@typedef` 标记指定的）可以使用任何 `TypeScript` 类型和大多数 `JSDoc` 类型。\n\n```typescript\n/** @type {string} */\nvar s;\n\n/** @type {Window} */\nvar win;\n\n/** @type {PromiseLike<string>} */\nvar promisedString;\n\n// You can specify an HTML Element with DOM properties\n/** @type {HTMLElement} */\n\nvar myElement = document.querySelector(selector);\nelement.dataset.myData = \"\";\n```\n\n- `@type` 可以指定联合类型—例如，`string` 和 `boolean` 类型的联合。\n\n```typescript\n/** @type {{string | boolean}} */\nvar sb;\n```\n\n- 注意：括号是可选的\n\n```typescript\n/** @type {string | boolean} */\nvar sb;\n```\n\n- 有多种方式来指定数组类型\n\n```typescript\n/** @type {number[]} */\nvar ns;\n/** @type {Array.<number>} */\nvar nds;\n/** @type {Array<number>} */\nvar nas;\n```\n\n- 还可以指定对象字面量类型。例如，一个带有 `a(字符串)` 和 `b(数字)` 属性的对象，使用下面的语法：\n\n```typescript\n/** @type {{a: string, b: number}} */\nvar var9;\n```\n\n- 可以使用字符串和数字索引签名来指定 `map-like` 和 `array-like` 的对象，使用标准的 `JSDoc` 语法或者 `TypeScript` 语法。\n\n```typescript\n/**\n * A map-like object that maps arbitrary `string` properties to `number`s.\n *\n * @type {Object.<string, number>}\n * */\nvar stringToNumber;\n/** @type {Object.<number, object>} */\nvar arrayLike;\n```\n\n- 这两个类型与 `TypeScript` 里的 `{ [x: string]: number }` 和 `{ [x: number]: any }` 是等同的。 编译器能识别出这两种语法。\n- 可以使用 `TypeScript` 或 `Closure` 语法指定函数类型。\n\n```typescript\n/** @type {function(string, boolean): number} Closure syntax */\nvar sbn;\n/** @type {(s: string, b: boolean) => number} Typescript syntax */\nvar sbn2;\n```\n\n- 或者直接使用未指定的 `Function` 类型：\n\n```typescript\n/** @type {Function} */\nvar fn7;\n/** @type {function} */\nvar fn6;\n```\n\n- `Closure` 的其它类型也可以使用：\n\n```typescript\n/** @type {*} - can be 'any' type */\nvar star;\n/** @type {?} - unknown type (same as 'any') */\nvar question;\n```\n\n#### (2) 转换\n\n> `TypeScript` 借鉴了 `Closure` 里的转换语法。在括号表达式前面使用 `@type` 标记，可以将一种类型转换成另一种类型\n\n```typescript\n/**\n * @type {number | string}\n */\nvar numberOrString = Math.random() < 0.5 ? \"hello\" : 100;\nvar typeAssertedNumber = /** @type {number} */ numberOrString;\n```\n\n#### (3) 导入类型\n\n> 可以使用导入类型从其它文件中导入声明。 这个语法是 `TypeScript` 特有的，与 `JSDoc` 标准不同：\n\n```typescript\n/**\n * @param p { import(\"./a\").Pet }\n */\nfunction walk(p) {\n  console.log(`Walking ${p.name}...`);\n}\n```\n\n> 导入类型也可以使用在类型别名声明中：\n\n```typescript\n/**\n * @typedef Pet { import(\"./a\").Pet }\n */\n\n/**\n * @type {Pet}\n */\nvar myPet;\nmyPet.name;\n```\n\n> 导入类型可以用在从模块中得到一个值的类型。\n\n```typescript\n/**\n * @type {typeof import(\"./a\").x }\n */\nvar x = require(\"./a\").x;\n```\n\n#### (4) [@param ](/param) 和 [@returns ](/returns)\n\n> `@param` 语法 和 `@type` 相同，但增加了一个参数名。 使用 `[]` 可以把参数声明为可选的：\n\n```typescript\n// Parameters may be declared in a variety of syntactic forms\n/**\n * @param {string}  p1 - A string param.\n * @param {string=} p2 - An optional param (Closure syntax)\n * @param {string} [p3] - Another optional param (JSDoc syntax).\n * @param {string} [p4=\"test\"] - An optional param with a default value\n * @return {string} This is the result\n */\nfunction stringsStringStrings(p1, p2, p3, p4) {\n  // TODO\n}\n```\n\n> 函数的返回值类型也是类似的：\n\n```typescript\n/**\n * @return {PromiseLike<string>}\n */\nfunction ps() {}\n\n/**\n * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'\n */\nfunction ab() {}\n```\n\n#### (5) @typedef, @callback, 和 [@param ](/param)\n\n> `@typedef` 可以用来声明复杂类型。和 `@param` 类似的语法。\n\n```typescript\n/**\n * @typedef {Object} SpecialType - creates a new type named 'SpecialType'\n * @property {string} prop1 - a string property of SpecialType\n * @property {number} prop2 - a number property of SpecialType\n * @property {number=} prop3 - an optional number property of SpecialType\n * @prop {number} [prop4] - an optional number property of SpecialType\n * @prop {number} [prop5=42] - an optional number property of SpecialType with default\n */\n/** @type {SpecialType} */\nvar specialTypeObject;\n```\n\n> 可以在第一行上使用 `object` 或 `Object`。\n\n```typescript\n/**\n * @typedef {object} SpecialType1 - creates a new type named 'SpecialType'\n * @property {string} prop1 - a string property of SpecialType\n * @property {number} prop2 - a number property of SpecialType\n * @property {number=} prop3 - an optional number property of SpecialType\n */\n/** @type {SpecialType1} */\nvar specialTypeObject1;\n```\n\n> `@param` 允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：\n\n```typescript\n/**\n * @param {Object} options - The shape is the same as SpecialType above\n * @param {string} options.prop1\n * @param {number} options.prop2\n * @param {number=} options.prop3\n * @param {number} [options.prop4]\n * @param {number} [options.prop5=42]\n */\nfunction special(options) {\n  return (options.prop4 || 1001) + options.prop5;\n}\n```\n\n> `@callback` 与 `@typedef` 相似，但它指定函数类型而不是对象类型：\n\n```typescript\n/**\n * @callback Predicate\n * @param {string} data\n * @param {number} [index]\n * @returns {boolean}\n */\n/** @type {Predicate} */\nconst ok = s => !(s.length % 2);\n```\n\n> 当然，所有这些类型都可以使用 `TypeScript` 的语法 `@typedef` 在一行上声明：\n\n```typescript\n/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n/** @typedef {(data: string, index?: number) => boolean} Predicate */\n```\n\n#### (6) [@template ](/template)\n\n> 使用 `@template` 声明泛型：\n\n```typescript\n/**\n * @template T\n * @param {T} p1 - A generic parameter that flows through to the return type\n * @return {T}\n */\nfunction id(x) {\n  return x;\n}\n```\n\n> 用逗号或多个标记来声明多个类型参数：\n\n```typescript\n/**\n * @template T,U,V\n * @template W,X\n */\n```\n\n> 还可以在参数名前指定类型约束。只有列表的第一项类型参数会被约束:\n\n```typescript\n/**\n * @template {string} K - K must be a string or string literal\n * @template {{ serious(): string }} Seriousalizable - must have a serious method\n * @param {K} key\n * @param {Seriousalizable} object\n */\nfunction seriousalize(key, object) {\n  // ????\n}\n```\n\n#### (7) [@constructor ](/constructor)\n\n> 编译器通过 `this` 属性的赋值来推断构造函数, 但你可以让检查更严格提示更友好, 你可以添加一个 `@constructor` 标记:\n\n```typescript\n/**\n * @constructor\n * @param {number} data\n */\nfunction C(data) {\n  this.size = 0;\n  this.initialize(data); // Should error, initializer expects a string\n}\n/**\n * @param {string} s\n */\nC.prototype.initialize = function (s) {\n  this.size = s.length;\n};\n\nvar c = new C(0);\nvar result = C(1); // C should only be called with new\n```\n\n> 通过 `@constructor`, `this` 将在构造函数`C`里被检查，因此你在 `initialize` 方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用`C`而不是构造它，也会得到一个错误。\n\n> 不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用 `@constructor`。\n\n#### (8) [@this ](/this)\n\n> 编译器通常可以通过上下文来推断出 `this` 的类型。但你可以使用 `@this` 来明确指定它的类型：\n\n```typescript\n/**\n * @this {HTMLElement}\n * @param {*} e\n */\nfunction callbackForLater(e) {\n  this.clientHeight = parseInt(e); // should be fine!\n}\n```\n\n#### (9) [@extends ](/extends)\n\n> 当 `JavaScript` 类继承了一个基类, 无处指定类型参数的类型, 而 `@extends` 标记提供了这样一种方式:\n\n```typescript\n/**\n * @template T\n * @extends {Set<T>}\n */\nclass SortableSet extends Set {\n  // ...\n}\n```\n\n> 注意 `@extends` 只作用于类。当前，无法实现构造函数继承类的情况。\n\n#### (10) [@enum ](/enum)\n\n> `@enum` 标记允许你创建一个对象字面量, 它的成员都有确定的类型。不同于 `JavaScript` 里大多数的对象字面量，它不允许添加额外成员。\n\n```typescript\n/** @enum {number} */\nconst JSDocState = {\n  BeginningOfLine: 0,\n  SawAsterisk: 1,\n  SavingComments: 2\n};\n```\n\n> 注意 `@enum` 与 `TypeScript` 的 `@enum` 大不相同, 它更加简单。然而，不同于 `TypeScript` 的枚举, `@enum` 可以是任何类型:\n\n```typescript\n/** @enum {function(number): number} */\nconst Math = {\n  add1: n => n + 1,\n  id: n => -n,\n  sub1: n => n - 1\n};\n```\n\n#### (11) 更多示例\n\n```tsx\nvar someObj = {\n  /**\n   * @param {string} param1 - Docs on property assignments work\n   */\n  x: function (param1) {}\n};\n\n/**\n * As do docs on variable assignments\n * @return {Window}\n */\nlet someFunc = function () {};\n\n/**\n * And class methods\n * @param {string} greeting The greeting to use\n */\nFoo.prototype.sayHi = greeting => console.log(\"Hi!\");\n\n/**\n * And arrow functions expressions\n * @param {number} x - A multiplier\n */\nlet myArrow = x => x * x;\n\n/**\n * Which means it works for stateless function components in JSX too\n * @param {{a: string, b: number}} test - Some param\n */\nvar sfc = test => <div>{test.a.charAt(0)}</div>;\n\n/**\n * A parameter can be a class constructor, using Closure syntax.\n *\n * @param {{new(...args: any[]): object}} C - The class to register\n */\nfunction registerClass(C) {}\n\n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn10(p1) {}\n\n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn9(p1) {\n  return p1.join();\n}\n```\n\n#### (12) 已知不支持的模式\n\n> 在值空间中将对象视为类型是不可以的, 除非对象创建了类型, 如构造函数。\n\n```typescript\nfunction aNormalFunction() {}\n/**\n * @type {aNormalFunction}\n */\nvar wrong;\n/**\n * Use 'typeof' instead:\n * @type {typeof aNormalFunction}\n */\nvar right;\n```\n\n> 对象字面量属性上的 `=` 后缀不能指定这个属性是可选的:\n\n```typescript\n/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * Use postfix question on the property name instead:\n * @type {{ a: string, b?: number }}\n */\nvar right;\n```\n\n> `Nullable` 类型只在启用了 `strictNullChecks` 检查时才启作用:\n\n```typescript\n/**\n * @type {?number}\n * With strictNullChecks: true -- number | null\n * With strictNullChecks: off  -- number\n */\nvar nullable;\n```\n\n> `Non-nullable` 类型没有意义, 以其原类型对待:\n\n```typescript\n/**\n * @type {!number}\n * Just has type number\n */\nvar normal;\n```\n\n> 不同于 `JSDoc` 类型系统, `TypeScript` 只允许将类型标记为包不包含 `null`。`Non-nullable` -- 如果启用了 `strictNullChecks`，那么 `number` 是 `非null` 的。 如果没有启用，那么 `number` 是可以为 `null` 的。\n","slug":"前端/TypeScript 文档","published":1,"updated":"2021-04-07T07:30:04.867Z","_id":"ckn7476az003fyx7ybx8ffg98","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、-基础类型\"><a href=\"#一、-基础类型\" class=\"headerlink\" title=\"一、 基础类型\"></a>一、 基础类型</h2><h3 id=\"1-1-类型断言\"><a href=\"#1-1-类型断言\" class=\"headerlink\" title=\"1.1 类型断言\"></a>1.1 类型断言</h3><blockquote>\n<p>有时候你会遇到这样的情况，你会比 <code>TypeScript</code> 更了解某个值的详细信息。通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。类型断言好比其它语言里的类型转换，但是不尽兴特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p>\n</blockquote>\n<ul>\n<li><p>类型断言有两种形式</p>\n</li>\n<li><p>第一种：尖括号语法 (当在 <code>TypeScript</code> 里使用 <code>JSX</code> 时，只有 <code>as</code> 语言断言是被允许的)</p>\n</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种：<code>as</code> 语法</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _someValue: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _strLength: <span class=\"built_in\">number</span> = (_someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-基础类型\"><a href=\"#1-2-基础类型\" class=\"headerlink\" title=\"1.2 基础类型\"></a>1.2 基础类型</h3><h4 id=\"1-2-1-布尔值\"><a href=\"#1-2-1-布尔值\" class=\"headerlink\" title=\"1.2.1 布尔值\"></a>1.2.1 布尔值</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-2-数字\"><a href=\"#1-2-2-数字\" class=\"headerlink\" title=\"1.2.2 数字\"></a>1.2.2 数字</h4><blockquote>\n<p>与 <code>javascript</code> 一样，<code>TypeScript</code> 里的所有数字都是浮点数。这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量， <code>TypeScript</code> 还支持 <code>ECMA2015</code> 中引入的二进制和八进制字面量。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0xf00d</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b1010</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o744</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-3-字符串\"><a href=\"#1-2-3-字符串\" class=\"headerlink\" title=\"1.2.3 字符串\"></a>1.2.3 字符串</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strName: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;bob&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-4-数组\"><a href=\"#1-2-4-数组\" class=\"headerlink\" title=\"1.2.4 数组\"></a>1.2.4 数组</h4><blockquote>\n<p><code>TypeScript</code> 像 <code>JavaScript</code> 一样可以操作数组元素。有两种方法定义数组。</p>\n</blockquote>\n<ul>\n<li>第一种：可以在元素类型后面接上 <code>[]</code>;</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list1: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种：使用数组泛型, <code>Array&lt;元素类型&gt;</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list2: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-5-元组-Tuple\"><a href=\"#1-2-5-元组-Tuple\" class=\"headerlink\" title=\"1.2.5 元组 Tuple\"></a>1.2.5 元组 Tuple</h4><ul>\n<li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br><span class=\"line\">x = [<span class=\"string\">&quot;hello&quot;</span>, <span class=\"number\">10</span>]; <span class=\"comment\">// =&gt; Ok</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">&quot;hello&quot;</span>]; <span class=\"comment\">// =&gt; Error</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当访问一个已知索引的元素，会得到正确的类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)); <span class=\"comment\">// =&gt; Ok</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)); <span class=\"comment\">// =&gt; Error</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当访问一个越界的元素，会使用联合类型替代</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">&quot;world&quot;</span>; <span class=\"comment\">// Ok, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()); <span class=\"comment\">// Ok, &quot;string&quot;和&quot;number&quot;都有toString方法</span></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span>; <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-6-枚举\"><a href=\"#1-2-6-枚举\" class=\"headerlink\" title=\"1.2.6 枚举\"></a>1.2.6 枚举</h4><ul>\n<li><code>enum</code> 类型是对 <code>JavaScript</code> 标准数据类型的一个补充。像 <code>C#</code> 等其他语言一样，使用枚举类型可以为一组数值赋予友好的名字</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认情况下，从 <code>0</code> 开始为元素编号。你也可以手动的指定成员的数值。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color1 &#123;</span><br><span class=\"line\">  Red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c1: Color1 = Color1.Green;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>或者全部采用赋值</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color2 &#123;</span><br><span class=\"line\">  Red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  Green = <span class=\"number\">2</span>,</span><br><span class=\"line\">  Blue = <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c2: Color2 = Color2.Green;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color3 &#123;</span><br><span class=\"line\">  Red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color3[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-7-Any\"><a href=\"#1-2-7-Any\" class=\"headerlink\" title=\"1.2.7 Any\"></a>1.2.7 Any</h4><ul>\n<li>有时候，我们想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自于动态的内容，比如来自用户输入或第三方库。这种情况下，我们不希望类型检查器对这些值进行检查而是让它们通过编译阶段的检查。那么我们可以使用 <code>any</code> 类型来标记这些变量</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">notSure = <span class=\"string\">&quot;maybe a string instead&quot;</span>;</span><br><span class=\"line\">notSure = <span class=\"literal\">false</span>; <span class=\"comment\">// Ok</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。你可能认为 <code>Object</code> 有相似的作用，就像在其他语言中那样。但是 <code>Object</code> 类型的变量只是允许你给他赋任意值，但是却不能够在它上面调用任意的方法，即使它真有这些方法。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure1: <span class=\"built_in\">any</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">notSure1.ifItExists(); <span class=\"comment\">// Ok</span></span><br><span class=\"line\">notSure1.toFixed(); <span class=\"comment\">// Ok</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> prettySure: <span class=\"built_in\">Object</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">// prettySure.toFixed(); // Error, Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当你只知道一部分数据类型时，<code>any</code> 类型也是有用的。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">&quot;free&quot;</span>];</span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-8-Void\"><a href=\"#1-2-8-Void\" class=\"headerlink\" title=\"1.2.8 Void\"></a>1.2.8 Void</h4><ul>\n<li>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;This is my warning message&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusbale: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-9-Null-和-Undefined\"><a href=\"#1-2-9-Null-和-Undefined\" class=\"headerlink\" title=\"1.2.9 Null 和 Undefined\"></a>1.2.9 Null 和 Undefined</h4><ul>\n<li><code>TypeScript</code> 里，<code>undefined</code> 和 <code>null</code> 两者各有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。和 <code>void</code> 相似，它们本身的类型用处不是很大。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</li>\n<li>然而，当你指定了一个 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自。这能避免很多常见的问题。也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。</li>\n</ul>\n<h4 id=\"1-2-10-Never\"><a href=\"#1-2-10-Never\" class=\"headerlink\" title=\"1.2.10 Never\"></a>1.2.10 Never</h4><ul>\n<li><code>never</code> 类型表示的是那些永不存在的值的类型。例如：<code>never</code> 类型是那些总会抛出异常或根本不会有返回值的函数表达式或箭头函数表达式的返回值类型；</li>\n<li>变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</li>\n<li><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；</li>\n</ul>\n<blockquote>\n<p>然而，没有类型是 <code>never</code> 的子类型或可以赋值给 <code>never</code> 类型(除了 <code>never</code> 本身之外)。即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回 never 的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> error(<span class=\"string\">&quot;Something failed&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回 never 的函数必须存在法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-11-Object\"><a href=\"#1-2-11-Object\" class=\"headerlink\" title=\"1.2.11 Object\"></a>1.2.11 Object</h4><ul>\n<li><code>Object</code> 表示非原始类型，也就是除 <code>number</code>, <code>string</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code> 或 <code>undefined</code> 之外的类型。</li>\n<li>使用 <code>Object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: <span class=\"built_in\">object</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\">create(&#123; <span class=\"attr\">prop</span>: <span class=\"number\">0</span> &#125;); <span class=\"comment\">// Ok</span></span><br><span class=\"line\">create(<span class=\"literal\">null</span>); <span class=\"comment\">// Ok</span></span><br><span class=\"line\">create(<span class=\"number\">42</span>); <span class=\"comment\">//Error</span></span><br><span class=\"line\">create(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"literal\">false</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"literal\">undefined</span>); <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、变量声明\"><a href=\"#二、变量声明\" class=\"headerlink\" title=\"二、变量声明\"></a>二、变量声明</h2><h3 id=\"2-1-介绍\"><a href=\"#2-1-介绍\" class=\"headerlink\" title=\"2.1 介绍\"></a>2.1 介绍</h3><blockquote>\n<p><code>let</code> 和 <code>const</code> 是 <code>JavaScript</code> 里相对较新的变量声明方式。 像我们之前提到过的， <code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 <code>JavaScript</code> 里常见一些问题。 <code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。<br>因为 <code>TypeScript</code> 是 <code>JavaScript</code> 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code> 。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。<br>如果你之前使用 <code>JavaScript</code> 时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>\n</blockquote>\n<h3 id=\"2-2-var-声明\"><a href=\"#2-2-var-声明\" class=\"headerlink\" title=\"2.2 var 声明\"></a>2.2 var 声明</h3><blockquote>\n<p>一直以来我们都是通过 <code>var</code> 关键字定义 <code>JavaScript</code> 变量。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。<br>我们也可以在函数内部定义变量：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>并且我们也可以在其它函数内部访问相同的变量。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\">g(); <span class=\"comment\">// returns 11;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的例子里，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问及修改 <code>a</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  a = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = g();</span><br><span class=\"line\">  a = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// returns 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-作用域规则\"><a href=\"#2-3-作用域规则\" class=\"headerlink\" title=\"2.3 作用域规则\"></a>2.3 作用域规则</h3><blockquote>\n<p>对于熟悉其它语言的人来说，<code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">shouldInitialize: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">true</span>); <span class=\"comment\">// returns &#x27;10&#x27;</span></span><br><span class=\"line\">f(<span class=\"literal\">false</span>); <span class=\"comment\">// returns &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有些读者可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面_，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为 <code>var</code> 作用域或函数作用域。函数参数也使用函数作用域。<br>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>\n</blockquote>\n<h3 id=\"2-4-捕获变量怪异之处\"><a href=\"#2-4-捕获变量怪异之处\" class=\"headerlink\" title=\"2.4 捕获变量怪异之处\"></a>2.4 捕获变量怪异之处</h3><blockquote>\n<p>快速的猜一下下面的代码会返回什么：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>介绍一下，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。<br>好吧，看一下结果：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>很多 <code>JavaScript</code> 程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>还记得我们上面提到的捕获变量吗？<br>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。<br>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。 <code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10！</code><br>一个通常的解决方法是使用立即执行的函数表达式（<code>IIFE</code>）来捕获每次迭代时 <code>i</code> 的值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// capture the current state of &#x27;i&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\">// by invoking a function with its current value</span></span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">  &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p>\n</blockquote>\n<h3 id=\"2-5-let-声明\"><a href=\"#2-5-let-声明\" class=\"headerlink\" title=\"2.5 let 声明\"></a>2.5 let 声明</h3><blockquote>\n<p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， let 与 <code>var</code> 的写法一致。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>\n</blockquote>\n<h3 id=\"2-6-块作用域\"><a href=\"#2-6-块作用域\" class=\"headerlink\" title=\"2.6 块作用域\"></a>2.6 块作用域</h3><blockquote>\n<p>当用 <code>let</code> 声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">input: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Still okay to reference &#x27;a&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Error: &#x27;b&#x27; doesn&#x27;t exist here</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里我们定义了<code>2</code>个变量 <code>a</code> 和 <code>b</code> 。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。<br>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">&quot;oh no!&quot;</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Oh well.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: &#x27;e&#x27; doesn&#x27;t exist here</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++; <span class=\"comment\">// illegal to use &#x27;a&#x27; before it&#x27;s declared;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 <code>ES2015</code>，现代的运行时会抛出一个错误；然而，现今 <code>TypeScript</code> 是不会报错的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// okay to capture &#x27;a&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能在&#x27;a&#x27;被声明前调用&#x27;foo&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 运行时应该抛出错误</span></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于暂时性死区的更多信息，查看这里 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\">Mozilla Developer Network.</a></p>\n</blockquote>\n<h3 id=\"2-7-重定义及屏蔽\"><a href=\"#2-7-重定义及屏蔽\" class=\"headerlink\" title=\"2.7 重定义及屏蔽\"></a>2.7 重定义及屏蔽</h3><blockquote>\n<p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 <code>1</code> 个。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的 <code>x</code>，并且这是完全有效的代码。 这经常会成为<code>bug</code> 的来源。 好的是， <code>let</code> 声明就不会这么宽松了。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span>; <span class=\"comment\">// 错误，不能在1个作用域里多次声明`x</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>并不是要求两个均是块级作用域的声明 <code>TypeScript</code> 才会给出一个错误的警告。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// error: interferes with parameter declaration</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// error: can&#x27;t have both declarations of &#x27;x&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">condition, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">false</span>, <span class=\"number\">0</span>); <span class=\"comment\">// returns 0</span></span><br><span class=\"line\">f(<span class=\"literal\">true</span>, <span class=\"number\">0</span>); <span class=\"comment\">// returns 100</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个版本的循环能得到正确的结果，因为内层循环的 i 可以屏蔽掉外层循环的 <code>i</code>。<br>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p>\n</blockquote>\n<h3 id=\"2-8-块级作用域变量的获取\"><a href=\"#2-8-块级作用域变量的获取\" class=\"headerlink\" title=\"2.8 块级作用域变量的获取\"></a>2.8 块级作用域变量的获取</h3><blockquote>\n<p>在我们最初谈及获取用 <code>var</code> 声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">theCityThatAlwaysSleeps</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> getCity;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> city = <span class=\"string\">&quot;Seattle&quot;</span>;</span><br><span class=\"line\">    getCity = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getCity();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因为我们已经在 <code>city</code> 的环境里获取到了 <code>city</code> ，所以就算 if 语句执行结束后我们仍然可以访问它。<br>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。<br>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>会输出与预料一致的结果：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-9-const-声明\"><a href=\"#2-9-const-声明\" class=\"headerlink\" title=\"2.9 const 声明\"></a>2.9 const 声明</h3><blockquote>\n<p><code>const</code> 声明是声明变量的另一种方式。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。<br>这很好理解，它们引用的值是不可变的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;Aurora&quot;</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;Danielle&quot;</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// all &quot;okay&quot;</span></span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Rory&quot;</span>;</span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Kitty&quot;</span>;</span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Cat&quot;</span>;</span><br><span class=\"line\">kitty.numLives--;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。 接口一章有详细说明。</p>\n</blockquote>\n<h3 id=\"2-10-let-vs-const\"><a href=\"#2-10-let-vs-const\" class=\"headerlink\" title=\"2.10 let vs. const\"></a>2.10 let vs. const</h3><blockquote>\n<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。<br>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 <code>const</code> 也可以让我们更容易的推测数据的流动。<br>跟据你的自己判断，如果合适的话，与团队成员商议一下。<br>这个手册大部分地方都使用了 <code>let</code> 声明。</p>\n</blockquote>\n<h3 id=\"2-11-解构\"><a href=\"#2-11-解构\" class=\"headerlink\" title=\"2.11 解构\"></a>2.11 解构</h3><blockquote>\n<p><code>Another TypeScript</code> 已经可以解析其它 <code>ECMAScript 2015</code> 特性了。 完整列表请参见 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">the article on the Mozilla Developer Network</a>。 本章，我们将给出一个简短的概述。</p>\n</blockquote>\n<h4 id=\"2-11-1-解构数组\"><a href=\"#2-11-1-解构数组\" class=\"headerlink\" title=\"2.11.1 解构数组\"></a>2.11.1 解构数组</h4><blockquote>\n<p>最简单的解构莫过于数组的解构赋值了：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second); <span class=\"comment\">// outputs 2</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这创建了 <code>2</code> 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first = input[<span class=\"number\">0</span>];</span><br><span class=\"line\">second = input[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>解构作用于已声明的变量会更好：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// swap variables</span></span><br><span class=\"line\">[first, second] = [second, first];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>作用于函数参数：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(first);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(second);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(input);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然，由于是 <code>JavaScript</code>, 你可以忽略你不关心的尾随元素：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>或其它元素：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-11-2-对象解构\"><a href=\"#2-11-2-对象解构\" class=\"headerlink\" title=\"2.11.2 对象解构\"></a>2.11.2 对象解构</h4><blockquote>\n<p>你也可以解构对象：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">  a: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">  b: <span class=\"number\">12</span>,</span><br><span class=\"line\">  c: <span class=\"string\">&quot;bar&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这通过 <code>o.a and o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。<br>就像数组解构，你可以用没有声明的赋值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123; a, b &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;baz&quot;</span>, <span class=\"attr\">b</span>: <span class=\"number\">101</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，我们需要用括号将它括起来，因为 <code>Javascript</code> 通常会将以 <code>&#123;</code> 起始的语句解析为一个块。<br>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.b + passthrough.c.length;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-11-3-属性重命名\"><a href=\"#2-11-3-属性重命名\" class=\"headerlink\" title=\"2.11.3 属性重命名\"></a>2.11.3 属性重命名</h4><blockquote>\n<p>你也可以给属性以不同的名字：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">a</span>: newName1, <span class=\"attr\">b</span>: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 “<code>a</code> 作为 <code>newName1</code>“。 方向是从左到右，好像你写成了以下样子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.a;</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.b;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125;: &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; b: <span class=\"built_in\">number</span> &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-11-4-默认值\"><a href=\"#2-11-4-默认值\" class=\"headerlink\" title=\"2.11.4 默认值\"></a>2.11.4 默认值</h4><blockquote>\n<p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>; b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>\n</blockquote>\n<h4 id=\"2-11-5-函数声明\"><a href=\"#2-11-5-函数声明\" class=\"headerlink\" title=\"2.11.5 函数声明\"></a>2.11.5 函数声明</h4><blockquote>\n<p>解构也能用于函数声明。 看以下简单的情况：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; b?: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a = <span class=\"string\">&quot;&quot;</span>, b = <span class=\"number\">0</span> &#125; = &#123;&#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的代码是一个类型推断的例子，将在本手册后文介绍。<br>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 <code>C</code> 的定义有一个 <code>b</code> 可选属性：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b = <span class=\"number\">0</span> &#125; = &#123; a: <span class=\"string\">&quot;&quot;</span> &#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;yes&quot;</span> &#125;); <span class=\"comment\">// ok, default b = 0</span></span><br><span class=\"line\">f(); <span class=\"comment\">// ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0</span></span><br><span class=\"line\">f(&#123;&#125;); <span class=\"comment\">// error, &#x27;a&#x27; is required if you supply an argument</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p>\n</blockquote>\n<h4 id=\"2-11-6-展开\"><a href=\"#2-11-6-展开\" class=\"headerlink\" title=\"2.11.6 展开\"></a>2.11.6 展开</h4><blockquote>\n<p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second</code> 的一份浅拷贝。 它们不会被展开操作所改变。<br>你还可以展开对象：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; <span class=\"attr\">food</span>: <span class=\"string\">&quot;spicy&quot;</span>, <span class=\"attr\">price</span>: <span class=\"string\">&quot;$$&quot;</span>, <span class=\"attr\">ambiance</span>: <span class=\"string\">&quot;noisy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, <span class=\"attr\">food</span>: <span class=\"string\">&quot;rich&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>search</code> 的值为 <code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; <span class=\"attr\">food</span>: <span class=\"string\">&quot;spicy&quot;</span>, <span class=\"attr\">price</span>: <span class=\"string\">&quot;$$&quot;</span>, <span class=\"attr\">ambiance</span>: <span class=\"string\">&quot;noisy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; <span class=\"attr\">food</span>: <span class=\"string\">&quot;rich&quot;</span>, ...defaults &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: &quot;rich&quot;</code>，在这里这并不是我们想要的结果。<br>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\">自身的可枚举属性</a>。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  p = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">m</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = &#123; ...c &#125;;</span><br><span class=\"line\">clone.p; <span class=\"comment\">// ok</span></span><br><span class=\"line\">clone.m(); <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其次，<code>TypeScript</code> 编译器不允许展开泛型函数上的类型参数。 这个特性会在 <code>TypeScript</code> 的未来版本中考虑实现。</p>\n</blockquote>\n<h2 id=\"三、接口\"><a href=\"#三、接口\" class=\"headerlink\" title=\"三、接口\"></a>三、接口</h2><h3 id=\"3-1-实现一个简单的接口\"><a href=\"#3-1-实现一个简单的接口\" class=\"headerlink\" title=\"3.1 实现一个简单的接口\"></a>3.1 实现一个简单的接口</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelledValue &#123;</span><br><span class=\"line\">  label: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123; <span class=\"attr\">size</span>: <span class=\"number\">10</span>, <span class=\"attr\">label</span>: <span class=\"string\">&quot;size 10 Object&quot;</span> &#125;;</span><br><span class=\"line\">printLabel(myObj);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-可选属性\"><a href=\"#3-2-可选属性\" class=\"headerlink\" title=\"3.2 可选属性\"></a>3.2 可选属性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createConfig</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;white&quot;</span>, <span class=\"attr\">area</span>: <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createConfig(&#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;black&quot;</span>, <span class=\"attr\">width</span>: <span class=\"number\">20</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mySquare);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-只读属性\"><a href=\"#3-3-只读属性\" class=\"headerlink\" title=\"3.3 只读属性\"></a>3.3 只读属性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Point &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1: Point = &#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">p1.x = <span class=\"number\">5</span>; <span class=\"comment\">// error! 因为属性是只读的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-额外的属性检查\"><a href=\"#3-4-额外的属性检查\" class=\"headerlink\" title=\"3.4 额外的属性检查\"></a>3.4 额外的属性检查</h3><blockquote>\n<p>问题：将” <em>可选属性</em> “与” <code>option bags</code> “模式相结合而引发</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createConfig</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;white&quot;</span>, <span class=\"attr\">area</span>: <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>let mySquare = createConfig(&#123; colour: &quot;red&quot;, width: 100 &#125;); //报错</code></p>\n</blockquote>\n<ul>\n<li>解决方案一：采用类型断言</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createConfig(&#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">opacity</span>: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解决方案二：采用添加一个字符串索引签名(最佳方案)</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> _SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解决方案三：变量赋值</li>\n</ul>\n<h3 id=\"3-5-函数类型\"><a href=\"#3-5-函数类型\" class=\"headerlink\" title=\"3.5 函数类型\"></a>3.5 函数类型</h3><h4 id=\"3-5-1-函数类型\"><a href=\"#3-5-1-函数类型\" class=\"headerlink\" title=\"3.5.1 函数类型\"></a>3.5.1 函数类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc &#123;</span><br><span class=\"line\">  (source: <span class=\"built_in\">string</span>, <span class=\"attr\">subString</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = source.search(subString);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-5-2-函数类型\"><a href=\"#3-5-2-函数类型\" class=\"headerlink\" title=\"3.5.2 函数类型\"></a>3.5.2 函数类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> add: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> add2 = (x: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>): <span class=\"function\"><span class=\"params\">number</span> =&gt;</span> x + y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buildNameFun: <span class=\"function\">(<span class=\"params\">fname: <span class=\"built_in\">string</span>, ...rest: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">string</span>&gt;</span>) =&gt;</span> <span class=\"built_in\">string</span> = <span class=\"function\">(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">string</span>&gt;</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;firstName&#125;</span>, <span class=\"subst\">$&#123;restOfName.join(<span class=\"string\">&quot; &quot;</span>)&#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = (a: <span class=\"built_in\">number</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): <span class=\"function\"><span class=\"params\">number</span> =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-5-3-函数类型\"><a href=\"#3-5-3-函数类型\" class=\"headerlink\" title=\"3.5.3 函数类型\"></a>3.5.3 函数类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> func &#123;</span><br><span class=\"line\">  (x: <span class=\"built_in\">string</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> func: func = <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span>, y: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.search(y) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-6-可索引类型\"><a href=\"#3-6-可索引类型\" class=\"headerlink\" title=\"3.6 可索引类型\"></a>3.6 可索引类型</h3><ul>\n<li>例如：<code>a[10]</code> 或 <code>ageMap[&quot;daniel&quot;]</code></li>\n<li>可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: StringArray;</span><br><span class=\"line\">myArray = [<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Fred&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> myStr: <span class=\"built_in\">string</span> = myArray[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myStr);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Ts</code> 支持两种索引签名：字符串 和 数字。可以同时使用两种类型的索引，但数字索引的返回值必须是字符串索引返回值类型的子类型。</p>\n</blockquote>\n<h3 id=\"3-7-类类型\"><a href=\"#3-7-类类型\" class=\"headerlink\" title=\"3.7 类类型\"></a>3.7 类类型</h3><blockquote>\n<p>接口描述了类的公共部分，而不是类的公有和私有两部分。它不会帮你检查类是否具有某些私有成员</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>); <span class=\"comment\">// 在接口中描述的方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"title\">implements</span> <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setTime</span>(<span class=\"params\">d: <span class=\"built_in\">Date</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在类中的具体实现</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.currentTime = d;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当操作类的时候，我们需要知道类是具有两个类型的：<em>静态部分的类型</em> 和 _实例的类型_。<br>当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误。<br>因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p>\n</blockquote>\n<ul>\n<li>因此应当直接操作 <em>类的静态部分</em></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> err_ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, <span class=\"attr\">minute</span>: <span class=\"built_in\">number</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">err_Clock</span> <span class=\"title\">implements</span> <span class=\"title\">err_ClockConstructor</span> </span>&#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下面是实现对 <em>静态类型</em> 的检查工作</li>\n</ul>\n<blockquote>\n<p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, <span class=\"attr\">minute</span>: <span class=\"built_in\">number</span>): ClockInterface;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  tick();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createClock</span>(<span class=\"params\">ctor: ClockConstructor, hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span></span>): <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ctor(hour, minute);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DigitalClock</span> <span class=\"title\">implements</span> <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">tick</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;beep beep&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnalogClock</span> <span class=\"title\">implements</span> <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">tick</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;tick tick&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = createClock(DigitalClock, <span class=\"number\">12</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = createClock(AnalogClock, <span class=\"number\">7</span>, <span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(digital);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(analog);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-8-接口继承\"><a href=\"#3-8-接口继承\" class=\"headerlink\" title=\"3.8 接口继承\"></a>3.8 接口继承</h3><ul>\n<li>和类一样，接口也可以相互继承。可以灵活地将接口分割到可重用的模块里。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一个接口可以继承多个接口，创建出多个接口的合成接口</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke &#123;</span><br><span class=\"line\">  penWidth: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape, PenStroke &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span>;</span><br><span class=\"line\">square.penWidth = <span class=\"number\">5.0</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>目的: <code>=&gt;</code> 灵活地将接口分割到可重用的模块中</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lamp &#123;</span><br><span class=\"line\">  lampOn(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  lampOff(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> wx &#123;</span><br><span class=\"line\">  wxNumber: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  showWxNumber(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Photo <span class=\"keyword\">extends</span> Lamp, wx &#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuaWeiPhone</span> <span class=\"title\">implements</span> <span class=\"title\">Photo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wxNumber: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;华为手机&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  lampOn(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  lampOff(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">wxNumber: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.wxNumber = wxNumber;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  showWxNumber(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;我的微信号：123&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> huaWeiPhone = <span class=\"keyword\">new</span> HuaWeiPhone(<span class=\"number\">12345678910</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(huaWeiPhone.showWxNumber());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(huaWeiPhone.photo());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-9-混合类型\"><a href=\"#3-9-混合类型\" class=\"headerlink\" title=\"3.9 混合类型\"></a>3.9 混合类型</h3><blockquote>\n<p>一个对象可以同时做为函数和对象使用，并带有额外的属性</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">  (start: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  interval: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  reset(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> counter = &lt;Counter&gt;<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// return start + &#x27;string&#x27;;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  counter.interval = <span class=\"number\">123</span>;</span><br><span class=\"line\">  counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter();</span><br><span class=\"line\">c(<span class=\"number\">10</span>);</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span>;</span><br><span class=\"line\">c.reset();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-10-接口继承类\"><a href=\"#3-10-接口继承类\" class=\"headerlink\" title=\"3.10 接口继承类\"></a>3.10 接口继承类</h3><ol>\n<li>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。</li>\n<li>就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。</li>\n<li>接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。</li>\n<li>这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现( <code>implement</code> )。</li>\n<li>当你有一个庞大的继承接口时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。这个子类除了继承至基类外与基类没有任何关系。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Control</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">Control</span> <span class=\"title\">implements</span> <span class=\"title\">SelectableControl</span> </span>&#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextBox</span> <span class=\"keyword\">extends</span> <span class=\"title\">Control</span> </span>&#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：&quot;Image&quot;类型缺少&quot;state&quot;属性</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Image</span> <span class=\"title\">implements</span> <span class=\"title\">SelectableControl</span> </span>&#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Location</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在上面的例子中，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员。包括私有成员 <code>state</code>。因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口，因为只有 <code>Control</code> 的子类才能够拥有一个声明于 <code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。<br>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code> 和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类(因为它们都继承自 <code>Control</code> 并有 <code>select</code> 方法，但 <code>Image</code> 和 <code>Location</code> 类并不是这样的。)</p>\n</blockquote>\n<h3 id=\"3-11-接口继承接口\"><a href=\"#3-11-接口继承接口\" class=\"headerlink\" title=\"3.11 接口继承接口\"></a>3.11 接口继承接口</h3><blockquote>\n<p>目的: <code>=&gt;</code> 灵活地将接口分割到可重用的模块中</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lamp &#123;</span><br><span class=\"line\">  lampOn(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  lampOff(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> wx &#123;</span><br><span class=\"line\">  wxNumber: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  showWxNumber(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Photo <span class=\"keyword\">extends</span> Lamp, wx &#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuaWeiPhone</span> <span class=\"title\">implements</span> <span class=\"title\">Photo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wxNumber: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;华为手机&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOn</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOff</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">wxNumber: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.wxNumber = wxNumber;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">showWxNumber</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;我的微信号是：123&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> huaWeiPhone = <span class=\"keyword\">new</span> HuaWeiPhone(<span class=\"number\">13100970071</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(huaWeiPhone.showWxNumber());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(huaWeiPhone.photo());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-12-类接口实现\"><a href=\"#3-12-类接口实现\" class=\"headerlink\" title=\"3.12 类接口实现\"></a>3.12 类接口实现</h3><blockquote>\n<p>手机类是一个大类<br>华为是手机类下的一个类<br>华为手机有拍照和闪光灯功能，照相机也有拍照和闪光灯功能<br>因此华为手机和照相机的公共特性就是拍照和闪光灯<br>所以通过关键字 <code>implements</code> 来标识提取出来的接口</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拍照</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Photo &#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 闪光灯</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Lamp &#123;</span><br><span class=\"line\">  lampOn(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  lampOff(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Phone</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuaWei</span> <span class=\"keyword\">extends</span> <span class=\"title\">Phone</span> <span class=\"title\">implements</span> <span class=\"title\">Photo</span>, <span class=\"title\">Lamp</span> </span>&#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;华为拍照&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOn</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOff</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DigitalCamera</span> <span class=\"title\">implements</span> <span class=\"title\">Photo</span>, <span class=\"title\">Lamp</span> </span>&#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;照相机拍照&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOn</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOff</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、类\"><a href=\"#四、类\" class=\"headerlink\" title=\"四、类\"></a>四、类</h2><h3 id=\"4-1-创建一个基本类\"><a href=\"#4-1-创建一个基本类\" class=\"headerlink\" title=\"4.1 创建一个基本类\"></a>4.1 创建一个基本类</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gretter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> gretting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.gretting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.gretting&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> gretter: Gretter = <span class=\"keyword\">new</span> Gretter(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gretter);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-继承\"><a href=\"#4-2-继承\" class=\"headerlink\" title=\"4.2 继承\"></a>4.2 继承</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">move</span>(<span class=\"params\">distanceInMeters: <span class=\"built_in\">number</span> = <span class=\"number\">0</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Snake</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">move</span>(<span class=\"params\">distanceInMeters = <span class=\"number\">5</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Slithering...&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.move(distanceInMeters);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Horse</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">move</span>(<span class=\"params\">distanceInMeters = <span class=\"number\">45</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Galloping&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.move(distanceInMeters);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sam = <span class=\"keyword\">new</span> Snake(<span class=\"string\">&quot;Sammy the Python&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Animal = <span class=\"keyword\">new</span> Horse(<span class=\"string\">&quot;Tommy the Palomino&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sam.move();</span><br><span class=\"line\">tom.move(<span class=\"number\">34</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-public-关键字\"><a href=\"#4-3-public-关键字\" class=\"headerlink\" title=\"4.3 public 关键字\"></a>4.3 public 关键字</h3><blockquote>\n<p>默认为 <code>public</code><br>在 <code>TypeScript</code> 中,成员都默认为 <code>public</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal_public</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">move</span>(<span class=\"params\">distanceInMeters: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-private-关键字\"><a href=\"#4-4-private-关键字\" class=\"headerlink\" title=\"4.4 private 关键字\"></a>4.4 private 关键字</h3><blockquote>\n<p>理解 <code>private</code></p>\n<ol>\n<li>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问</li>\n<li>如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal_private</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> cat = <span class=\"keyword\">new</span> Animal_private(<span class=\"string\">&quot;Cat&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// cat.name; // 错误：&#x27;name&#x27;是私有的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal_private_1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rhino</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal_private_1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(<span class=\"string\">&quot;Rhino&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal_private_1(<span class=\"string\">&quot;Goat&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> rhino = <span class=\"keyword\">new</span> Rhino();</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">animal = rhino;</span><br><span class=\"line\"><span class=\"comment\">// animal = employee; //错误：Animal与Employee不兼容</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-5-protected-关键字\"><a href=\"#4-5-protected-关键字\" class=\"headerlink\" title=\"4.5 protected 关键字\"></a>4.5 protected 关键字</h3><ul>\n<li>理解 <code>protected</code></li>\n</ul>\n<blockquote>\n<p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但是有一点不同，<code>protected</code> 成员在派生类中仍然可以访问。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.department = department;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">getElevatorPitch</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span> and I work in <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.department&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> _Employee(<span class=\"string\">&quot;Howard&quot;</span>, <span class=\"string\">&quot;Sales&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.getElevatorPitch());</span><br><span class=\"line\"><span class=\"comment\">// console.log(howard.name); // 错误，因为 name 无法在外部访问，但是可以在派生类中访问</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造函数也可以被标记成 <code>protected</code></li>\n</ul>\n<blockquote>\n<p>这意味着这个类不能在包含它的类外被实例化。但是能被继承。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">__Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// __Employee 能够继承 Person</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">__Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">__Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.department = department;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">getElevatorPitch</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span> and I work in <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.department&#125;</span>.`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> __howard = <span class=\"keyword\">new</span> __Employee(<span class=\"string\">&quot;Howard&quot;</span>, <span class=\"string\">&quot;Sales&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// let __join = new __Person(&quot;John&quot;);// 错误：&#x27;Person&#x27;的构造函数是被保护的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-6-readonly-修饰符\"><a href=\"#4-6-readonly-修饰符\" class=\"headerlink\" title=\"4.6 readonly 修饰符\"></a>4.6 readonly 修饰符</h3><ul>\n<li>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Octopus</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> numberOfLegs: <span class=\"built_in\">number</span> = <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dad = <span class=\"keyword\">new</span> Octopus(<span class=\"string\">&quot;Man with the 8 strong legs&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// dad.name = &quot;Man with the 3-piece suit&quot;;// 错误，name是只读的</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数属性</li>\n</ul>\n<blockquote>\n<ol>\n<li>参数属性可以方便地让我们在一个地方定义并初始化一个成员。</li>\n<li>参数属性通过给构造函数参数前面添加一个访问限定符来声明。</li>\n<li>使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_Octopus</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> numberOfLegs: <span class=\"built_in\">number</span> = <span class=\"number\">9</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">readonly</span> name: <span class=\"built_in\">string</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-7-存取器-get-amp-set\"><a href=\"#4-7-存取器-get-amp-set\" class=\"headerlink\" title=\"4.7 存取器 get &amp; set\"></a>4.7 存取器 get &amp; set</h3><blockquote>\n<p>存取器 支持 <code>es5+</code>，不支持 <code>es3</code></p>\n</blockquote>\n<ol>\n<li><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。它能帮助你有效的控制对对象成员的访问。</li>\n<li>没有存取器的例子</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_Employee</span> </span>&#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _employee = <span class=\"keyword\">new</span> _Employee();</span><br><span class=\"line\">_employee.fullName = <span class=\"string\">&quot;Bob Smith&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (_employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(_employee.fullName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>拥有存取器的例子</li>\n</ol>\n<blockquote>\n<ol>\n<li>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</li>\n<li>只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。</li>\n<li>这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> passcode = <span class=\"string\">&quot;secret passcode&quot;</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _fullName: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">fullName</span>(): <span class=\"title\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._fullName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">fullName</span>(<span class=\"params\">newName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (passcode &amp;&amp; passcode === <span class=\"string\">&quot;secret passcode&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>._fullName = newName;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Error: Unauthorized update of employee!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">employee.fullName = <span class=\"string\">&quot;Bob smith&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-8-静态属性\"><a href=\"#4-8-静态属性\" class=\"headerlink\" title=\"4.8 静态属性\"></a>4.8 静态属性</h3><blockquote>\n<p>我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> origin = &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">calculateDistanceFromOrigin</span>(<span class=\"params\">point: &#123; x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span> &#125;</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xDist = point.x - Gird.origin.x;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> yDist = point.y - Gird.origin.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class=\"built_in\">this</span>.scale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> scale: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Gird.origin.x);</span><br><span class=\"line\"><span class=\"keyword\">let</span> grid1 = <span class=\"keyword\">new</span> Gird(<span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> gird2 = <span class=\"keyword\">new</span> Gird(<span class=\"number\">5.0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid1.calculateDistanceFromOrigin(&#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">10</span> &#125;));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gird2.calculateDistanceFromOrigin(&#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">10</span> &#125;));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-9-抽象类\"><a href=\"#4-9-抽象类\" class=\"headerlink\" title=\"4.9 抽象类\"></a>4.9 抽象类</h3><ol>\n<li>抽象类作为其他派生类的基类使用，它们一般不会直接被实例化。</li>\n<li>不同于接口，抽象类可以包含成员的实现细节</li>\n<li><code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> makeSound(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  move(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;roaming the earth ...&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。</li>\n<li>抽象方法的语法于接口方法相似，二者都是定义方法签名但不包含方法体。然而抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">  printName(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Department name: <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> printMeeting(): <span class=\"built_in\">void</span>; <span class=\"comment\">// 必须在派生类中实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingDepartment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(<span class=\"string\">&quot;Accounting and Auditing&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  printMeeting(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The Accounting Department meets each Monday at 10am.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  generateReports(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Generating accounting reports...&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> department: Department; <span class=\"comment\">// 允许创建一个对抽象类的引用</span></span><br><span class=\"line\"><span class=\"comment\">// department = new Departmemnt(); // 错误，不能创建一个抽象类的实例</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> AccountingDepartment(); <span class=\"comment\">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class=\"line\">department.printName();</span><br><span class=\"line\">department.printMeeting();</span><br><span class=\"line\"><span class=\"comment\">// department.generateReports(); // 错误，方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-10-高级技巧-构造函数\"><a href=\"#4-10-高级技巧-构造函数\" class=\"headerlink\" title=\"4.10 高级技巧(构造函数)\"></a>4.10 高级技巧(构造函数)</h3><blockquote>\n<p>当在 <code>TypeScript</code> 里声明了一个类的时候，实际上声明了很多东西。首先就是类的实例类型</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello,&quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter; <span class=\"comment\">// =&gt;意思：Greeter类的实例的类型是Greeter</span></span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以认为类具有 <em>实例部分</em> 与 <em>静态部分</em></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_Greeter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">&quot;Hello, there&quot;</span>;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.greeting) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello,&quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _Greeter.standardGreeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _greeter: _Greeter;</span><br><span class=\"line\">_greeter = <span class=\"keyword\">new</span> _Greeter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_greeter.greet());</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此处创建了一个 <code>greeterMaker</code> 的变量，这个变量保存了这个 <em>类</em> 或者说保存了 _类构造函数_。然后使用 <code>typeof _Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，”告诉我 <code>Greeter</code> 标识符的类型”，也就是构造函数的类型。这个类型包含了类的所有静态成员和构造函数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _greeterMaker: <span class=\"keyword\">typeof</span> _Greeter = _Greeter;</span><br><span class=\"line\">_greeterMaker.standardGreeting = <span class=\"string\">&quot;Hey there!&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _greeter2: _Greeter = <span class=\"keyword\">new</span> _greeterMaker();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_greeter2.greet());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-11-高级技巧-把类当作接口使用\"><a href=\"#4-11-高级技巧-把类当作接口使用\" class=\"headerlink\" title=\"4.11 高级技巧(把类当作接口使用)\"></a>4.11 高级技巧(把类当作接口使用)</h3><blockquote>\n<p>类定义会创建两个东西：<em>类的实例类型</em> 和 _一个构造函数_。<br>因为类可以创建出类型，所以能够在允许使用接口的地方使用类</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Point3d <span class=\"keyword\">extends</span> Point &#123;</span><br><span class=\"line\">  z: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> point3d: Point3d = &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">z</span>: <span class=\"number\">4</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、函数\"><a href=\"#五、函数\" class=\"headerlink\" title=\"五、函数\"></a>五、函数</h2><h3 id=\"5-1-介绍\"><a href=\"#5-1-介绍\" class=\"headerlink\" title=\"5.1 介绍\"></a>5.1 介绍</h3><blockquote>\n<p>函数是 <code>JavaScript</code> 应用程序的基础。它帮助你实现抽象层，模拟层，信息隐藏和模块。在 <code>TypeScript</code> 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，让我们可以更容易的使用。</p>\n</blockquote>\n<h3 id=\"5-2-函数类型\"><a href=\"#5-2-函数类型\" class=\"headerlink\" title=\"5.2 函数类型\"></a>5.2 函数类型</h3><h4 id=\"5-2-1-为函数定义类型\"><a href=\"#5-2-1-为函数定义类型\" class=\"headerlink\" title=\"5.2.1 为函数定义类型\"></a>5.2.1 为函数定义类型</h4><blockquote>\n<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。</p>\n</blockquote>\n<blockquote>\n<p><code>TypeScript</code> 能够根据返回语句自动推断出返回值类型，因此我们通常省略它。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-2-书写完整的函数类型\"><a href=\"#5-2-2-书写完整的函数类型\" class=\"headerlink\" title=\"5.2.2 书写完整的函数类型\"></a>5.2.2 书写完整的函数类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd1: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>函数类型分为两个部分：<em>参数类型</em> 和 _返回值类型_。当写出完整函数类型的时候，这两部分都是需要的。我们以参数列表的形式写出参数类型，为每一个参数指定一个名字和类型。这个名字只是为了增加可读性。</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</li>\n<li>第二部分是返回值类型。对于返回值，我们在函数和返回值类型之间使用 <code>=&gt;</code> 符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code>,而不能留空。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>函数的类型只是由参数类型和返回值组成的。函数中使用的捕获变量不会体现在类型里。实际上，这些变量是函数的隐藏状态并不是组成 <code>API</code> 的一部分。</p>\n</blockquote>\n<ul>\n<li>我们也可以这么写：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd2: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-3-推断类型\"><a href=\"#5-2-3-推断类型\" class=\"headerlink\" title=\"5.2.3 推断类型\"></a>5.2.3 推断类型</h4><blockquote>\n<p>在尝试下面这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型。这叫做：”按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myAdd has the full function type</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; <span class=\"keyword\">return</span> x + y &#125;;</span><br><span class=\"line\"><span class=\"comment\">// The parameters `x` and `y` have the type number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd4: (baseValue: <span class=\"built_in\">number</span>, <span class=\"attr\">increment</span>: <span class=\"built_in\">number</span>) =<span class=\"built_in\">number</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-3-可选参数和默认参数\"><a href=\"#5-3-可选参数和默认参数\" class=\"headerlink\" title=\"5.3 可选参数和默认参数\"></a>5.3 可选参数和默认参数</h3><blockquote>\n<p><code>TypeScript</code> 里的每个函数参数都是必须的。这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。</p>\n</blockquote>\n<ol>\n<li>简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// let result1 =  buildName(&quot;Bob&quot;); // error</span></span><br><span class=\"line\"><span class=\"comment\">// let result2 = buildName(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>JavaScript</code>里，每个参数都是可选的，可传可不传。没传参的时候，它的值就是 <code>undefined</code>。在 <code>TypeScript</code> 里我们可以在参数旁边使用 <code>?</code> 实现可选参数的功能。</li>\n<li>注意：可选参数必须跟在必选参数后面，不能放在前面</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName1</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName?: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lastName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result_1 = buildName1(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result_2 = buildName1(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// let result_3 = buildName1(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // error</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>可以设置默认初始化的参数</li>\n<li>在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。也就是说，可选参数与末尾的默认参数共享参数类型。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName2</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName = <span class=\"string\">&quot;Smith&quot;</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>与普通可选参数参数不同的是，带默认值的参数不需要放在必须参数的后面。如果带默认值的参数出现在必须参数的前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName3</span>(<span class=\"params\">firstName = <span class=\"string\">&quot;Will&quot;</span>, lastName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// let result__1 = buildName3(&quot;Bob&quot;); // error</span></span><br><span class=\"line\"><span class=\"comment\">// let result__2 = buildName3(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result__3 = buildName3(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result__4 = buildName3(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;Jack&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-剩余参数\"><a href=\"#5-4-剩余参数\" class=\"headerlink\" title=\"5.4 剩余参数\"></a>5.4 剩余参数</h3><blockquote>\n<p>必要参数，默认参数 和 可选参数 有个共同点：它们表示某一个参数。有时，你想同时操作多个参数，或者你并不知道会有多少参数传进来。在 <code>JavaScript</code> 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。在 <code>TypeScript</code> 里，你可以把所有参数收集到一个变量里</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + restOfName.join(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employeeName = buildName(<span class=\"string\">&quot;Jose&quot;</span>, <span class=\"string\">&quot;Smith&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>剩余参数会被当作个数不限的可选参数。可以一个都没有，也可以有任意个。编译器创建参数数组，名字是你在省略号后面给定的名字，你可以在函数体内使用这个数组。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName1</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + restOfName.join(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buildNameFun: <span class=\"function\">(<span class=\"params\">fName: <span class=\"built_in\">string</span>, ...rest: <span class=\"built_in\">string</span>[]</span>) =&gt;</span> <span class=\"built_in\">string</span> = buildName1;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>this</code> 参数。在使用了 <code>--noImplicitThis</code> 标记之后，<code>this</code> 类型可能会是 <code>any</code>。此时需要提供一个显示的 <code>this</code> 参数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">  suit: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  card: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">  suits: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  cards: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">  createCardPicker(<span class=\"built_in\">this</span>: Deck): <span class=\"function\">() =&gt;</span> Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">&quot;hearts&quot;</span>, <span class=\"string\">&quot;spades&quot;</span>, <span class=\"string\">&quot;clubs&quot;</span>, <span class=\"string\">&quot;diamonds&quot;</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker(): <span class=\"function\">(<span class=\"params\"><span class=\"built_in\">this</span>: Deck</span>) =&gt;</span> Card &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; <span class=\"attr\">suit</span>: <span class=\"built_in\">this</span>.suits[pickedSuit], <span class=\"attr\">card</span>: pickedCard % <span class=\"number\">13</span> &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker();</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`card: <span class=\"subst\">$&#123;pickedCard.card&#125;</span> of <span class=\"subst\">$&#123;pickedCard.suit&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、泛型\"><a href=\"#六、泛型\" class=\"headerlink\" title=\"六、泛型\"></a>六、泛型</h2><h3 id=\"6-1-介绍\"><a href=\"#6-1-介绍\" class=\"headerlink\" title=\"6.1 介绍\"></a>6.1 介绍</h3><blockquote>\n<p>在软件工程中，我们不仅要创建一致的定义良好的 <code>API</code>，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>在像 <code>C#</code> 和 <code>Java</code> 这样的语言中，可以使用 <code>泛型</code> 来创建可重用组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。<br>除了泛型接口，我们还可以创建泛型类。注意，无法创建泛型枚举和泛型命名空间。</p>\n</blockquote>\n<h3 id=\"6-2-泛型之-hello-world\"><a href=\"#6-2-泛型之-hello-world\" class=\"headerlink\" title=\"6.2 泛型之 hello world\"></a>6.2 泛型之 hello world</h3><blockquote>\n<p>创建一个 <code>identity</code> 函数，这个函数会返回任何传入它的值。</p>\n</blockquote>\n<ul>\n<li>如果不使用泛型，函数可能是：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>也可以使用 <code>any</code> 类型定义函数，但是这样可能会导致传入的类型与返回的类型不相同。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity1</span>(<span class=\"params\">arg: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。</p>\n</blockquote>\n<ul>\n<li>这里我们使用了类型变量，它是一种特殊的变量，只能用于表示类型而不是值。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity2</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用方式一：传入所有的参数，包括类型参数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity2&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用方式二(更普遍)：利用了类型推论-即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output2 = identity2(<span class=\"string\">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-3-使用泛型变量\"><a href=\"#6-3-使用泛型变量\" class=\"headerlink\" title=\"6.3 使用泛型变量\"></a>6.3 使用泛型变量</h3><blockquote>\n<p>使用泛型创建像 <code>identity</code> 这样的函数时，编译器要求你在函数体必须正确的使用这个通用的类型。换句话说，你必须把这些参数当作是任意或所有类型。</p>\n</blockquote>\n<ul>\n<li>如果我们想打印出 <code>arg</code> 的长度，也许会这样做。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length); <span class=\"comment\">// 错误，T 类型也许不会有.length属性</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果我们像操作 <code>T</code> 类型的数组</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T[]</span>): <span class=\"title\">T</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity2</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: <span class=\"built_in\">Array</span>&lt;T&gt;</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-4-泛型类型-泛型接口\"><a href=\"#6-4-泛型类型-泛型接口\" class=\"headerlink\" title=\"6.4 泛型类型(泛型接口)\"></a>6.4 泛型类型(泛型接口)</h3><ol>\n<li>泛型函数的类型和非泛型函数的类型一样，首先列出类型参数，类似于函数声明。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;T&gt;<span class=\"function\">(<span class=\"params\">arg: T</span>) =&gt;</span> T = identity;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>我们也可以为类型中的泛型类型参数使用不同的名称，只要在数量上和使用方式上能对应上就可以。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity1</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity1: &lt;U&gt;<span class=\"function\">(<span class=\"params\">arg: U</span>) =&gt;</span> U = identity;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity2</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity2: &#123; &lt;T&gt;(arg: T): T &#125; = identity;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn &#123;</span><br><span class=\"line\">  &lt;T&gt;(arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity3</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity3: GenericIdentityFn = identity3;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>我们可能想把泛型参数当作整个接口的一个参数。这样我们就能清楚的知道使用的具体是哪个泛型类型(比如：<code>Dictionary&lt;string&gt;</code> 而不只是 <code>Dictionary</code>)。这样接口里的其它成员也能知道这个参数的类型了。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> _GenericIdentityFn&lt;T&gt; &#123;</span><br><span class=\"line\">  (arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _myIdentity: _GenericIdentityFn&lt;<span class=\"built_in\">number</span>&gt; = _identity;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，我们的示例做了少许改动。不再描述泛型函数，而是把非泛型函数签名作为泛型类型的一部分。</p>\n</blockquote>\n<blockquote>\n<p>当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型(这里是：<code>number</code>)，从而锁定之后代码里使用的类型。</p>\n</blockquote>\n<blockquote>\n<p>对于描述哪部分类型属于泛型部分来说，理解何时把参数 “放在调用签名里” 和何时 “放在接口上” 是很有帮助的。</p>\n</blockquote>\n<h3 id=\"6-5-泛型类\"><a href=\"#6-5-泛型类\" class=\"headerlink\" title=\"6.5 泛型类\"></a>6.5 泛型类</h3><blockquote>\n<p>泛型类和泛型接口差不多。泛型类使用 <code>&lt;&gt;</code> 括起泛型类型，跟在类名后面。类分为两部分：静态部分 和 实例部分。泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>\n</blockquote>\n<blockquote>\n<p><code>enericNumber</code> 类的使用是非常直观的，并没有什么去限制它只能使用 <code>number</code> 类型。</p>\n</blockquote>\n<ul>\n<li>也可以使用字符串或其它更复杂的类型。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericNumber</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  zeroValue: T;</span><br><span class=\"line\">  add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">number</span>&gt;();</span><br><span class=\"line\">myGenericNumber.zeroValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">myGenericNumber.add = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringNumeric = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">stringNumeric.zeroValue = <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">stringNumeric.add = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class=\"string\">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-6-泛型约束\"><a href=\"#6-6-泛型约束\" class=\"headerlink\" title=\"6.6 泛型约束\"></a>6.6 泛型约束</h3><blockquote>\n<p>我们应该记得之前的一个例子，我们有时候想要操作某类型的一组值，并且我们知道这组值具有什么样的属性。</p>\n</blockquote>\n<blockquote>\n<p>在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 length 属性。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相比与操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p>\n</blockquote>\n<blockquote>\n<p>为此，我们需要定义一个接口来描述约束条件。创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lengthwise &#123;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Lengthwise</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>此时这个泛型函数被定义了约束。因此它不再适用于任意类型：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(<span class=\"number\">3</span>); <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们需要传入符合约束类型的值，必须包含的属性。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(&#123; <span class=\"attr\">length</span>: <span class=\"number\">10</span>, <span class=\"attr\">value</span>: <span class=\"number\">3</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-7-在泛型约束中使用类型参数\"><a href=\"#6-7-在泛型约束中使用类型参数\" class=\"headerlink\" title=\"6.7 在泛型约束中使用类型参数\"></a>6.7 在泛型约束中使用类型参数</h3><blockquote>\n<p>你可以声明一个类型参数，且它被另一个类型参数所约束。例如，现在我们需想要用属性名从对象里获取这个属性。并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T, key: K</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">3</span>, <span class=\"attr\">d</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">getProperty(x, <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">getProperty(x, <span class=\"string\">&quot;m&quot;</span>); <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-8-在泛型里使用类类型\"><a href=\"#6-8-在泛型里使用类类型\" class=\"headerlink\" title=\"6.8 在泛型里使用类类型\"></a>6.8 在泛型里使用类类型</h3><blockquote>\n<p>在 <code>TypeScript</code> 使用泛型创建工厂函数时，需要引用构造函数的类类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">c: &#123; <span class=\"keyword\">new</span> (): T &#125;</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> c();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>下面是一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeeKeeper</span> </span>&#123;</span><br><span class=\"line\">  hasMask: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZooKeeper</span> </span>&#123;</span><br><span class=\"line\">  nameTag: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  numLegs: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  keeper: BeeKeeper;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lion</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  keeper: ZooKeeper;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createInstance</span>&lt;<span class=\"title\">A</span> <span class=\"title\">extends</span> <span class=\"title\">Animal</span>&gt;(<span class=\"params\">c: <span class=\"keyword\">new</span> () =&gt; A</span>): <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> c();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">createInstance(Lion).keeper.nameTag;</span><br><span class=\"line\">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-9-多个类型变量\"><a href=\"#6-9-多个类型变量\" class=\"headerlink\" title=\"6.9 多个类型变量\"></a>6.9 多个类型变量</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">info</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">N</span>&gt;(<span class=\"params\">name: S, age: N</span>): [<span class=\"title\">S</span>, <span class=\"title\">N</span>] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [name, age];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(info(<span class=\"string\">&quot;pr&quot;</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(info&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>&gt;(<span class=\"string\">&quot;pr&quot;</span>, <span class=\"number\">18</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、枚举\"><a href=\"#七、枚举\" class=\"headerlink\" title=\"七、枚举\"></a>七、枚举</h2><h3 id=\"7-1-介绍\"><a href=\"#7-1-介绍\" class=\"headerlink\" title=\"7.1 介绍\"></a>7.1 介绍</h3><blockquote>\n<p>使用枚举我们可以定义一些带有名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。<code>TypeScript</code> 支持数字的和基于字符串的枚举。</p>\n</blockquote>\n<h3 id=\"7-2-数字枚举\"><a href=\"#7-2-数字枚举\" class=\"headerlink\" title=\"7.2 数字枚举\"></a>7.2 数字枚举</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Direction &#123;</span><br><span class=\"line\">  Up = <span class=\"number\">1</span>,</span><br><span class=\"line\">  Down,</span><br><span class=\"line\">  Left,</span><br><span class=\"line\">  Right</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如上，我们定义了一个数字枚举，<code>Up</code>使用初始化为 <code>1</code>，其余成员会从 <code>1</code> 开始自动增长。 换句话说，<code>Direction.Up</code> 的值为 <code>1</code>，<code>Down</code> 值为 <code>2</code>，<code>Left</code> 值为 <code>3</code>，<code>Right</code> 值为 <code>4</code>。</p>\n</blockquote>\n<ol>\n<li>我们还可以完全不使用初始化器</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Direction2 &#123;</span><br><span class=\"line\">  Up,</span><br><span class=\"line\">  Down,</span><br><span class=\"line\">  Left,</span><br><span class=\"line\">  Right</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>现在，<code>Up</code> 的值为 <code>0</code>，<code>Down</code> 的值为 <code>1</code> 等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。</p>\n</blockquote>\n<ol start=\"2\">\n<li>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> _Response &#123;</span><br><span class=\"line\">  No = <span class=\"number\">0</span>,</span><br><span class=\"line\">  Yes = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">respond</span>(<span class=\"params\">recipient: <span class=\"built_in\">string</span>, message: _Response</span>): <span class=\"title\">void</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">respond(<span class=\"string\">&quot;Princess Caroline&quot;</span>, _Response.Yes);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>数字枚举可以被混入到计算过的和常量成员（如下所示）。</li>\n</ol>\n<blockquote>\n<p>简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。换句话说，下面的情况是不被允许的：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E &#123;</span><br><span class=\"line\">  A = getSomeValue(),</span><br><span class=\"line\">  B <span class=\"comment\">// error! &#x27;A&#x27; is not constant-initialized, so &#x27;B&#x27; needs an initializer</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-3-字符串枚举\"><a href=\"#7-3-字符串枚举\" class=\"headerlink\" title=\"7.3 字符串枚举\"></a>7.3 字符串枚举</h3><blockquote>\n<p>字符串枚举的概念很简单，但是有细微的运行时的差别。在一个字符串枚举里，每个成员都必须使用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Direction &#123;</span><br><span class=\"line\">  Up = <span class=\"string\">&quot;UP&quot;</span>,</span><br><span class=\"line\">  Down = <span class=\"string\">&quot;DOWN&quot;</span>,</span><br><span class=\"line\">  Left = <span class=\"string\">&quot;LEFT&quot;</span>,</span><br><span class=\"line\">  Right = <span class=\"string\">&quot;RIGHT&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。</p>\n</blockquote>\n<h3 id=\"7-4-异构枚举\"><a href=\"#7-4-异构枚举\" class=\"headerlink\" title=\"7.4 异构枚举\"></a>7.4 异构枚举</h3><blockquote>\n<p>从技术的角度来说，枚举可以混合字符串和数字成员，但是你似乎并不会这么做：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> BooleanLikeHeterogeneousEnum &#123;</span><br><span class=\"line\">  No = <span class=\"number\">0</span>,</span><br><span class=\"line\">  Yes = <span class=\"string\">&quot;YES&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>除非你真的想要利用 <code>JavaScript</code> 运行时的行为，否则我们不建议这样做。</p>\n</blockquote>\n<h3 id=\"7-5-计算的和常量成员\"><a href=\"#7-5-计算的和常量成员\" class=\"headerlink\" title=\"7.5 计算的和常量成员\"></a>7.5 计算的和常量成员</h3><blockquote>\n<p>每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当作是常量</p>\n</blockquote>\n<ol>\n<li>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 <code>0</code>：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E &#123;</span><br><span class=\"line\">  X</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>它不带有初始化器且它之前的枚举成员是一个数字常量。这种情况下，当前枚举成员的值为它上一个枚举成员的值加 <code>1</code>。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E1 &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">enum</span> E2 &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>枚举成员使用 常量枚举表达式进行初始化。常量枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。</li>\n</ol>\n<blockquote>\n<p>当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p>\n<ol>\n<li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li>\n<li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li>\n<li>带括号的常量枚举表达式</li>\n<li>一元运算符 +，-，～ 其中之一应用在了常量枚举表达式</li>\n<li>常量枚举表达式作为二元运算符 <code>+，-，*，/，%，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，&amp;，|，^</code> 的操作对象</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>若常量枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译阶段报错。</p>\n</blockquote>\n<blockquote>\n<p>所有其它情况的枚举成员被当作是需要计算得出的值</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> FileAccess &#123;</span><br><span class=\"line\">  <span class=\"comment\">// constant numbers</span></span><br><span class=\"line\">  None,</span><br><span class=\"line\">  Read = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">  White = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">  ReadWhite = Read | White,</span><br><span class=\"line\">  <span class=\"comment\">// computed number</span></span><br><span class=\"line\">  G = <span class=\"string\">&quot;123&quot;</span>.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-联合枚举与枚举成员的类型\"><a href=\"#7-6-联合枚举与枚举成员的类型\" class=\"headerlink\" title=\"7.6 联合枚举与枚举成员的类型\"></a>7.6 联合枚举与枚举成员的类型</h3><blockquote>\n<p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员，或者是被初始化为：</p>\n<ol>\n<li>任何字符串字面量(例如：<code>&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>)</li>\n<li>任何数字字面量(例如：<code>1, 100</code>)</li>\n<li>应用了一元 - 符号的数字字面量(例如：<code>-1, -100</code>) 当所有枚举成员都拥有字面量枚举值时，它就有了一种特殊的含义。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>首先，枚举成员成为了类型！例如，我们可以说某些成员只能是枚举成员的值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> ShapeKind &#123;</span><br><span class=\"line\">  Circle,</span><br><span class=\"line\">  Square</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Circle &#123;</span><br><span class=\"line\">  kind: ShapeKind.Circle;</span><br><span class=\"line\">  radius: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  kind: ShapeKind.Square;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Circle = &#123;</span><br><span class=\"line\">  kind: ShapeKind.Square, <span class=\"comment\">// error</span></span><br><span class=\"line\">  radius: <span class=\"number\">100</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另一个变化是枚举类型本身变成了每个枚举成员的联合。虽然我们还没有讨论 联合类型 。但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。因此，<code>TypeScript</code> 能够捕获在比较值的时候犯的愚蠢的错误。例如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E &#123;</span><br><span class=\"line\">  Foo,</span><br><span class=\"line\">  Bar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: E</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== E.Foo || x !== E.Bar) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// // Error! Operator &#x27;!==&#x27; cannot be applied to types &#x27;E.Foo&#x27; and &#x27;E.Bar&#x27;.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个例子里，我们先检查 <code>x</code> 是否不是 <code>E.Foo</code>。 如果通过了这个检查，然后 <code>||</code> 会发生短路效果，<br><code>if</code> 语句体里的内容会被执行。 然而，这个检查没有通过，那么 x 则只能为 <code>E.Foo</code>，因此没理由再去检查它是否为 <code>E.Bar</code>。</p>\n</blockquote>\n<h3 id=\"7-7-运行时的枚举\"><a href=\"#7-7-运行时的枚举\" class=\"headerlink\" title=\"7.7 运行时的枚举\"></a>7.7 运行时的枚举</h3><ul>\n<li>枚举是在运行时真正存在的对象。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以传递给函数么？</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">obj: &#123; X: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj.X;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>没问题，因为 <code>&quot;E&quot;</code> 包含一个数值型属性 <code>&quot;X&quot;</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(E);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-8-编译时的枚举\"><a href=\"#7-8-编译时的枚举\" class=\"headerlink\" title=\"7.8 编译时的枚举\"></a>7.8 编译时的枚举</h3><blockquote>\n<p>尽管一个枚举是在运行时真正存在的对象，但 <code>keyof</code> 关键字的行为与其作用在对象上时有所不同。应该使用 <code>keyof</code> <code>typeof</code> 来获取一个表示枚举里所有字符串 <code>key</code> 的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> LogLevel &#123;</span><br><span class=\"line\">  ERROR,</span><br><span class=\"line\">  WARN,</span><br><span class=\"line\">  INFO,</span><br><span class=\"line\">  DEBUG</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>等同于：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LogLevelStrings = <span class=\"string\">&quot;ERROR&quot;</span> | <span class=\"string\">&quot;WARN&quot;</span> | <span class=\"string\">&quot;INFO&quot;</span> | <span class=\"string\">&quot;DEBUG&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> LogLevelStrings = keyof <span class=\"keyword\">typeof</span> LogLevel;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printImportant</span>(<span class=\"params\">key: LogLevelStrings, message: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = LogLevel[key];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= LogLevel.WARN) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Log Level key is: &quot;</span>, key);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Log Level value is: &quot;</span>, num);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Log Level message is &quot;</span>, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printImportant(<span class=\"string\">&quot;ERROR&quot;</span>, <span class=\"string\">&quot;This is a message&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-9-反向映射\"><a href=\"#7-9-反向映射\" class=\"headerlink\" title=\"7.9 反向映射\"></a>7.9 反向映射</h3><blockquote>\n<p>除了创建一个以属性名作为对象成员的对象外，数字枚举成员还具有了反向映射，从枚举值到枚举名字。</p>\n</blockquote>\n<ul>\n<li>例如在下面的例子中：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> _Enum &#123;</span><br><span class=\"line\">  A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _a = _Enum.A;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _nameOfA = _Enum[_a]; <span class=\"comment\">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>TypeScript</code> 可能会将这段代码编译为下面的 <code>JavaScript</code>：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Enum;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Enum</span>) </span>&#123;</span><br><span class=\"line\">  Enum[(Enum[<span class=\"string\">&quot;A&quot;</span>] = <span class=\"number\">0</span>)] = <span class=\"string\">&quot;A&quot;</span>;</span><br><span class=\"line\">&#125;)(Enum || (Enum = &#123;&#125;));</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = Enum.A;</span><br><span class=\"line\"><span class=\"keyword\">var</span> nameOfA = Enum[a]; <span class=\"comment\">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（<code>name -&gt; value</code>）和反向映射（<code>value -&gt; name</code>）。</p>\n</blockquote>\n<blockquote>\n<p>引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p>\n</blockquote>\n<blockquote>\n<p>要注意的是不会为字符串枚举成员生成反向映射。</p>\n</blockquote>\n<h3 id=\"7-10-const-枚举\"><a href=\"#7-10-const-枚举\" class=\"headerlink\" title=\"7.10 const 枚举\"></a>7.10 const 枚举</h3><blockquote>\n<p>大多数情况下，枚举是十分有效的方案。然而在某些情况下需求很严格。为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 <code>const</code> 枚举。</p>\n</blockquote>\n<blockquote>\n<p>常量枚举通过在枚举上使用 <code>const</code> 修饰符来定义。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">enum</span> Enum &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B = A * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">enum</span> Directions &#123;</span><br><span class=\"line\">  Up,</span><br><span class=\"line\">  Down,</span><br><span class=\"line\">  Left,</span><br><span class=\"line\">  Right</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class=\"line\"><span class=\"comment\">// 生成后的代码为：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> directions1 = [<span class=\"number\">0</span> <span class=\"comment\">/* Up */</span>, <span class=\"number\">1</span> <span class=\"comment\">/* Down */</span>, <span class=\"number\">2</span> <span class=\"comment\">/* Left */</span>, <span class=\"number\">3</span> <span class=\"comment\">/* Right */</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-11-外部枚举\"><a href=\"#7-11-外部枚举\" class=\"headerlink\" title=\"7.11 外部枚举\"></a>7.11 外部枚举</h3><blockquote>\n<p>外部枚举 用来描述已经存在的枚举类型的形状。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">enum</span> Enum &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>外部枚举 和 非外部枚举 之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。</p>\n</blockquote>\n<blockquote>\n<p>对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p>\n</blockquote>\n<h2 id=\"八、类型别名\"><a href=\"#八、类型别名\" class=\"headerlink\" title=\"八、类型别名\"></a>八、类型别名</h2><h3 id=\"8-1-类型别名\"><a href=\"#8-1-类型别名\" class=\"headerlink\" title=\"8.1 类型别名\"></a>8.1 类型别名</h3><ol>\n<li>创建别名需要使用关键字 <code>type</code></li>\n<li>使用别名通常用在有 联合类型 的场景下</li>\n</ol>\n<blockquote>\n<p>注意：不要混淆了 <code>TypeScript</code> 中的 <code>=&gt;</code>; 和 <code>ES6</code> 中的 <code>=&gt;</code> 在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义。(左边是输入类型，需要用括号扩起来，右边是输出类型)；在 <code>ES6</code> 中，<code>=&gt;</code> 叫做箭头函数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Name = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ShowName = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> NameOrShowName = Name | ShowName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getName = <span class=\"function\">(<span class=\"params\">name: NameOrShowName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> name === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> name();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> showName = <span class=\"function\">() =&gt;</span> <span class=\"string\">&quot;pr is a boy&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getName(<span class=\"string\">&quot;pr&quot;</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getName(showName()));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-2-字符串字面量类型\"><a href=\"#8-2-字符串字面量类型\" class=\"headerlink\" title=\"8.2 字符串字面量类型\"></a>8.2 字符串字面量类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> EventNames = <span class=\"string\">&quot;click&quot;</span> | <span class=\"string\">&quot;scroll&quot;</span> | <span class=\"string\">&quot;mousemove&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handleEvent: <span class=\"function\">(<span class=\"params\">a: Element, b: EventNames</span>) =&gt;</span> <span class=\"built_in\">string</span> = <span class=\"function\">(<span class=\"params\">ele: Element, event: EventNames</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;ele&#125;</span> <span class=\"subst\">$&#123;event&#125;</span>`</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">handleEvent(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;header&quot;</span>), <span class=\"string\">&quot;scroll&quot;</span>);</span><br><span class=\"line\">handleEvent(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;footer&quot;</span>), <span class=\"string\">&quot;click&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"九、类型推论\"><a href=\"#九、类型推论\" class=\"headerlink\" title=\"九、类型推论\"></a>九、类型推论</h2><h3 id=\"9-1-基础\"><a href=\"#9-1-基础\" class=\"headerlink\" title=\"9.1 基础\"></a>9.1 基础</h3><blockquote>\n<p>在 <code>TypeScript</code> 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>变量 <code>x</code> 的类型被推断为数字。这种推断发生在初始化变量和成员，设置默认参数和决定函数返回值时。</p>\n</blockquote>\n<blockquote>\n<p>大多数情况下，类型推论是直接了当地。</p>\n</blockquote>\n<h3 id=\"9-2-最佳通用类型\"><a href=\"#9-2-最佳通用类型\" class=\"headerlink\" title=\"9.2 最佳通用类型\"></a>9.2 最佳通用类型</h3><blockquote>\n<p>当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断出一个最合适的通用类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">null</span>];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。这里有两种选择: <code>number</code> 和 <code>null</code>。计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>\n</blockquote>\n<blockquote>\n<p>由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zoo = [<span class=\"keyword\">new</span> Rhino(), <span class=\"keyword\">new</span> Elephant(), <span class=\"keyword\">new</span> Snake()];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。</p>\n</blockquote>\n<blockquote>\n<p>为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zoo: Animal[] = [<span class=\"keyword\">new</span> Rhino(), <span class=\"keyword\">new</span> Elephant(), <span class=\"keyword\">new</span> Snake()];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p>\n</blockquote>\n<h3 id=\"9-3-上下文归类\"><a href=\"#9-3-上下文归类\" class=\"headerlink\" title=\"9.3 上下文归类\"></a>9.3 上下文归类</h3><ol>\n<li><code>TypeScript</code> 类型推论也可能按照相反的方向进行，这被叫做”上下文归类”。按上下文归类会发生在表达式类型与所处的位置相关时。</li>\n</ol>\n<blockquote>\n<p>在下面这个例子里，<code>TypeScript</code> 类型检查器会使用 <code>Window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。所以它能够推断出 <code>mouseEvent</code> 参数的类型中包含了 <code>button</code> 属性而不包含 <code>kangaroo</code> 属性。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mouseEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.button); <span class=\"comment\">// &lt;- Ok</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.kangaroo); <span class=\"comment\">// &lt;- error</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>TypeScript</code> 还能够很好地推断出其它上下文中的类型。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">uiEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(uiEvent.button); <span class=\"comment\">// Error</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的函数被赋给 <code>window.onscroll``，TypeScript</code> 能够知道 <code>uiEvent</code> 是 <code>UIEvent</code>，而不是 <code>MouseEvent。UIEvent</code> 对象不包含 <code>button</code> 属性，因此 <code>TypeScript</code> 会报错。</p>\n</blockquote>\n<ol>\n<li>如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为 <code>any</code> 类型，而且也不会报错(除非你开启了 <code>--noImplicitAny</code> 选项)</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handler = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">uiEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(uiEvent.button); <span class=\"comment\">// &lt;- Ok</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们也可以明确地为函数参数类型赋值来覆写上下文类型：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">uiEvent: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(uiEvent.button); <span class=\"comment\">// &lt;- Now, no error is given</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但这段代码会打印 <code>undefined</code>，因为 <code>uiEvent</code> 并不包含 <code>button</code> 属性。</p>\n</blockquote>\n<blockquote>\n<p>上下文归类会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。</p>\n</blockquote>\n<ul>\n<li>上下文类型也会做为最佳通用类型的候选类型。比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createZoo</span>(<span class=\"params\"></span>): <span class=\"title\">Animal</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">new</span> Rhino(), <span class=\"keyword\">new</span> Elephant(), <span class=\"keyword\">new</span> Snake()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面这个例子里，最佳通用类型有 <code>4</code> 个候选者：<code>Animal, Rhino, Elephant, Snake</code>。当然，<code>Animal</code> 会被作为最佳通用类型。</p>\n</blockquote>\n<h2 id=\"十、类型兼容性\"><a href=\"#十、类型兼容性\" class=\"headerlink\" title=\"十、类型兼容性\"></a>十、类型兼容性</h2><h3 id=\"10-1-介绍\"><a href=\"#10-1-介绍\" class=\"headerlink\" title=\"10.1 介绍\"></a>10.1 介绍</h3><blockquote>\n<p><code>TypeScript</code> 里的兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。它正好与名义( <code>nominal</code> )类型形成对比。(译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。)看下面的例子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Named &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p: Named;</span><br><span class=\"line\"><span class=\"comment\">// Ok, because of structural typing</span></span><br><span class=\"line\">p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在使用基于名义类型的断言，比如 <code>C#</code> 或 <code>Java</code> 中，这段代码会报错， 因为 <code>Person</code> 类没有明确说明其实现了 <code>Named</code> 接口。<br><code>TypeScript</code> 的结构性子类型是根据 <code>JavaScript</code> 代码的典型写法来设计的。 因为 <code>JavaScript</code> 里广泛地使用匿名对象，例如函数表达式和对象字面量， 所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p>\n</blockquote>\n<h3 id=\"10-2-关于可靠性的注意事项\"><a href=\"#10-2-关于可靠性的注意事项\" class=\"headerlink\" title=\"10.2 关于可靠性的注意事项\"></a>10.2 关于可靠性的注意事项</h3><blockquote>\n<p><code>TypeScript</code> 的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript 允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p>\n</blockquote>\n<h3 id=\"10-3-开始\"><a href=\"#10-3-开始\" class=\"headerlink\" title=\"10.3 开始\"></a>10.3 开始</h3><ul>\n<li><code>TypeScript</code> 结构化类型系统的基本规则是，如果 <code>x</code> 要兼容 <code>y</code>，那么 <code>y</code> 至少具有与 <code>x</code> 相同的属性。比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Named &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: Named;</span><br><span class=\"line\"><span class=\"comment\">// y&#x27;s inferred type is &#123; name: string; location: string &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> y = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">location</span>: <span class=\"string\">&quot;Seattle&quot;</span> &#125;;</span><br><span class=\"line\">x = y;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里要检查 <code>y</code> 是否能赋值给 <code>x</code>，编译器检查 <code>x</code> 中的每个属性，看是否能在 <code>y</code> 中也找到对应属性。</p>\n</blockquote>\n<blockquote>\n<p>在这个例子中，<code>y</code> 必须包含名字是 <code>name</code> 的 <code>string</code> 类型成员。<code>y</code> 满足条件，因此赋值正确。</p>\n</blockquote>\n<ul>\n<li>检查函数参数时使用相同的规则</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">n: Named</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Hello, &quot;</span> + n.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet(y); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，<code>y</code> 有个额外的 <code>location</code> 属性，但这不会引发错误。<br>只有目标类型（这里是 <code>Named</code>）的成员会被一一检查是否兼容。<br>这个比较过程是递归进行的，检查每个成员及子成员。</p>\n</blockquote>\n<h3 id=\"10-4-比较两个函数\"><a href=\"#10-4-比较两个函数\" class=\"headerlink\" title=\"10.4 比较两个函数\"></a>10.4 比较两个函数</h3><ol>\n<li>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。</li>\n</ol>\n<ul>\n<li>下面我们从两个简单的函数入手，它们仅是参数列表略有不同：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"function\">(<span class=\"params\">a: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"function\">(<span class=\"params\">b: <span class=\"built_in\">number</span>, s: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">y = x; <span class=\"comment\">// &lt;- Ok</span></span><br><span class=\"line\"><span class=\"comment\">// x = y; // &lt;- Error</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>要查看 <code>x</code> 是否能赋值给 <code>y</code>，首先看它们的参数列表。 <code>x</code> 的每个参数必须能在 <code>y</code> 里找到对应类型的参数。注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，<code>x</code> 的每个参数在 <code>y</code> 中都能找到对应的参数，所以允许赋值。第二个赋值错误，因为 <code>y</code> 有个必需的第二个参数，但是 <code>x</code> 并没有，所以不允许赋值。<br>你可能会疑惑为什么允许忽略参数，像例子 <code>y = x</code> 中那样。 原因是忽略额外的参数在 <code>JavaScript</code> 里是很常见的。<br>例如，<code>Array.forEach</code> 给回调函数传 <code>3</code> 个参数：数组元素，索引 和 整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> items = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">// Don&#x27;t force these extra arguments</span></span><br><span class=\"line\">items.forEach(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(item));</span><br><span class=\"line\"><span class=\"comment\">// Should be Ok</span></span><br><span class=\"line\">items.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">console</span>.log(item));</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x1 = <span class=\"function\">() =&gt;</span> (&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> y1 = <span class=\"function\">() =&gt;</span> (&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">location</span>: <span class=\"string\">&quot;Seattle&quot;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">x1 = y1; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">y1 = x1; <span class=\"comment\">// Error, because x() lacks a location property</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</li>\n</ol>\n<h3 id=\"10-5-函数参数双向协变\"><a href=\"#10-5-函数参数双向协变\" class=\"headerlink\" title=\"10.5 函数参数双向协变\"></a>10.5 函数参数双向协变</h3><blockquote>\n<p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。实际上，这极少会发声错误，并且能够实现很多 <code>JavaScript</code> 里的常见模式。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> EventType &#123;</span><br><span class=\"line\">  Mouse,</span><br><span class=\"line\">  Keyboard</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Event &#123;</span><br><span class=\"line\">  timestamp: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> MouseEvent <span class=\"keyword\">extends</span> Event &#123;</span><br><span class=\"line\">  x1: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  y1: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> keyEvent <span class=\"keyword\">extends</span> Event &#123;</span><br><span class=\"line\">  keyCode: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listenEvent</span>(<span class=\"params\">eventType: EventType, handler: (n: Event) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* …… */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unsound, but useful and common 不完整，但是常用常见</span></span><br><span class=\"line\">listenEvent(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;e.x1&#125;</span>,<span class=\"subst\">$&#123;e.y1&#125;</span>`</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Undesirable alternatives in presence of soundness 完整但是不受欢迎</span></span><br><span class=\"line\">listenEvent(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;(&lt;MouseEvent&gt;e).x1&#125;</span>,<span class=\"subst\">$&#123;(&lt;MouseEvent&gt;e).y1&#125;</span>`</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">listenEvent(EventType.Mouse, &lt;<span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;(<span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;e.x1&#125;</span>,<span class=\"subst\">$&#123;e.y1&#125;</span>`</span>)));</span><br><span class=\"line\"><span class=\"comment\">// Still disallowed (clear error). Type safety enforced for wholly incompatible types</span></span><br><span class=\"line\"><span class=\"comment\">// 仍然不允许（清除错误）。完全不兼容类型所强制规定的类型安全</span></span><br><span class=\"line\"><span class=\"comment\">// listenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-6-可选参数和剩余参数\"><a href=\"#10-6-可选参数和剩余参数\" class=\"headerlink\" title=\"10.6 可选参数和剩余参数\"></a>10.6 可选参数和剩余参数</h3><ol>\n<li>比较函数兼容性的时候，可选参数与必须参数是可互换的。源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。</li>\n<li>当一个函数有剩余参数时，它被当做无限个可选参数。</li>\n<li>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些 undefined 。</li>\n</ol>\n<blockquote>\n<p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数 但对类型系统来说是不确定的参数来调用：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">invokeLater</span>(<span class=\"params\">args: <span class=\"built_in\">any</span>[], callback: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... Invoke callback with &#x27;args&#x27; ... 通过args调用callback */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span></span><br><span class=\"line\"><span class=\"comment\">// 不健全的是 - 被调用时候可能会提供任意数量的参数</span></span><br><span class=\"line\">invokeLater([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(x + <span class=\"string\">&quot;,&quot;</span> + y));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Confusing (x and y are actually required) and unrecoverable</span></span><br><span class=\"line\"><span class=\"comment\">// 令我们困惑(是否需要 x 和 y) 并且 不可恢复</span></span><br><span class=\"line\">invokeLater([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x?, y?</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(x + <span class=\"string\">&quot;,&quot;</span> + y));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-7-函数重载\"><a href=\"#10-7-函数重载\" class=\"headerlink\" title=\"10.7 函数重载\"></a>10.7 函数重载</h3><blockquote>\n<p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。这确保了目标函数可以在所有源函数可调用的地方调用。</p>\n</blockquote>\n<h3 id=\"10-8-枚举\"><a href=\"#10-8-枚举\" class=\"headerlink\" title=\"10.8 枚举\"></a>10.8 枚举</h3><blockquote>\n<p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p>\n</blockquote>\n<ul>\n<li>比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Status &#123;</span><br><span class=\"line\">  Ready,</span><br><span class=\"line\">  Waiting</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Blue,</span><br><span class=\"line\">  Green</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _status = Status.Ready;</span><br><span class=\"line\"><span class=\"comment\">// _status = Color.Green; // Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-9-类\"><a href=\"#10-9-类\" class=\"headerlink\" title=\"10.9 类\"></a>10.9 类</h3><blockquote>\n<p>类与对象字面量和接口差不多，但是有一点不同：类的静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。静态成员和构造函数不在比较的范围内。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  feet: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, numFeet: <span class=\"built_in\">number</span>, c: <span class=\"built_in\">boolean</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Size</span> </span>&#123;</span><br><span class=\"line\">  feet: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">numFeet: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: Animal;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s: Size;</span><br><span class=\"line\">a = s; <span class=\"comment\">//Ok</span></span><br><span class=\"line\">s = a; <span class=\"comment\">//Ok</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-10-类的私有和受保护成员\"><a href=\"#10-10-类的私有和受保护成员\" class=\"headerlink\" title=\"10.10 类的私有和受保护成员\"></a>10.10 类的私有和受保护成员</h3><blockquote>\n<p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>\n</blockquote>\n<h3 id=\"10-11-泛型\"><a href=\"#10-11-泛型\" class=\"headerlink\" title=\"10.11 泛型\"></a>10.11 泛型</h3><blockquote>\n<p>因为 <code>TypeScript</code> 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。</p>\n</blockquote>\n<ul>\n<li>比如</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: Empty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y: Empty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">x = y; <span class=\"comment\">// Ok, because y matches structure of x</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面代码里，<code>x</code> 和 <code>y</code> 是兼容的，因为它们的结构使用类型参数时，并没有什么不同。</p>\n</blockquote>\n<ul>\n<li>把这个例子改变一下，增加一个成员，就能看出是如何工作的了。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class=\"line\">  data: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x1: NotEmpty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y1: NotEmpty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\">x1 = y1; <span class=\"comment\">// Error，because x and y are not compatible</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p>\n</blockquote>\n<blockquote>\n<p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 <code>any</code> 比较。然后用结果类型进行比较，就像上面第一个例子。</p>\n</blockquote>\n<ul>\n<li>比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identity = <span class=\"function\"><span class=\"keyword\">function</span> &lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">x: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> reverse = <span class=\"function\"><span class=\"keyword\">function</span> &lt;<span class=\"title\">U</span>&gt;(<span class=\"params\">y: U</span>): <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">identity = reverse; <span class=\"comment\">// Ok, because (x: any) =&gt; any matches (y: any) =&gt; any</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-12-高级主题\"><a href=\"#10-12-高级主题\" class=\"headerlink\" title=\"10.12 高级主题\"></a>10.12 高级主题</h3><ul>\n<li>子类型和赋值</li>\n</ul>\n<blockquote>\n<p>目前为止，我们使用了”兼容性”，它在语言规范里没有定义，在 <code>TypeScript</code> 里，有两种兼容性：子类型 和 赋值。它们的不同点在于：赋值扩展了子类型兼容性，增加了一些规则，允许和 <code>any</code> 来回赋值，以及 enum 和对应数字值之间的来回赋值。<br>语言里的不同地方分别使用了它们之中的机制。实际上，类型兼容性是由赋值兼容性来控制的，即使在 <code>implements</code> 和 <code>extends</code> 语句也不例外。</p>\n</blockquote>\n<h2 id=\"十一、高级类型\"><a href=\"#十一、高级类型\" class=\"headerlink\" title=\"十一、高级类型\"></a>十一、高级类型</h2><h3 id=\"11-1-交叉类型\"><a href=\"#11-1-交叉类型\" class=\"headerlink\" title=\"11.1 交叉类型\"></a>11.1 交叉类型</h3><blockquote>\n<p>交叉类型 是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。例如，<code>Person &amp; Serializable &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Serializable</code> 和 <code>Loggable</code>。就是说这个类型的对象同时拥有了这三种类型的成员。<br>我们大多数是在混入( <code>mixins</code> )或其它不适合典型面向对象模型的地方看到交叉类型的使用。(在 <code>JavaScript</code> 里发生这种情况的场合很多！)</p>\n</blockquote>\n<h4 id=\"11-1-1-ReadOnly-的实现\"><a href=\"#11-1-1-ReadOnly-的实现\" class=\"headerlink\" title=\"11.1.1 ReadOnly 的实现\"></a>11.1.1 <code>ReadOnly</code> 的实现</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReadOnly&lt;T&gt; = &#123;</span><br><span class=\"line\">    readOnly [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-1-2-Partial-的实现\"><a href=\"#11-1-2-Partial-的实现\" class=\"headerlink\" title=\"11.1.2 Partial 的实现\"></a>11.1.2 <code>Partial</code> 的实现</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-1-3-Pick-的实现\"><a href=\"#11-1-3-Pick-的实现\" class=\"headerlink\" title=\"11.1.3 Pick 的实现\"></a>11.1.3 <code>Pick</code> 的实现</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> K]: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-1-4-Record-的实现\"><a href=\"#11-1-4-Record-的实现\" class=\"headerlink\" title=\"11.1.4 Record 的实现\"></a>11.1.4 <code>Record</code> 的实现</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Record&lt;K <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>, T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> K]: T;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>下面是如何创建混入的一个简单的例子(<code>&quot;target&quot;: &quot;es5&quot;</code>):</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>&lt;<span class=\"title\">First</span>, <span class=\"title\">Second</span>&gt;(<span class=\"params\">first: First, second: Second</span>): <span class=\"title\">First</span> &amp; <span class=\"title\">Second</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result: Partial&lt;First &amp; Second&gt;= &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> prop <span class=\"keyword\">in</span> first) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hasOwnProperty(prop)) &#123;</span><br><span class=\"line\">            (&lt;First&gt;result)[prop] = first[prop];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> prop <span class=\"keyword\">in</span> second) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (second.hasOwnProperty(prop)) &#123;</span><br><span class=\"line\">            (&lt;Second&gt;result)[prop] = second[prop];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">First</span> &amp; <span class=\"attr\">Second</span>&gt;</span>result;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">&gt;</span></span><br><span class=\"line\"><span class=\"xml\">class Person &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    constructor(public name: string) &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">interface Loggable &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    log(name: string): void;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">class ConsoleLogger implements Loggable &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    log(name) &#123;</span></span><br><span class=\"line\"><span class=\"xml\">        console.log(`Hello, I&#x27;m $&#123;name&#125;`)</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">const jim = extend(new Person(&quot;Jim&quot;), ConsoleLogger.prototype);</span></span><br><span class=\"line\"><span class=\"xml\">let c = jim.log(jim.name);</span></span><br><span class=\"line\"><span class=\"xml\">console.log(c);</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-2-联合类型\"><a href=\"#11-2-联合类型\" class=\"headerlink\" title=\"11.2 联合类型\"></a>11.2 联合类型</h3><blockquote>\n<p>联合类型 和 交叉类型 很有关联，但是使用上却完全不同。偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。例如下面的函数：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class=\"line\"><span class=\"comment\"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class=\"line\"><span class=\"comment\"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">&quot; &quot;</span>) + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got &#x27;<span class=\"subst\">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">padLeft(<span class=\"string\">&quot;Hello World&quot;</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 <code>TypeScript</code> 却不会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">&quot;Hello World&quot;</span>, <span class=\"literal\">true</span>); <span class=\"comment\">// 编译阶段通过，运行时报错。</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。这么做显然是非常清晰的，但同时也存在了过度设计。&#96;padLeft&#96; 原始版本的好处之一就是允许我们传入原始类型。这样做的话使用起来既简单又方便。如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。代替 &#96;any&#96;，我们可以使用 联合类型 作为 &#96;padding&#96; 的参数。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;typescript</span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Takes a string and adds &quot;padding&quot; to the left.</span><br><span class=\"line\"> * If &#39;padding&#39; is a string, then &#39;padding&#39; is appended to the left side.</span><br><span class=\"line\"> * If &#39;padding&#39; is a number, then that number of spaces is added to the left side.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function padLeft1(value: string, padding: string | number) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; let indentedString1 &#x3D; padLeft1(&quot;Hello world&quot;, true); &#x2F;&#x2F; errors during compilation</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>联合类型 表示一个值可以是几种类型之一。我们使用竖线(<code>|</code>)分隔每个类型，所以 <code>number | string | boolean</code> 表示一个值可能是 <code>number</code>, <code>string</code>, <code>boolean</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly();</span><br><span class=\"line\"></span><br><span class=\"line\">  lagEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim();</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); <span class=\"comment\">// &lt;- ok</span></span><br><span class=\"line\"><span class=\"comment\">// pet.swim(); // &lt;- errors</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的联合类型可能有点复杂，但是你很容易就习惯了。如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Bird</code> 具有一个 <code>fly</code> 成员。我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>fly</code> 方法。如果变量在运行时是 <code>Fish</code> 类型，那么调用 <code>pet.fly()</code> 就出错了。</p>\n</blockquote>\n<h3 id=\"11-3-类型守卫与类型区分\"><a href=\"#11-3-类型守卫与类型区分\" class=\"headerlink\" title=\"11.3 类型守卫与类型区分\"></a>11.3 类型守卫与类型区分</h3><blockquote>\n<p>联合类型适用于那些值可以为不同类型的情况。但当我们想确切地了解是否为 <code>Fish</code> 时怎么办？<code>JavaScript</code> 里常用来区分 <code>2</code> 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim();</span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly();</span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>每一个访问的成员都会报错</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (pet.swim) &#123;</span><br><span class=\"line\">  pet.swim();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pet.fly) &#123;</span><br><span class=\"line\">  pet.fly();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为了让这段代码工作，我们需要使用类型断言</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class=\"line\">  (&lt;Fish&gt;pet).swim();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((&lt;Bird&gt;pet).fly) &#123;</span><br><span class=\"line\">  (&lt;Bird&gt;pet).fly();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-4-用户自定义的类型守卫\"><a href=\"#11-4-用户自定义的类型守卫\" class=\"headerlink\" title=\"11.4 用户自定义的类型守卫\"></a>11.4 用户自定义的类型守卫</h3><blockquote>\n<p>这里我们注意到不得不多次使用类型断言。假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p>\n</blockquote>\n<blockquote>\n<p><code>TypeScript</code> 里的类型守卫机制让它成为了现实。类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。要想定义一个类型守卫，我们只需要简单地定义一个函数，它的返回值是一个类型谓词：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim();</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly();</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (&lt;Fish&gt;pet).swim !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。<br>每当使用一些变量调用 <code>isFish</code> <code>时，TypeScript</code> 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的<br><code>swim</code> 和 <code>fly</code> 的调用都没有问题了</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isFish(pet)) &#123;</span><br><span class=\"line\">  pet.swim();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.fly();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分之里，一定不是 <code>Fish</code> 类型，一定是 Bird 类型。</p>\n</blockquote>\n<h3 id=\"11-5-typeof-类型守卫\"><a href=\"#11-5-typeof-类型守卫\" class=\"headerlink\" title=\"11.5 typeof 类型守卫\"></a>11.5 typeof 类型守卫</h3><blockquote>\n<p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。 我们可以像下面这样利用类型断言来写：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span>(<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">&quot;number&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span>(<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">&quot;string&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isNumber(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">&quot; &quot;</span>) + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, go <span class=\"subst\">$&#123;padding&#125;</span>.`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。幸运的是，现在我们不必将 <code>typeof x === &quot;number&quot;</code> 抽象成一个函数，因为 <code>TypeScript</code> 可以将它识别为一个类型守卫。也就是说，我们可以直接在代码里检查类型了。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newPadLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">&quot; &quot;</span>) + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, go <span class=\"subst\">$&#123;padding&#125;</span>.`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这些 <code>typeof</code> 类型守卫只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>, <code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。但是 <code>TypeScript</code> 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。</p>\n</blockquote>\n<h3 id=\"11-6-instanceof-类型守卫\"><a href=\"#11-6-instanceof-类型守卫\" class=\"headerlink\" title=\"11.6 instanceof 类型守卫\"></a>11.6 instanceof 类型守卫</h3><blockquote>\n<p><code>instanceof</code> 类型守卫是通过构造函数来细化类型的一种方式。比如，我们借鉴一下之前字符串填充的例子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Padder &#123;</span><br><span class=\"line\">  getPaddingString(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpaceRepeatingPadder</span> <span class=\"title\">implements</span> <span class=\"title\">Padder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> numSpaces: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getPaddingString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(<span class=\"built_in\">this</span>.numSpaces + <span class=\"number\">1</span>).join(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringPadder</span> <span class=\"title\">implements</span> <span class=\"title\">Padder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> value: <span class=\"built_in\">string</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getPaddingString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomPadder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &lt; <span class=\"number\">0.5</span> ? <span class=\"keyword\">new</span> SpaceRepeatingPadder(<span class=\"number\">4</span>) : <span class=\"keyword\">new</span> StringPadder(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类型为 SpaceRepeatingPadder | StringPadder</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> padder: Padder = getRandomPadder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (padder <span class=\"keyword\">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class=\"line\">  padder; <span class=\"comment\">// 类型细化为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (padder <span class=\"keyword\">instanceof</span> StringPadder) &#123;</span><br><span class=\"line\">  padder; <span class=\"comment\">// 类型细化为 &#x27;StringPadder&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>instanceof</code> 的右侧要求是一个构造函数，<code>TypeScript</code> 将细化为:</p>\n</blockquote>\n<ol>\n<li>此构造函数的 <code>prototype</code> 属性的类型，如果它的类型不为 <code>any</code> 的话</li>\n<li>标签签名所返回的类型的联合</li>\n</ol>\n<blockquote>\n<p>以此顺序。</p>\n</blockquote>\n<h3 id=\"11-7-可为-null-的类型\"><a href=\"#11-7-可为-null-的类型\" class=\"headerlink\" title=\"11.7 可为 null 的类型\"></a>11.7 可为 null 的类型</h3><blockquote>\n<p><code>TypeScript</code> 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code> ，它们分别具有值 <code>null</code> 和 <code>undefined</code>。默认情况下，类型检查器会认为 <code>null</code> 和 <code>undefined</code> 可以赋值给任何类型。<code>null</code> 和 <code>undefined</code> 是所有其它类型的一个有效值。这意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。</p>\n</blockquote>\n<blockquote>\n<p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。</p>\n</blockquote>\n<ul>\n<li>你可以使用联合类型明确的包含它们：```typescript<br>let s = “foo”;<br>s = null; // –strictNullChecks 模式下 错误， ‘null’ 不能赋值给 ‘string’<br>let sn: string | null = “bar”;<br>sn = null; // Ok<br>sn = undefined; // –strictNullChecks 模式下 error, 因为’undefined’不能赋值给’string | null’</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;  注意：按照 &#96;JavaScript&#96; &#96;的语义，TypeScript&#96; 会把 &#96;null&#96; 和 &#96;undefined&#96; 区别对待。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; &#96;string | null&#96;，&#96;string | undefined&#96; 和 &#96;string | undefined | null&#96; 是不同的类型。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 11.8 可选参数和可选属性</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- 使用了 &#96;--strictNullChecks&#96; ，可选参数会被自动地加上 &#96;| undefined&#96;:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;typescript</span><br><span class=\"line\">function f(x: number, y?: number) &#123;</span><br><span class=\"line\">    return x + (y || 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(1, 2);</span><br><span class=\"line\">f(1);</span><br><span class=\"line\">f(1, undefined);</span><br><span class=\"line\">f(1, null); &#x2F;&#x2F; error, &#39;null&#39; is not assignable to &#39;number | undefined&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可选属性也会有同样的处理</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  a: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  b?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\">c.a = <span class=\"number\">12</span>;</span><br><span class=\"line\">c.a = <span class=\"literal\">undefined</span>; <span class=\"comment\">// error, &#x27;undefined&#x27; is not assignable to &#x27;number&#x27;</span></span><br><span class=\"line\">c.b = <span class=\"number\">13</span>;</span><br><span class=\"line\">c.b = <span class=\"literal\">undefined</span>; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">c.b = <span class=\"literal\">null</span>; <span class=\"comment\">// error, &#x27;null&#x27; is not assignable to &#x27;number | undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-9-类型守卫和类型断言\"><a href=\"#11-9-类型守卫和类型断言\" class=\"headerlink\" title=\"11.9 类型守卫和类型断言\"></a>11.9 类型守卫和类型断言</h3><blockquote>\n<p>由于可以为 <code>null</code> 的类型是通过联合类型实现，那么你需要使用类型守卫来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sn == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;default&quot;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里很明显地去除了 <code>null</code>, 你也可以使用短路运算符:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sn || <span class=\"string\">&quot;default&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀：<code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">broken</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epihet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name.charAt(<span class=\"number\">0</span>) + <span class=\"string\">&quot;. the&quot;</span> + epihet; <span class=\"comment\">// error, &#x27;name&#x27; is possibly null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">&quot;Bob&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">&quot;great&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fixed</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epihet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name!.charAt(<span class=\"number\">0</span>) + <span class=\"string\">&quot;. the&quot;</span> + epihet; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">&quot;Bob&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">&quot;great&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code> (除非是立即调用的函数表达式)。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数作为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p>\n</blockquote>\n<h3 id=\"11-10-类型别名\"><a href=\"#11-10-类型别名\" class=\"headerlink\" title=\"11.10 类型别名\"></a>11.10 类型别名</h3><ol>\n<li>类型别名会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于 原始值，联合类型，元组 以及其它任何你需要手写的类型。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Name = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> NameResolver = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> NameOrResolver = Name | NameResolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">n: NameOrResolver</span>): <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> n === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。</li>\n</ol>\n<p>3.给原始类型起别名通常没有什么用，尽管可以作为文档的一种形式使用。</p>\n<ol start=\"4\">\n<li>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Container&lt;T&gt; = &#123; <span class=\"attr\">value</span>: T &#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>我们也可以使用类型别名来在属性里引用自己：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tree&lt;T&gt; = &#123;</span><br><span class=\"line\">  value: T;</span><br><span class=\"line\">  left: Tree&lt;T&gt;;</span><br><span class=\"line\">  right: Tree&lt;T&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LinkedList&lt;T&gt; = T &amp; &#123; <span class=\"attr\">next</span>: LinkedList&lt;T&gt; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> people: LinkedList&lt;Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = people.name;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = people.next.name;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = people.next.next.name;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = people.next.next.next.name;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>然而，类型别名不能出现在声明右侧的任何地方</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type Yikes = Array&lt;Yikes&gt;; // error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-11-接口-vs-类型别名\"><a href=\"#11-11-接口-vs-类型别名\" class=\"headerlink\" title=\"11.11 接口 vs 类型别名\"></a>11.11 接口 vs 类型别名</h3><blockquote>\n<p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p>\n</blockquote>\n<ol>\n<li>接口创建了一个新的名字，可以在其它任何地方使用。类型别名并不创建新名字 - 比如，错误信息就不会使用别名。</li>\n</ol>\n<blockquote>\n<p>在下面的示例代码里，在编译器中将鼠标悬停在 <code>interfaced</code> 上，显示它返回的是 <code>Interface</code>，但悬停在 <code>aliased</code> 上时，显示的却是对象字面量类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Alias = &#123; <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Interface &#123;</span><br><span class=\"line\">  num: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aliased</span>(<span class=\"params\">arg: Alias</span>): <span class=\"title\">Alias</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interfaced</span>(<span class=\"params\">arg: Interface</span>): <span class=\"title\">Interface</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>另一个重要区别是类型别名不能被 <code>extends</code> 和 <code>implements</code> (自己也不能 <code>extends</code> 和 <code>implements</code> 其它类型)。因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。</li>\n<li>另一方面，如果你无法通过接口来描述一个类型并且需要使用 联合类型 或 元组类型，这时通常会使用类型别名。</li>\n</ol>\n<h3 id=\"11-12-字符串字面量类型\"><a href=\"#11-12-字符串字面量类型\" class=\"headerlink\" title=\"11.12 字符串字面量类型\"></a>11.12 字符串字面量类型</h3><blockquote>\n<p>字符串字面量类型允许你指定字符串必须的固定值。在实际应用中，字符串字面量类型可以与联合类型，类型守卫和类型别名很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Easing = <span class=\"string\">&quot;ease-in&quot;</span> | <span class=\"string\">&quot;ease-out&quot;</span> | <span class=\"string\">&quot;ease-in-out&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UIElement</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">animate</span>(<span class=\"params\">dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span>, easing: Easing</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (easing === <span class=\"string\">&quot;ease-in&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">&quot;ease-out&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">&quot;ease-in-out&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// error! should not pass null or undefined.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"keyword\">new</span> UIElement();</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;ease-in&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// button.animate(0, 0,&quot;uneasy&quot;); // error: &quot;uneasy&quot; is not allowed here</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>你只能从三种允许的字符中选择其一来作为参数传递，传入其它值则会产生错误。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Argument of type &#x27;&quot;uneasy&quot;&#x27; is not assignable to parameter of type &#x27;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串字面量类型还可以用于区分函数重载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: <span class=\"string\">&quot;img&quot;</span></span>): <span class=\"title\">HTMLImageElement</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createELement</span>(<span class=\"params\">tagName: <span class=\"string\">&quot;input&quot;</span></span>): <span class=\"title\">HTMLInputElement</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// ... more overloads ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: <span class=\"string\">&quot;string&quot;</span></span>): <span class=\"title\">Element</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... code goes here ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-13-数字字面量类型\"><a href=\"#11-13-数字字面量类型\" class=\"headerlink\" title=\"11.13 数字字面量类型\"></a>11.13 数字字面量类型</h3><ul>\n<li><code>TypeScript</code> 还具有数字字面量类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rollDice</span>(<span class=\"params\"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们很少直接这样使用，但它们可以用在缩小范围调试 <code>bug</code> 的时候。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== <span class=\"number\">1</span> || x !== <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ~~~~~~</span></span><br><span class=\"line\">    <span class=\"comment\">// Operator &#x27;!==&#x27; cannot be applied to types &#x27;1&#x27; and &#x27;2&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>换句话说，当 <code>x</code> 与 <code>2</code> 进行比较的时候，它的值必须为 <code>1</code>，这就意味着上面的比较检查是非法的。</p>\n</blockquote>\n<h3 id=\"11-14-枚举成员类型\"><a href=\"#11-14-枚举成员类型\" class=\"headerlink\" title=\"11.14 枚举成员类型\"></a>11.14 枚举成员类型</h3><blockquote>\n<p>如我们在枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。在我们谈及“单例类型”的时候，多数是指 枚举成员类型 和 数字/字符串 字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。</p>\n</blockquote>\n<h3 id=\"11-15-可辨识联合\"><a href=\"#11-15-可辨识联合\" class=\"headerlink\" title=\"11.15 可辨识联合\"></a>11.15 可辨识联合</h3><blockquote>\n<p>你可以合并 单例类型，联合类型，类型守卫 和 类型别名 来创建一个叫做 可辨识联合 的高级模式，它也称作 标签联合 或 代数数据类型。可辨识联合 在函数式编程里很有用处。一些语言会自动地为你辨识联合；而 <code>TypeScript</code> 则基于已有的 <code>JavaScript</code> 模式，。它具有 <code>3</code> 个要素：</p>\n</blockquote>\n<ol>\n<li>具有普通的单例类型属性 - 可辨识的特征</li>\n<li>一个类型别名包含了那些类型的联合 - 联合。</li>\n<li>此属性上的类型守卫</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  size: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Rectangle &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;rectangle&quot;</span>;</span><br><span class=\"line\">  width: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  height: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Circle &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  radius: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>首先我们声明了将要联合的接口。每个接口都有 <code>kind</code> 属性但有不同的字符串字面量类型。<code>kind</code> 属性称作 可辨识的特征或标签。其它的属性则特定于各个接口。注意，目前各个接口间是没有联系的。</p>\n</blockquote>\n<ul>\n<li>下面我们将它们联合到一起。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Shape = Square | Rectangle | Circle;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在我们使用可辨识联合</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.width * s.height;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> areaSquare = area(&#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;square&quot;</span>, <span class=\"attr\">size</span>: <span class=\"number\">12</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> areaRectangle = area(&#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;rectangle&quot;</span>, <span class=\"attr\">width</span>: <span class=\"number\">14</span>, <span class=\"attr\">height</span>: <span class=\"number\">13</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> areaCircle = area(&#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>, <span class=\"attr\">radius</span>: <span class=\"number\">5</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(areaSquare, areaRectangle, areaCircle);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-16-完整性检查\"><a href=\"#11-16-完整性检查\" class=\"headerlink\" title=\"11.16 完整性检查\"></a>11.16 完整性检查</h3><blockquote>\n<p>当没有涵盖所有 可辨识联合 的变化时，我们想让编译器可以通知我们。比如，如果我们添加了 <code>Triangle</code> 和 <code>Shape</code>，我们同时还需要更新 <code>area</code>：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  size: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Rectangle &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;rectangle&quot;</span>;</span><br><span class=\"line\">  width: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  height: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Circle &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  radius: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// interface Triangle &#123; kind: &quot;triangle&quot;, bottom: number, height: number &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Shape = Square | Rectangle | Circle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.width * s.height;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// should error here - we didn&#x27;t handle case &quot;triangle&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>有两种方式可以实现。</li>\n</ul>\n<ol>\n<li>首先是启用 <code>--strictNullChecks</code> 并且指定一个返回值类型:</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area1</span>(<span class=\"params\">s: Shape</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因为 <code>switch</code> 没有包含所有情况，所以 <code>TypeScript</code> 认为这个函数有时候会返回 <code>undefined</code>。如果你明确地指定了返回值类型为 <code>number</code>，那么你会看到一个错误，因为实际上返回值类型为 <code>number | undefined</code>。然而，这种方法存在些微妙之处且 <code>--strictNullChecks</code> 对旧代码支持不好。</p>\n</blockquote>\n<ol start=\"2\">\n<li>第二种方法使用 <code>never</code> 类型，编译器用它来进行完整性检查</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assertNever</span>(<span class=\"params\">x: <span class=\"built_in\">never</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;Unexpected object: &quot;</span> + x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area2</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">     <span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s.width * s.height;</span><br><span class=\"line\">     <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"keyword\">default</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> assertNever(s); <span class=\"comment\">// error here if there are missing cases</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里，<code>assertNever</code> 检查 <code>s</code> 是否为 <code>never</code> 类型 - 即为除去所有可能情况后剩下的类型。如果你忘记了某个 <code>case</code>，那么 <code>s</code> 将具有一个真实的类型并且你会得到一个错误。这种方式需要你定义一个额外的函数，但是在你忘记某个 <code>case</code> 的时候也更加明显。</p>\n</blockquote>\n<h3 id=\"11-17-多态的-this-类型\"><a href=\"#11-17-多态的-this-类型\" class=\"headerlink\" title=\"11.17 多态的 this 类型\"></a>11.17 多态的 this 类型</h3><blockquote>\n<p>多态的 <code>this</code> 类型表示的是某个包含类或接口的子类型。这被称作是 <code>F-bounded</code> 多态性。它能很容易的表现连贯接口间的继承。</p>\n</blockquote>\n<ul>\n<li>比如，在计算器的例子里，在每个操作之后都返回 <code>this</code> 类型。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasicCalculator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">protected</span> value: <span class=\"built_in\">number</span> = <span class=\"number\">0</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> currentValue(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> add(operand: <span class=\"built_in\">number</span>): <span class=\"built_in\">this</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value += operand;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> multiply(operand: <span class=\"built_in\">number</span>): <span class=\"built_in\">this</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value *= operand;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...other operations go here...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"keyword\">new</span> BasicCalculator(<span class=\"number\">2</span>).multiply(<span class=\"number\">5</span>).add(<span class=\"number\">1</span>).currentValue();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(v);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于这个类使用了 <code>this</code> 类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何改变。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScientificCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">BasicCalculator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">value = <span class=\"number\">0</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">sin</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = <span class=\"built_in\">Math</span>.sin(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ... other operations go here ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> v1 = <span class=\"keyword\">new</span> ScientificCalculator(<span class=\"number\">2</span>).multiply(<span class=\"number\">5</span>).sin().add(<span class=\"number\">1</span>).currentValue();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(v1);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果没有 <code>this</code> 类型，<code>ScientificCalculator</code> 就不能够在继承 <code>BasicCalculator</code> 的同时还保持接口的连贯性。<code>multiply</code> 将会返回 <code>BasicCalculator</code>，它并没有 <code>sin</code> 方法。然而，使用 <code>this</code> 类型，<code>multiply</code> 会返回 <code>this</code>，在这里就是 <code>ScientificCalculator</code>。</p>\n</blockquote>\n<h3 id=\"11-18-索引类型\"><a href=\"#11-18-索引类型\" class=\"headerlink\" title=\"11.18 索引类型\"></a>11.18 索引类型</h3><blockquote>\n<p>使用索引类型，编译器就能够检查使用了动态属性名的代码。</p>\n</blockquote>\n<ul>\n<li>例如，一个常见的 <code>JavaScript</code> 模式是从对象中选取属性的子集。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">js_pluck</span>(<span class=\"params\">o, names</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> names.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> o[n]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下面是如何在 <code>TypeScript</code> 里使用此函数，通过 索引类型查询和 索引访问 操作符：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pluck</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">o: T, names: K[]</span>): <span class=\"title\">T</span>[<span class=\"title\">K</span>][] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> names.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> o[n]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person: Person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;Jarid&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">35</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings: <span class=\"built_in\">string</span>[] = pluck(person, [<span class=\"string\">&quot;name&quot;</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strings);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译器会检查 <code>name</code> 是否真的是 <code>Person</code> 的一个属性。本例还引入了几个新的类型操作符。</p>\n</blockquote>\n<h4 id=\"11-18-1-首先是-keyof-T，索引类型查询操作符。\"><a href=\"#11-18-1-首先是-keyof-T，索引类型查询操作符。\" class=\"headerlink\" title=\"11.18.1 首先是 keyof T，索引类型查询操作符。\"></a>11.18.1 首先是 <code>keyof T</code>，索引类型查询操作符。</h4><blockquote>\n<p>对于任何类型 <code>T</code> ，<code>keyof T</code> 的结果为 <code>T</code> 上已知的公共属性名的联合。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> personProps: keyof Person; <span class=\"comment\">// &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>keyof Person</code> 是完全可以与 <code>&#39;name&#39; \\| &#39;age&#39;</code> 互相替换的。不同的是如果你添加了其它的属性到 <code>Person</code>, 例如 <code>address: string</code>，那么<code>keyof Person</code> 会自动变为 <code>&#39;name&#39; | &#39;age&#39; | &#39;address&#39;</code>。你可以像 <code>pluck</code> 函数这类上下文里使用 <code>keyof</code> ，因为在使用之前你并不清楚可能出现的属性名。但编译器会检查你是否传入了正确的属性名给 <code>pluck</code>：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pluck(person, [&#x27;age&#x27;, &#x27;unknown&#x27;]); // error, &#x27;unknown&#x27; is not in &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-18-2-第二个操作符是-T-K-索引访问操作符。\"><a href=\"#11-18-2-第二个操作符是-T-K-索引访问操作符。\" class=\"headerlink\" title=\"11.18.2 第二个操作符是 T[K], 索引访问操作符。\"></a>11.18.2 第二个操作符是 <code>T[K]</code>, 索引访问操作符。</h4><blockquote>\n<p>在这里，类型语法反应了表达式语法。这意味着 <code>person[&#39;name&#39;]</code> 具有类型 <code>Person[&#39;name&#39;]</code> – 在我们的例子里则为 <code>string</code> 类型。然而，就像索引类型查询一样，你可以在普通的上下文里使用 <code>T[K]</code>，这正是它的强大所在。你只要确保类型变量 <code>K extends keyof T</code> 就可以了。</p>\n</blockquote>\n<ul>\n<li>例如下面 <code>getProperty</code> 函数的例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">o: T, name: K</span>): <span class=\"title\">T</span>[<span class=\"title\">K</span>] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o[name]; <span class=\"comment\">// o[name] is of type T[K]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>getProperty</code> 里的 <code>o: T</code> 和 <code>name: K</code>，意味着 <code>o[name]: T[K]</code>。当你返回 <code>T[K]</code> 的结果，</p>\n</blockquote>\n<blockquote>\n<p>编译器会是实例化键的真实类型，因此 <code>getProperty</code> 的返回值类型会随着你需要的属性改变。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _name: <span class=\"built_in\">string</span> = getProperty(person, <span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> _age: <span class=\"built_in\">number</span> = getProperty(person, <span class=\"string\">&quot;age&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// let unknown = getProperty(person, &quot;unknown&quot;); // error, &#x27;unknown&#x27; is not in &#x27;name&#x27; | &#x27;age&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_name, <span class=\"string\">&quot; &quot;</span>, _age);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-19-索引类型和字符串索引签名\"><a href=\"#11-19-索引类型和字符串索引签名\" class=\"headerlink\" title=\"11.19 索引类型和字符串索引签名\"></a>11.19 索引类型和字符串索引签名</h3><blockquote>\n<p><code>keyof</code> 和 <code>T[K]</code> 与字符串索引签名进行交互。如果你有一个带有字符串索引签名的类型，那么 <code>keyof T</code> 会是 <code>string</code>。并且 <code>T[string]</code> 为索引签名的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Dictionary&lt;T&gt; &#123;</span><br><span class=\"line\">  [key: <span class=\"built_in\">string</span>]: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> keys: keyof Dictionary&lt;<span class=\"built_in\">number</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value: Dictionary&lt;<span class=\"built_in\">number</span>&gt;[<span class=\"string\">&quot;foo&quot;</span>]; <span class=\"comment\">// number</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-20-映射类型\"><a href=\"#11-20-映射类型\" class=\"headerlink\" title=\"11.20 映射类型\"></a>11.20 映射类型</h3><ul>\n<li>一个常见的任务是将一个已知的类型每个属性都变为可选的。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PersonPartial &#123;</span><br><span class=\"line\">  name?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>或者我们只想要一个只读版本</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PersonReadonly &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这在 <code>JavaScript</code> 里经常出现。<code>TypeScript</code> 提供了从旧类型中创建新类型的一种方式 <code>--</code> 映射类型。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。假如，你可以令每个属性成为 <code>readonly</code> 类型或可选的。</p>\n</blockquote>\n<ul>\n<li>下面是一些例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>像下面这样使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonPartial = Partial;</span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonReadonly = Readonly;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是，这个语法描述的是类型而非成员。若想添加额外的成员，则可以使用 交叉类型。</p>\n</blockquote>\n<ul>\n<li>这样使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PartialWithNewMember&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125; &amp; &#123; <span class=\"attr\">newMember</span>: <span class=\"built_in\">boolean</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不要这样使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PartialWithNewMember&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">  newMember: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>下面来看看最简单的映射类型和它的组成部分</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Keys = <span class=\"string\">&quot;option1&quot;</span> | <span class=\"string\">&quot;option2&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Flags = &#123; [K <span class=\"keyword\">in</span> Keys]: <span class=\"built_in\">boolean</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它的语法与索引签名的语法类型，内部使用了 <code>for...in</code>。具有三个部分：</p>\n</blockquote>\n<ol>\n<li>类型变量 <code>K</code>，它会依次绑定到每个属性。</li>\n<li>字符串字面量联合的 <code>Keys</code>，它包含了要迭代的属性名的集合。</li>\n<li>属性的结果类型。</li>\n</ol>\n<blockquote>\n<p>在上面这个简单的例子里，<code>Keys</code> 是硬编码的属性列表并且属性类型永远是 <code>boolean</code>，因此这个映射类型</p>\n</blockquote>\n<ul>\n<li>等同于：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> _FLags = &#123;</span><br><span class=\"line\">  option1: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  option2: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在真正的应用里，可能不同于上面的 <code>Readonly</code> 或 <code>Partial</code>。它们会基于一些已存在的类型，且按照一定的方式转换字段。这就是 <code>keyof</code> 和 <code>索引访问类型</code> 要做的事情。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> NullablePerson = &#123; [P <span class=\"keyword\">in</span> keyof Person]: Person[P] | <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> PartialPerson = &#123; [P <span class=\"keyword\">in</span> keyof Person]?: Person[P] &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但它更有用的地方是可以有一些通用版本。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Nullable&lt;T&gt; = &#123; [P <span class=\"keyword\">in</span> keyof T]: T[P] | <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Partial1&lt;T&gt; = &#123; [P <span class=\"keyword\">in</span> keyof T]?: T[P] &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在这些例子里，属性列表是 <code>keyof T</code> 且结果类型是 <code>T[P]</code> 的变体。这是使用通用映射类型的一个好模版。因为这类转换是同态的，映射只作用于 <code>T</code> 的属性而没有其它的。编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。假如，假设 <code>Person.name</code> 是只读的，那么 <code>Partial1&lt;Person&gt;.name</code> 也将是只读的且为可选的。</p>\n</blockquote>\n<blockquote>\n<p>下面是另一个例子，<code>T[P]</code> 被包装在 <code>Proxy&lt;T&gt;</code> 类里：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"built_in\">Proxy</span>&lt;T&gt; = &#123;</span><br><span class=\"line\">  get(): T;</span><br><span class=\"line\">  set(value: T): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]: <span class=\"built_in\">Proxy</span>&lt;T[P]&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">o: T</span>): <span class=\"title\">Proxify</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...wrap proxies</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyProps = proxify(props);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>Readonly&lt;T&gt;</code> 和 <code>Partial&lt;T&gt;</code> 用处不小，因此它们于 <code>pick</code> 和 <code>Record</code> 一同被包含进了 <code>TypeScript</code> 的标准库里：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> K]: T[P];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Record&lt;K <span class=\"keyword\">extends</span> keyof <span class=\"built_in\">any</span>, T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> K]: T;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Readonly</code>, <code>Partial</code> 和 <code>Pick</code> 是同态的，但 <code>Record</code> 不是。因为 <code>Record</code> 并不需要输入类型来拷贝属性，所以它不属于同态：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ThreeStringProps = Record&lt;<span class=\"string\">&quot;prop1&quot;</span> | <span class=\"string\">&quot;prop2&quot;</span> | <span class=\"string\">&quot;prop3&quot;</span>, <span class=\"built_in\">string</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。</p>\n</blockquote>\n<h3 id=\"11-21-由映射类型进行判断\"><a href=\"#11-21-由映射类型进行判断\" class=\"headerlink\" title=\"11.21 由映射类型进行判断\"></a>11.21 由映射类型进行判断</h3><blockquote>\n<p>现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。其实这也非常容易：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class=\"line\">  get(): T;</span><br><span class=\"line\">  set(value: T): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unproxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">t: Proxify&lt;T&gt;</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> t) &#123;</span><br><span class=\"line\">    result[k] = t[k].get();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// let originalProps = unproxify(proxyProps);</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意这个拆包推断只适用于同态的映射类型。如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。</p>\n</blockquote>\n<h3 id=\"11-22-有条件类型\"><a href=\"#11-22-有条件类型\" class=\"headerlink\" title=\"11.22 有条件类型\"></a>11.22 有条件类型</h3><blockquote>\n<p><code>TypeScript 2.8</code> 引入了有条件类型，它能够表示非统一的类型。有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T <span class=\"keyword\">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的类型意思是：若 <code>T</code> 能够赋值给 <code>U</code>，那么类型是 <code>X</code>，否则为 <code>Y</code></p>\n</blockquote>\n<blockquote>\n<p>有条件的类型 <code>T extends U ? X : Y</code> 或者解析为 <code>X</code>，或者解析为 <code>Y</code>，再或者延迟解析，因为它可能依赖一个或多个类型变量。若 <code>T</code> 或 <code>U</code> 包含类型参数，那么是否解析为 <code>X</code> 或 <code>Y</code> 或推迟，取决于类型系统是否有足够的信息来确定 <code>T</code> 总是可以赋值给 <code>U</code>。</p>\n</blockquote>\n<ul>\n<li>下面是一些类型可以被立即解析的例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">boolean</span>&gt;(<span class=\"params\">x: T</span>): <span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">true</span> ? <span class=\"title\">string</span> : <span class=\"title\">number</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Type is &#x27;string&#x27; | &#x27;number&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = f(<span class=\"built_in\">Math</span>.random() &lt; <span class=\"number\">0.5</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另外一个例子涉及 <code>TypeName</code> 类型别名，它使用了嵌套了有条件类型</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TypeName&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span> ? <span class=\"string\">&quot;string&quot;</span> : T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span> ? <span class=\"string\">&quot;number&quot;</span> : T <span class=\"keyword\">extends</span> <span class=\"built_in\">boolean</span> ? <span class=\"string\">&quot;boolean&quot;</span> : T <span class=\"keyword\">extends</span> <span class=\"literal\">undefined</span> ? <span class=\"string\">&quot;undefined&quot;</span> : T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span> ? <span class=\"string\">&quot;function&quot;</span> : <span class=\"string\">&quot;object&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T0 = TypeName&lt;<span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T1 = TypeName&lt;<span class=\"string\">&quot;a&quot;</span>&gt;; <span class=\"comment\">// &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T2 = TypeName&lt;<span class=\"literal\">true</span>&gt;; <span class=\"comment\">// &quot;boolean&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T3 = TypeName&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>&gt;; <span class=\"comment\">// &quot;function&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T4 = TypeName&lt;<span class=\"built_in\">string</span>[]&gt;; <span class=\"comment\">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下面是一个有条件类型被推迟解析的例子</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Foo &#123;</span><br><span class=\"line\">  propA: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  propB: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">x: T</span>): <span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Foo</span> ? <span class=\"title\">string</span> : <span class=\"title\">number</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>&lt;<span class=\"title\">U</span>&gt;(<span class=\"params\">x: U</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Has type &#x27;U extends Foo ? string : number&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = f(x);</span><br><span class=\"line\">  <span class=\"comment\">// This assignment is allowed though!</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> b: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> = a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里，<code>a</code> 变量含有未确定的有条件类型。当有另一段代码调用 <code>foo</code>，它会用其它类型替换 <code>U</code>，<code>TypeScript</code> 将重新计算有条件类型，决定它是否可以选择一个分支。与此同时，我们可以将有条件类型赋值给其它类型，只要有条件类型的每个分支，都可以赋值给目标类型。因此在我们的例子里，我们可以将 <code>U extends Foo ? string : number</code> 赋值给 <code>string | number</code>，因为不管这个有条件类型最终结果是什么，它只能是 <code>string | number</code>。</p>\n</blockquote>\n<h3 id=\"11-23-分布式有条件类型\"><a href=\"#11-23-分布式有条件类型\" class=\"headerlink\" title=\"11.23 分布式有条件类型\"></a>11.23 分布式有条件类型</h3><blockquote>\n<p>如果有条件类型里待检查的类型是 <code>naked type parameter</code> ，那么它也被称为”分布式有条件类型”。分布式有条件类型在实例化时会自动分发成联合类型。例如：实例化 <code>T extends U ? X : Y</code>，<code>T</code> 的类型为 <code>A | B | C</code>，会被解析为 <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>。</p>\n</blockquote>\n<ul>\n<li>例子：```typescript<br>type TypeName<T> =<br>T extends string ? “string” :<br>T extends number ? “number” :<br>T extends boolean ? “boolean” :<br>T extends undefined ? “undefined” :<br>T extends Function ? “function” : “object”;<br>type T10 = TypeName&lt;string | (() =&gt; void)&gt;; // “string” | “function”<br>type T11 = TypeName&lt;string | string[] | undefined&gt;; // “string” | “object” | “undefined”<br>type T12 = TypeName&lt;string[] | number[]&gt;; // “object”</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;  在 &#96;T extends U ? X : Y&#96; 的实例化里，对 &#96;T&#96; 的引用被解析为联合类型的一部分(比如，&#96;T&#96; 指向某一单个部分，在有条件类型分布到联合类型之后)。此外，在 &#96;X&#96; 内对 &#96;T&#96; 的引用有一个附加的类型参数约束 &#96;U&#96;(例如，&#96;T&#96; 被当成在 &#96;X&#96; 内可赋值给 &#96;U&#96;)。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- 例子：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;typescript</span><br><span class=\"line\">type BoxedValue&lt;T&gt; &#x3D; &#123; value: T &#125;;</span><br><span class=\"line\">type BoxedArray&lt;T&gt; &#x3D; &#123; array: T[] &#125;;</span><br><span class=\"line\">type Boxed&lt;T&gt; &#x3D; T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">type T20 &#x3D; Boxed&lt;string&gt;; &#x2F;&#x2F; BoxedValue&lt;string&gt;;</span><br><span class=\"line\">type T21 &#x3D; Boxed&lt;number[]&gt;; &#x2F;&#x2F; BoxedArray&lt;number&gt;;</span><br><span class=\"line\">type T22 &#x3D; Boxed&lt;string | number[]&gt;; &#x2F;&#x2F; BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-23-1-有条件类型的分布式的属性可以方便地用来过滤联合类型：\"><a href=\"#11-23-1-有条件类型的分布式的属性可以方便地用来过滤联合类型：\" class=\"headerlink\" title=\"11.23.1 有条件类型的分布式的属性可以方便地用来过滤联合类型：\"></a>11.23.1 有条件类型的分布式的属性可以方便地用来过滤联合类型：</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Diff&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? <span class=\"built_in\">never</span> : T; <span class=\"comment\">// Remove types from T that are assignable to U(从 T 中删除可分配给 U 的类型)</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Filter&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? T : <span class=\"built_in\">never</span>; <span class=\"comment\">// Remove types from T that are not assignable to U(从 T 中删除不可赋值给 U 的类型)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T30 = Diff&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;b&quot; | &quot;d&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T31 = Filter&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;a&quot; | &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T32 = Diff&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T33 = Filter&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// () =&gt; void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> _NonNullable&lt;T&gt; = Diff&lt;T, <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// Remove null and undefined from T</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T34 = _NonNullable&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T35 = _NonNullable&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string | string[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">x: T, y: _NonNullable&lt;T&gt;</span>) </span>&#123;</span><br><span class=\"line\">  x = y; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">  <span class=\"comment\">// y = x ;// Error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">string</span> | <span class=\"title\">undefined</span>&gt;(<span class=\"params\">x: T, y: _NonNullable&lt;T&gt;</span>) </span>&#123;</span><br><span class=\"line\">  x = y; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">  <span class=\"comment\">// y = x; //Error</span></span><br><span class=\"line\">  <span class=\"comment\">// let s1: string = x; // Error</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> s2: <span class=\"built_in\">string</span> = y; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-23-2-有条件类型与映射类型结合时特别有用\"><a href=\"#11-23-2-有条件类型与映射类型结合时特别有用\" class=\"headerlink\" title=\"11.23.2 有条件类型与映射类型结合时特别有用\"></a>11.23.2 有条件类型与映射类型结合时特别有用</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FunctionPropertyNames&lt;T&gt; = &#123; [K <span class=\"keyword\">in</span> keyof T]: T[K] <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span> ? K : <span class=\"built_in\">never</span> &#125;[keyof T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> NonFunctionPropertyNames&lt;T&gt; = &#123; [K <span class=\"keyword\">in</span> keyof T]: T[K] <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span> ? <span class=\"built_in\">never</span> : K &#125;[keyof T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Part &#123;</span><br><span class=\"line\">  id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  subparts: Part[];</span><br><span class=\"line\">  updatePart(newName: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T40 = FunctionPropertyNames&lt;Part&gt;; <span class=\"comment\">// &quot;updatePart&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T41 = NonFunctionPropertyNames&lt;Part&gt;; <span class=\"comment\">// &quot;id&quot; | &quot;name&quot; | &quot;subparts&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T42 = FunctionProperties&lt;Part&gt;; <span class=\"comment\">// &#123; updatePart(newName: string): void &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T43 = NonFunctionProperties&lt;Part&gt;; <span class=\"comment\">// &#123; id: number, name: string, suparts: Part[] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-23-3-与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。\"><a href=\"#11-23-3-与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。\" class=\"headerlink\" title=\"11.23.3 与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。\"></a>11.23.3 与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。</h4><ul>\n<li>比如下面的错误：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt;: T; // Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-24-有条件类型中的类型推断\"><a href=\"#11-24-有条件类型中的类型推断\" class=\"headerlink\" title=\"11.24 有条件类型中的类型推断\"></a>11.24 有条件类型中的类型推断</h3><blockquote>\n<p>现在有条件类型的 <code>extends</code> 子语句中，允许出现 <code>infer</code> 声明，它会引入一个待推断的类型变量。这个推断的类型变量可以在有条件类型的 <code>true</code> 分支中被引用。允许出现多个同类型变量的 <code>infer</code>。</p>\n</blockquote>\n<blockquote>\n<p>例如：下面代码会提取函数类型的返回值</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> _ReturnType&lt;T&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有条件类型 可以嵌套来构成一系列的匹配模式，按顺序进行求值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Unpacked&lt;T&gt; = T <span class=\"keyword\">extends</span> (infer U)[] ? U : T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer U ? U : T <span class=\"keyword\">extends</span> <span class=\"built_in\">Promise</span>&lt;infer U&gt; ? U : T;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T0 = Unpacked&lt;<span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T1 = Unpacked&lt;<span class=\"built_in\">string</span>[]&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T2 = Unpacked&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T3 = Unpacked&lt;<span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T4 = Unpacked&lt;<span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">string</span>&gt;[]&gt;; <span class=\"comment\">// Promise&lt;string&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T5 = Unpacked&lt;Unpacked&lt;<span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">string</span>&gt;[]&gt;&gt;; <span class=\"comment\">// string</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Foo&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">a</span>: infer U; b: infer U &#125; ? U : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> T10 = Foo&lt;&#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; b: <span class=\"built_in\">string</span> &#125;&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T11 = Foo&lt;&#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; b: <span class=\"built_in\">number</span> &#125;&gt;; <span class=\"comment\">// string | number</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相似地，在抗变位置上同一个类型变量的多个候选类型会被推断为交叉类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Bar&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">a</span>: <span class=\"function\">(<span class=\"params\">x: infer U</span>) =&gt;</span> <span class=\"built_in\">void</span>; b: <span class=\"function\">(<span class=\"params\">x: infer U</span>) =&gt;</span> <span class=\"built_in\">void</span> &#125; ? U : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> T20 = Bar&lt;&#123; <span class=\"attr\">a</span>: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>; b: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span> &#125;&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T21 = Bar&lt;&#123; <span class=\"attr\">a</span>: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>; b: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">void</span> &#125;&gt;; <span class=\"comment\">// string &amp; number</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 当推断具有多个调用签名(例如函数重载类型)的类型时，用最后的签名(大概是最自由的包含所有情况的签名) 进行推断。无法根据参数类型列表来进行解析重载。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;typescript</span><br><span class=\"line\">declare function foo(x: string): number;</span><br><span class=\"line\">declare function foo(x: number): string;</span><br><span class=\"line\">declare function foo(x: string | number): string | number;</span><br><span class=\"line\"></span><br><span class=\"line\">type T30 &#x3D; ReturnType&lt;typeof foo&gt;; &#x2F;&#x2F; string | number</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>无法在正常类型参数的约束子语句中使用 <code>infer</code> 声明：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type ReturnType1&lt;T extends (...args: any[]) =&gt; infer R&gt; = R; // Error</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是，可以这样达到同样的效果，在约束里删掉类型变量，用 有条件类型 来替换：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> AnyFunction = <span class=\"function\">(<span class=\"params\">...args: <span class=\"built_in\">any</span>[]</span>) =&gt;</span> <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ReturnType2&lt;T <span class=\"keyword\">extends</span> AnyFunction&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>实际上，就是 <code>ReturnType</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> __ReturnType&lt;T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>) =&gt; infer R ? R : <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-25-预定义的有条件类型\"><a href=\"#11-25-预定义的有条件类型\" class=\"headerlink\" title=\"11.25 预定义的有条件类型\"></a>11.25 预定义的有条件类型</h3><blockquote>\n<p><code>TypeScript 2.8</code> 在 <code>lib.d.ts</code> 里增加了一些预定义的有条件类型</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>Exclude&lt;T, U&gt;</code> – 从 <code>T</code> 中剔除可以赋值给 <code>U</code> 的类型</li>\n<li><code>Extract&lt;T, U&gt;</code> – 提取 <code>T</code> 中可以赋值给 <code>U</code> 的类型</li>\n<li><code>NonNullable&lt;T&gt;</code> – 从 <code>T</code> 中剔除 <code>null</code> 和 <code>undefined</code></li>\n<li><code>ReturnType&lt;T&gt;</code> – 获取函数返回值类型</li>\n<li><code>InstanceType&lt;T&gt;</code> – 获取构造函数类型的实例类型</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>Example</code>:</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T00 = Exclude&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;b&quot; | &quot;d&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T01 = Extract&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;a&quot; | &quot;c&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T02 = Exclude&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// &quot;string&quot; | &quot;number&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T03 = Extract&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// () =&gt; void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T04 = NonNullable&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T05 = NonNullable&lt;(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>) | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// (() =&gt; string) | string[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: s &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T10 = ReturnType&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T11 = ReturnType&lt;<span class=\"function\">(<span class=\"params\">s: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;; <span class=\"comment\">// void</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T12 = ReturnType&lt;&lt;T&gt;<span class=\"function\">() =&gt;</span> T&gt;; <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T13 = ReturnType&lt;&lt;T <span class=\"keyword\">extends</span> U, U <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span>[]&gt;<span class=\"function\">() =&gt;</span> T&gt;; <span class=\"comment\">// number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T14 = ReturnType&lt;<span class=\"keyword\">typeof</span> f1&gt;; <span class=\"comment\">// &#123; a: number, b: string &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T15 = ReturnType&lt;<span class=\"built_in\">any</span>&gt;; <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T16 = ReturnType&lt;<span class=\"built_in\">never</span>&gt;; <span class=\"comment\">// never</span></span><br><span class=\"line\"><span class=\"comment\">// type T17 = ReturnType&lt;string&gt;; // Error</span></span><br><span class=\"line\"><span class=\"comment\">// type T18 = ReturnType&lt;Function&gt;; // Error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T20 = InstanceType&lt;<span class=\"keyword\">typeof</span> C&gt;; <span class=\"comment\">// C</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T21 = InstanceType&lt;<span class=\"built_in\">any</span>&gt;; <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T22 = InstanceType&lt;<span class=\"built_in\">never</span>&gt;; <span class=\"comment\">// never</span></span><br><span class=\"line\"><span class=\"comment\">// type T23 = InstanceType&lt;string&gt;; // Error</span></span><br><span class=\"line\"><span class=\"comment\">// type T24 = InstanceType&lt;Function&gt;; // Error</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：<code>Exclude</code> 类型是建议的 <code>Diff</code> 类型的一种实现，我们使用 <code>Exclude</code> 这个名字是为了避免破坏已经定义了的 <code>Diff</code> 的代码，并且我们感觉这个名字能更好地表达类型的语义。我们没有增加 <code>Omit&lt;T, K&gt;</code> 类型，因为它可以很容易的用 <code>Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</code> 来表示</p>\n</blockquote>\n<h2 id=\"十二、实用工具类型\"><a href=\"#十二、实用工具类型\" class=\"headerlink\" title=\"十二、实用工具类型\"></a>十二、实用工具类型</h2><blockquote>\n<p><code>TypeScript</code> 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的。</p>\n</blockquote>\n<h3 id=\"12-1-Partial-局部的\"><a href=\"#12-1-Partial-局部的\" class=\"headerlink\" title=\"12.1 Partial 局部的\"></a>12.1 Partial 局部的</h3><blockquote>\n<p>构造类型 <code>T</code>, 并将它所有的属性设置成可选的，它的返回类型表示输入类型的所有子类型。</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PartialTodo &#123;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  description: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateTodo</span>(<span class=\"params\">todo: PartialTodo, fieldsToUpdate: Partial&lt;PartialTodo&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partialTodo1 = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">&quot;organize desk&quot;</span>,</span><br><span class=\"line\">  description: <span class=\"string\">&quot;clear clutter&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partialTodo2 = updateTodo(partialTodo1, &#123;</span><br><span class=\"line\">  description: <span class=\"string\">&quot;throw out trash&quot;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-2-Readonly-只读的\"><a href=\"#12-2-Readonly-只读的\" class=\"headerlink\" title=\"12.2 Readonly 只读的\"></a>12.2 Readonly 只读的</h3><blockquote>\n<p>构造类型 T<strong>，并将它所有的属性设置为</strong> readonly<strong>，也就是说构造出的类型的属性不能被再次赋值</strong></p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ReadonlyTodo &#123;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readonlyTodo: Readonly&lt;ReadonlyTodo&gt; = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">&quot;Delete inactive users&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">readonlyTodo.title = <span class=\"string\">&quot;Hello&quot;</span>; <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.freeze</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">freeze</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T</span>): <span class=\"title\">Readonly</span>&lt;<span class=\"title\">T</span>&gt;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-3-Record-lt-T-K-gt-记录\"><a href=\"#12-3-Record-lt-T-K-gt-记录\" class=\"headerlink\" title=\"12.3 Record&lt;T, K&gt; 记录\"></a>12.3 Record&lt;T, K&gt; 记录</h3><blockquote>\n<p>构造一个类型，其属性名的类型为 <code>K</code>，属性值的类型为 <code>T</code>。这个工具可用来将某个类型的属性映射到另一个类型上。</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PageInfo &#123;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Page = <span class=\"string\">&quot;home&quot;</span> | <span class=\"string\">&quot;about&quot;</span> | <span class=\"string\">&quot;contact&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> x: Record&lt;Page, PageInfo&gt; = &#123;</span><br><span class=\"line\">  about: &#123; <span class=\"attr\">title</span>: <span class=\"string\">&quot;about&quot;</span> &#125;,</span><br><span class=\"line\">  contact: &#123; <span class=\"attr\">title</span>: <span class=\"string\">&quot;concat&quot;</span> &#125;,</span><br><span class=\"line\">  home: &#123; <span class=\"attr\">title</span>: <span class=\"string\">&quot;home&quot;</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-4-Pick-lt-T-K-gt-挑选\"><a href=\"#12-4-Pick-lt-T-K-gt-挑选\" class=\"headerlink\" title=\"12.4 Pick&lt;T, K&gt; 挑选\"></a>12.4 Pick&lt;T, K&gt; 挑选</h3><blockquote>\n<p>从类型 <code>T</code> 中挑选部分属性 <code>K</code> 来构造类型</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PickTodo &#123;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  description: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  completed: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> TodoPreview = Pick&lt;PickTodo, <span class=\"string\">&quot;title&quot;</span> | <span class=\"string\">&quot;completed&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pickTodo: TodoPreview = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">&quot;Clean room&quot;</span>,</span><br><span class=\"line\">  completed: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-5-Exclude-lt-T-U-gt-剔除\"><a href=\"#12-5-Exclude-lt-T-U-gt-剔除\" class=\"headerlink\" title=\"12.5 Exclude&lt;T, U&gt; 剔除\"></a>12.5 Exclude&lt;T, U&gt; 剔除</h3><blockquote>\n<p>从类型 <code>T</code> 中剔除所有可以赋值给 <code>U</code> 的属性，然后构造一个类型。</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T0 = Exclude&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span>&gt;; <span class=\"comment\">// &quot;b&quot; | &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T1 = Exclude&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span>&gt;; <span class=\"comment\">// &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T2 = Exclude&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// string | number</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-6-Extract-lt-T-U-gt-提取\"><a href=\"#12-6-Extract-lt-T-U-gt-提取\" class=\"headerlink\" title=\"12.6 Extract&lt;T, U&gt; 提取\"></a>12.6 Extract&lt;T, U&gt; 提取</h3><blockquote>\n<p>从类型 <code>T</code> 中提取所有可以赋值给 <code>U</code> 的类型，然后构造一个类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T01 = Extract&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;a&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T02 = Extract&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// () =&gt; void</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-7-NonNullable\"><a href=\"#12-7-NonNullable\" class=\"headerlink\" title=\"12.7 NonNullable\"></a>12.7 NonNullable</h3><blockquote>\n<p>从类型 <code>T</code> 中剔除 <code>null</code> 和 <code>undefined</code>，然后构造一个类型</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T10 = NonNullable&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T11 = NonNullable&lt;<span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string[]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-8-ReturnType-返回值类型\"><a href=\"#12-8-ReturnType-返回值类型\" class=\"headerlink\" title=\"12.8 ReturnType 返回值类型\"></a>12.8 ReturnType 返回值类型</h3><blockquote>\n<p>由函数类型 <code>T</code> 的返回值类型构造一个类型</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: s &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T0 = ReturnType&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T1 = ReturnType&lt;<span class=\"function\">(<span class=\"params\">s: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;; <span class=\"comment\">// void</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T2 = ReturnType&lt;&lt;T&gt;<span class=\"function\">() =&gt;</span> T&gt;; <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T3 = ReturnType&lt;&lt;T <span class=\"keyword\">extends</span> U, U <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span>[]&gt;<span class=\"function\">() =&gt;</span> T&gt;; <span class=\"comment\">// number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T4 = ReturnType&lt;<span class=\"keyword\">typeof</span> f1&gt;; <span class=\"comment\">// &#123; a: number, b: string &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T5 = ReturnType&lt;<span class=\"built_in\">any</span>&gt;; <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T6 = ReturnType&lt;<span class=\"built_in\">never</span>&gt;; <span class=\"comment\">// never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T7 = ReturnType&lt;<span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T8 = ReturnType&lt;<span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-9-InstanceType-构造函数-实例类型\"><a href=\"#12-9-InstanceType-构造函数-实例类型\" class=\"headerlink\" title=\"12.9 InstanceType 构造函数 实例类型\"></a>12.9 InstanceType 构造函数 实例类型</h3><blockquote>\n<p>由构造函数类型 <code>T</code> 的实例类型构造一个类型。</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T01 = InstanceType&lt;<span class=\"keyword\">typeof</span> C&gt;; <span class=\"comment\">// C</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T02 = InstanceType&lt;<span class=\"built_in\">any</span>&gt;; <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T03 = InstanceType&lt;<span class=\"built_in\">never</span>&gt;; <span class=\"comment\">// never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T04 = InstanceType&lt;<span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T05 = InstanceType&lt;<span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-10-Required\"><a href=\"#12-10-Required\" class=\"headerlink\" title=\"12.10 Required\"></a>12.10 Required</h3><blockquote>\n<p>构造一个类型，使类型 <code>T</code> 的所有属性为 <code>required</code></p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Props &#123;</span><br><span class=\"line\">  a?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  b?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj: Props = &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;; <span class=\"comment\">// Ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2: Required&lt;Props&gt; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;; <span class=\"comment\">// Error, property &#x27;b&#x27; missing</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-11-ThisType-this\"><a href=\"#12-11-ThisType-this\" class=\"headerlink\" title=\"12.11 ThisType this\"></a>12.11 ThisType this</h3><blockquote>\n<p>这个工具不会返回一个转换后的类型。它作为上下文的 <code>this</code> 类型的一个标记。<br>注意：若想要使用此类型，必须启用 <code>--noImplicitThis</code></p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compile with --noImplicitThis</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ObjectDescriptor&lt;D, M&gt; = &#123;</span><br><span class=\"line\">  data?: D;</span><br><span class=\"line\">  methods?: M &amp; ThisType&lt;D &amp; M&gt;; <span class=\"comment\">// Type of &#x27;this&#x27; in methods is D &amp; M</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeObject</span>&lt;<span class=\"title\">D</span>, <span class=\"title\">M</span>&gt;(<span class=\"params\">desc: ObjectDescriptor&lt;D, M&gt;</span>): <span class=\"title\">D</span> &amp; <span class=\"title\">M</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data: <span class=\"built_in\">object</span> = desc.data || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> methods: <span class=\"built_in\">object</span> = desc.methods || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...data, ...methods &#125; <span class=\"keyword\">as</span> D &amp; M;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _obj = makeObject(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">moveBy</span>(<span class=\"params\">dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.x += dx; <span class=\"comment\">// Strongly typed this</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.y += dy; <span class=\"comment\">// Strongly typed this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">_obj.x = <span class=\"number\">10</span>;</span><br><span class=\"line\">_obj.y = <span class=\"number\">10</span>;</span><br><span class=\"line\">_obj.moveBy(<span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面例子中，<code>makeObject</code> 参数里的 <code>methods</code> 对象具有一个上下文类型 <code>ThisType&lt;D &amp; M&gt;</code>，因此 <code>methods</code> 对象的方法里 this 的类型为 <code>&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;</code>。<br>在 <code>lib.d.ts</code> 里，<code>ThisType&lt;T&gt;</code> 标识接口是个简单的空接口声明。除了在被识别为对象字面量的上下文类型之外，这个接口与一般的空接口没有什么不同。</p>\n</blockquote>\n<h2 id=\"十三、Symbols\"><a href=\"#十三、Symbols\" class=\"headerlink\" title=\"十三、Symbols\"></a>十三、Symbols</h2><blockquote>\n<p>介绍：自 <code>ECMAScript 2015</code> 起，<code>symbol</code> 成为了一种新的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。</p>\n</blockquote>\n<h3 id=\"13-1-symbol-类型的值是通过-Symbol-构造函数创建的。\"><a href=\"#13-1-symbol-类型的值是通过-Symbol-构造函数创建的。\" class=\"headerlink\" title=\"13.1 symbol 类型的值是通过 Symbol 构造函数创建的。\"></a>13.1 <code>symbol</code> 类型的值是通过 <code>Symbol</code> 构造函数创建的。</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>); <span class=\"comment\">// 可选的字符串 key</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-Symbols-是不可改变且唯一的\"><a href=\"#13-2-Symbols-是不可改变且唯一的\" class=\"headerlink\" title=\"13.2 Symbols 是不可改变且唯一的\"></a>13.2 <code>Symbols</code> 是不可改变且唯一的</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym3 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym4 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">sym3 === sym4; <span class=\"comment\">// false symbols 是唯一的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3-像字符串一样，symbols-也可以被用作对象属性的键。\"><a href=\"#13-3-像字符串一样，symbols-也可以被用作对象属性的键。\" class=\"headerlink\" title=\"13.3 像字符串一样，symbols 也可以被用作对象属性的键。\"></a>13.3 像字符串一样，<code>symbols</code> 也可以被用作对象属性的键。</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [sym]: <span class=\"string\">&quot;value&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[sym]); <span class=\"comment\">// &quot;value&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-4-Symbols-也可以与计算出的属性名相结合来声明对象的属性和类成员。\"><a href=\"#13-4-Symbols-也可以与计算出的属性名相结合来声明对象的属性和类成员。\" class=\"headerlink\" title=\"13.4 Symbols 也可以与计算出的属性名相结合来声明对象的属性和类成员。\"></a>13.4 <code>Symbols</code> 也可以与计算出的属性名相结合来声明对象的属性和类成员。</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getClassNameSymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  [getClassNameSymbol]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;C&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> className = c[getClassNameSymbol](); <span class=\"comment\">// &quot;C&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-5-众所周知的-Symbols\"><a href=\"#13-5-众所周知的-Symbols\" class=\"headerlink\" title=\"13.5 众所周知的 Symbols\"></a>13.5 众所周知的 <code>Symbols</code></h3><blockquote>\n<p>除了用户定义的 <code>Symbols</code>，还有一些已经众所周知的内置 <code>symbols</code>。内置 <code>symbols</code> 用来表示语言内部的行为。<br>以下为这些 <code>symbols</code> 的列表：</p>\n</blockquote>\n<ul>\n<li><code>Symbol.hasInstance</code></li>\n</ul>\n<blockquote>\n<p>该方法会被 <code>instanceof</code> 运算符调用。构造器对象用来识别一个对象是否是其实例。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.isConcatSpreadable</code></li>\n</ul>\n<blockquote>\n<p>布尔值，表示当在一个对象上调用 <code>Array.prototype.concat</code> 时，这个对象的数组元素是否可展开。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.iterator</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>for-of</code> 语句调用，。返回对象的默认迭代器</p>\n</blockquote>\n<ul>\n<li><code>Symbol.match</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>String.prototype.match</code> 调用。正则表达式用来匹配字符串</p>\n</blockquote>\n<ul>\n<li><code>Symbol.replace</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>String.prototype.replac</code>e 调用。正则表达式用来替换字符串中匹配的子串。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.search</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>String.prototype.search</code> 调用。正则表达式返回被匹配部分在字符串中的索引。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.species</code></li>\n</ul>\n<blockquote>\n<p>函数值，为一个构造函数。用来创建派生对象。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.split</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>String.prototype.split</code> 调用。正则表达式用来分割字符串。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.toPrimitive</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>ToPrimitive</code> 抽象操作调用。把对象转换为相应的原始值。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.toStringTag</code></li>\n</ul>\n<blockquote>\n<p>方法，被内置方法 <code>Object.prototype.toString</code> 调用。返回创建对象时默认的字符串描述。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.unscopables</code></li>\n</ul>\n<blockquote>\n<p>对象，它自己拥有的属性会被 <code>with</code> 作用域排除在外。</p>\n</blockquote>\n<h2 id=\"十四、迭代器和生成器\"><a href=\"#十四、迭代器和生成器\" class=\"headerlink\" title=\"十四、迭代器和生成器\"></a>十四、迭代器和生成器</h2><ul>\n<li>可迭代性</li>\n</ul>\n<blockquote>\n<p>当一个对象实现了 <code>Symbol.iterator</code> 属性时，我们认为它是可迭代的。一些内置的类型如 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code> 等都已经实现了各自的 <code>Symbol.iterator</code>。对象上的 <code>Symbol.iterator</code> 函数负责返回供迭代的值。</p>\n</blockquote>\n<h3 id=\"14-1-for-…-of-语句\"><a href=\"#14-1-for-…-of-语句\" class=\"headerlink\" title=\"14.1 for … of 语句\"></a>14.1 for … of 语句</h3><blockquote>\n<p><code>for ... of</code> 会遍历可迭代对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p>\n</blockquote>\n<ul>\n<li>下面是在数组上使用 <code>for ... of</code> 的简单例子</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someArray = [<span class=\"number\">1</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"literal\">false</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> someArray) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(entry); <span class=\"comment\">// 1, &quot;string&quot;, false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-2-for-…-of-Vs-for-…-in-语句\"><a href=\"#14-2-for-…-of-Vs-for-…-in-语句\" class=\"headerlink\" title=\"14.2 for … of Vs for … in 语句\"></a>14.2 for … of Vs for … in 语句</h3><blockquote>\n<p><code>for ... of</code> 和 <code>for ... in</code> 均可迭代一个列表；但是用于迭代的值却不同，<code>for ... in</code> 迭代的是对象的 <code>键</code> 的列表，而 <code>for ... of</code> 则迭代对象的键对应的值。</p>\n</blockquote>\n<ul>\n<li>下面的例子展示了两者之间的区别：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> list) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// &quot;0&quot; &quot;1&quot; &quot;2&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> list) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// &quot;4&quot; &quot;5&quot; &quot;6&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另一个区别是 <code>for ... in</code> 可以操作任何对象；它提供了查看对象属性的一种方法。但是 <code>for ... of</code> 关注于迭代对象的值。内置对象 <code>Map</code> 和 <code>Set</code> 已经实现了 <code>Symbol.iterator</code> 方法，让我们可以访问它们保存的值。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pets = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&quot;Cat&quot;</span>, <span class=\"string\">&quot;Dog&quot;</span>, <span class=\"string\">&quot;Hamster&quot;</span>]);</span><br><span class=\"line\">pets[<span class=\"string\">&quot;species&quot;</span>] = <span class=\"string\">&quot;mammals&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">in</span> pets) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(pet);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">of</span> pets) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-3-代码生成目标为-ES5-和-ES3\"><a href=\"#14-3-代码生成目标为-ES5-和-ES3\" class=\"headerlink\" title=\"14.3 代码生成目标为 ES5 和 ES3\"></a>14.3 代码生成目标为 <code>ES5</code> 和 <code>ES3</code></h3><blockquote>\n<p>当生成目标为 <code>ES5</code> 或 <code>ES3</code>，迭代器只允许在 <code>Array</code> 类型上使用。在非数组值上使用 <code>for ... of</code> 语句会得到一个错误，就算这些非数组值已经实现了 <code>Symbol.iterator</code> 属性。</p>\n</blockquote>\n<blockquote>\n<p>编译器会生成一个简单的 <code>for</code> 循环做为 <code>for ... of</code> 循环，比如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 生成的代码为：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">number</span> = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> _i = <span class=\"number\">0</span>; _i &lt; numbers.length; _i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> num = numbers[_i];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-4-目标为-ECMAScript-2015-或更高\"><a href=\"#14-4-目标为-ECMAScript-2015-或更高\" class=\"headerlink\" title=\"14.4 目标为 ECMAScript 2015 或更高\"></a>14.4 目标为 <code>ECMAScript 2015</code> 或更高</h3><blockquote>\n<p>当目标为兼容 <code>ECMAScript 2015</code> 的引擎时，编译器会生成相应引擎的 <code>for ... of</code> 内置迭代器实现方式。</p>\n</blockquote>\n<h2 id=\"十五、模块\"><a href=\"#十五、模块\" class=\"headerlink\" title=\"十五、模块\"></a>十五、模块</h2><h3 id=\"15-1-关于术语的一点说明\"><a href=\"#15-1-关于术语的一点说明\" class=\"headerlink\" title=\"15.1 关于术语的一点说明\"></a>15.1 关于术语的一点说明</h3><blockquote>\n<p>请务必注意一点：<code>TypeScript 1.5</code> 里术语名已经发生了变化。”<code>内部模块</code>“ 现在被称作 “<code>命名空间</code>“。”<code>外部模块</code>“ 现在则简称为 “<code>模块</code>“。这是为了与 <code>ECMAScript 2015</code> 里的术语保持已一致， (也就是说 <code>module X</code> { 相当于现在推荐的写法 <code>namespace X</code> })</p>\n</blockquote>\n<h3 id=\"15-2-介绍\"><a href=\"#15-2-介绍\" class=\"headerlink\" title=\"15.2 介绍\"></a>15.2 介绍</h3><ol>\n<li>从 <code>ECMAScript 2015</code> 开始，<code>JavaScript</code> 引入了模块的概念。<code>TypeScript</code> 也沿用这个概念。</li>\n<li>模块在其自身的作用域里执行，而不是在全局作用域；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用 <code>export</code> 形式之一导出它们。相反，如果想使用其它模块导出的 <code>变量</code>，<code>函数</code>，<code>类</code>，<code>接口</code> 等的时候，你必须要导入它们，可以使用 <code>import</code> 形式之一。</li>\n<li>模块是自声明的；两个模块之间的关系是通过在文件级别上使用 <code>import</code> 和 <code>exports</code> 建立的。</li>\n<li>模块使用模块加载器去导入其它的模块。在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。大家最熟知的 <code>JavaScript</code> 模块加载器是服务与 <code>Node.js</code> 的 <code>CommonJS</code> 和 服务于 <code>Web</code> 应用的 <code>Require.js</code>。</li>\n<li><code>TypeScript</code> 和 <code>ECMAScript 2015</code> 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 <code>import</code> 或者 <code>export</code> 声明，那么它的内容将被视为全局可见的 (因此对模块也是可见的)。</li>\n</ol>\n<h3 id=\"15-3-导出\"><a href=\"#15-3-导出\" class=\"headerlink\" title=\"15.3 导出\"></a>15.3 导出</h3><h4 id=\"15-3-1-导出声明\"><a href=\"#15-3-1-导出声明\" class=\"headerlink\" title=\"15.3.1. 导出声明\"></a>15.3.1. 导出声明</h4><blockquote>\n<p>任何声明( 比如 <code>变量</code>，<code>函数</code>，<code>类</code>，<code>类型别名</code> 或 <code>接口</code> )都能够通过添加 <code>export</code> 关键字来导出。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-3-2-导出语句\"><a href=\"#15-3-2-导出语句\" class=\"headerlink\" title=\"15.3.2 导出语句\"></a>15.3.2 导出语句</h4><blockquote>\n<p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator1</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ZipCodeValidator1 &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ZipCodeValidator1 <span class=\"keyword\">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-3-3-重新导出\"><a href=\"#15-3-3-重新导出\" class=\"headerlink\" title=\"15.3.3 重新导出\"></a>15.3.3 重新导出</h4><blockquote>\n<p>我们经常会去扩展其它模块，并且只导出那个模块的那部分内容。</p>\n</blockquote>\n<blockquote>\n<p>重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseIntBasedZipCodeValidator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isAcceptable</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; <span class=\"built_in\">parseInt</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 导出原先的验证器但做了重命名</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ZipCodeValidator <span class=\"keyword\">as</span> RegExpBasedZipCodeValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>或者一个模块可以包裹多个模块，并把它们导出的内容联合在一起，通过语法：<code>export * from &quot;module&quot;</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StringValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./LetterOnlyValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-4-导入\"><a href=\"#15-4-导入\" class=\"headerlink\" title=\"15.4 导入\"></a>15.4 导入</h3><blockquote>\n<p>模块的导入操作与导出一样简单，可以使用以下 <code>import</code> 形式之一来导入其它模块中的导出内容。</p>\n</blockquote>\n<h4 id=\"15-4-1-导入一个模块中的某个导出内容\"><a href=\"#15-4-1-导入一个模块中的某个导出内容\" class=\"headerlink\" title=\"15.4.1 导入一个模块中的某个导出内容\"></a>15.4.1 导入一个模块中的某个导出内容</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以对导入内容重命名</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator <span class=\"keyword\">as</span> ZCV &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> ZCV();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分\"><a href=\"#15-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分\" class=\"headerlink\" title=\"15.4.2 将整个模块导入到一个变量，并通过它来访问模块的导出部分\"></a>15.4.2 将整个模块导入到一个变量，并通过它来访问模块的导出部分</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> validator <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> validator.ZipCodeValidator();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-4-3-具有副作用的导入模块\"><a href=\"#15-4-3-具有副作用的导入模块\" class=\"headerlink\" title=\"15.4.3 具有副作用的导入模块\"></a>15.4.3 具有副作用的导入模块</h4><blockquote>\n<p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。这些模块可能没有任何的导出或用户根本</p>\n</blockquote>\n<blockquote>\n<p>就不关注它的导出。使用下面的方法来导入这些模块。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./my-module.js&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-5-默认导出\"><a href=\"#15-5-默认导出\" class=\"headerlink\" title=\"15.5 默认导出\"></a>15.5 默认导出</h3><blockquote>\n<p>每个模块都可以有一个 <code>default</code> 导出。默认导出使用 <code>default</code> 关键字标记；并且一个模块只能够有一个 <code>default</code> 导出。需要使用 一种特殊的导入形式来导入 <code>default</code> 导出。</p>\n</blockquote>\n<blockquote>\n<p><code>default</code> 导出十分便利。比如，像 <code>JQuery</code> 这样的类库可能有一个默认导出 <code>jQuery</code> 或 <code>$</code>，并且我们基本上也会使用同样的名字 <code>jQuery</code> 或 <code>$</code> 导出 <code>JQuery</code>。</p>\n</blockquote>\n<ul>\n<li><code>JQuery.d.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">let</span> $: JQuery;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> $;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>App.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&quot;JQuery&quot;</span>;</span><br><span class=\"line\">$(<span class=\"string\">&quot;button.continue&quot;</span>).html(<span class=\"string\">&quot;Next step ...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类和函数声明可以直接被标记为默认导出。标记为默认导出的类和函数的名字是可以省略的。</p>\n</blockquote>\n<ul>\n<li><code>ZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isAcceptable</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; ZipCodeValidator.numberRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> validator <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> validator();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>或者</code></p>\n</blockquote>\n<ul>\n<li><code>StaticZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> validate <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StaticZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// use function validate</span></span><br><span class=\"line\">strings.forEach(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; <span class=\"subst\">$&#123;validate(s)&#125;</span> ? &quot; matches&quot; : &quot; does not match&quot;`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>default</code> 导出也可以是一个值</p>\n</blockquote>\n<ul>\n<li><code>OneTwoThree.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Log.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> num <span class=\"keyword\">from</span> <span class=\"string\">&quot;./OneTwoThree&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num); <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>export =</code> 和 <code>import = require()</code></p>\n</blockquote>\n<ol>\n<li><code>CommonJS</code> 和 <code>AMD</code> 的环境里都有一个 <code>exports</code> 变量，这个变量包含了一个模块的所有导出内容。</li>\n<li><code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code> 都可以被赋值为一个对象，这种情况下其作用就类似于 es6 语法里的默认导出，即 <code>export default</code> 语法了。虽然作用相似，但是 <code>export default</code> 语法并不能兼容 <code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code>。</li>\n<li>为了支持 <code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code>，<code>TypeScript</code> 提供了 <code>export =</code> 语法。</li>\n<li><code>export =</code> 语法定义一个模块的导出对象。这里的对象一词指的是类，接口，命名空间，函数或枚举。</li>\n<li>若使用 <code>export =</code> 导出一个模块，则必须使用 <code>TypeScript</code> 的特定语法 <code>import module = require(&#39;module&#39;)</code> 来导入此模块。</li>\n</ol>\n<ul>\n<li><code>ZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isAcceptable</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> = ZipCodeValidator; <span class=\"comment\">// 重点</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> zip = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>); <span class=\"comment\">// 重点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98502&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> zip();</span><br><span class=\"line\">strings.forEach(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;validator.isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-6-生成模块代码\"><a href=\"#15-6-生成模块代码\" class=\"headerlink\" title=\"15.6 生成模块代码\"></a>15.6 生成模块代码</h3><blockquote>\n<p>根据编译时指定的模块目标参数，编译器会生成相应的供 <code>Node.js\\(CommonJS\\)，Require.js\\(AMD\\)</code>，<code>UMD</code>，<code>SystemJS</code> 或 <code>ECMAScript 2015 native module\\(ES6\\)</code> 模块加载系统使用的代码。</p>\n</blockquote>\n<blockquote>\n<p>想要了解生成代码中 <code>define</code>，<code>require</code> 和 <code>register</code> 的意义，需要参考相应的模块加载器的文档。</p>\n</blockquote>\n<ul>\n<li><code>SimpleModule.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> m = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;mod&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> t = m.something + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>AMD / RequireJS SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./mod&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>, mod_1</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.t = mod_1.something + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>CommonJS / Node SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mod_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./mod&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.t = mod_1.something + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>UMD SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">factory</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span>.exports === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> v = factory(<span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v !== <span class=\"literal\">undefined</span>) <span class=\"built_in\">module</span>.exports = v;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./mod&quot;</span>], factory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mod_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./mod&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.t = mod_1.something + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>System SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.register([<span class=\"string\">&quot;./mod&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">exports_1</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mod_1;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> t;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    setters: [</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mod_1_1</span>) </span>&#123;</span><br><span class=\"line\">        mod_1 = mod_1_1;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    execute: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      exports_1(<span class=\"string\">&quot;t&quot;</span>, (t = mod_1.something + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Native ECMAScript 2015 modules SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; something &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./mod&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> t = something + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-7-简单示例\"><a href=\"#15-7-简单示例\" class=\"headerlink\" title=\"15.7 简单示例\"></a>15.7 简单示例</h3><blockquote>\n<p>下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。</p>\n</blockquote>\n<blockquote>\n<p>为了编译，我们必须要在命令行上指定一个模块目标。对于 <code>Node.js</code> 来说，使用 <code>--module commonjs</code>；对于 <code>Require.js</code> 来说，使用 <code>--module amd</code>。</p>\n</blockquote>\n<ul>\n<li>比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc --<span class=\"built_in\">module</span> commonjs Test.ts</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译完成后，每个模块会生成一个单独的 <code>.js</code> 文件。好比使用了 <code>reference</code> 标签，编译器会根据 <code>import</code> 语句编译相应的文件。</p>\n</blockquote>\n<ul>\n<li><code>Validation.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>LetterOnlyValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; StringValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> lettersRegExp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LetterOnlyValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lettersRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; StringValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; StringValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; LetterOnlyValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./LetterOnlyValidator&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Some samples to try</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Validators to use</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> validators: &#123; [s: <span class=\"built_in\">string</span>]: StringValidator &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> LetterOnlyValidator();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Show whether each string passed each validator</span></span><br><span class=\"line\">strings.forEach(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-8-可选的模块加载和其它高级加载场景\"><a href=\"#15-8-可选的模块加载和其它高级加载场景\" class=\"headerlink\" title=\"15.8 可选的模块加载和其它高级加载场景\"></a>15.8 可选的模块加载和其它高级加载场景</h3><ol>\n<li>有时候，你只想在某种条件下才加载某个模块。在 <code>TypeScript</code> 里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且保证类型完全。</li>\n<li>编译器会检测是否每个模块都会在生成的 <code>JavaScript</code> 中用到。如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 <code>require</code> 这个模块的代码。省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。</li>\n<li>这种模式的核心是 <code>import id = require(&quot;...&quot;)</code> 语句可以让我们访问模块导出的类型。模块加载器会被动态调用(通过 <code>require</code>)，就像下面的 <code>if</code> 代码块里那样。它利用了省略引用的优化，所以模块只在被需要时加载。为了让这个模块工作，一定要注意 <code>import</code> 定义的标识符只能在表示类型处使用(不能在会转换成 <code>JavaScript</code> 的地方。)</li>\n<li>为了确保类型安全性，我们可以使用 <code>typeof</code> 关键字。<code>typeof</code> 关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。</li>\n</ol>\n<ul>\n<li><code>示例 1</code>. <code>Node.js</code> 里的动态模块加载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">require</span>(<span class=\"params\">moduleName: <span class=\"built_in\">string</span></span>): <span class=\"title\">any</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator <span class=\"keyword\">as</span> Zip &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidator) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ZipCodeValidator: <span class=\"keyword\">typeof</span> Zip = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (validator.isAcceptable(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">    /!* ... *!/;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>示例 2</code>. <code>require.js</code> 里的动态模块加载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">require</span>(<span class=\"params\">moduleNames: <span class=\"built_in\">string</span>[], onLoad: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Zip <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidator) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>], <span class=\"function\">(<span class=\"params\">ZipCodeValidator: <span class=\"keyword\">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> ZipCodeValidator.ZipCodeValidator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validator.isAcceptable(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">      /!* ... *!/;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>示例 3</code>. <code>System.js</code> 里的动态模块加载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> System: <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator <span class=\"keyword\">as</span> Zip &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidator) &#123;</span><br><span class=\"line\">  System.import(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>).then(<span class=\"function\">(<span class=\"params\">ZipCodeValidator: <span class=\"keyword\">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.isAcceptable(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">      /!*...*!/;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-9-使用其它的-JavaScript-库\"><a href=\"#15-9-使用其它的-JavaScript-库\" class=\"headerlink\" title=\"15.9 使用其它的 JavaScript 库\"></a>15.9 使用其它的 JavaScript 库</h3><blockquote>\n<p>要想描述非 <code>TypeScript</code> 编写的类库的类型，我们需要声明类库所暴露的 <code>API</code>。</p>\n</blockquote>\n<blockquote>\n<p>我们叫它声明因为它不是’外部程序’的具体实现，它们通常是在 <code>.d.ts</code> 文件里定义的。类似于 <code>C/C++</code> 里的 <code>.h</code> 文件。</p>\n</blockquote>\n<h4 id=\"15-9-1-外部模块\"><a href=\"#15-9-1-外部模块\" class=\"headerlink\" title=\"15.9.1 外部模块\"></a>15.9.1 外部模块</h4><blockquote>\n<p>在 <code>Node.js</code> 里大部分工作是通过加载一个或多个模块实现的。我们可以使用顶级的 <code>export</code> 声明来为每个模块都定义一个 <code>.d.ts</code> 文件，但最好还是写在一个大的 <code>.d.ts</code> 文件里。我们使用与构造一个外部命名空间相似的方法，但是这里使用 <code>module</code> 关键字并且把名字用引号括起来，方便之后 <code>import</code>。</p>\n</blockquote>\n<ul>\n<li><code>例如：</code></li>\n<li><code>node.d.ts(simplified except)</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;url&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Url &#123;</span><br><span class=\"line\">    protocol?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    hostname?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    pathname?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parse</span>(<span class=\"params\">urlStr: <span class=\"built_in\">string</span>, parseQueryString?, slashesDenoteHost?</span>): <span class=\"title\">Url</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;path&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalize</span>(<span class=\"params\">p: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">join</span>(<span class=\"params\">...paths: <span class=\"built_in\">any</span>[]</span>): <span class=\"title\">string</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> sep: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>现在我们可以 <code>/// &lt;reference&gt; node.d.ts</code> 并且使用 <code>import url = require(&#39;url&#39;)</code>；或 <code>import * as URl from &quot;url&quot;</code> 加载模块。`</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;node.d.ts&quot;&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> URL <span class=\"keyword\">from</span> <span class=\"string\">&quot;url&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myUrl = URL.parse(<span class=\"string\">&quot;http://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-9-2-外部模块简写\"><a href=\"#15-9-2-外部模块简写\" class=\"headerlink\" title=\"15.9.2 外部模块简写\"></a>15.9.2 外部模块简写</h4><blockquote>\n<p>假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。</p>\n</blockquote>\n<blockquote>\n<p><code>declarations.d.ts</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;hot-new-module&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>简写模块里所有导出类型将是 <code>any</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> x, &#123; y &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;hot-new-module&quot;</span>;</span><br><span class=\"line\">x(y);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-9-3-模块声明通配符\"><a href=\"#15-9-3-模块声明通配符\" class=\"headerlink\" title=\"15.9.3 模块声明通配符\"></a>15.9.3 模块声明通配符</h4><blockquote>\n<p>某些模块加载器如 <code>SystemJS</code> 和 <code>AMD</code> 支持导入非 <code>JavaScript</code> 内容。它们通常会使用一个前缀或后缀来表示特殊的加载语法，模块声明通配符可以用来表示这些情况。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;*!text&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> content: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>some do it the other way around</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;json!*&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在你可以就导入匹配 <code>&quot;!text&quot;</code> 或 <code>&quot;json!&quot;</code> 的内容了。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fileContent <span class=\"keyword\">from</span> <span class=\"string\">&quot;./xyz.txt!txt&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> data <span class=\"keyword\">from</span> <span class=\"string\">&quot;json!http://example.com/data.json&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data, fileContent);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-9-4-UMD-模块\"><a href=\"#15-9-4-UMD-模块\" class=\"headerlink\" title=\"15.9.4 UMD 模块\"></a>15.9.4 <code>UMD</code> 模块</h4><blockquote>\n<p>有些模块被设计成兼容多个模块加载器，或者不使用模块加载器(全局变量)。它们以 <code>UMD</code> 模块为代表。这些库可以通过导入的形式或全局变量的形式访问。</p>\n</blockquote>\n<ul>\n<li><code>例如：</code></li>\n<li><code>math-lib.d.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPrime</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>): <span class=\"title\">boolean</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">as</span> <span class=\"keyword\">namespace</span> mathLib;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>之后，这个库可以在某个模块里通过导入来使用:</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; isPrime &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;math-lib&quot;</span>;</span><br><span class=\"line\">isPrime(<span class=\"number\">2</span>);</span><br><span class=\"line\">mathLib.isPrime(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>它同样可以通过全局变量的形式使用，但只能在某个脚本(指不带有模块导入或导出的脚本文件)里。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mathLib.isPrime(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-10-创建模块结构指导\"><a href=\"#15-10-创建模块结构指导\" class=\"headerlink\" title=\"15.10 创建模块结构指导\"></a>15.10 创建模块结构指导</h3><h4 id=\"15-10-1-尽可能地在顶层导出\"><a href=\"#15-10-1-尽可能地在顶层导出\" class=\"headerlink\" title=\"15.10.1 尽可能地在顶层导出\"></a>15.10.1 尽可能地在顶层导出</h4><ol>\n<li>用户应该更容易地使用你模块导出的内容。嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</li>\n<li>从你的模块中导出一个命名空间就是一个增加嵌套的例子。虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。这对用户来说是很不方便的并且通常是多余的。</li>\n<li>导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。除非它能方便地表述或便于清晰使用，否则请考虑直接导出一个辅助方法。</li>\n</ol>\n<h4 id=\"15-10-2-如果仅导出单个-class-或-function，使用-export-default\"><a href=\"#15-10-2-如果仅导出单个-class-或-function，使用-export-default\" class=\"headerlink\" title=\"15.10.2 如果仅导出单个 class 或 function，使用 export default\"></a>15.10.2 如果仅导出单个 <code>class</code> 或 <code>function</code>，使用 <code>export default</code></h4><blockquote>\n<p>就像” <code>在顶层导出</code> “帮助减少用户使用的难度，一个默认的导出也能起到这个效果。如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。这会令模块的导入和使用变得些许简单，比如：</p>\n</blockquote>\n<ul>\n<li><code>MyClass.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    /!* ... *!/;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>MyFunc.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getThing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;thing&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Consumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> t <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyClass&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> f <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyFunc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> t();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f());</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对用户来说这是最理想的。他们可以随意命名导入模块的类型 (本例为 <code>t</code> ) 并且不需要多余的 ( <code>.</code> ) 来找到相关对象。</p>\n</blockquote>\n<h4 id=\"15-10-3-如果要导出多个对象，把它们放在顶层里导出\"><a href=\"#15-10-3-如果要导出多个对象，把它们放在顶层里导出\" class=\"headerlink\" title=\"15.10.3 如果要导出多个对象，把它们放在顶层里导出\"></a>15.10.3 如果要导出多个对象，把它们放在顶层里导出</h4><ul>\n<li><code>MyThings.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeType</span> </span>&#123;/!*...*!/&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-10-4-相反地，当导入的时候-明确地列出导入的名字。\"><a href=\"#15-10-4-相反地，当导入的时候-明确地列出导入的名字。\" class=\"headerlink\" title=\"15.10.4 (相反地，当导入的时候)明确地列出导入的名字。\"></a>15.10.4 (相反地，当导入的时候)明确地列出导入的名字。</h4><ul>\n<li><code>Consumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; SomeType, someFunc &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyThings&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> SomeType();</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = someFunc();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-10-5-使用命名空间导入模式当你要导出大量内容的时候\"><a href=\"#15-10-5-使用命名空间导入模式当你要导出大量内容的时候\" class=\"headerlink\" title=\"15.10.5 使用命名空间导入模式当你要导出大量内容的时候\"></a>15.10.5 使用命名空间导入模式当你要导出大量内容的时候</h4><ul>\n<li><code>MyLargeModule.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Flower</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Consumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> myLargeModule <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyLargeModule.ts&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> myLargeModule.Dog();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-10-6-使用重新导出进行扩展\"><a href=\"#15-10-6-使用重新导出进行扩展\" class=\"headerlink\" title=\"15.10.6 使用重新导出进行扩展\"></a>15.10.6 使用重新导出进行扩展</h4><blockquote>\n<p>你可能经常需要扩展一个模块的功能。<code>JS</code> 里常用的一个模式是 <code>JQuery</code> 那样去扩展原对象。如我们之前提到的，模块不会像全局命名空间那样去合并。推荐的方案是 不要去改变原来的对象，而是导出一个新的实体来提供新的功能。</p>\n</blockquote>\n<blockquote>\n<p>假设 <code>Calculator.ts</code> 模块里定义了一个简单的计算器实现。这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。</p>\n</blockquote>\n<ul>\n<li><code>Calculator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> memory = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> operator: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">processDigit</span>(<span class=\"params\">digit: <span class=\"built_in\">string</span>, currentValue: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digit &gt;= <span class=\"string\">&quot;0&quot;</span> &amp;&amp; digit &lt;= <span class=\"string\">&quot;9&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> currentValue * <span class=\"number\">10</span> + (digit.charCodeAt(<span class=\"number\">0</span>) - <span class=\"string\">&quot;0&quot;</span>.charCodeAt(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">processOperator</span>(<span class=\"params\">operator: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;/&quot;</span>].indexOf(operator) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> operator;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> evaluateOperator(operator: <span class=\"built_in\">string</span>, <span class=\"attr\">left</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">right</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">this</span>.operator) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left - right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left * right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left / right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"title\">evaluate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.operator) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.memory = <span class=\"built_in\">this</span>.evaluateOperator(<span class=\"built_in\">this</span>.operator, <span class=\"built_in\">this</span>.memory, <span class=\"built_in\">this</span>.current);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.memory = <span class=\"built_in\">this</span>.current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">handleChar</span>(<span class=\"params\">char: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (char === <span class=\"string\">&quot;=&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.evaluate();</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> value = Calculator.processDigit(char, <span class=\"built_in\">this</span>.current);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.current = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = Calculator.processOperator(char);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.evaluate();</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.operator = value;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Unsupported input: &#x27;<span class=\"subst\">$&#123;char&#125;</span>&#x27;`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">getResult</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.memory;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">c: Calculator, input: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; input.length; i++) &#123;</span><br><span class=\"line\">    c.handleChar(input[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`result of &#x27;<span class=\"subst\">$&#123;input&#125;</span>&#x27; is &#x27;<span class=\"subst\">$&#123;c.getResult()&#125;</span>&#x27;`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下面使用导出的 <code>test</code> 函数来测试计算器</li>\n<li><code>TestCalculator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Calculator, test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> Calculator();</span><br><span class=\"line\">test(c, <span class=\"string\">&quot;1+2*33/11=&quot;</span>); <span class=\"comment\">// prints 9</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在扩展它，添加支持输入其它进制(十进制以外)。</li>\n<li><code>ProgrammerCalculator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Calculator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProgrammerCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">Calculator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> digits = [<span class=\"string\">&quot;0&quot;</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;4&quot;</span>, <span class=\"string\">&quot;5&quot;</span>, <span class=\"string\">&quot;6&quot;</span>, <span class=\"string\">&quot;7&quot;</span>, <span class=\"string\">&quot;8&quot;</span>, <span class=\"string\">&quot;9&quot;</span>, <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>, <span class=\"string\">&quot;F&quot;</span>];</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> base: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> maxBase = ProgrammerCalculator.digits.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (base &lt;= <span class=\"number\">0</span> || base &gt; maxBase) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`base has to be within 0 to <span class=\"subst\">$&#123;maxBase&#125;</span> inclusive`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"title\">processDigit</span>(<span class=\"params\">digit: <span class=\"built_in\">string</span>, currentValue: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ProgrammerCalculator.digits.indexOf(digit) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> currentValue * <span class=\"built_in\">this</span>.base + ProgrammerCalculator.digits.indexOf(digit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ProgrammerCalculator <span class=\"keyword\">as</span> Calculator &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>新的 <code>ProgrammerCalculator</code> 模块导出的 API 与原先的 <code>Calculator</code> 模块很相似，但却没有改变原模块里的对象。</p>\n</blockquote>\n<ul>\n<li><code>TestProgrammerCalculator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Calculator, test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ProgrammerCalculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> Calculator(<span class=\"number\">2</span>);</span><br><span class=\"line\">test(c, <span class=\"string\">&quot;001+010=&quot;</span>); <span class=\"comment\">// prints 3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-10-7-模块里不要使用命名空间\"><a href=\"#15-10-7-模块里不要使用命名空间\" class=\"headerlink\" title=\"15.10.7 模块里不要使用命名空间\"></a>15.10.7 模块里不要使用命名空间</h4><blockquote>\n<p>当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。记住这点，命名空间在使用模块时几乎没什么价值。</p>\n</blockquote>\n<blockquote>\n<p>在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型分组是很便利的。例如，在 <code>C\\#</code> 里，你会从 <code>System.Collections</code> 里找到所有集合的类型。通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。然而，模块本身已经存在于文件系统之中，这是必须的。我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。我们可以创建 <code>/collections/generic/</code> 文件夹，把相应模块放在这里。</p>\n</blockquote>\n<blockquote>\n<p>命名空间对解决全局作用域里命名冲突来说是很重要的。比如，你有一个 <code>My.Application.Customer.AddFrom</code> 和 <code>My.Application.Order.AddForm</code> <code>--</code> 两个类型的名字相同，但命名空间不同。然而，这对于模块来说却不是一个问题。在一个模块里，没有理由两个对象拥有同一个名字。从模块的使用角度来说，使用者会挑出它们用来引用模块的名字，所以也没有理由发声重名的情况。</p>\n</blockquote>\n<h4 id=\"15-10-8-危险信号\"><a href=\"#15-10-8-危险信号\" class=\"headerlink\" title=\"15.10.8 危险信号\"></a>15.10.8 危险信号</h4><blockquote>\n<p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间。</p>\n</blockquote>\n<ol>\n<li>文件的顶层声明是 <code>export namespace Foo &#123;...&#125;</code> ( 删除 <code>Foo</code> 并把所有内容向上层移动一层)</li>\n<li>文件只有一个 <code>export class</code> 或 <code>export function</code> (考虑使用 <code>export default</code>)</li>\n<li>多个文件的顶层具有同样的 <code>export namespace Foo</code> {( 不要以为这些会合并到一个 <code>Foo</code> 中! )}</li>\n</ol>\n<h2 id=\"十六、命名空间\"><a href=\"#十六、命名空间\" class=\"headerlink\" title=\"十六、命名空间\"></a>十六、命名空间</h2><h3 id=\"16-1-介绍\"><a href=\"#16-1-介绍\" class=\"headerlink\" title=\"16.1 介绍\"></a>16.1 介绍</h3><blockquote>\n<p>这篇文章描述了如何在 <code>TypeScript</code> 里使用命名空间(之前叫做”内部模块”)来组织你的代码。就像我们在术语说明里提到的那样，<code>&quot;内部模块&quot;</code> 现在叫做 <code>&quot;命名空间&quot;</code>。另外，任何使用 <code>module</code> 关键字来声明一个内部模块的地方都应该使用 <code>namespace</code> 关键字来替换。这就避免了让新的使用者被相似的名称所迷惑。</p>\n</blockquote>\n<ul>\n<li><code>第一步</code></li>\n</ul>\n<blockquote>\n<p>我们先来写一段程序并将在整篇文章中都使用这个例子。我们定义几个简单的字符串验证器，</p>\n</blockquote>\n<blockquote>\n<p>假设你会使用它们来验证表单里的用户输入或验证外部数据。</p>\n</blockquote>\n<ul>\n<li><code>所有验证器都放在一个文件里</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> letterRegExp = <span class=\"regexp\">/^[A-Za-z]$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LetterOnlyValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> letterRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> validators: &#123; [s: <span class=\"built_in\">string</span>]: StringValidator &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters Only&quot;</span>] = <span class=\"keyword\">new</span> LetterOnlyValidator();</span><br><span class=\"line\"><span class=\"comment\">// show whether each string passed each validator</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> isMatch = validators[name].isAcceptable(s);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`&#x27;<span class=\"subst\">$&#123;s&#125;</span>&#x27; <span class=\"subst\">$&#123;isMatch ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> &#x27;<span class=\"subst\">$&#123;name&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-2-命名空间\"><a href=\"#16-2-命名空间\" class=\"headerlink\" title=\"16.2 命名空间\"></a>16.2 命名空间</h3><blockquote>\n<p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。因此，我们把验证器包裹到一个命名空间里内，而不是把它们放在全局空间下。</p>\n</blockquote>\n<blockquote>\n<p>下面的例子里，把所有与验证器相关的类型都放到一个叫做 <code>Validation</code> 的命名空间里。因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 <code>export</code>。相反的，变量 <code>LetterRegExp</code> 和 <code>numberRegExp</code> 是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。在文件末尾的测试代码里，由于是在命名空间之外访问的，因此需要限定类型的名称，比如 <code>Validation.LettersOnlyValidator</code>。</p>\n</blockquote>\n<ul>\n<li>使用命名空间的验证器</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Validation &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> LetterRegExp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LetterOnlyValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> LetterRegExp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> validators: &#123; [s: <span class=\"built_in\">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP Code&quot;</span>] = <span class=\"keyword\">new</span> Validation.ZipCodeValidator();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters Only&quot;</span>] = <span class=\"keyword\">new</span> Validation.LetterOnlyValidator();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`&#x27;<span class=\"subst\">$&#123;s&#125;</span>&#x27; <span class=\"subst\">$&#123;validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> &#x27;<span class=\"subst\">$&#123;name&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-3-分离到多文件\"><a href=\"#16-3-分离到多文件\" class=\"headerlink\" title=\"16.3 分离到多文件\"></a>16.3 分离到多文件</h3><blockquote>\n<p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以方便维护。</p>\n</blockquote>\n<h4 id=\"16-3-1-多文件中的命名空间\"><a href=\"#16-3-1-多文件中的命名空间\" class=\"headerlink\" title=\"16.3.1 多文件中的命名空间\"></a>16.3.1 多文件中的命名空间</h4><blockquote>\n<p>现在，我们把 <code>Validation</code> 命名空间分割成多个文件。尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。</p>\n</blockquote>\n<ul>\n<li><code>Validation.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Validation &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>LetterOnlyValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;;</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Validation &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lettersRegExp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LettersOnlyValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> lettersRegExp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Validation &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Some samples to try</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Validators to use</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> validators: &#123; [s: <span class=\"built_in\">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> Validation.ZipCodeValidator();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> Validation.LettersOnlyValidator();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Show whether each string passed each validator</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。我们有两种方式。</p>\n</blockquote>\n<ol>\n<li>第一种方式，把所有的输入文件编译为一个输出文件，需要使用 <code>--outFile</code> 标记： <code>tsc --outFile sample.js Test.ts</code> 编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。 <code>tsc --outFile sample.js Validation.ts LetterOnlyValidator.ts ZipCodeValidator.ts Test.ts</code></li>\n<li>第二种方式，我们可以编写每一个文件(默认方式)，那么每个源文件都会对应生成一个 <code>JavaScript</code> 文件。然后，在页面上通过 <code>&lt;script&gt;</code> 标签把所有生成的 <code>JavaScript</code> 文件按正确的顺序引进来，比如：</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyTestPage.html (excerpt)</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;Validation.js&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;LettersOnlyValidator.js&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> /&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;ZipCodeValidator.js&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> /&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;Test.js&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> /&gt;</span></span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-4-别名\"><a href=\"#16-4-别名\" class=\"headerlink\" title=\"16.4 别名\"></a>16.4 别名</h3><blockquote>\n<p>另一种简化命名空间操作的方法是用 <code>import q = x.y.z</code> 给常用的对象起一个短的名字。不要与用来加载模块的 <code>import x = require(&#39;name&#39;)</code> 语法弄混了，这里的语法是为指定的符号创建一个别名。你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Shapes &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> Polygons &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Polygons = Shapes.Polygons;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sq = <span class=\"keyword\">new</span> Polygons.Square(); <span class=\"comment\">// Same as &quot;new Shapes.Polygons.Square()&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：我们并没有使用 <code>require</code> 关键字，而是直接使用导入符号的限定名赋值。这与使用 <code>var</code> 相似，但它还适用于类型和导入的具有命名空间含义的符号。重要的是，对于值来讲，<code>import</code> 会生成与原始符号不同的引用，所以改变别名的 <code>var</code> 值并不会影响原始变量的值。</p>\n</blockquote>\n<h3 id=\"16-5-使用其它的-JavaScript-库\"><a href=\"#16-5-使用其它的-JavaScript-库\" class=\"headerlink\" title=\"16.5 使用其它的 JavaScript 库\"></a>16.5 使用其它的 JavaScript 库</h3><blockquote>\n<p>为了描述不是用 <code>TypeScript</code> 编写的类库的类型，我们需要声明类库导出的 <code>API</code>。由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。我们称其为声明是因为它不是外部程序的具体实现。我们通常在 <code>.d.ts</code> 里写这些声明。如果你熟悉 <code>C/C+</code>+，你可以把它们当作 <code>.h</code> 文件。</p>\n</blockquote>\n<blockquote>\n<p>外部命名空间 (<code>declare namespace =&gt;</code>; 声明全局对象)</p>\n</blockquote>\n<blockquote>\n<p>流行的程序库 <code>D3</code> 在全局对象 <code>d3</code> 里定义它的功能。因为这个库通过一个<code>&lt;script&gt;</code> 标签加载 (不是通过模块加载器)，它的声明文件使用内部模块来定义它的类型。为了让 <code>TypeScript</code> 编译器识别它的类型，我们使用外部命名空间声明。</p>\n</blockquote>\n<ul>\n<li>比如，我们可以像下面这样写</li>\n<li><code>D3.d.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> D3 &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Selectors &#123;</span><br><span class=\"line\">    select: &#123;</span><br><span class=\"line\">      (selector: <span class=\"built_in\">string</span>): Selection;</span><br><span class=\"line\">      (element: EventTarget): Selection;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Event &#123;</span><br><span class=\"line\">    x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Base <span class=\"keyword\">extends</span> Selectors &#123;</span><br><span class=\"line\">    event: Event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> d3: D3.Base;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十七、命名空间和模块\"><a href=\"#十七、命名空间和模块\" class=\"headerlink\" title=\"十七、命名空间和模块\"></a>十七、命名空间和模块</h2><h3 id=\"17-1-介绍\"><a href=\"#17-1-介绍\" class=\"headerlink\" title=\"17.1 介绍\"></a>17.1 介绍</h3><blockquote>\n<p>这篇文章将概括介绍在 <code>TypeScript</code> 里使用模块与命名空间来组织代码的方法。我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。</p>\n</blockquote>\n<h3 id=\"17-2-使用命名空间\"><a href=\"#17-2-使用命名空间\" class=\"headerlink\" title=\"17.2 使用命名空间\"></a>17.2 使用命名空间</h3><blockquote>\n<p>命名空间是位于全局命名空间下的一个普通的带有名字的 <code>JavaScript</code> 对象。这令命名空间十分容易使用。它们可以在多文件中同时使用，并通过 <code>--outFile</code> 结合在一起。命名空间是帮你组织 <code>Web</code> 应用不错的方式，你可以把所有依赖都放在 <code>HTML</code> 页面的 <code>&lt;script&gt;</code> 标签里。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型应用中。</p>\n</blockquote>\n<h3 id=\"17-3-使用模块\"><a href=\"#17-3-使用模块\" class=\"headerlink\" title=\"17.3 使用模块\"></a>17.3 使用模块</h3><ol>\n<li>像命名空间一样，模块可以包含代码和声明。不同的模块可以声明它的依赖。</li>\n<li>模块会把依赖添加到模块加载器上(像是 <code>CommonJS</code> / <code>RequireJS</code>)。对于小型的 JS 应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。</li>\n<li>对于 <code>Node.js</code> 应用来说，模块是默认并推荐的组织代码的方式。</li>\n<li>从 <code>ECMAScript 2015</code> 开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。</li>\n</ol>\n<blockquote>\n<p>因此，对于新项目来说推荐使用模块作为组织代码的方式。</p>\n</blockquote>\n<h3 id=\"17-4-命名空间和模块的陷阱\"><a href=\"#17-4-命名空间和模块的陷阱\" class=\"headerlink\" title=\"17.4 命名空间和模块的陷阱\"></a>17.4 命名空间和模块的陷阱</h3><blockquote>\n<p>这部分我们会描述常见的命名空间和模块的使用陷阱和如何其避免它们。</p>\n</blockquote>\n<h4 id=\"17-4-1-对模块使用-lt-reference-gt\"><a href=\"#17-4-1-对模块使用-lt-reference-gt\" class=\"headerlink\" title=\"17.4.1 对模块使用 /// &lt;reference&gt;\"></a>17.4.1 对模块使用 <code>/// &lt;reference&gt;</code></h4><blockquote>\n<p>一个常见的错误是使用 <code>/// &lt;reference&gt;</code> 引用模块文件，应该使用 <code>import</code>。要理解这之间的差别，我们首先应该弄清编译器是如何根据 <code>import</code> 路径(例如：<code>import x from &quot;...&quot;</code>；或 <code>import x = require(&quot;...&quot;)</code> 里面的 <code>...</code>，等等)来定位模块的类型信息的。</p>\n</blockquote>\n<blockquote>\n<p>编译器首先尝试去查找相应路径下的 <code>.ts</code>，<code>.tsx</code> 再或者 <code>.d.ts</code>。如果这些文件都找不到，编译器会查找外部模块声明。回想一下，它们是在 <code>.d.ts</code> 文件里声明的。</p>\n</blockquote>\n<ul>\n<li><code>myModules.d.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// In a .d.ts file or .ts file that is not a module</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;SomeModule&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>): <span class=\"title\">string</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>myOtherModule.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;myModules.d.ts&quot;&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> m <span class=\"keyword\">from</span> <span class=\"string\">&quot;SomeModule&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的引用标签指定了外来模块的位置。这就是一些 <code>TypeScript</code> 例子中引用 <code>node.d.ts</code> 的方法。</p>\n</blockquote>\n<h4 id=\"17-4-2-不必要的命名空间\"><a href=\"#17-4-2-不必要的命名空间\" class=\"headerlink\" title=\"17.4.2 不必要的命名空间\"></a>17.4.2 不必要的命名空间</h4><blockquote>\n<p>如果你想把命名空间转换为模块，它可能会像下面这个文件一样。</p>\n</blockquote>\n<ul>\n<li><code>shapes.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> Shapes &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>顶层的模块 <code>Shapes</code> 包裹了 <code>Triangle</code> 和 <code>Square</code>。对于使用它的人来说这是令人迷惑和讨厌的。</p>\n</blockquote>\n<ul>\n<li><code>shapeConsumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> shapes <span class=\"keyword\">from</span> <span class=\"string\">&quot;./shapes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> shapes.Shapes.Triangle(); <span class=\"comment\">// shapes.Shapes?</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>TypeScript</code> 里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。再次重申，不应该对模块使用命名空间。使用命名空间是为了提供逻辑分组和避免命名冲突。模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。</p>\n</blockquote>\n<ul>\n<li>下面是改进的例子：</li>\n<li><code>shape.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>shapeConsumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> shapes <span class=\"keyword\">from</span> <span class=\"string\">&quot;./shapes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> shapes.Triangle();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"17-4-3-模块的取舍\"><a href=\"#17-4-3-模块的取舍\" class=\"headerlink\" title=\"17.4.3 模块的取舍\"></a>17.4.3 模块的取舍</h4><blockquote>\n<p>就像每个 <code>JS</code> 文件对应一个模块一样，<code>TypeScript</code> 里模块文件与生成的 <code>JS</code> 文件也是一一对应的。这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。例如当目标模块系统为 <code>commonjs</code> 或 <code>umd</code> 时，无法使用 <code>outFile</code> 选项，但是 <code>TypeScript 1.8</code> 以上的版本能够使用 <code>outFile</code> 当目标为 <code>amd</code> 或 <code>system</code>。</p>\n</blockquote>\n<h2 id=\"十八、模块解析\"><a href=\"#十八、模块解析\" class=\"headerlink\" title=\"十八、模块解析\"></a>十八、模块解析</h2><h3 id=\"18-1-说明\"><a href=\"#18-1-说明\" class=\"headerlink\" title=\"18.1 说明\"></a>18.1 说明</h3><ol>\n<li>模块解析是指编译器在查找导入模块内容时所遵循的流程。假设有一个导入语句 <code>import &#123; a &#125; from &quot;moduleA&quot;</code>; 为了去检查任何对 <code>a</code> 的使用，编译器需要准确的知道它表示什么，并且需要检查它的定义 <code>moduleA</code>。</li>\n<li>这时候，编译器会有个疑问“ <code>moduleA</code> 的结构是怎样的？” 这听上去很简单，但 moduleA 可能在你写的某个 .ts/.tsx 文件里或者在你的代码所依赖的 <code>.d.ts</code> 里。</li>\n<li>首先，编译器会尝试定位表示导入模块的文件。编译器会遵循以下二种策略之一： <code>Classic</code> 或 <code>Node</code>。这些策略会告诉编译器到哪里去查找 <code>moduleA</code>。</li>\n<li>如果上面的解析失败了并且模块名是非相对的（且是在” <code>moduleA</code> “的情况下），编译器会尝试定位一个外部模块声明。我们接下来会讲到非相对导入。</li>\n</ol>\n<p><code>5</code>. 最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为 <code>error TS2307: Cannot find module &#39;moduleA&#39;.</code></p>\n<h3 id=\"18-2-相对-vs-非相对模块导入\"><a href=\"#18-2-相对-vs-非相对模块导入\" class=\"headerlink\" title=\"18.2 相对 vs. 非相对模块导入\"></a>18.2 相对 vs. 非相对模块导入</h3><blockquote>\n<p>根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。</p>\n</blockquote>\n<ol>\n<li>相对导入是以 <code>/，./</code> 或 <code>../</code> 开头的。 下面是一些例子：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Entry <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/Entry&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Default &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../constants/http&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;/mod&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>所有其它形式的导入被当作非相对的。下面是一些例子：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&quot;JQuery&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@angular/core&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相对导入在解析时是相对于导入它的文件，并不能解析为一个外部模块声明。你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。</p>\n</blockquote>\n<blockquote>\n<p>非相对模块的导入可以相对于 baseUrl 或 通过下文会讲到的路径映射来解析。它们还可以被解析成 外部模块声明。</p>\n</blockquote>\n<blockquote>\n<p>使用非相对路径来导入你的外部依赖。</p>\n</blockquote>\n<h3 id=\"18-3-模块解析策略\"><a href=\"#18-3-模块解析策略\" class=\"headerlink\" title=\"18.3 模块解析策略\"></a>18.3 模块解析策略</h3><blockquote>\n<p>共有两种可用的模块解析策略：<code>Node</code> 和 <code>Classic</code>。 你可以使用 <code>--moduleResolution</code> 标记来指定使用哪种模块解析策略。若未指定，那么在使用了 -<code>-module AMD \\| System \\| ES2015</code> 时的默认值为 <code>Classic</code>，其它情况时则为 <code>Node</code>。</p>\n</blockquote>\n<h4 id=\"18-3-1-Classic\"><a href=\"#18-3-1-Classic\" class=\"headerlink\" title=\"18.3.1 Classic\"></a>18.3.1 Classic</h4><blockquote>\n<p>这种策略在以前是 <code>TypeScript</code> 默认的解析策略。 现在，它存在的理由主要是为了向后兼容。</p>\n</blockquote>\n<blockquote>\n<p>相对导入的模块是相对于导入它的文件进行解析的。 因此 <code>/root/src/folder/A.ts</code> 文件里的 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code> 会使用下面的查找流程：</p>\n</blockquote>\n<ol>\n<li>/root/src/folder/moduleB.ts``</li>\n<li>/root/src/folder/moduleB.d.ts``</li>\n</ol>\n<blockquote>\n<p>对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。</p>\n</blockquote>\n<ul>\n<li><code>比如：</code></li>\n</ul>\n<blockquote>\n<p>有一个对 <code>moduleB</code> 的非相对导入 <code>import &#123; b &#125; from &quot;moduleB&quot;</code>，它是在 <code>/root/src/folder/A.ts</code> 文件里，会以如下的方式来定位”<code>moduleB</code>“：</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/moduleB.ts</code></li>\n<li><code>/root/moduleB.d.ts</code></li>\n<li><code>/moduleB.ts</code></li>\n<li><code>/moduleB.d.ts</code></li>\n</ol>\n</blockquote>\n<h4 id=\"18-3-2-Node\"><a href=\"#18-3-2-Node\" class=\"headerlink\" title=\"18.3.2 Node\"></a>18.3.2 Node</h4><blockquote>\n<p>这个解析策略试图在运行时模仿 <code>Node.js</code> 模块解析机制。完整的 <code>Node.js</code> 解析算法可以在 <code>Node.js module documentation</code> 找到。</p>\n</blockquote>\n<ul>\n<li>Node.js 如何解析模块</li>\n</ul>\n<blockquote>\n<p>为了理解 <code>TypeScript</code> 编译依照的解析步骤，先弄明白<code>Node.js</code>模块是非常重要的。</p>\n</blockquote>\n<blockquote>\n<p>通常，在 <code>Node.js</code> 里导入是通过 <code>require</code> 函数调用进行的。 <code>Node.js</code> 会根据 <code>require</code> 是相对路径还是非相对路径做出不同的行为。</p>\n</blockquote>\n<blockquote>\n<p>相对路径很简单。 例如，假设有一个文件路径为 <code>/root/src/moduleA.js</code>，包含了一个导入 <code>var x = require(&quot;./moduleB&quot;)</code>;</p>\n</blockquote>\n<ul>\n<li>Node.js 以下面的顺序解析这个导入</li>\n</ul>\n<ol>\n<li>检查 <code>/root/src/moduleB.js</code> 文件是否存在。</li>\n<li>检查 <code>/root/src/moduleB</code> 目录是否包含一个 <code>package.json</code> 文件，且 <code>package.json</code> 文件指定了一个”<code>main</code>“模块。</li>\n</ol>\n<blockquote>\n<p>在我们的例子里，如果 <code>Node.js</code> 发现文件 <code>/root/src/moduleB/package.json</code> 包含了 <code>&#123; &quot;main&quot;: &quot;lib/mainModule.js&quot; &#125;</code>，那么 <code>Node.js</code> 会引用 <code>/root/src/moduleB/lib/mainModule.js</code>。</p>\n</blockquote>\n<ol start=\"3\">\n<li>检查 <code>/root/src/moduleB</code> 目录是否包含一个 <code>index.js</code> 文件。 这个文件会被隐式地当作那个文件夹下的”<code>main</code>“模块。</li>\n</ol>\n<p>你可以阅读 <code>Node.js</code> 文档了解更多详细信息：<a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">file modules</a> 和 <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">folder modules</a>。</p>\n<blockquote>\n<p>但是，非相对模块名的解析是个完全不同的过程。<code>Node</code> 会在一个特殊的文件夹 <code>node\\_modules</code> 里查找你的模块。<code>node\\_modules</code> 可能与当前文件在同一级目录下，或者在上层目录里。<code>Node</code> 会向上级目录遍历，查找每个 <code>node\\_modules</code>直到它找到要加载的模块。<br>还是用上面例子，但假设 <code>/root/src/moduleA.js</code> 里使用的是非相对路径导入 <code>var x = require(&quot;moduleB&quot;)</code>;</p>\n</blockquote>\n<ul>\n<li><code>Node</code> 则会以下面的顺序去解析 <code>moduleB</code>，直到有一个匹配上。</li>\n</ul>\n<blockquote>\n<p>1.<code>/root/src/node_modules/moduleB.js</code> 2.<code>/root/src/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 3.<code>/root/src/node_modules/moduleB/index.js</code> 4.<code>/root/node_modules/moduleB.js</code> 5.<code>/root/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 6.<code>/root/node_modules/moduleB/index.js</code> 7.<code>/node_modules/moduleB.js</code> 8.<code>/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 9.<code>/node_modules/moduleB/index.js</code></p>\n</blockquote>\n<blockquote>\n<p>注意 <code>Node.js</code> 在步骤（<code>4</code>）和（<code>7</code>）会向上跳一级目录。<br>你可以阅读 <code>Node.js</code> 文档了解更多详细信息：<a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\">loading modules from node_modules</a>。</p>\n</blockquote>\n<ul>\n<li>TypeScript 如何解析模块</li>\n</ul>\n<blockquote>\n<p><code>TypeScript</code> 是模仿 <code>Node.js</code> 运行时的解析策略来在编译阶段定位模块定义文件。因此，<code>TypeScript</code> 在 <code>Node</code> 解析逻辑基础上增加了 TypeScript 源文件的扩展名（ <code>.ts</code>，<code>.tsx</code> 和 <code>.d.ts</code>）。同时，<code>TypeScript</code> 在 <code>package.json</code> 里使用字段”<code>types</code>“来表示类似”<code>main</code>“的意义 <code>-</code> 编译器会使用它来找到要使用的”<code>main</code>“定义文件。</p>\n</blockquote>\n<blockquote>\n<p>比如，有一个导入语句 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code> 在 <code>/root/src/moduleA.ts</code> 里，会以下面的流程来定位 <code>&quot;./moduleB&quot;</code> ：</p>\n<ol>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.tsx</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li>\n<li><code>/root/src/moduleB/index.ts</code></li>\n<li><code>/root/src/moduleB/index.tsx</code></li>\n<li><code>/root/src/moduleB/index.d.ts</code></li>\n</ol>\n</blockquote>\n<blockquote>\n<p>回想一下 <code>Node.js</code> 先查找 <code>moduleB.js</code> 文件，然后是合适的 <code>package.json</code>，再之后是 <code>index.js</code>。</p>\n</blockquote>\n<blockquote>\n<p>类似地，非相对的导入会遵循 <code>Node.js</code> 的解析逻辑，首先查找文件，然后是合适的文件夹。因此 <code>/root/src/moduleA.ts</code> 件里的 <code>import &#123; b &#125; from &quot;moduleB&quot;</code> 会以下面的查找顺序解析：</p>\n<ol>\n<li><code>/root/src/node_modules/moduleB.ts</code></li>\n<li><code>/root/src/node_modules/moduleB.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB.d.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li>\n<li><code>/root/src/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/index.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB/index.d.ts</code></li>\n<li><code>/root/node_modules/moduleB.ts</code></li>\n<li><code>/root/node_modules/moduleB.tsx</code></li>\n<li><code>/root/node_modules/moduleB.d.ts</code></li>\n<li><code>/root/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li>\n<li><code>/root/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/node_modules/moduleB/index.tsx</code></li>\n<li><code>/root/node_modules/moduleB/index.d.ts</code></li>\n<li><code>/node_modules/moduleB.ts</code></li>\n<li><code>/node_modules/moduleB.tsx</code></li>\n<li><code>/node_modules/moduleB.d.ts</code></li>\n<li><code>/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li>\n<li><code>/node_modules/moduleB/index.ts</code></li>\n<li><code>/node_modules/moduleB/index.tsx</code></li>\n<li><code>/node_modules/moduleB/index.d.ts</code></li>\n</ol>\n</blockquote>\n<blockquote>\n<p>不要被这里步骤的数量吓到 <code>-</code> <code>TypeScript</code> 只是在步骤（<code>8</code>）和（<code>15</code>）向上跳了两次目录。 这并不比 <code>Node.js</code> 里的流程复杂。</p>\n</blockquote>\n<h3 id=\"18-4-附加的模块解析标记\"><a href=\"#18-4-附加的模块解析标记\" class=\"headerlink\" title=\"18.4 附加的模块解析标记\"></a>18.4 附加的模块解析标记</h3><blockquote>\n<ol>\n<li>有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将 <code>.ts</code> 编译成 <code>.js</code>，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。</li>\n<li><code>TypeScript</code> 编译器有一些额外的标记用来通知编译器在源码编译成最终输出的过程中都发生了哪个转换。</li>\n<li>有一点要特别注意的是编译器不会进行这些转换操作；它只是利用这些信息来指导模块的导入。</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>Base URL</code></li>\n</ul>\n<blockquote>\n<p>在利用 <code>AMD</code> 模块加载器的应用里使用 <code>baseUrl</code> 是常见做法，它要求在运行时模块都被放到了一个文件夹里。这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。</p>\n</blockquote>\n<blockquote>\n<p>设置 <code>baseUrl</code> 来告诉编译器到哪里去查找模块。 所有 <code>非相对模块</code> 导入都会被当做相对于 <code>baseUrl</code>。</p>\n</blockquote>\n<ul>\n<li><code>baseUrl</code> 的值由以下两者之一决定：</li>\n</ul>\n<blockquote>\n<ol>\n<li>命令行中 <code>baseUrl</code> 的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）</li>\n<li><code>tsconfig.json</code>里的 <code>baseUrl</code> 属性（如果给定的路径是相对的，那么将相对于‘<code>tsconfig.json</code>’路径进行计算）</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意相对模块的导入不会被设置的 <code>baseUrl</code> 所影响，因为它们总是相对于导入它们的文件。</p>\n</blockquote>\n<blockquote>\n<p>阅读更多关于 <code>baseUrl</code> 的信息 <a href=\"https://requirejs.org/docs/api.html#config-baseUrl\">RequireJS</a> 和 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl\"><code>SystemJS</code></a>。</p>\n</blockquote>\n<h3 id=\"18-5-路径映射\"><a href=\"#18-5-路径映射\" class=\"headerlink\" title=\"18.5 路径映射\"></a>18.5 路径映射</h3><blockquote>\n<p>有时模块不是直接放在 <code>baseUrl</code> 下面。 比如，充分 “<code>jquery</code>“模块地导入，在运行时可能被解释为”<code>node\\_modules/jquery/dist/jquery.slim.min.js</code>“。 加载器使用映射配置来将模块名映射到运行时的文件，查看 <a href=\"https://requirejs.org/docs/api.html#config-paths\">RequireJs documentation</a> 和 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths\">SystemJS documentation</a>。</p>\n</blockquote>\n<blockquote>\n<p><code>TypeScript</code> 编译器通过使用 <code>tsconfig.json</code> 文件里的 “<code>paths</code>“ 来支持这样的声明映射。 下面是一个如何指定 <code>jquery</code> 的”<code>paths</code>“的例子。</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;baseUrl&quot;</span>: <span class=\"string\">&quot;.&quot;</span>, <span class=\"comment\">// This must be specified if &quot;paths&quot; is.</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;paths&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;jquery&quot;</span>: [<span class=\"string\">&quot;node_modules/jquery/dist/jquery&quot;</span>] <span class=\"comment\">// 此处映射是相对于&quot;baseUrl&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>请注意”<code>paths</code>“是相对于”<code>baseUrl</code>“进行解析。 如果 “<code>baseUrl</code>“ 被设置成了除”<code>.</code>“外的其它值，比如 <code>tsconfig.json</code> 所在的目录，那么映射必须要做相应的改变。如果你在上例中设置了 <code>&quot;baseUrl&quot;: &quot;./src&quot;</code>，那么 <code>jquery</code> 应该映射到 <code>&quot;../node\\_modules/jquery/dist/jquery&quot;</code>。</p>\n</blockquote>\n<blockquote>\n<p>通过”<code>paths</code>“我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">projectRoot</span><br><span class=\"line\">├── folder1</span><br><span class=\"line\">│   ├── file1.ts (imports <span class=\"string\">&#x27;folder1/file2&#x27;</span> and <span class=\"string\">&#x27;folder2/file3&#x27;</span>)</span><br><span class=\"line\">│   └── file2.ts</span><br><span class=\"line\">├── generated</span><br><span class=\"line\">│   ├── folder1</span><br><span class=\"line\">│   └── folder2</span><br><span class=\"line\">│       └── file3.ts</span><br><span class=\"line\">└── tsconfig.json</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>相应的 <code>tsconfig.json</code> 文件如下：</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;baseUrl&quot;</span>: <span class=\"string\">&quot;.&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;paths&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;*&quot;</span>: [<span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;generated/*&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它告诉编译器所有匹配 <code>&quot;\\*&quot;</code>（所有的值）模式的模块导入会在以下两个位置查找：</p>\n<ol>\n<li><code>&quot;\\*&quot;</code>： 表示名字不发生改变，所以映射为  <code>=&gt;</code> <code>/</code></li>\n<li>“<code>generated/</code>“表示模块名添加了“<code>generated</code>”前缀，所以映射为 <code>&lt;moduleName&gt; =&gt; &lt;baseUrl&gt;/generated/&lt;moduleName&gt;</code></li>\n</ol>\n</blockquote>\n<ul>\n<li><code>按照这个逻辑，编译器将会如下尝试解析这两个导入：</code></li>\n</ul>\n<blockquote>\n<p>(i). 导入<code>&#39;folder1/file2&#39;</code></p>\n<ol>\n<li>匹配 <code>&#39;\\*&#39;</code> 模式且通配符捕获到整个名字。</li>\n<li>尝试列表里的第一个替换：<code>&#39;\\*&#39; -&gt; folder1/file2</code>。</li>\n<li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&gt; projectRoot/folder1/file2.ts</code>。</li>\n<li>文件存在。完成。</li>\n</ol>\n<p>(ii). 导入<code>&#39;folder2/file3&#39;</code></p>\n<ol>\n<li>匹配 <code>&#39;\\*&#39;</code> 模式且通配符捕获到整个名字。</li>\n<li>尝试列表里的第一个替换：<code>&#39;\\*&#39; -&gt; folder2/file3</code>。</li>\n<li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&gt; projectRoot/folder2/file3.ts</code>。</li>\n<li>文件不存在，跳到第二个替换。</li>\n<li>第二个替换：<code>&#39;generated/&#39; -&gt; generated/folder2/file3</code>。</li>\n<li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&amp;gt; projectRoot/generated/folder2/file3.ts</code>。</li>\n<li>文件存在。完成。</li>\n</ol>\n</blockquote>\n<ul>\n<li>利用 <code>rootDirs</code> 指定虚拟目录</li>\n</ul>\n<blockquote>\n<p>有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。 利用 <code>rootDirs</code>，可以告诉编译器生成这个虚拟目录的 <code>roots</code>； 因此编译器可以在“虚拟”目录下解析相对模块导入，就好像它们被合并在了一起一样。</p>\n</blockquote>\n<blockquote>\n<p>比如，有下面的工程结构：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src</span><br><span class=\"line\"> └── views</span><br><span class=\"line\">     └── view1.ts (imports <span class=\"string\">&#x27;./template1&#x27;</span>)</span><br><span class=\"line\">     └── view2.ts</span><br><span class=\"line\"></span><br><span class=\"line\"> generated</span><br><span class=\"line\"> └── templates</span><br><span class=\"line\">         └── views</span><br><span class=\"line\">             └── template1.ts (imports <span class=\"string\">&#x27;./view2&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>src/views</code> 里的文件是用于控制 UI 的用户代码。 <code>generated/templates</code> 是 <code>UI</code> 模版，在构建时通过模版生成器自动生成。构建中的一步会将 <code>/src/views</code> 和 <code>/generated/templates/views</code> 的输出拷贝到同一个目录下。 在运行时，视图可以假设它的模版与它同在一个目录下，因此可以使用相对导入 <code>&quot;./template&quot;</code>。</p>\n</blockquote>\n<blockquote>\n<p>可以使用”<code>rootDirs</code>“来告诉编译器。”<code>rootDirs</code>“指定了一个 <code>roots</code> 列表，列表里的内容会在运行时被合并。</p>\n</blockquote>\n<blockquote>\n<p>因此，针对这个例子， <code>tsconfig.json</code> 如下：</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDirs&quot;</span>: [<span class=\"string\">&quot;src/views&quot;</span>, <span class=\"string\">&quot;generated/templates/views&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>每当编译器在某一 <code>rootDirs</code> 的子目录下发现了相对模块导入，它就会尝试从每一个 <code>rootDirs</code> 中导入。</p>\n</blockquote>\n<blockquote>\n<p><code>rootDirs</code> 的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑( <code>bundles</code> )和运行时的特性，比如条件引入和工程特定的加载器插件。</p>\n</blockquote>\n<blockquote>\n<p>设想这样一个国际化的场景，构建工具自动插入特定的路径记号来生成针对不同区域的捆绑，比如将 <code>\\#&#123;locale&#125;</code> 做为相对模块路径 <code>./\\#&#123;locale&#125;/messages</code> 的一部分。在这个假定的设置下，工具会枚举支持的区域，将抽像的路径映射成 <code>./zh/messages</code>，<code>./de/messages</code> 等。</p>\n</blockquote>\n<blockquote>\n<p>假设每个模块都会导出一个字符串的数组。比如 <code>./zh/messages</code> 可能包含：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> [<span class=\"string\">&quot;您好吗&quot;</span>, <span class=\"string\">&quot;很高兴认识你&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>利用 <code>rootDirs</code> 我们可以让编译器了解这个映射关系，从而也允许编译器能够安全地解析 <code>./\\#&#123;locale&#125;/messages</code>，就算这个目录永远都不存在。比如，使用下面的 <code>tsconfig.json</code>：</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDirs&quot;</span>: [<span class=\"string\">&quot;src/zh&quot;</span>, <span class=\"string\">&quot;src/de&quot;</span>, <span class=\"string\">&quot;src/#&#123;locale&#125;&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译器现在可以将 <code>import messages from &#39;./#&#123;locale&#125;/messages&#39;</code> 解析为 <code>import messages from &#39;./zh/messages&#39;</code> 用做工具支持的目的，并允许在开发时不必了解区域信息。</p>\n</blockquote>\n<h3 id=\"18-6-跟踪模块解析\"><a href=\"#18-6-跟踪模块解析\" class=\"headerlink\" title=\"18.6 跟踪模块解析\"></a>18.6 跟踪模块解析</h3><blockquote>\n<p>如之前讨论，编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过 <code>--traceResolution</code> 启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。</p>\n</blockquote>\n<blockquote>\n<p>假设我们有一个使用了 <code>typescript</code> 模块的简单应用。<code>app.ts</code> 里有一个这样的导入 <code>import * as ts from &quot;typescript&quot;</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">│   tsconfig.json</span><br><span class=\"line\">├───node_modules</span><br><span class=\"line\">│   └───typescript</span><br><span class=\"line\">│       └───lib</span><br><span class=\"line\">│               typescript.d.ts</span><br><span class=\"line\">└───src</span><br><span class=\"line\">        app.ts</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 <code>--traceResolution</code> 调用编译器。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc --traceResolution</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>输出结果如下：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">======== Resolving <span class=\"built_in\">module</span> <span class=\"string\">&#x27;typescript&#x27;</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;src/app.ts&#x27;</span>. ========</span><br><span class=\"line\">Module resolution kind is not specified, using <span class=\"string\">&#x27;NodeJs&#x27;</span>.</span><br><span class=\"line\">Loading <span class=\"built_in\">module</span> <span class=\"string\">&#x27;typescript&#x27;</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node_modules&#x27;</span> folder.</span><br><span class=\"line\">File <span class=\"string\">&#x27;src/node_modules/typescript.ts&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;src/node_modules/typescript.tsx&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;src/node_modules/typescript.d.ts&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;src/node_modules/typescript/package.json&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;node_modules/typescript.ts&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;node_modules/typescript.tsx&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;node_modules/typescript.d.ts&#x27;</span> does not exist.</span><br><span class=\"line\">Found <span class=\"string\">&#x27;package.json&#x27;</span> at <span class=\"string\">&#x27;node_modules/typescript/package.json&#x27;</span>.</span><br><span class=\"line\"><span class=\"string\">&#x27;package.json&#x27;</span> has <span class=\"string\">&#x27;types&#x27;</span> field <span class=\"string\">&#x27;./lib/typescript.d.ts&#x27;</span> that references <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span>.</span><br><span class=\"line\">File <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span> exist - use it <span class=\"keyword\">as</span> a <span class=\"built_in\">module</span> resolution result.</span><br><span class=\"line\">======== Module name <span class=\"string\">&#x27;typescript&#x27;</span> was successfully resolved to <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span>. ========</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要留意的地方：</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>导入的名字及位置 <code>======== Resolving module &#39;typescript&#39; from &#39;src/app.ts&#39;. ========</code></li>\n<li>编译器使用的策略 <code>Module resolution kind is not specified, using &#39;NodeJs&#39;.</code></li>\n<li>从 <code>npm</code> 加载 <code>types</code> <code>&#39;package.json&#39; has &#39;types&#39; field &#39;./lib/typescript.d.ts&#39; that references &#39;node\\_modules/typescript/lib/typescript.d.ts&#39;.</code></li>\n<li>最终结果 <code>======== Module name &#39;typescript&#39; was successfully resolved to &#39;node\\_modules/typescript/lib/typescript.d.ts&#39;. ========</code></li>\n</ol>\n</blockquote>\n<ul>\n<li>使用 <code>--noResolve</code></li>\n</ul>\n<blockquote>\n<p>正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件 <code>import</code>，这个文件被会加到一个文件列表里，以供编译器稍后处理。<code>--noResolve</code> 编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。</p>\n</blockquote>\n<blockquote>\n<p><code>比如</code>:</p>\n</blockquote>\n<ul>\n<li><code>app.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> A <span class=\"keyword\">from</span> <span class=\"string\">&quot;moduleA&quot;</span>; <span class=\"comment\">// OK, moduleA passed on the command-line</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> B <span class=\"keyword\">from</span> <span class=\"string\">&quot;moduleB&quot;</span>; <span class=\"comment\">// Error TS2307: Cannot find module &#x27;moduleB&#x27;.</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc app.ts moduleA.ts --noResolve</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 <code>--noResolve</code> 编译 <code>app.ts</code>：</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>可能正确找到 <code>moduleA</code>，因为它在命令行上指定了。</li>\n<li>找不到 <code>moduleB</code>，因为没有在命令行上传递。</li>\n</ol>\n</blockquote>\n<h3 id=\"18-7-常见问题\"><a href=\"#18-7-常见问题\" class=\"headerlink\" title=\"18.7 常见问题\"></a>18.7 常见问题</h3><ul>\n<li>为什么在 <code>exclude</code> 列表里的模块还会被编译器使用</li>\n</ul>\n<blockquote>\n<p><code>tsconfig.json</code> 将文件夹转变一个“工程” 如果不指定任何 “<code>exclude</code>” 或 “<code>files</code>”，文件夹里的所有文件包括 <code>tsconfig.json</code> 和 所有的子目录 都会在编译列表里。 如果你想利用 “<code>exclude</code>”排除某些文件，甚至你想指定所有要编译的文件列表，请使用“<code>files</code>”。</p>\n</blockquote>\n<blockquote>\n<p>有些是被 <code>tsconfig.json</code> 自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。</p>\n</blockquote>\n<blockquote>\n<p>因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行 <code>import</code> 或使用了 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令的文件。</p>\n</blockquote>\n<h2 id=\"十九、声明合并\"><a href=\"#十九、声明合并\" class=\"headerlink\" title=\"十九、声明合并\"></a>十九、声明合并</h2><h3 id=\"19-1-介绍\"><a href=\"#19-1-介绍\" class=\"headerlink\" title=\"19.1 介绍\"></a>19.1 介绍</h3><blockquote>\n<p><code>TypeScript</code> 中有些独特的概念可以在类型层面上描述 <code>JavaScript</code> 对象的模型。这其中尤其独特的一个例子 “声明合并” 的概念。</p>\n</blockquote>\n<blockquote>\n<p>理解了这个概念，将有助于操作现有的 <code>JavaScript</code> 代码。同时，也会有助于理解更多高级抽象的概念。</p>\n</blockquote>\n<blockquote>\n<p>对本文件来讲，”<code>声明合并</code>“ 是指编译器将针对同一个名字的两个独立声明合并为单一声明。合并后的声明同时拥有原先两个声明的特性。任何数量的声明都可被合并；不局限于两个声明。</p>\n</blockquote>\n<h3 id=\"19-2-基础概念\"><a href=\"#19-2-基础概念\" class=\"headerlink\" title=\"19.2 基础概念\"></a>19.2 基础概念</h3><blockquote>\n<p><code>TypeScript</code> 中的声明会创建以下三种实体之一：<code>命名空间</code>，<code>类型</code> 或 <code>值</code>。创建命名空间的声明会新建一个命名空间，它包含了用(.)符号来访问时使用的名字。创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。<br>最后，创建值的声明会创建在 <code>JavaScript</code> 输出中看到的值。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Declaration Type</th>\n<th align=\"left\">Namespace</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Namespace</code></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Class</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Enum</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Interface</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>Type Alias</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>Function</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Variable</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>理解每个声明创建了什么，有助于理解当声明合并时，有哪些东西被合并了。</p>\n</blockquote>\n<h3 id=\"19-3-合并接口\"><a href=\"#19-3-合并接口\" class=\"headerlink\" title=\"19.3 合并接口\"></a>19.3 合并接口</h3><blockquote>\n<p>最简单最常见的声明合并类型是接口合并。从根本上说，合并的机制是把双方的成员放到一个同名的接口里。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Box &#123;</span><br><span class=\"line\">  height: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  width: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Box &#123;</span><br><span class=\"line\">  scale: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> box: Box = &#123; <span class=\"attr\">height</span>: <span class=\"number\">5</span>, <span class=\"attr\">width</span>: <span class=\"number\">6</span>, <span class=\"attr\">scale</span>: <span class=\"number\">10</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接口的非函数成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。</p>\n</blockquote>\n<blockquote>\n<p>对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。同时需要注意，当接口 <code>A</code> 与后来的接口 <code>A</code> 合并时，后面的接口具有更高的优先级。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如下例所示：</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cloner &#123;</span><br><span class=\"line\">  clone(animal: Animal): Animal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cloner &#123;</span><br><span class=\"line\">  clone(animal: Sheep): Sheep;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cloner &#123;</span><br><span class=\"line\">  clone(animal: Dog): Dog;</span><br><span class=\"line\">  clone(animal: Cat): Cat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这三个接口合并成一个声明：</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cloner &#123;</span><br><span class=\"line\">  clone(animal: Dog): Dog;</span><br><span class=\"line\">  clone(animal: Cat): Cat;</span><br><span class=\"line\">  clone(animal: Sheep): Sheep;</span><br><span class=\"line\">  clone(animal: Animal): Animal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前的位置。</p>\n</blockquote>\n<blockquote>\n<p>这个规则有一个例外是当出现特殊的函数签名时。如果签名里有一个参数的类型是单一的字符串字面量(比如，不是字符串字面量的联合类型)，那么它将会被提升到重载列表的最顶端。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如，下面的接口会合并到一起</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Document &#123;</span><br><span class=\"line\">  createElement(tagName: <span class=\"built_in\">any</span>): ELement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Document &#123;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;div&quot;</span>): HTMLDivElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;span&quot;</span>): HTMLSpanElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Document &#123;</span><br><span class=\"line\">  createElement(tagName: <span class=\"built_in\">string</span>): HTMLElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;canvas&quot;</span>): HTMLCanvasElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 合并后的 Document 将会像下面这样:</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Document &#123;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;canvas&quot;</span>): HTMLCanvasElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;div&quot;</span>): HTMLDivElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;span&quot;</span>): HTMLSpanElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"built_in\">string</span>): HTMLElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"built_in\">any</span>): Element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"19-4-合并命名空间\"><a href=\"#19-4-合并命名空间\" class=\"headerlink\" title=\"19.4 合并命名空间\"></a>19.4 合并命名空间</h3><ol>\n<li>与接口相似，同名的命名空间也会合并其成员。命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。</li>\n<li>对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。</li>\n<li>对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Animals 声明合并示例：</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Animals &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zebra</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Animals &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Legged &#123;</span><br><span class=\"line\">    numberOfLegs: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等同于：</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Animals &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Legged &#123;</span><br><span class=\"line\">    numberOfLegs: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zebra</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>除了这些合并外，你还需要了解非导出成员是如何处理的。非导出成员仅在其原有的(合并前的)命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。</p>\n</blockquote>\n<ul>\n<li>下面提供了清晰的说明：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> haveMuscles = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animalsHaveMuscles</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> haveMuscles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAnimalsHaveMuscles</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> haveMuscles; <span class=\"comment\">// // Error, because haveMuscles is not accessible here</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因为 <code>haveMuscles</code> 并没有导出，只有 <code>animalsHaveMuscles</code> 函数共享了原始未合并的命名空间可以访问这个变量。<br><code>doAnimalsHaveMuscles</code> 函数虽是合并命名空间的一部分，但是访问不了未导出的成员。</p>\n</blockquote>\n<h3 id=\"19-5-命名空间与类和函数和枚举类型合并\"><a href=\"#19-5-命名空间与类和函数和枚举类型合并\" class=\"headerlink\" title=\"19.5 命名空间与类和函数和枚举类型合并\"></a>19.5 命名空间与类和函数和枚举类型合并</h3><blockquote>\n<p>命名空间可以与其它类型的声明合并。只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。<br><code>TypeScript</code> 使用这个功能去实现一些 <code>JavaScript</code> 里的设计模式。</p>\n</blockquote>\n<h4 id=\"19-5-1-合并命名空间和类\"><a href=\"#19-5-1-合并命名空间和类\" class=\"headerlink\" title=\"19.5.1 合并命名空间和类\"></a>19.5.1 合并命名空间和类</h4><blockquote>\n<p>这让我们可以表示内部类</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Album</span> </span>&#123;</span><br><span class=\"line\">  label: Album.AlbumLabel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Album &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlbumLabel</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>合并规则</code> 与上面 <code>合并命名空间</code> 小节里讲的规则一致，我们必须导出 <code>AlbumLabel</code> 类，好让合并的类能访问。</p>\n</blockquote>\n<blockquote>\n<p><code>合并结果</code>是一个类并带有一个内部类。你也可以使用命名空间为类增加一些静态属性。</p>\n</blockquote>\n<blockquote>\n<p>除了内部类的模式，你在 <code>JavaScript</code> 里，创建一个函数稍后扩展它增加一些属性也是很常见的。<code>TypeScript</code> 使用声明合并来达到这个目的并保证类型安全。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildLabel</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buildLabel.prefix + name + buildLabel.suffix;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> buildLabel &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> suffix = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> prefix = <span class=\"string\">&quot;Hello, &quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buildLabel(<span class=\"string\">&quot;Sam Smith&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相似的，命名空间可以用来扩展枚举类型</span></span><br><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;</span><br><span class=\"line\">  red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  green = <span class=\"number\">2</span>,</span><br><span class=\"line\">  blue = <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Color &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mixColor</span>(<span class=\"params\">colorName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (colorName === <span class=\"string\">&quot;yellow&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Color.red + Color.green;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName === <span class=\"string\">&quot;white&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Color.red + Color.green + Color.blue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName === <span class=\"string\">&quot;magenta&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Color.red + Color.blue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName === <span class=\"string\">&quot;cyan&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Color.green + Color.blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"19-5-2-非法的合并\"><a href=\"#19-5-2-非法的合并\" class=\"headerlink\" title=\"19.5.2 非法的合并\"></a>19.5.2 非法的合并</h4><blockquote>\n<p><code>TypeScript</code> 并非允许所有的合并。目前，类不能与其它类或变量合并。想要了解如何模仿类的合并，请参照 <a href=\"https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/Mixins%E6%B7%B7%E5%85%A5/README.md\">TypeScript 混入</a>。</p>\n</blockquote>\n<h3 id=\"19-6-模块扩展\"><a href=\"#19-6-模块扩展\" class=\"headerlink\" title=\"19.6 模块扩展\"></a>19.6 模块扩展</h3><blockquote>\n<p>虽然 <code>JavaScript</code> 不支持合并，但你可以为导入的对象打补丁以更新它们。</p>\n</blockquote>\n<ul>\n<li>让我们考察一下这个玩具性的示例：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... implementation left as an exercise for the reader...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\">Observable.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... another exercise for the reader</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它也可以很好地工作在 <code>TypeScript</code> 中，但编译器对 <code>Observable.prototype.map</code> 一无所知。你可以使用扩展模块来将它告诉编译器。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.ts stays the same</span></span><br><span class=\"line\"><span class=\"comment\">// map.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;./observable&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> Observable&lt;T&gt; &#123;</span><br><span class=\"line\">    map&lt;U&gt;(f: <span class=\"function\">(<span class=\"params\">x: T</span>) =&gt;</span> U): Observable&lt;U&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Observable.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... another exercise for the reader</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./map&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> o: Observable&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">o.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x.toFixed());</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>模块名的解析和用 <code>import / export</code> 解析模块标识符的方式是一致的。 更多信息请参考 <a href=\"https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/%E6%A8%A1%E5%9D%97/README.md\">Modules</a>。当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明(仅可以扩展模块中已经存在的声明)。</p>\n</blockquote>\n<h3 id=\"19-7-全局扩展\"><a href=\"#19-7-全局扩展\" class=\"headerlink\" title=\"19.7 全局扩展\"></a>19.7 全局扩展</h3><blockquote>\n<p>你也可以在模块内部添加声明到全局作用域中</p>\n</blockquote>\n<blockquote>\n<p><code>observable.ts</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... still no implementation ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">global</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> Array&lt;T&gt; &#123;</span><br><span class=\"line\">    toObservable(): Observable&lt;T&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.toObservable = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>全局扩展和与模块扩展的行为和限制是相同的。</p>\n</blockquote>\n<h2 id=\"二十、JSX\"><a href=\"#二十、JSX\" class=\"headerlink\" title=\"二十、JSX\"></a>二十、JSX</h2><h3 id=\"20-1-介绍\"><a href=\"#20-1-介绍\" class=\"headerlink\" title=\"20.1 介绍\"></a>20.1 介绍</h3><blockquote>\n<p><code>JSX</code> 是一种嵌入式的类似 <code>XML</code> 的语法。它可以被转换成合法的 <code>JavaScript</code>，尽管转换的语义是根据不同的实现而定的。<br><code>JSX</code> 因 <code>React</code> 框架而流行，但也存在其它的实现。<code>TypeScript</code> 支持内嵌，类型检查以及将 <code>JSX</code> 直接编译为 JavaScript。</p>\n</blockquote>\n<h3 id=\"20-2-基本用法\"><a href=\"#20-2-基本用法\" class=\"headerlink\" title=\"20.2 基本用法\"></a>20.2 基本用法</h3><ul>\n<li>想要使用 <code>JSX</code> 必须做两件事：</li>\n</ul>\n<blockquote>\n<ol>\n<li>给文件一个 <code>.tsx</code> 扩展名</li>\n<li>启用 <code>jsx</code> 选项</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>TypeScript</code> 具有三种 <code>JSX</code> 模式：<code>preserve</code>, <code>react</code> 和 <code>react-native</code>。这些模式只在代码生成阶段起作用 - 类型检查并不受影响。</li>\n</ul>\n<blockquote>\n<ol>\n<li>在 <code>preserve</code> 模式下生成代码中会保留 <code>JSX</code> 以供后续的转换操作使用( <code>比如：Babel</code> )。另外，输出文件会带有 <code>.jsx</code> 扩展名。</li>\n<li><code>react</code> 模式会生成 <code>React.createElement</code>，在使用前不需要再进行转换操作了，输出文件的扩展名为 <code>.js</code>。</li>\n<li><code>react-native</code> 相当于 <code>preserve</code>，它也保留了所有的 <code>JSX</code>，但是输出文件的扩展名是 <code>.js</code>。</li>\n</ol>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式</th>\n<th align=\"left\">输入</th>\n<th align=\"left\">输出</th>\n<th align=\"left\">输出文件扩展名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">preserve</td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\">react</td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>React.createElement(&quot;div&quot;)</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\">react-native</td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>你可以通过在命令行里使用 <code>--jsx</code> 标记或 <code>tsconfig.json</code> 里的选项来指定模式。<br>注意：<code>React</code> 标识符是写死的硬编码，所以你必须保证 <code>React</code>（大写的<code>R</code>）是可用的。</p>\n</blockquote>\n<h3 id=\"20-3-as-操作符\"><a href=\"#20-3-as-操作符\" class=\"headerlink\" title=\"20.3 as 操作符\"></a>20.3 as 操作符</h3><blockquote>\n<p>回想一下怎么写类型断言</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &lt;foo&gt;bar;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里断言 <code>bar</code> 变量是 <code>foo</code> 类型的。 因为 <code>TypeScript</code> 也使用尖括号来表示类型断言，在结合 <code>JSX</code> 的语法后将带来解析上的困难。因此，<code>TypeScript</code> 在 <code>.tsx</code> 文件里禁用了使用尖括号的类型断言。</p>\n</blockquote>\n<blockquote>\n<p>由于不能够在 <code>.tsx</code> 文件里使用上述语法，因此我们应该使用另一个类型断言操作符：<code>as</code>。</p>\n</blockquote>\n<ul>\n<li>上面的例子可以很容易地使用 <code>as</code> 操作符改写：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = bar <span class=\"keyword\">as</span> foo;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>as</code> 操作符在 <code>.ts</code> 和 <code>.tsx</code> 里都可用，并且与尖括号类型断言行为是等价的。</p>\n</blockquote>\n<h3 id=\"20-4-类型检查\"><a href=\"#20-4-类型检查\" class=\"headerlink\" title=\"20.4 类型检查\"></a>20.4 类型检查</h3><blockquote>\n<p>为了理解 <code>JSX</code> 的类型检查，你必须首先理解 <code>固有元素</code> 与 <code>基于值的元素</code> 之间的区别。假设有这样一个 <code>JSX</code> 表达式 <code>&lt;expr /&gt;</code>，<code>expr</code> 可能引用环境自带的某些东西(比如，在 <code>DOM</code> 环境里的 <code>div</code> 或 <code>span</code>)或者是你自定义的组件。这是非常重要的。原因有如下两点：</p>\n</blockquote>\n<ol>\n<li>对于 <code>React</code>，固有元素会生成字符串 (<code>React.createElement(&quot;div&quot;)</code> )，然后由你自定义的组件却不会生成( <code>React.createElement(MyComponent)</code>)。</li>\n<li>传入 <code>JSX</code> 元素里的属性类型的查找方式不同。固有元素总以一个小写字母开头，基于值的元素总是以一个大写字母开头。</li>\n</ol>\n<h4 id=\"20-4-1-固有元素\"><a href=\"#20-4-1-固有元素\" class=\"headerlink\" title=\"20.4.1 固有元素\"></a>20.4.1 固有元素</h4><blockquote>\n<p>固有元素使用特殊的接口 <code>JSX.IntrinsicElements</code> 来查找。默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。然而，如果这个接口存在，那么固有元素的名字需要在 <code>JSX.IntrinsicElements</code> 接口的属性里查找。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface IntrinsicElements &#123;</span><br><span class=\"line\">        foo: any;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;foo /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;bar /&gt;; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在上例中，``没有问题，但是<code>会报错，因为它没在 JSX.IntrinsicElements</code> 里指定。</p>\n</blockquote>\n<blockquote>\n<p>注意：你也可以在 <code>JSX.IntrinsicElements</code> 上指定一个用来捕获所有字符串索引：</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface IntrinsicElements &#123;</span><br><span class=\"line\">        [elemName: string]: any;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"20-4-2-基于值的元素\"><a href=\"#20-4-2-基于值的元素\" class=\"headerlink\" title=\"20.4.2 基于值的元素\"></a>20.4.2 基于值的元素</h4><blockquote>\n<p>基于值的元素会简单的在它所在的作用域里按标识符查找。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MyComponent <span class=\"keyword\">from</span> <span class=\"string\">&quot;./myComponent&quot;</span>;</span><br><span class=\"line\">&lt;MyComponent /&gt; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;SomeOtherComponent /&gt; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有两种方式可以定义基于值的元素：</p>\n<ol>\n<li>无状态函数组件 (<code>SFC</code>)</li>\n<li>类组件</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>由于这两种基于值的元素在 <code>JSX</code> 表达式里无法区分，因此 <code>TypeScript</code> 首先会尝试将表达式作为无状态函数组件进行解析。如果解析成功，那么 <code>TypeScript</code> 就完成了表达式到其声明的解析操作。如果按照无状态函数组件解析失败，那么 <code>TypeScript</code> 会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。</p>\n</blockquote>\n<h5 id=\"1-无状态函数组件\"><a href=\"#1-无状态函数组件\" class=\"headerlink\" title=\"(1) 无状态函数组件\"></a>(1) 无状态函数组件</h5><blockquote>\n<p>正如其名，组件被定义成 <code>JavaScript</code> 函数，它的第一个参数是 <code>props</code> 对象。<code>TypeScript</code> 会强制它的返回值可以赋值给 <code>JSX.Element</code>。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface FooProp &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    X: number;</span><br><span class=\"line\">    Y: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">declare <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">AnotherComponent</span>(<span class=\"params\">prop: &#123; name: string &#125;</span>)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ComponentFoo</span>(<span class=\"params\">prop: FooProp</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AnotherComponent</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;prop.name&#125;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> Button = <span class=\"function\">(<span class=\"params\">prop: &#123; value: string &#125;, context: &#123; color: string &#125;</span>) =&gt;</span> &lt;button&gt;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于无状态函数组件是简单的 <code>JavaScript</code> 函数，所以我们还可以利用函数重载。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface ClickableProps &#123;</span><br><span class=\"line\">    children: JSX.Element[] | JSX.Element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface HomeProps <span class=\"keyword\">extends</span> ClickableProps &#123;</span><br><span class=\"line\">    home: JSX.Element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface SlideProps <span class=\"keyword\">extends</span> ClickableProps &#123;</span><br><span class=\"line\">    side: JSX.Element | string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MainButton</span>(<span class=\"params\">prop: HomeProps</span>): <span class=\"title\">JSX</span>.<span class=\"title\">Element</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MainButton</span>(<span class=\"params\">prop: SlideProps</span>): <span class=\"title\">JSX</span>.<span class=\"title\">Element</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-类组件\"><a href=\"#2-类组件\" class=\"headerlink\" title=\"(2) 类组件\"></a>(2) 类组件</h5><blockquote>\n<ol>\n<li>我们可以定义类组件的类型。然而，我们首先最好弄懂两个新的术语：<code>元素类的类型</code> 和 <code>元素实例的类型</code>。</li>\n<li>现在有 <code>&lt;Expr /&gt;</code>，元素类的类型为 <code>Expr</code> 的类型。所以在上面的例子里，如果 <code>MyComponent</code> 是 <code>ES6</code> 的类，那么类类型就是类的构造函数和静态部分。如果 <code>MyComponent</code> 是个工厂函数，类类型为这个函数。</li>\n<li>一旦建立起了类类型，实例类型由构造器或调用签名(如果存在的话)的返回值的联合构成。再次说明，在 <code>ES6</code> 类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用构造签名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myComponent = <span class=\"keyword\">new</span> MyComponent();</span><br><span class=\"line\"><span class=\"comment\">// 元素类的类型 =&gt; MyComponent;</span></span><br><span class=\"line\"><span class=\"comment\">// 元素实例的类型 =&gt; &#123; render: () =&gt; void &#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyFactoryFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render: <span class=\"function\">() =&gt;</span> &#123;&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用调用签名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myComponent = MyFactoryFunction();</span><br><span class=\"line\"><span class=\"comment\">// 元素类的类型 =&gt; FactoryFunction</span></span><br><span class=\"line\"><span class=\"comment\">// 元素实例的类型 =&gt; &#123; render: () =&gt; void &#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>元素的实例类型很有趣，因为它必须赋值给 <code>JSX.ElementClass</code> 或 <code>抛出一个错误</code>。默认的 <code>JSX.ElementClass</code> 为 <code>&#123;&#125;</code>，但是它可以被扩展用来限制 <code>JSX</code> 的类型以符合相应的接口。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface ElementClass &#123;</span><br><span class=\"line\">        render: any</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyFactoryFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        render: <span class=\"function\">() =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;MyComponent /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;MyFactoryFunction /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotAValidComponent</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NotAValidFactoryFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;NotAValidComponent /&gt;; <span class=\"comment\">// 错误</span></span><br><span class=\"line\">&lt;NotAValidFactoryFunction /&gt;; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-5-属性类型检查\"><a href=\"#20-5-属性类型检查\" class=\"headerlink\" title=\"20.5 属性类型检查\"></a>20.5 属性类型检查</h3><ol>\n<li>属性类型检查的第一步是 确定元素类型。这在 <code>固有元素</code> 和 <code>基于值的元素</code> 之间稍有不同。</li>\n<li>对于固有元素，这是 <code>JSX.IntrinsicElements</code> 属性的类型。</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface IntrinsicElements &#123;</span><br><span class=\"line\">        foo: &#123;</span><br><span class=\"line\">            bar?: boolean;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// `foo` 的元素属性类型为 `&#123;bar?: boolean&#125;`</span></span><br><span class=\"line\">&lt;foo bar /&gt;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>对于基于值的元素，就稍微复杂些。它取决于先前确定的在元素实例类型上的某个属性的类型。至于该使用哪个属性来确定类型取决于 <code>JSX.ElementAttributesProperty</code>。它应该使用单一的属性来定义。这个属性名之后会被使用。<code>TypeScript 2.8</code>，如果未指定 <code>JSX.ElementAttributesProperty</code>，那么将使用 <code>类元素构造函数</code> 或 <code>SFC</code> 调用的第一个参数类型。</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">  interface ElementAttributesProperty &#123;</span><br><span class=\"line\">      props; <span class=\"comment\">// 指定用来使用的属性名</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在元素实例上指定类型</span></span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">      foo?: string;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// `MyComponent` 的元素属性类型为 `&#123;foo?: string&#125;`</span></span><br><span class=\"line\">&lt;MyComponent foo=<span class=\"string\">&quot;bar&quot;</span> /&gt;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>元素属性类型用于 <code>JSX</code> 里进行属性的类型检查。支持可选属性和必须属性</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface IntrinsicElements &#123;</span><br><span class=\"line\">        foo: &#123;</span><br><span class=\"line\">            requiredProp: string;</span><br><span class=\"line\">            optionalProp?: number;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> optionalProp=&#123;<span class=\"number\">0</span>&#125; /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;foo /&gt;; <span class=\"comment\">// 错误，缺少requiredProp</span></span><br><span class=\"line\">&lt;foo requiredProp=&#123;<span class=\"number\">0</span>&#125; /&gt;; <span class=\"comment\">// 错误，requiredProp 应该是字符串</span></span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> unknownProp /&gt;; <span class=\"comment\">// 错误，unknownProp 属性不存在</span></span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> some-unknown-prop /&gt;; <span class=\"comment\">// 正确，`some-unknown-prop` 不是合法的标识符</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果一个属性名不是个合法的 <code>JS</code> 标识符(像 <code>data-\\*</code> 属性)，并且它没出现在元素属性类型里时不会当作一个错误。</p>\n</blockquote>\n<blockquote>\n<p>另外，<code>JSX</code> 还会使用 <code>JSX.IntrinsicAttributes</code> 接口来指定额外的属性，这些额外的属性通常不会被组件的 <code>props</code> 或 <code>arguments</code> 使用 - 比如 <code>React</code> 里的 <code>key</code>。还有，<code>JSX.IntrinsicClassAttributes&lt;T&gt;</code> 泛型类型也可以用来做同样的事情。这里的泛型参数表示类实例类型。在 <code>React</code> 里，它用来允许 <code>Ref&lt;T&gt;</code> 类型上的 <code>ref</code> 属性。通常来讲，这些接口上的所有属性都是可选的，除非你想要用户在每个 <code>JSX</code> 标签上都提供一些属性。</p>\n</blockquote>\n<blockquote>\n<p>延展操作符也可以使用</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> props = &#123; <span class=\"attr\">requiredProp</span>: <span class=\"string\">&quot;bar&quot;</span> &#125;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> badProps = &#123;&#125;;</span><br><span class=\"line\">&lt;foo &#123;...badProps&#125; /&gt;; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-6-子孙类型检查\"><a href=\"#20-6-子孙类型检查\" class=\"headerlink\" title=\"20.6 子孙类型检查\"></a>20.6 子孙类型检查</h3><blockquote>\n<p>从 <code>TypeScript 2.3</code> 开始，我们引入了 <code>children</code> 类型检查。<code>children</code> 是元素属性(<code>attribute</code>)类型的一个特殊属性(<code>property</code>)，子 <code>JSXExpression</code> 将会被插入到属性里。与使用 <code>JSX.ElementAttributesProperty</code> 来决定 <code>props</code> 名类似，我们可以利用 <code>JSX.ElementChildrenAttribute</code> 来决定 <code>children</code> 名。<code>JSX.ElementChildrenAttribute</code> 应该被声明在单一的属性(<code>property</code>)里。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> JSX &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> ElementChildrenAttribute &#123;</span><br><span class=\"line\">    children: &#123;&#125;; <span class=\"comment\">// specify children name to use</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如不特殊指定子孙的类型，我们将使用 <code>React typings</code> 里的默认类型</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">  World</span><br><span class=\"line\">&lt;/div&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> CustomComp = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>props.children<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;CustomComp&gt;</span><br><span class=\"line\">  &lt;div&gt;Hello World&lt;/div&gt;</span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;This is just a JS expression...&quot;</span> + <span class=\"number\">1000</span>&#125;</span><br><span class=\"line\">&lt;/CustomComp&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface PropsType &#123;</span><br><span class=\"line\">  children: JSX.Element;</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">PropsType</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;h2&gt;</span><br><span class=\"line\">              &#123;<span class=\"built_in\">this</span>.props.children&#125;</span><br><span class=\"line\">          &lt;/h2&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Ok</span></span><br><span class=\"line\">&lt;Component&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class=\"line\">&lt;/Component&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: children is of type JSX.Element not array of JSX.Element</span></span><br><span class=\"line\">&lt;Component&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class=\"line\">  &lt;h2&gt;Hello World&lt;/h2&gt;</span><br><span class=\"line\">&lt;/Component&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: children is of type JSX.Element not array of JSX.Element or string.</span></span><br><span class=\"line\">&lt;Component&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">  World</span><br><span class=\"line\">&lt;/Component&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-7-JSX-结果类型\"><a href=\"#20-7-JSX-结果类型\" class=\"headerlink\" title=\"20.7 JSX 结果类型\"></a>20.7 JSX 结果类型</h3><blockquote>\n<p>默认地 <code>JSX</code> 表达式结果的类型为 <code>any</code>。你可以自定义这个类型，通过指定 <code>JSX.Element</code> 接口。然而，不能够从接口里检索元素，属性或 <code>JSX</code> 的子元素的类型信息。它是一个黑盒。</p>\n</blockquote>\n<h3 id=\"20-8-嵌入的表达式\"><a href=\"#20-8-嵌入的表达式\" class=\"headerlink\" title=\"20.8 嵌入的表达式\"></a>20.8 嵌入的表达式</h3><blockquote>\n<p><code>JSX</code> 允许你使用 <code>&#123;&#125;</code> 标签来内嵌表达式</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map(i &#x3D;&gt; (</span><br><span class=\"line\">      &lt;span&gt;&#123;i &#x2F; 2&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">    ))&#125;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\">&#x2F;&#x2F; 上面的代码产生一个错误，因为你不能用数字来除以一个字符串。输出如下，若你使用了 preserve 选项</span><br><span class=\"line\">var a &#x3D; (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map(function (i) &#123;</span><br><span class=\"line\">      return &lt;span&gt;&#123;i &#x2F; 2&#125;&lt;&#x2F;span&gt;;</span><br><span class=\"line\">    &#125;)&#125;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-9-react-整合\"><a href=\"#20-9-react-整合\" class=\"headerlink\" title=\"20.9 react 整合\"></a>20.9 react 整合</h3><blockquote>\n<p>要想一起使用 <code>JSX</code> 和 <code>React</code>，你应该使用 <code>React</code> 类型定义。这些类型声明定义了 <code>JSX</code> 合适命名空间来使用 <code>React</code>。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;react.d.ts&quot; /&gt;</span></span><br><span class=\"line\">interface Props &#123;</span><br><span class=\"line\">  foo: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;MyComponent foo=<span class=\"string\">&quot;bar&quot;</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;MyComponent foo=&#123;<span class=\"number\">0</span>&#125; /&gt;; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-10-工厂函数\"><a href=\"#20-10-工厂函数\" class=\"headerlink\" title=\"20.10 工厂函数\"></a>20.10 工厂函数</h3><blockquote>\n<p><code>jsx</code>：<code>react</code> 编译选项使用的工厂函数是可以配置的。可以使用 <code>jsxFactory</code> 命令行选项，或内联的 <code>@jsx</code> 注释指令在每个文件上设置。比如，给 <code>createElement</code> 设置 <code>jsxFactory</code>，<code>&lt;div /&gt;</code> 会使用 <code>createElement(&quot;div&quot;)</code> 来生成，而不是 <code>React.createElement(&quot;div&quot;)</code>。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注释指令可以像下面这样使用：(在 TypeScript 2.8 里)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> preact = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;preact&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">/* @jsx preact.h */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>/&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> preact = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;preact&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> x = preact.h(<span class=\"string\">&quot;div&quot;</span>, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>工厂函数的选择同样会影响 <code>JSX</code> 命名空间的查找(类型检查)。如果工厂函数使用 <code>React.createElement</code> 定义(默认)，编译器会先检查 <code>React.JSX</code>，之后才检查全局的 <code>JSX</code>。如果工厂函数定义为 <code>h</code>，那么在检查全局的 <code>JSX</code> 之前先检查 <code>h.JSX</code>。</p>\n</blockquote>\n<h2 id=\"二十一、装饰器\"><a href=\"#二十一、装饰器\" class=\"headerlink\" title=\"二十一、装饰器\"></a>二十一、装饰器</h2><h3 id=\"21-1-介绍\"><a href=\"#21-1-介绍\" class=\"headerlink\" title=\"21.1 介绍\"></a>21.1 介绍</h3><blockquote>\n<p>随着 <code>TypeScript</code> 和 <code>ES6</code> 里引入了类，在一些场景下我们需要额外的特定来支持标注或修改类及其成员。装饰器(<code>Decorators</code>)为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。<code>JavaScript</code> 里的装饰器目前处在 建议征集的第二阶段，但在 <code>TypeScript</code> 里已作为一项实验性特性予以支持。<br>注意：装饰器是一项实验性特性，在未来的版本中可能会发生改变<br>若要启用实验性的装饰器特性，你必须在命令行或 <code>tsconfig.json</code> 里启用 <code>experimentalDecorators</code> 编译器选项。<br>命令行： <code>tsc --target ES5 --experimentalDecorators</code></p>\n</blockquote>\n<ul>\n<li>tsconfig.json</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span>: <span class=\"string\">&quot;ES5&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;experimentalDecorators&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-2-装饰器\"><a href=\"#21-2-装饰器\" class=\"headerlink\" title=\"21.2 装饰器\"></a>21.2 装饰器</h3><blockquote>\n<p>装饰器是一种特殊的声明，它能够被附加到 <code>类声明</code>、<code>方法</code>、<code>访问符</code>、<code>属性或参数上</code>。装饰器使用 <code>@expression</code> 这种形式，<code>expression</code> 求值后必须为一个函数，它会在运行时被调用，被装饰器的声明信息作为参数传入。<br>例如，有一个 <code>@sealed</code> 装饰器，我们会这样定义 <code>sealed</code> 函数</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sealed</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something with target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：后面类装饰器小节里有一个更加详细的例子。</p>\n</blockquote>\n<h3 id=\"21-3-装饰器工厂\"><a href=\"#21-3-装饰器工厂\" class=\"headerlink\" title=\"21.3 装饰器工厂\"></a>21.3 装饰器工厂</h3><blockquote>\n<p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p>\n</blockquote>\n<ul>\n<li>我们可以通过下面的方式来写一个装饰器工厂函数：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">color</span>(<span class=\"params\">value: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这是一个装饰器工厂</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是装饰器</span></span><br><span class=\"line\">    <span class=\"comment\">// do something with &quot;target&quot; and &quot;value&quot; ...</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：下面方法装饰器小节里有一个更加详细的例子。</p>\n</blockquote>\n<h3 id=\"21-4-装饰器组合\"><a href=\"#21-4-装饰器组合\" class=\"headerlink\" title=\"21.4 装饰器组合\"></a>21.4 装饰器组合</h3><blockquote>\n<p>多个装饰器可以同时应用到一个声明上，就像下面的实例：</p>\n</blockquote>\n<ol>\n<li>书写在同一行：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@f</span> <span class=\"meta\">@g</span> x</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>书写在多行上：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@f</span></span><br><span class=\"line\"><span class=\"meta\">@g</span></span><br><span class=\"line\">x</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当多个装饰器应用于一个声明上，它们求值方式与 复合函数 相似。在这个模型下，当复合 f 和 g 时，复合的结果 <code>\\(f∘g\\)\\(x\\)</code> 等同于 <code>f\\(g\\(x\\)\\)</code>。</p>\n</blockquote>\n<blockquote>\n<p>同样的，在 <code>TypeScript</code> 里，当多个装饰器应用在一个声明上时会进行如下步骤的操作： <code>1</code>. 由上至下依次对装饰器表达式求值 <code>2</code>. 求值的结果会被当作函数，由下至上依次被调用。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果我们使用 装饰器工厂 的话，可以通过下面的例子来观察它们求值的顺序：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;f(): evaluated&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, prototypeKey: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;f(): called&quot;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;g(): evaluated&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, prototypeKey: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;g(): called&quot;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@f</span>()</span><br><span class=\"line\">  <span class=\"meta\">@g</span>()</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在控制台里会打印出如下结果：</span></span><br><span class=\"line\">f(): evaluated</span><br><span class=\"line\">g(): evaluated</span><br><span class=\"line\">g(): called</span><br><span class=\"line\">f(): called</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-5-装饰器求值\"><a href=\"#21-5-装饰器求值\" class=\"headerlink\" title=\"21.5 装饰器求值\"></a>21.5 装饰器求值</h3><blockquote>\n<p>类中不同声明上的装饰器将按以下规定的顺序应用：</p>\n</blockquote>\n<ul>\n<li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。</li>\n<li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。</li>\n<li>参数装饰器应用到构造函数。</li>\n<li>类装饰器应用到类。</li>\n</ul>\n<h3 id=\"21-6-类装饰器\"><a href=\"#21-6-类装饰器\" class=\"headerlink\" title=\"21.6 类装饰器\"></a>21.6 类装饰器</h3><p>1.类装饰器在类声明之前被声明(紧靠着类声明)。类装饰器应用于类构造函数，可以用来监视修改或替换类定义。类装饰器不能用在声明文件中( <code>.d.ts</code> )，也不能用在任何外部上下文中(比如 <code>declare</code> 的类)。</p>\n<ol start=\"2\">\n<li>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</li>\n<li>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</li>\n</ol>\n<blockquote>\n<p>注意：如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。在运行时的装饰器调用逻辑中 不会为你做这些。<br>下面是使用类装饰器( <code>@sealed</code> )的例子，应用在 <code>Greeter</code> 类：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@sealed</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter1</span> </span>&#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们可以这样定义 @sealed 装饰器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sealed</span>(<span class=\"params\">constructor: <span class=\"built_in\">Function</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.seal(<span class=\"title\">constructor</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.seal(<span class=\"title\">constructor</span>.<span class=\"title\">prototype</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当 <code>@sealed</code> 被执行的时候，它将密闭此类的构造函数和原型。(注：参见 <code>Object.seal</code> )</p>\n</blockquote>\n<ul>\n<li>下面是一个重载构造函数的例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">classDecorator</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> </span>&#123; <span class=\"keyword\">new</span> (...args: <span class=\"built_in\">any</span>[]): &#123;&#125; &#125;&gt;(<span class=\"title\">constructor</span>: <span class=\"title\">T</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">constructor</span> </span>&#123;</span><br><span class=\"line\">    newProperty = <span class=\"string\">&quot;new property&quot;</span>;</span><br><span class=\"line\">    hello = <span class=\"string\">&quot;override&quot;</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@classDecorator</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter2</span> </span>&#123;</span><br><span class=\"line\">  property = <span class=\"string\">&quot;property&quot;</span>;</span><br><span class=\"line\">  hello: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">m: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.hello = m;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Greeter2(<span class=\"string\">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-7-方法装饰器\"><a href=\"#21-7-方法装饰器\" class=\"headerlink\" title=\"21.7 方法装饰器\"></a>21.7 方法装饰器</h3><blockquote>\n<p>方法装饰器声明在一个方法的声明之前(紧靠着方法声明)。它会被应用到方法的 <code>属性描述符</code> 上，可以用来监视，修改或者替换方法定义。方法装饰器不能用在声明文件 <code>.d.ts</code> 上，重载或者任何外部上下文(比如 <code>declare</code> 的类)中。</p>\n</blockquote>\n<blockquote>\n<p>方法装饰器表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p>\n<ol>\n<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>\n<li>成员的名字</li>\n<li>成员的属性修饰符</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：如果代码输出目标代码小于 <code>ES5</code>，属性描述符 将会是 <code>undefined</code>。</p>\n</blockquote>\n<blockquote>\n<p>如果方法装饰器返回一个值，它会被用作方法的 属性描述符。</p>\n</blockquote>\n<blockquote>\n<p>注意：如果代码输出目标版本小于 <code>ES5</code>，返回值会被忽略。</p>\n</blockquote>\n<ul>\n<li>下面是一个方法装饰器 (<code>@enumerable</code>) 的例子，应用于 <code>Greeter</code> 类的方法上。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@enumerable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们可以用下面的函数声明来定义 <code>@enumerable</code> 装饰器：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enumerable</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, property: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">    descriptor.enumerable = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的 <code>@enumerable(false)</code> 是一个装饰器工厂，当装饰器 <code>@enumerable(false)</code> 被调用时，它会修改属性描述符的 <code>enumerable</code> 属性。</p>\n</blockquote>\n<h3 id=\"21-8-访问器装饰器\"><a href=\"#21-8-访问器装饰器\" class=\"headerlink\" title=\"21.8 访问器装饰器\"></a>21.8 访问器装饰器</h3><blockquote>\n<p>访问器装饰器声明在一个访问器的声明之前(紧靠着访问器声明)。访问器装饰器 应用于访问器的 <code>属性描述符</code> 并且可以用来监视，修改或替换一个访问器的定义。访问器装饰器不能用在声明文件中( <code>.d.ts</code> )，或者任何外部上下文(比如 <code>declare</code> 的类)里。</p>\n</blockquote>\n<blockquote>\n<p>注意：<code>TypeScript</code> 不允许同时装饰一个成员的 <code>get</code> 和 <code>set</code> 访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了 <code>get</code> 和 <code>set</code> 访问器，而不是分开声明的。</p>\n</blockquote>\n<blockquote>\n<p>访问器装饰器表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p>\n<ol>\n<li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。</li>\n<li>成员的名字</li>\n<li>成员的属性描述符</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：如果代码输出目标版本小于 <code>ES5</code>，<code>Property Descriptor</code> 将会是 <code>undefined</code>。</p>\n</blockquote>\n<blockquote>\n<p>如果访问器装饰器返回一个值，它会被用作方法的 <code>属性描述符</code> 注意：如果代码输出目标版本小于 <code>ES5</code> 返回值会被忽略。</p>\n</blockquote>\n<ul>\n<li>下面是使用了访问器装饰器 (<code>@configurable</code>) 的例子，应用于 <code>Point</code> 类的成员上。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@configurable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">x</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@configurable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">y</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p: Point = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们可以通过如下函数声明来定义 <code>@configurable</code> 装饰器：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configurable</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyKey: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">    descriptor.configurable = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-9-属性装饰器\"><a href=\"#21-9-属性装饰器\" class=\"headerlink\" title=\"21.9 属性装饰器\"></a>21.9 属性装饰器</h3><blockquote>\n<p>属性装饰器声明在一个属性声明之前(紧靠着属性声明)。属性装饰器不能用在声明文件中（<code>.d.ts</code>），或者任何外部上下文（比如 <code>declare</code> 的类）里。</p>\n</blockquote>\n<blockquote>\n<p>属性装饰器表达式会在运行时当作函数被调用，传入下列 <code>2</code> 个参数：</p>\n<ol>\n<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>\n<li>成员的名字。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：<code>属性描述符</code> 不会作为参数传入属性装饰器，这与 <code>TypeScript</code> 是如何初始化属性装饰器有关。因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p>\n</blockquote>\n<ul>\n<li>我们可以用它来记录这个属性的元数据，如下例所示：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@format</span>(<span class=\"string\">&quot;Hello, %s&quot;</span>)</span><br><span class=\"line\">    greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> formatString = getFormat(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;greeting&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> formatString.replace(<span class=\"string\">&quot;%s&quot;</span>, <span class=\"built_in\">this</span>.greeting);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"keyword\">let</span> g: Greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">&quot;鼓励&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"comment\">// 然后定义 @format 装饰器 和 getFormat 函数</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> formatMetadataKey = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;format&quot;</span>);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">format</span>(<span class=\"params\">formatString: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.metadata(formatMetadataKey, formatString);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFormat</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyKey: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.getMetadata(formatMetadataKey, target, propertyKey);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个 <code>@format(&quot;Hello, %s&quot;)</code> 装饰器是个 <code>装饰器工厂</code>。当 <code>@format(&quot;Hello, %s&quot;)</code> 被调用时，它添加一条这个属性的元数据，通过 <code>reflect-metadata</code> 库里的 <code>Reflect.metadata</code> 函数。当 <code>getFormat</code> 被调用时，它读取格式的元数据。</p>\n</blockquote>\n<blockquote>\n<p>注意：这个例子需要使用 <code>reflect-metadata</code> 库。查看 元数据 了解 <code>reflect-metadata</code> 库更详细的信息。</p>\n</blockquote>\n<h3 id=\"21-10-参数装饰器\"><a href=\"#21-10-参数装饰器\" class=\"headerlink\" title=\"21.10 参数装饰器\"></a>21.10 参数装饰器</h3><blockquote>\n<p><code>参数装饰器</code> 声明在一个参数声明之前(紧靠着参数声明)。参数装饰器应用于 <code>类构造函数</code> 或 <code>方法声明</code>。参数装饰器 不能用在声明文件（<code>.d.ts</code>），重载或其它外部上下文（比如 <code>declare</code> 的类）里。<br><code>参数装饰器</code> 表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p>\n<ol>\n<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>\n<li>成员的名字</li>\n<li>参数在函数参数列表的索引</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：参数装饰器只能用来监视一个方法的参数是否被传入。</p>\n</blockquote>\n<blockquote>\n<p>参数装饰器的返回值会被忽略</p>\n</blockquote>\n<ul>\n<li>下面定义了参数装饰器( <code>@required</code> )并应用于 <code>Greeter</code> 类方法的一个参数：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"><span class=\"meta\">@required</span> name: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello &quot;</span> + name + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后我们使用下面的函数定义 <code>@required</code> 和 <code>@validate</code> 装饰器</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> requiredMetadataKey = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;required&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">required</span>(<span class=\"params\">target: <span class=\"built_in\">Object</span>, propertyKey: <span class=\"built_in\">string</span> | symbol, parameterIndex: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> existingRequiredParameters: <span class=\"built_in\">number</span>[] = <span class=\"built_in\">Reflect</span>.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];</span><br><span class=\"line\">  existingRequiredParameters.push(parameterIndex);</span><br><span class=\"line\">  <span class=\"built_in\">Reflect</span>.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">validate</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyName: <span class=\"built_in\">string</span>, descriptor: TypedPropertyDescriptor&lt;<span class=\"built_in\">Function</span>&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> method = descriptor.value;</span><br><span class=\"line\">  descriptor.value = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> requiredParameters: <span class=\"built_in\">number</span>[] = <span class=\"built_in\">Reflect</span>.getOwnMetadata(requiredMetadataKey, target, propertyName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requiredParameters) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> parameterIndex <span class=\"keyword\">of</span> requiredParameters) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameterIndex &gt;= <span class=\"built_in\">arguments</span>.length || <span class=\"built_in\">arguments</span>[parameterIndex] === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;Missing required argument.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> method.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>@required</code> 装饰器添加了元数据实体把参数标记为必须的。<br><code>@validate</code> 装饰器把 <code>greet</code> 方法包裹在一个函数里，在调用原先的函数前验证函数参数。<br><code>注意：</code>这个例子使用了 <code>reflect-metadata</code> 库。 查看 元数据 了解 <code>reflect-metadata</code> 库的更多信息。</p>\n</blockquote>\n<h3 id=\"21-11-元数据\"><a href=\"#21-11-元数据\" class=\"headerlink\" title=\"21.11 元数据\"></a>21.11 元数据</h3><blockquote>\n<p>一部分例子使用了 <code>reflect-metadata</code> 库来支持实现性的 <code>metadata API</code>。这个库还不是 <code>ECMAScript\\( JavaScript \\)</code> 标准的一部分。然而，当装饰器被 <code>ECMAScript</code> 官方标准采纳后，这些扩展也将被推荐给 <code>ECMAScript</code> 以采纳。</p>\n</blockquote>\n<ul>\n<li>你可以通过 <code>npm</code> 安装这个库</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>TypeScript</code> 支持为带有装饰器的声明生成元数据。你需要在 <code>命令行</code> 或 <code>tsconfig.json</code> 里启用 <code>emitDecoratorMetadata</code> 编译器选项。</p>\n</blockquote>\n<ul>\n<li>命令行：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>tsconfig.json</code></li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span>: <span class=\"string\">&quot;ES5&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;experimentalDecorators&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;emitDecoratorMetadata&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当启用了，只要 <code>reflect-metadata</code> 库被引入了，设计阶段添加的类型信息可以在运行时使用。</p>\n</blockquote>\n<ul>\n<li>如下例所示：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _p0: Point;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _p1: Point;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">p0</span>(<span class=\"params\">value: Point</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._p0 = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">p0</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._p0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">p1</span>(<span class=\"params\">value: Point</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._p1 = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">p1</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._p1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">validate</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyKey: <span class=\"built_in\">string</span>, descriptor: TypedPropertyDescriptor&lt;T&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> set = descriptor.set;</span><br><span class=\"line\">  descriptor.set = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">type</span> = <span class=\"built_in\">Reflect</span>.getMetadata(<span class=\"string\">&quot;design:type&quot;</span>, target, propertyKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(value <span class=\"keyword\">instanceof</span> <span class=\"keyword\">type</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&quot;Invalid type.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set(value);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>TypeScript</code> 编译器可以通过 <code>@Reflect.metadata</code> 装饰器注入设计阶段的类型信息。你可以认为它相当于下面的 <code>TypeScript：</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _p0: Point;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _p1: Point;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.metadata(<span class=\"string\">&quot;design:type&quot;</span>, Point)</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">p0</span>(<span class=\"params\">value: Point</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._p0 = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">p0</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._p0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.metadata(<span class=\"string\">&quot;design:type&quot;</span>, Point)</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">p1</span>(<span class=\"params\">value: Point</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._p1 = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">p1</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._p1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意： 装饰器元数据是个实验性的特性并且可能在以后的版本中发声破坏性的改变。</p>\n</blockquote>\n<h3 id=\"21-12-Reflect-metadata-库\"><a href=\"#21-12-Reflect-metadata-库\" class=\"headerlink\" title=\"21.12 Reflect-metadata 库\"></a>21.12 Reflect-metadata 库</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Reflect &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于装饰器</span></span><br><span class=\"line\">    metadata(k, v): <span class=\"function\">(<span class=\"params\">target, property?</span>) =&gt;</span> <span class=\"built_in\">void</span></span><br><span class=\"line\">    <span class=\"comment\">// 在对象上面定义元数据</span></span><br><span class=\"line\">    defineMetadata(k, v, o, p?): <span class=\"built_in\">void</span></span><br><span class=\"line\">    <span class=\"comment\">// 是否存在元数据</span></span><br><span class=\"line\">    hasMetadata(k, o, p?): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">    hasOwnMetadata(k, o, p?): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取元数据</span></span><br><span class=\"line\">    getMetadata(k, o, p?): <span class=\"built_in\">any</span></span><br><span class=\"line\">    getOwnMetadata(k, o, p?): <span class=\"built_in\">any</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取所有元数据的 Key</span></span><br><span class=\"line\">    getMetadataKeys(o, p?): <span class=\"built_in\">any</span>[]</span><br><span class=\"line\">    getOwnMetadataKeys(o, p?): <span class=\"built_in\">any</span>[]</span><br><span class=\"line\">    <span class=\"comment\">// 删除元数据</span></span><br><span class=\"line\">    deleteMetadata(k, o, p?): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"21-12-1-安装\"><a href=\"#21-12-1-安装\" class=\"headerlink\" title=\"21.12.1 安装\"></a>21.12.1 安装</h4><h5 id=\"Metadata-Reflection-API\"><a href=\"#Metadata-Reflection-API\" class=\"headerlink\" title=\"Metadata Reflection API\"></a>Metadata Reflection API</h5><ul>\n<li><a href=\"%5Bhttps://rbuckton.github.io/reflect-metadata%5D(https://rbuckton.github.io/reflect-metadata)\">Detailed proposal</a></li>\n</ul>\n<ol>\n<li>Installation</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install reflect-metadata</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Background</li>\n</ol>\n<ul>\n<li>Decorators add the ability to augment a class and its members as the class is defined, through a declarative syntax.</li>\n<li>Traceur attaches annotations to a static property on the class.</li>\n<li>Languages like C# (.NET), and Java support attributes or annotations that add metadata to types, along with a reflective API for reading metadata.</li>\n</ul>\n<ol start=\"3\">\n<li>Goals</li>\n</ol>\n<ul>\n<li>A number of use cases (Composition/Dependency Injection, Runtime Type Assertions, Reflection/Mirroring, Testing) want the ability to add additional metadata to a class in a consistent manner.</li>\n<li>A consistent approach is needed for various tools and libraries to be able to reason over metadata.</li>\n<li>Metadata-producing decorators (nee. “Annotations”) need to be generally composable with mutating decorators.</li>\n<li>Metadata should be available not only on an object but also through a Proxy, with related traps.</li>\n<li>Defining new metadata-producing decorators should not be arduous or over-complex for a developer.</li>\n<li>Metadata should be consistent with other language and runtime features of ECMAScript.</li>\n</ul>\n<ol start=\"4\">\n<li>Syntax</li>\n</ol>\n<ul>\n<li>Declarative definition of metadata:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  @<span class=\"built_in\">Reflect</span>.metadata(metadataKey, metadataValue)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Imperative definition of metadata:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Reflect</span>.defineMetadata(metadataKey, metadataValue, C.prototype, <span class=\"string\">&quot;method&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Imperative introspection of metadata:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> metadataValue = <span class=\"built_in\">Reflect</span>.getMetadata(metadataKey, obj, <span class=\"string\">&quot;method&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>Semantics</li>\n</ol>\n<ul>\n<li>Object has a new [[Metadata]] internal property that will contain a Map whose keys are property keys (or <code>undefined</code> ) and whose values are Maps of metadata keys to metadata values.</li>\n<li>Object will have a number of new internal methods for [[DefineOwnMetadata]], [[GetOwnMetadata]], [[HasOwnMetadata]], etc.<ul>\n<li>These internal methods can be overridden by a Proxy to support additional traps.</li>\n<li>These internal methods will by default call a set of abstract operations to define and read metadata.</li>\n</ul>\n</li>\n<li>The Reflect object will expose the MOP operations to allow imperative access to metadata.</li>\n<li>Metadata defined on class declaration <em>C</em> is stored in <em>C</em>.[[Metadata]], with <code>undefined</code> as the key.</li>\n<li>Metadata defined on static members of class declaration <em>C</em> are stored in <em>C</em>.[[Metadata]], with the property key as the key.</li>\n<li>Metadata defined on instance members of class declaration <em>C</em> are stored in <em>C</em>.prototype.[[Metadata]], with the property key as the key.</li>\n</ul>\n<ol>\n<li>API</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// define metadata on an object or property</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.defineMetadata(metadataKey, metadataValue, target);</span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.defineMetadata(metadataKey, metadataValue, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// check for presence of a metadata key on the prototype chain of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.hasMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.hasMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// check for presence of an own metadata key of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.hasOwnMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.hasOwnMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get metadata value of a metadata key on the prototype chain of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get metadata value of an own metadata key of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getOwnMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getOwnMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get all metadata keys on the prototype chain of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getMetadataKeys(target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getMetadataKeys(target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get all own metadata keys of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getOwnMetadataKeys(target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getOwnMetadataKeys(target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// delete metadata from an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.deleteMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.deleteMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// apply metadata via a decorator to a constructor</span></span><br><span class=\"line\">@<span class=\"built_in\">Reflect</span>.metadata(metadataKey, metadataValue)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// apply metadata via a decorator to a method (property)</span></span><br><span class=\"line\">  @<span class=\"built_in\">Reflect</span>.metadata(metadataKey, metadataValue)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>Alternatives</li>\n</ol>\n<ul>\n<li>Use properties rather than a separate API.<ul>\n<li>Obvious downside is that this can be a lot of code:</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ParamTypes</span>(<span class=\"params\">...types</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">target, propertyKey</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> symParamTypes = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;design:paramtypes&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propertyKey === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      target[symParamTypes] = types;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> symProperties = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;design:properties&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> properties, property;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(target, symProperties)) &#123;</span><br><span class=\"line\">        properties = target[symProperties];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        properties = target[symProperties] = &#123;&#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(properties, propertyKey)) &#123;</span><br><span class=\"line\">        property = properties[propertyKey];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        property = properties[propertyKey] = &#123;&#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      property[symParamTypes] = types;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>Notes</li>\n</ol>\n<ul>\n<li>Though it may seem counterintuitive, the methods on Reflect place the parameters for the metadata key and metadata value before the target or property key. This is due to the fact that the property key is the only optional parameter in the argument list. This also makes the methods easier to curry with Function#bind. This also helps reduce the overall footprint and complexity of a metadata-producing decorator that could target both a class or a property:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ParamTypes</span>(<span class=\"params\">...types</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// as propertyKey is effectively optional, its easier to use here</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">target, propertyKey</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Reflect</span>.defineMetadata(<span class=\"string\">&quot;design:paramtypes&quot;</span>, types, target, propertyKey);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// vs. having multiple overloads with the target and key in the front:</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// return (target, propertyKey) =&gt; &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//    if (propertyKey === undefined) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      Reflect.defineMetadata(target, &quot;design:paramtypes&quot;, types);</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    else &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      Reflect.defineMetadata(target, propertyKey, &quot;design:paramtypes&quot;, types);</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// vs. having a different methods for the class or a property:</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// return (target, propertyKey) =&gt; &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//    if (propertyKey === undefined) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      Reflect.defineMetadata(target, &quot;design:paramtypes&quot;, types);</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    else &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      Reflect.definePropertyMetadata(target, propertyKey, &quot;design:paramtypes&quot;, types);</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>To enable experimental support for metadata decorators in your TypeScript project, you must add <code>&quot;experimentalDecorators&quot;: true</code> to your tsconfig.json file.</li>\n<li>To enable experimental support for auto-generated type metadata in your TypeScript project, you must add <code>&quot;emitDecoratorMetadata&quot;: true</code> to your tsconfig.json file.<ul>\n<li>Please note that auto-generated type metadata may have issues with circular or forward references for types.</li>\n</ul>\n</li>\n</ul>\n<ol start=\"9\">\n<li>Issues</li>\n</ol>\n<ul>\n<li>A poorly written mutating decorator for a class constructor could cause metadata to become lost if the prototype chain is not maintained. Though, not maintaining the prototype chain in a mutating decorator for a class constructor would have other negative side effects as well. <a href=\"/rbuckton\">@rbuckton </a><ul>\n<li>This is mitigated if the mutating decorator returns a class expression that extends from the target, or returns a proxy for the decorator. <a href=\"/rbuckton\">@rbuckton </a></li>\n</ul>\n</li>\n<li>Metadata for a method is attached to the class (or prototype) via the property key. It would not then be available if trying to read metadata on the function of the method (e.g. “tearing-off” the method from the class). <a href=\"/rbuckton\">@rbuckton </a></li>\n</ul>\n<h2 id=\"二十二、Mixins-混入\"><a href=\"#二十二、Mixins-混入\" class=\"headerlink\" title=\"二十二、Mixins 混入\"></a>二十二、Mixins 混入</h2><h3 id=\"22-1-介绍\"><a href=\"#22-1-介绍\" class=\"headerlink\" title=\"22.1 介绍\"></a>22.1 介绍</h3><blockquote>\n<p>除了传统的面向对象继承方式，还流行一种通用可重用组件创建类的方式，就是联合另一个简单类的代码。<br>你可能在 <code>Scala</code> 等语言里对 <code>mixins</code> 及其特性已经很熟悉了，但它在 <code>JavaScript</code> 中也是很流行的。</p>\n</blockquote>\n<h3 id=\"22-2-混入示例\"><a href=\"#22-2-混入示例\" class=\"headerlink\" title=\"22.2 混入示例\"></a>22.2 混入示例</h3><blockquote>\n<p>下面的代码演示了如何在 <code>TypeScript</code> 里使用混入。后面我们还会解释这段代码是如何工作的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposable Mixin</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Disposable</span> </span>&#123;</span><br><span class=\"line\">  isDisposed: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">dispose</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isDisposed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Activatable Mixin</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activatable</span> </span>&#123;</span><br><span class=\"line\">  isActive: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">activate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isActive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">deactivate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isActive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartObject</span> <span class=\"title\">implements</span> <span class=\"title\">Disposable</span>, <span class=\"title\">Activatable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.isActive + <span class=\"string\">&quot;:&quot;</span> + <span class=\"built_in\">this</span>.isDisposed), <span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">interact</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.activate();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disposable</span></span><br><span class=\"line\">  isDisposed: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  dispose: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Activatable</span></span><br><span class=\"line\">  isActive: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  activate: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  deactivate: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">applyMixins(SmartObject, [Disposable, Activatable]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> smartObj = <span class=\"keyword\">new</span> SmartObject();</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> smartObj.interact(), <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">// In your runtime library somewhere</span></span><br><span class=\"line\"><span class=\"comment\">////////////////////////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMixins</span>(<span class=\"params\">derivedCtor: <span class=\"built_in\">any</span>, baseCtors: <span class=\"built_in\">any</span>[]</span>) </span>&#123;</span><br><span class=\"line\">  baseCtors.forEach(<span class=\"function\"><span class=\"params\">baseCtor</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"22-3-理解这个例子\"><a href=\"#22-3-理解这个例子\" class=\"headerlink\" title=\"22.3 理解这个例子\"></a>22.3 理解这个例子</h3><ol>\n<li>代码里首先定义了两个类，它们将做为 <code>mixins</code>。可以看到每个类都只定义了一个特定的行为或功能。稍后我们使用它们来创建一个新类，同时具有这两种功能。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposable Mixin</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Disponsable</span> </span>&#123;</span><br><span class=\"line\">  isDisponsed: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">dispose</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isDisponsed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Activatable Mixin</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activatable</span> </span>&#123;</span><br><span class=\"line\">  isActive: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">activate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isActive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">deactivate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isActive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>下面创建一个类，结合了这两个 <code>mixins</code>。 下面来看一下具体是怎么操作的：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartObject</span> <span class=\"title\">implements</span> <span class=\"title\">Disposable</span>, <span class=\"title\">Activatable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>首先应该注意到的是，没使用 <code>extends</code> 而是使用 <code>implements</code>。 把类当成了接口，仅使用 <code>Disposable</code> 和 <code>Activatable</code> 的类型而非其实现。 这意味着我们需要在类里面实现接口。但是这是我们在用 <code>mixin</code> 时想避免的。</li>\n<li>我们可以这么做来达到目的，为将要 <code>mixin</code> 进来的属性方法创建出占位属性。这告诉编译器这些成员在运行时是可用的。 这样就能使用 <code>mixin</code> 带来的便利，虽说需要提前定义一些占位属性。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposable</span></span><br><span class=\"line\">  isDisposed: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  dispose: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"comment\">// Activatable</span></span><br><span class=\"line\">  isActive: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  activate: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  deactivate: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>最后，把 <code>mixins</code> 混入定义的类，完成全部实现部分。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyMixins(SmartObject, [Disposable, Activatable]);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>最后，创建这个帮助函数，帮我们做混入操作。 它会遍历 <code>mixins</code> 上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMixins</span>(<span class=\"params\">derivedCtor: <span class=\"built_in\">any</span>, baseCtors: <span class=\"built_in\">any</span>[]</span>) </span>&#123;</span><br><span class=\"line\">  baseCtors.forEach(<span class=\"function\"><span class=\"params\">baseCtor</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二十三、三斜线指令\"><a href=\"#二十三、三斜线指令\" class=\"headerlink\" title=\"二十三、三斜线指令\"></a>二十三、三斜线指令</h2><ul>\n<li>三斜线指令是包含单个 <code>XML</code> 标签的单行注释。注释内容会做为编译器指令使用。</li>\n<li>三斜线指令仅可放在包含它的文件最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。如果它们出现在一个语句或声明之后，那么它们会被当作普通的单行注释，并且不具有特殊的含义。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;...&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;...&quot; /&gt; 指令是三斜线指令中最常见的一种。 它用于声明文件间的 依赖。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>三斜线引用告诉编译器在编译过程中要引入的额外文件。</li>\n<li>当使用 <code>--out</code> 或 <code>--outFile</code> 时，它也可以做为调整输出内容顺序的一种方法。文件在输出文件内容中的位置与经过预处理后的输入顺序一致。</li>\n</ul>\n<h3 id=\"23-1-预处理输入文件\"><a href=\"#23-1-预处理输入文件\" class=\"headerlink\" title=\"23.1 预处理输入文件\"></a>23.1 预处理输入文件</h3><blockquote>\n<p>编译器会对输入文件进行预处理来解析所有三斜线引用指令。在这个过程中，额外的文件会加到编译过程中。<br>这个过程会以一些根文件开始；它们是在命令行中指定的文件或是在 <code>tsconfig.json</code> 中的 <code>&quot;files&quot;</code> 列表里的文件。这些根文件按指定的顺序进行预处理。在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。<br>  一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。</p>\n</blockquote>\n<h3 id=\"23-2-错误\"><a href=\"#23-2-错误\" class=\"headerlink\" title=\"23.2 错误\"></a>23.2 错误</h3><blockquote>\n<p>引用不存在的文件会报错。一个文件用三斜线指令引用自己会报错。</p>\n</blockquote>\n<h3 id=\"23-3-使用-noResolve\"><a href=\"#23-3-使用-noResolve\" class=\"headerlink\" title=\"23.3 使用 --noResolve\"></a>23.3 使用 <code>--noResolve</code></h3><blockquote>\n<p>如果指定了 <code>--noResolve</code> 编译选项，三斜线指令会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference types=&quot;...&quot; /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>与 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令相似，这个指令是用来声明依赖的；一个 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 指令则声明了对某个包的依赖。</li>\n<li>对这些包的名字的解析与在 <code>import</code> 语句里对模块名的解析类似。可以简单地把三斜线类型引用指令当做 <code>import</code> 声明的包。</li>\n<li>例如，把 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code>引入到声明文件，表明这个文件使用了<code>@types/node/index.d.ts</code> 里面声明的名字；并且，这个包需要在编译阶段与声明文件一起被包含进来。</li>\n<li>仅当在你需要写一个 <code>.d.ts</code> 文件时才使用这个指令。</li>\n<li>对于那些在编译阶段生成的声明文件，编译器会自动地添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>；当且仅当结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加  <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 语句。</li>\n<li>若要在 <code>.ts</code> 文件里声明一个对 <code>@types</code> 包的依赖，使用 <code>--types</code> 命令行选项 或在 <code>tsconfig.json</code> 里指定。查看 在 <code>tsconfig.json</code> 里使用 <code>@types</code>，<code>typeRoots</code> 和 <code>types</code> 了解详情。</li>\n<li><code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 这个指令把一个文件标记成默认库。你会在 <code>lib.d.ts</code> 文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中不要包含这个默认库（比如，<code>lib.d.ts</code>）。 这与在命令行上使用 -<code>-noLib</code> 相似。</li>\n<li>还要注意，当传递了 <code>--skipDefaultLibCheck</code> 时，编译器只会忽略检查带有 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 的文件。</li>\n</ul>\n<h3 id=\"23-4-lt-amd-module-gt\"><a href=\"#23-4-lt-amd-module-gt\" class=\"headerlink\" title=\"23.4 &lt;amd-module /&gt;\"></a>23.4 <code>&lt;amd-module /&gt;</code></h3><blockquote>\n<p>默认情况下生成的 <code>AMD</code> 模块 都是匿名的。但是，当一些工具需要处理生成的模块时会产生问题，比如 <code>r.js。amd-module</code> 指令允许给编译器传入一个可选的模块名：</p>\n</blockquote>\n<ul>\n<li><code>amdModule.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;amd-module name=&quot;NamedModule&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这会将 <code>NamedModule</code> 传入到 <code>AMD define</code> 函数里：</p>\n</blockquote>\n<ul>\n<li><code>amdModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">&quot;NamedModule&quot;</span>, [<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> C = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> C;</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.C = C;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"23-5-lt-amd-dependency-gt\"><a href=\"#23-5-lt-amd-dependency-gt\" class=\"headerlink\" title=\"23.5 &lt;amd-dependency /&gt;\"></a>23.5 <code>&lt;amd-dependency /&gt;</code></h3><ul>\n<li>注意：这个指令被废弃了。使用 <code>import &quot;moduleName&quot;;</code> 语句代替。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;amd-dependency path=&quot;x&quot; /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 告诉编译器有一个非 TypeScript 模块依赖需要被注入，做为目标模块 require 调用的一部分。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>amd-dependency</code> 指令也可以带一个可选的 <code>name</code> 属性；它允许我们为 <code>amd-dependency</code> 传入一个可选名字：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;amd-dependency path=&quot;legacy/moduleA&quot; name=&quot;moduleA&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> moduleA: MyType;</span><br><span class=\"line\">moduleA.callStuff();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成的 <code>JavaScript</code> 代码：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;legacy/moduleA&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>, moduleA</span>) </span>&#123;</span><br><span class=\"line\">  moduleA.callStuff();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二十四、JavaScript-文件类型检查\"><a href=\"#二十四、JavaScript-文件类型检查\" class=\"headerlink\" title=\"二十四、JavaScript 文件类型检查\"></a>二十四、JavaScript 文件类型检查</h2><h3 id=\"24-1-JavaScript-文件类型检查\"><a href=\"#24-1-JavaScript-文件类型检查\" class=\"headerlink\" title=\"24.1 JavaScript 文件类型检查\"></a>24.1 JavaScript 文件类型检查</h3><blockquote>\n<p><code>TypeScript 2.3</code> 以后的版本支持使用 <code>--checkJs</code> 对 <code>.js</code> 文件进行类型检查和错误提示。</p>\n</blockquote>\n<blockquote>\n<p>你可以通过添加 <code>// @ts-nocheck</code> 注释来忽略类型检查；相反，你可以通过去掉 <code>--checkJs</code> 设置并添加一个 <code>// @ts-nocheck</code> 注释来选择检查某些 <code>.js</code> 文件。你还可以用 <code>// @ts-ignore</code> 来忽略本行的错误。如果你使用了 <code>tsconfig.json</code>，<code>JS</code> 检查将遵照一些严格检查标记，如 <code>noImplicitAny</code>，<code>strictNullChecks</code> 等。但因为 <code>JS</code> 检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。</p>\n</blockquote>\n<ul>\n<li>对比 <code>.js</code>文件和 <code>.ts</code> 文件在类型检查上的差异，有如下几点需要注意</li>\n</ul>\n<h4 id=\"1-用-JSDoc-类型表示类型信息\"><a href=\"#1-用-JSDoc-类型表示类型信息\" class=\"headerlink\" title=\"(1) 用 JSDoc 类型表示类型信息\"></a>(1) 用 <code>JSDoc</code> 类型表示类型信息</h4><blockquote>\n<p><code>.js</code> 文件里，类型可以和在 <code>.ts</code> 文件里一样被推断出来。同样地，当类型不能被推断时，它们可以通过 <code>JSDoc</code> 来指定，就好比在 <code>.ts</code> 文件里那样。如同 <code>TypeScript</code>，<code>--noImplicitAny</code> 会在编译器无法推断类型的位置报错。（除了对象字面量的情况；后面会详细介绍）<code>JSDoc</code> 注解修饰的声明会被设置为这个声明的类型。比如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;number&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x;</span><br><span class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">x = <span class=\"literal\">false</span>; <span class=\"comment\">// Error: boolean is not assignable to number</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>你可以在这里找到所有 <code>JSDoc</code> 支持的模式，<a href=\"https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript\">JSDoc 文档</a>。</p>\n</blockquote>\n<h4 id=\"2-属性的推断来自于类内的赋值语句\"><a href=\"#2-属性的推断来自于类内的赋值语句\" class=\"headerlink\" title=\"(2) 属性的推断来自于类内的赋值语句\"></a>(2) 属性的推断来自于类内的赋值语句</h4><blockquote>\n<p><code>ES2015</code> 没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。在 <code>.js</code> 文件里，编译器从类内部的属性赋值语句来推断属性类型。属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是 <code>undefined</code> 或 <code>null</code>。若是这种情况，类型将会是所有赋值的类型的联合类型。在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.constructorOnly = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.constructorUnknown = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.constructorOnly = <span class=\"literal\">false</span>; <span class=\"comment\">// error, constructorOnly is a number</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.constructorUnknown = <span class=\"string\">&quot;plunkbat&quot;</span>; <span class=\"comment\">// ok, constructorUnknown is string | undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.methodOnly = <span class=\"string\">&quot;ok&quot;</span>; <span class=\"comment\">// ok, but y could also be undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method2</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.methodOnly = <span class=\"literal\">true</span>; <span class=\"comment\">// also, ok, y&#x27;s type is string | boolean | undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果一个属性从没在类内设置过，它们会被当成未知的。</p>\n</blockquote>\n<blockquote>\n<p>如果类的属性只是读取用的，那么就在构造函数里用 <code>JSDoc</code> 声明它的类型。如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;name | undefined&#125;</span> </span>*/</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.prop = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;number | undefined&#125;</span> </span>*/</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\">c.prop = <span class=\"number\">0</span>; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">c.count = <span class=\"string\">&quot;string&quot;</span>; <span class=\"comment\">// Error: string is not assignable to number | undefined</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-构造函数等同于类\"><a href=\"#3-构造函数等同于类\" class=\"headerlink\" title=\"(3) 构造函数等同于类\"></a>(3) 构造函数等同于类</h4><blockquote>\n<p><code>ES2015</code> 以前，<code>Javascript</code> 使用构造函数代替类。编译器支持这种模式并能够将构造函数识别为 <code>ES2015</code> 的类。属性类型推断机制和上面介绍的一致。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.constructorOnly = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.constructorUnknown = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">C.prototype.method = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.constructorOnly = <span class=\"literal\">false</span>; <span class=\"comment\">// error</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.constructorUnknown = <span class=\"string\">&quot;plunkbat&quot;</span>; <span class=\"comment\">// OK, the type is string | undefined</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-支持-CommonJS-模块\"><a href=\"#4-支持-CommonJS-模块\" class=\"headerlink\" title=\"(4) 支持 CommonJS 模块\"></a>(4) 支持 <code>CommonJS</code> 模块</h4><blockquote>\n<p>在 <code>.js</code> 文件里，<code>TypeScript</code> 能识别出 <code>CommonJS</code> 模块。对 <code>exports</code> 和 <code>module.exports</code> 的赋值被识别为导出声明。相似地，<code>require</code> 函数调用被识别为模块导入。例如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// same as `import module &#x27;fs&#x27;`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// same as `export function readFile`</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fs.readFileSync(f);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对 <code>JavaScript</code> 文件里模块语法的支持比在 <code>TypeScript</code> 里宽泛多了。 大部分的赋值和声明方式都是允许的。</p>\n</blockquote>\n<h4 id=\"5-类，函数和对象字面量是命名空间\"><a href=\"#5-类，函数和对象字面量是命名空间\" class=\"headerlink\" title=\"(5) 类，函数和对象字面量是命名空间\"></a>(5) 类，函数和对象字面量是命名空间</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .js 文件里的类是命名空间。它可以用于嵌套类，比如：</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;&#125;</span><br><span class=\"line\">C.D = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// ES2015 之前的代码，它可以用来模拟静态方法。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Outer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.y = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Outer.Inner = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.yy = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 它还可以用于创建简单的命名空间：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ns = &#123;&#125;;</span><br><span class=\"line\">ns.C = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;&#125;;</span><br><span class=\"line\">ns.func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 同时还支持其它的变化</span></span><br><span class=\"line\"><span class=\"comment\">// 立即调用的函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ns = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n | &#123;&#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">ns.COUNT = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// defaulting to global</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> assign =</span><br><span class=\"line\">  assign ||</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// code goes here</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">assign.extra = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-对象字面量是开放的\"><a href=\"#6-对象字面量是开放的\" class=\"headerlink\" title=\"(6) 对象字面量是开放的\"></a>(6) 对象字面量是开放的</h4><ul>\n<li><code>.ts</code> 文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。这个规则在 <code>.js</code> 文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">obj.b = <span class=\"number\">2</span>; <span class=\"comment\">// Allowed</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对象字面量的表现就好比具有一个默认的索引签名 <code>\\[x:string\\]: any</code>，它们可以被当成开放的映射而不是封闭的对象。</li>\n<li>与其它 <code>JS</code> 检查行为相似，这种行为可以通过指定 <code>JSDoc</code> 类型来改变，例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;&#123; a: number &#125;</span></span>&#125; */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">obj.b = <span class=\"number\">2</span>; <span class=\"comment\">// Error, type &#123;a: number&#125; does not have property b</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-null-undefined-和-空数组的类型是-any-或-any\"><a href=\"#7-null-undefined-和-空数组的类型是-any-或-any\" class=\"headerlink\" title=\"(7) null undefined 和 空数组的类型是 any 或 any[]\"></a>(7) null undefined 和 空数组的类型是 any 或 any[]</h4><blockquote>\n<p>任何用 <code>null</code>，<code>undefined</code> 初始化的变量，参数或属性，它们的类型是 <code>any</code>，就算是在严格 <code>null</code> 检查模式下。任何用 <code>[]</code> 初始化的变量，参数或属性，它们的类型是 <code>any[]</code>，就算是在严格 <code>null</code> 检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">i = <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!i) i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> j = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  j = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.l = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.l.push(foo.i);</span><br><span class=\"line\">foo.l.push(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-函数参数是默认可选的\"><a href=\"#8-函数参数是默认可选的\" class=\"headerlink\" title=\"(8) 函数参数是默认可选的\"></a>(8) 函数参数是默认可选的</h4><blockquote>\n<p>由于在 <code>ES2015</code> 之前无法指定可选参数，因此 <code>.js</code> 文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。</p>\n</blockquote>\n<blockquote>\n<p>需要注意的一点是，使用过多的参数调用函数会得到一个错误。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a + <span class=\"string\">&quot; &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(<span class=\"number\">1</span>); <span class=\"comment\">// OK, second argument considered optional</span></span><br><span class=\"line\">bar(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">bar(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// Error, too many arguments</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>JSDoc</code> 注解的函数会被从这条规则里移除。使用 <code>JSDoc</code> 可选参数语法来表示可选性。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如：</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>[somebody] - Somebody&#x27;s name.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\">somebody</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!somebody) &#123;</span><br><span class=\"line\">    somebody = <span class=\"string\">&quot;John Doe&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Hello &quot;</span> + somebody);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHello();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-由-arguments-推断出的-var-args-参数声明\"><a href=\"#9-由-arguments-推断出的-var-args-参数声明\" class=\"headerlink\" title=\"(9) 由 arguments 推断出的 var-args 参数声明\"></a>(9) 由 <code>arguments</code> 推断出的 <code>var-args</code> 参数声明</h4><blockquote>\n<p>如果一个函数的函数体内有对 <code>arguments</code> 的引用，那么这个函数会隐式地被认为具有一个 <code>var-arg</code> 参数（比如: <code>(...arg: any[]) =&gt;; any)</code>）。使用 <code>JSDoc</code> 的 <code>var-arg</code> 语法来指定 <code>arguments</code> 的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@param <span class=\"type\">&#123;...number&#125;</span> </span>args */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"><span class=\"comment\">/* numbers */</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">    total += <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"10-未指定的类型参数默认为-any\"><a href=\"#10-未指定的类型参数默认为-any\" class=\"headerlink\" title=\"(10) 未指定的类型参数默认为 any\"></a>(10) 未指定的类型参数默认为 <code>any</code></h4><blockquote>\n<p>由于 <code>JavaScript</code> 里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为 <code>any</code>。</p>\n</blockquote>\n<h4 id=\"11-在-extends-语句中：\"><a href=\"#11-在-extends-语句中：\" class=\"headerlink\" title=\"(11) 在 extends 语句中：\"></a>(11) 在 <code>extends</code> 语句中：</h4><blockquote>\n<p>例如，<code>React.Component</code> 被定义成具有两个类型参数，<code>Props</code> 和 <code>State</code>。 在一个 <code>.js</code> 文件里，没有一个合法的方式在 <code>extends</code> 语句里指定它们。默认地参数类型为 <code>any</code>：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.props.b; <span class=\"comment\">// Allowed, since this.props is of type any</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 <code>JSDoc</code> 的 <code>@augments</code> 来明确地指定类型。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@augments <span class=\"type\">&#123;Component&lt;&#123;a: number&#125;</span></span>, State&gt;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.props.b; <span class=\"comment\">// Error: b does not exist on &#123;a:number&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-在-JSDoc-引用中\"><a href=\"#12-在-JSDoc-引用中\" class=\"headerlink\" title=\"(12) 在 JSDoc 引用中\"></a>(12) 在 JSDoc 引用中</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type<span class=\"type\">&#123;Array&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = [];</span><br><span class=\"line\"></span><br><span class=\"line\">x.push(<span class=\"number\">1</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\">x.push(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// OK, x is of type Array&lt;any&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type<span class=\"type\">&#123;Array.&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y = [];</span><br><span class=\"line\"></span><br><span class=\"line\">y.push(<span class=\"number\">1</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\">y.push(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// Error, string is not assignable to number</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"13-在函数调用中\"><a href=\"#13-在函数调用中\" class=\"headerlink\" title=\"(13) 在函数调用中\"></a>(13) 在函数调用中</h4><blockquote>\n<p>泛型函数的调用使用 <code>arguments</code> 来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为 <code>any</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reject();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p; <span class=\"comment\">// Promise&lt;any&gt;;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"24-2-支持的-JSDoc\"><a href=\"#24-2-支持的-JSDoc\" class=\"headerlink\" title=\"24.2 支持的 JSDoc\"></a>24.2 支持的 JSDoc</h3><blockquote>\n<p>面的列表列出了当前所支持的 <code>JSDoc</code> 注解，你可以用它们在 <code>JavaScript</code> 文件里添加类型信息。 注意，没有在下面列出的标记（例如 <code>@async</code>）都是还不支持的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>  <span class=\"meta\">@type</span></span><br><span class=\"line\"><span class=\"number\">2.</span>  <span class=\"meta\">@param</span> (or <span class=\"meta\">@arg</span> or <span class=\"meta\">@argument</span>)</span><br><span class=\"line\"><span class=\"number\">3.</span>  <span class=\"meta\">@returns</span> (or <span class=\"meta\">@return</span>)</span><br><span class=\"line\"><span class=\"number\">4.</span>  <span class=\"meta\">@typedef</span></span><br><span class=\"line\"><span class=\"number\">5.</span>  <span class=\"meta\">@callback</span></span><br><span class=\"line\"><span class=\"number\">6.</span>  <span class=\"meta\">@template</span></span><br><span class=\"line\"><span class=\"number\">7.</span>  <span class=\"meta\">@class</span> (or <span class=\"meta\">@constructor</span>)</span><br><span class=\"line\"><span class=\"number\">8.</span>  <span class=\"meta\">@this</span></span><br><span class=\"line\"><span class=\"number\">9.</span>  <span class=\"meta\">@extends</span> (or <span class=\"meta\">@augments</span>)</span><br><span class=\"line\"><span class=\"number\">10.</span> <span class=\"meta\">@enum</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它们代表的意义与 <code>usejsdoc.org</code> 上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。</p>\n</blockquote>\n<h4 id=\"1-type\"><a href=\"#1-type\" class=\"headerlink\" title=\"(1) @type \"></a>(1) <a href=\"/type\">@type </a></h4><blockquote>\n<p>可以使用 <code>@type</code> 标记并引用一个类型名称（原始类型，<code>TypeScript</code> 里声明的类型，或在 <code>JSDoc</code> 里 <code>@typedef</code> 标记指定的）可以使用任何 <code>TypeScript</code> 类型和大多数 <code>JSDoc</code> 类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;string&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Window&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> win;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;PromiseLike&lt;string&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promisedString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// You can specify an HTML Element with DOM properties</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;HTMLElement&#125;</span> </span>*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myElement = <span class=\"built_in\">document</span>.querySelector(selector);</span><br><span class=\"line\">element.dataset.myData = <span class=\"string\">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>@type</code> 可以指定联合类型—例如，<code>string</code> 和 <code>boolean</code> 类型的联合。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;&#123;string | boolean&#125;</span></span>&#125; */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sb;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意：括号是可选的</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;string | boolean&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sb;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>有多种方式来指定数组类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;number[]&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ns;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Array.&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nds;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Array&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nas;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还可以指定对象字面量类型。例如，一个带有 <code>a(字符串)</code> 和 <code>b(数字)</code> 属性的对象，使用下面的语法：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;&#123;a: string, b: number&#125;</span></span>&#125; */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> var9;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以使用字符串和数字索引签名来指定 <code>map-like</code> 和 <code>array-like</code> 的对象，使用标准的 <code>JSDoc</code> 语法或者 <code>TypeScript</code> 语法。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A map-like object that maps arbitrary `string` properties to `number`s.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;Object.&lt;string, number&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stringToNumber;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Object.&lt;number, object&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayLike;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这两个类型与 <code>TypeScript</code> 里的 <code>&#123; [x: string]: number &#125;</code> 和 <code>&#123; [x: number]: any &#125;</code> 是等同的。 编译器能识别出这两种语法。</li>\n<li>可以使用 <code>TypeScript</code> 或 <code>Closure</code> 语法指定函数类型。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;function(string, boolean): number&#125;</span> </span>Closure syntax */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sbn;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;(s: string, b: boolean) =&gt; number&#125;</span> </span>Typescript syntax */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sbn2;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>或者直接使用未指定的 <code>Function</code> 类型：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Function&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn7;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;function&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn6;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Closure</code> 的其它类型也可以使用：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;*&#125;</span> </span>- can be &#x27;any&#x27; type */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> star;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;?&#125;</span> </span>- unknown type (same as &#x27;any&#x27;) */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> question;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-转换\"><a href=\"#2-转换\" class=\"headerlink\" title=\"(2) 转换\"></a>(2) 转换</h4><blockquote>\n<p><code>TypeScript</code> 借鉴了 <code>Closure</code> 里的转换语法。在括号表达式前面使用 <code>@type</code> 标记，可以将一种类型转换成另一种类型</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;number | string&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> numberOrString = <span class=\"built_in\">Math</span>.random() &lt; <span class=\"number\">0.5</span> ? <span class=\"string\">&quot;hello&quot;</span> : <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> typeAssertedNumber = <span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;number&#125;</span> </span>*/</span> numberOrString;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-导入类型\"><a href=\"#3-导入类型\" class=\"headerlink\" title=\"(3) 导入类型\"></a>(3) 导入类型</h4><blockquote>\n<p>可以使用导入类型从其它文件中导入声明。 这个语法是 <code>TypeScript</code> 特有的，与 <code>JSDoc</code> 标准不同：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>p &#123; import(&quot;./a&quot;).Pet &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">walk</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Walking <span class=\"subst\">$&#123;p.name&#125;</span>...`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>导入类型也可以使用在类型别名声明中：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@typedef </span>Pet &#123; import(&quot;./a&quot;).Pet &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;Pet&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myPet;</span><br><span class=\"line\">myPet.name;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>导入类型可以用在从模块中得到一个值的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;typeof import(&quot;./a&quot;).x &#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./a&quot;</span>).x;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-param-和-returns\"><a href=\"#4-param-和-returns\" class=\"headerlink\" title=\"(4) @param  和 @returns \"></a>(4) <a href=\"/param\">@param </a> 和 <a href=\"/returns\">@returns </a></h4><blockquote>\n<p><code>@param</code> 语法 和 <code>@type</code> 相同，但增加了一个参数名。 使用 <code>[]</code> 可以把参数声明为可选的：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Parameters may be declared in a variety of syntactic forms</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span>  <span class=\"variable\">p1</span></span> - A string param.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string=&#125;</span> <span class=\"variable\">p2</span></span> - An optional param (Closure syntax)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>[p3] - Another optional param (JSDoc syntax).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>[p4=&quot;test&quot;] - An optional param with a default value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;string&#125;</span> </span>This is the result</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringsStringStrings</span>(<span class=\"params\">p1, p2, p3, p4</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>函数的返回值类型也是类似的：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;PromiseLike&lt;string&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ps</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns <span class=\"type\">&#123;&#123; a: string, b: number &#125;</span></span>&#125; - May use &#x27;<span class=\"doctag\">@returns</span>&#x27; as well as &#x27;<span class=\"doctag\">@return</span>&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ab</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-typedef-callback-和-param\"><a href=\"#5-typedef-callback-和-param\" class=\"headerlink\" title=\"(5) @typedef, @callback, 和 @param \"></a>(5) @typedef, @callback, 和 <a href=\"/param\">@param </a></h4><blockquote>\n<p><code>@typedef</code> 可以用来声明复杂类型。和 <code>@param</code> 类似的语法。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@typedef <span class=\"type\">&#123;Object&#125;</span> <span class=\"variable\">SpecialType</span></span> - creates a new type named &#x27;SpecialType&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">prop1</span></span> - a string property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">prop2</span></span> - a number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;number=&#125;</span> <span class=\"variable\">prop3</span></span> - an optional number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@prop <span class=\"type\">&#123;number&#125;</span> </span>[prop4] - an optional number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@prop <span class=\"type\">&#123;number&#125;</span> </span>[prop5=42] - an optional number property of SpecialType with default</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;SpecialType&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> specialTypeObject;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以在第一行上使用 <code>object</code> 或 <code>Object</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@typedef <span class=\"type\">&#123;object&#125;</span> <span class=\"variable\">SpecialType1</span></span> - creates a new type named &#x27;SpecialType&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">prop1</span></span> - a string property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">prop2</span></span> - a number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;number=&#125;</span> <span class=\"variable\">prop3</span></span> - an optional number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;SpecialType1&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> specialTypeObject1;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>@param</code> 允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> <span class=\"variable\">options</span></span> - The shape is the same as SpecialType above</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>options.prop1</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>options.prop2</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number=&#125;</span> </span>options.prop3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[options.prop4]</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[options.prop5=42]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">special</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (options.prop4 || <span class=\"number\">1001</span>) + options.prop5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>@callback</code> 与 <code>@typedef</code> 相似，但它指定函数类型而不是对象类型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@callback <span class=\"variable\">Predicate</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">data</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[index]</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns <span class=\"type\">&#123;boolean&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Predicate&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ok = <span class=\"function\"><span class=\"params\">s</span> =&gt;</span> !(s.length % <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然，所有这些类型都可以使用 <code>TypeScript</code> 的语法 <code>@typedef</code> 在一行上声明：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@typedef <span class=\"type\">&#123;&#123; prop1: string, prop2: string, prop3?: number &#125;</span></span>&#125; SpecialType */</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@typedef <span class=\"type\">&#123;(data: string, index?: number) =&gt; boolean&#125;</span> </span>Predicate */</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-template\"><a href=\"#6-template\" class=\"headerlink\" title=\"(6) @template \"></a>(6) <a href=\"/template\">@template </a></h4><blockquote>\n<p>使用 <code>@template</code> 声明泛型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template <span class=\"variable\">T</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;T&#125;</span> <span class=\"variable\">p1</span></span> - A generic parameter that flows through to the return type</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;T&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">id</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>用逗号或多个标记来声明多个类型参数：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template </span>T,U,V</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template </span>W,X</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>还可以在参数名前指定类型约束。只有列表的第一项类型参数会被约束:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">K</span></span> - K must be a string or string literal</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template <span class=\"type\">&#123;&#123; serious(): string &#125;</span></span>&#125; Seriousalizable - must have a serious method</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;K&#125;</span> <span class=\"variable\">key</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Seriousalizable&#125;</span> <span class=\"variable\">object</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">seriousalize</span>(<span class=\"params\">key, <span class=\"built_in\">object</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ????</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-constructor\"><a href=\"#7-constructor\" class=\"headerlink\" title=\"(7) @constructor \"></a>(7) <a href=\"/constructor\">@constructor </a></h4><blockquote>\n<p>编译器通过 <code>this</code> 属性的赋值来推断构造函数, 但你可以让检查更严格提示更友好, 你可以添加一个 <code>@constructor</code> 标记:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@constructor</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">data</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.initialize(data); <span class=\"comment\">// Should error, initializer expects a string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">C.prototype.initialize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size = s.length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> C(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = C(<span class=\"number\">1</span>); <span class=\"comment\">// C should only be called with new</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>通过 <code>@constructor</code>, <code>this</code> 将在构造函数<code>C</code>里被检查，因此你在 <code>initialize</code> 方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用<code>C</code>而不是构造它，也会得到一个错误。</p>\n</blockquote>\n<blockquote>\n<p>不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用 <code>@constructor</code>。</p>\n</blockquote>\n<h4 id=\"8-this\"><a href=\"#8-this\" class=\"headerlink\" title=\"(8) @this \"></a>(8) <a href=\"/this\">@this </a></h4><blockquote>\n<p>编译器通常可以通过上下文来推断出 <code>this</code> 的类型。但你可以使用 <code>@this</code> 来明确指定它的类型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@this <span class=\"type\">&#123;HTMLElement&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> <span class=\"variable\">e</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callbackForLater</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.clientHeight = <span class=\"built_in\">parseInt</span>(e); <span class=\"comment\">// should be fine!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-extends\"><a href=\"#9-extends\" class=\"headerlink\" title=\"(9) @extends \"></a>(9) <a href=\"/extends\">@extends </a></h4><blockquote>\n<p>当 <code>JavaScript</code> 类继承了一个基类, 无处指定类型参数的类型, 而 <code>@extends</code> 标记提供了这样一种方式:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template <span class=\"variable\">T</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@extends <span class=\"type\">&#123;Set&lt;T&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortableSet</span> <span class=\"keyword\">extends</span> <span class=\"title\">Set</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>@extends</code> 只作用于类。当前，无法实现构造函数继承类的情况。</p>\n</blockquote>\n<h4 id=\"10-enum\"><a href=\"#10-enum\" class=\"headerlink\" title=\"(10) @enum \"></a>(10) <a href=\"/enum\">@enum </a></h4><blockquote>\n<p><code>@enum</code> 标记允许你创建一个对象字面量, 它的成员都有确定的类型。不同于 <code>JavaScript</code> 里大多数的对象字面量，它不允许添加额外成员。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@enum <span class=\"type\">&#123;number&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> JSDocState = &#123;</span><br><span class=\"line\">  BeginningOfLine: <span class=\"number\">0</span>,</span><br><span class=\"line\">  SawAsterisk: <span class=\"number\">1</span>,</span><br><span class=\"line\">  SavingComments: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>@enum</code> 与 <code>TypeScript</code> 的 <code>@enum</code> 大不相同, 它更加简单。然而，不同于 <code>TypeScript</code> 的枚举, <code>@enum</code> 可以是任何类型:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@enum <span class=\"type\">&#123;function(number): number&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">Math</span> = &#123;</span><br><span class=\"line\">  add1: <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>,</span><br><span class=\"line\">  id: <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> -n,</span><br><span class=\"line\">  sub1: <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n - <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-更多示例\"><a href=\"#11-更多示例\" class=\"headerlink\" title=\"(11) 更多示例\"></a>(11) 更多示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var someObj &#x3D; &#123;</span><br><span class=\"line\">  &#x2F;**</span><br><span class=\"line\">   * @param &#123;string&#125; param1 - Docs on property assignments work</span><br><span class=\"line\">   *&#x2F;</span><br><span class=\"line\">  x: function (param1) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * As do docs on variable assignments</span><br><span class=\"line\"> * @return &#123;Window&#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">let someFunc &#x3D; function () &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * And class methods</span><br><span class=\"line\"> * @param &#123;string&#125; greeting The greeting to use</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">Foo.prototype.sayHi &#x3D; greeting &#x3D;&gt; console.log(&quot;Hi!&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * And arrow functions expressions</span><br><span class=\"line\"> * @param &#123;number&#125; x - A multiplier</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">let myArrow &#x3D; x &#x3D;&gt; x * x;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Which means it works for stateless function components in JSX too</span><br><span class=\"line\"> * @param &#123;&#123;a: string, b: number&#125;&#125; test - Some param</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">var sfc &#x3D; test &#x3D;&gt; &lt;div&gt;&#123;test.a.charAt(0)&#125;&lt;&#x2F;div&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * A parameter can be a class constructor, using Closure syntax.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param &#123;&#123;new(...args: any[]): object&#125;&#125; C - The class to register</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function registerClass(C) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @param &#123;...string&#125; p1 - A &#39;rest&#39; arg (array) of strings. (treated as &#39;any&#39;)</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function fn10(p1) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @param &#123;...string&#125; p1 - A &#39;rest&#39; arg (array) of strings. (treated as &#39;any&#39;)</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function fn9(p1) &#123;</span><br><span class=\"line\">  return p1.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-已知不支持的模式\"><a href=\"#12-已知不支持的模式\" class=\"headerlink\" title=\"(12) 已知不支持的模式\"></a>(12) 已知不支持的模式</h4><blockquote>\n<p>在值空间中将对象视为类型是不可以的, 除非对象创建了类型, 如构造函数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aNormalFunction</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;aNormalFunction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wrong;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Use &#x27;typeof&#x27; instead:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;typeof aNormalFunction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> right;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对象字面量属性上的 <code>=</code> 后缀不能指定这个属性是可选的:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;&#123; a: string, b: number= &#125;</span></span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wrong;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Use postfix question on the property name instead:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;&#123; a: string, b?: number &#125;</span></span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> right;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Nullable</code> 类型只在启用了 <code>strictNullChecks</code> 检查时才启作用:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;?number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * With strictNullChecks: true -- number | null</span></span><br><span class=\"line\"><span class=\"comment\"> * With strictNullChecks: off  -- number</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nullable;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Non-nullable</code> 类型没有意义, 以其原类型对待:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;!number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * Just has type number</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> normal;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>不同于 <code>JSDoc</code> 类型系统, <code>TypeScript</code> 只允许将类型标记为包不包含 <code>null</code>。<code>Non-nullable</code> – 如果启用了 <code>strictNullChecks</code>，那么 <code>number</code> 是 <code>非null</code> 的。 如果没有启用，那么 <code>number</code> 是可以为 <code>null</code> 的。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、-基础类型\"><a href=\"#一、-基础类型\" class=\"headerlink\" title=\"一、 基础类型\"></a>一、 基础类型</h2><h3 id=\"1-1-类型断言\"><a href=\"#1-1-类型断言\" class=\"headerlink\" title=\"1.1 类型断言\"></a>1.1 类型断言</h3><blockquote>\n<p>有时候你会遇到这样的情况，你会比 <code>TypeScript</code> 更了解某个值的详细信息。通常这会发生在你清楚的知道一个实体具有比它现有类型更确切的类型。类型断言好比其它语言里的类型转换，但是不尽兴特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。</p>\n</blockquote>\n<ul>\n<li><p>类型断言有两种形式</p>\n</li>\n<li><p>第一种：尖括号语法 (当在 <code>TypeScript</code> 里使用 <code>JSX</code> 时，只有 <code>as</code> 语言断言是被允许的)</p>\n</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someValue: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strLength: <span class=\"built_in\">number</span> = (&lt;<span class=\"built_in\">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种：<code>as</code> 语法</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _someValue: <span class=\"built_in\">any</span> = <span class=\"string\">&quot;this is a string&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _strLength: <span class=\"built_in\">number</span> = (_someValue <span class=\"keyword\">as</span> <span class=\"built_in\">string</span>).length;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-基础类型\"><a href=\"#1-2-基础类型\" class=\"headerlink\" title=\"1.2 基础类型\"></a>1.2 基础类型</h3><h4 id=\"1-2-1-布尔值\"><a href=\"#1-2-1-布尔值\" class=\"headerlink\" title=\"1.2.1 布尔值\"></a>1.2.1 布尔值</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isDone: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-2-数字\"><a href=\"#1-2-2-数字\" class=\"headerlink\" title=\"1.2.2 数字\"></a>1.2.2 数字</h4><blockquote>\n<p>与 <code>javascript</code> 一样，<code>TypeScript</code> 里的所有数字都是浮点数。这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量， <code>TypeScript</code> 还支持 <code>ECMA2015</code> 中引入的二进制和八进制字面量。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> decLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> hexLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0xf00d</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> binaryLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0b1010</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> octalLiteral: <span class=\"built_in\">number</span> = <span class=\"number\">0o744</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-3-字符串\"><a href=\"#1-2-3-字符串\" class=\"headerlink\" title=\"1.2.3 字符串\"></a>1.2.3 字符串</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> strName: <span class=\"built_in\">string</span> = <span class=\"string\">&quot;bob&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-4-数组\"><a href=\"#1-2-4-数组\" class=\"headerlink\" title=\"1.2.4 数组\"></a>1.2.4 数组</h4><blockquote>\n<p><code>TypeScript</code> 像 <code>JavaScript</code> 一样可以操作数组元素。有两种方法定义数组。</p>\n</blockquote>\n<ul>\n<li>第一种：可以在元素类型后面接上 <code>[]</code>;</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list1: <span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>第二种：使用数组泛型, <code>Array&lt;元素类型&gt;</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list2: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-5-元组-Tuple\"><a href=\"#1-2-5-元组-Tuple\" class=\"headerlink\" title=\"1.2.5 元组 Tuple\"></a>1.2.5 元组 Tuple</h4><ul>\n<li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x: [<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>];</span><br><span class=\"line\">x = [<span class=\"string\">&quot;hello&quot;</span>, <span class=\"number\">10</span>]; <span class=\"comment\">// =&gt; Ok</span></span><br><span class=\"line\">x = [<span class=\"number\">10</span>, <span class=\"string\">&quot;hello&quot;</span>]; <span class=\"comment\">// =&gt; Error</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当访问一个已知索引的元素，会得到正确的类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">0</span>].substr(<span class=\"number\">1</span>)); <span class=\"comment\">// =&gt; Ok</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">1</span>].substr(<span class=\"number\">1</span>)); <span class=\"comment\">// =&gt; Error</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当访问一个越界的元素，会使用联合类型替代</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x[<span class=\"number\">3</span>] = <span class=\"string\">&quot;world&quot;</span>; <span class=\"comment\">// Ok, 字符串可以赋值给(string | number)类型</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x[<span class=\"number\">5</span>].toString()); <span class=\"comment\">// Ok, &quot;string&quot;和&quot;number&quot;都有toString方法</span></span><br><span class=\"line\">x[<span class=\"number\">6</span>] = <span class=\"literal\">true</span>; <span class=\"comment\">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-6-枚举\"><a href=\"#1-2-6-枚举\" class=\"headerlink\" title=\"1.2.6 枚举\"></a>1.2.6 枚举</h4><ul>\n<li><code>enum</code> 类型是对 <code>JavaScript</code> 标准数据类型的一个补充。像 <code>C#</code> 等其他语言一样，使用枚举类型可以为一组数值赋予友好的名字</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Color = Color.Green;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认情况下，从 <code>0</code> 开始为元素编号。你也可以手动的指定成员的数值。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color1 &#123;</span><br><span class=\"line\">  Red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c1: Color1 = Color1.Green;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>或者全部采用赋值</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color2 &#123;</span><br><span class=\"line\">  Red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  Green = <span class=\"number\">2</span>,</span><br><span class=\"line\">  Blue = <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c2: Color2 = Color2.Green;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color3 &#123;</span><br><span class=\"line\">  Red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  Green,</span><br><span class=\"line\">  Blue</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> colorName: <span class=\"built_in\">string</span> = Color3[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(colorName);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-7-Any\"><a href=\"#1-2-7-Any\" class=\"headerlink\" title=\"1.2.7 Any\"></a>1.2.7 Any</h4><ul>\n<li>有时候，我们想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来自于动态的内容，比如来自用户输入或第三方库。这种情况下，我们不希望类型检查器对这些值进行检查而是让它们通过编译阶段的检查。那么我们可以使用 <code>any</code> 类型来标记这些变量</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure: <span class=\"built_in\">any</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">notSure = <span class=\"string\">&quot;maybe a string instead&quot;</span>;</span><br><span class=\"line\">notSure = <span class=\"literal\">false</span>; <span class=\"comment\">// Ok</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在对现有代码进行改写的时候，<code>any</code> 类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。你可能认为 <code>Object</code> 有相似的作用，就像在其他语言中那样。但是 <code>Object</code> 类型的变量只是允许你给他赋任意值，但是却不能够在它上面调用任意的方法，即使它真有这些方法。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure1: <span class=\"built_in\">any</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\">notSure1.ifItExists(); <span class=\"comment\">// Ok</span></span><br><span class=\"line\">notSure1.toFixed(); <span class=\"comment\">// Ok</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> prettySure: <span class=\"built_in\">Object</span> = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"comment\">// prettySure.toFixed(); // Error, Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当你只知道一部分数据类型时，<code>any</code> 类型也是有用的。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list: <span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>, <span class=\"literal\">true</span>, <span class=\"string\">&quot;free&quot;</span>];</span><br><span class=\"line\">list[<span class=\"number\">1</span>] = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-8-Void\"><a href=\"#1-2-8-Void\" class=\"headerlink\" title=\"1.2.8 Void\"></a>1.2.8 Void</h4><ul>\n<li>某种程度上来说，<code>void</code> 类型像是与 <code>any</code> 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">warnUser</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;This is my warning message&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>声明一个 <code>void</code> 类型的变量没有什么大用，因为你只能为它赋予 <code>undefined</code> 和 <code>null</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> unusbale: <span class=\"built_in\">void</span> = <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-9-Null-和-Undefined\"><a href=\"#1-2-9-Null-和-Undefined\" class=\"headerlink\" title=\"1.2.9 Null 和 Undefined\"></a>1.2.9 Null 和 Undefined</h4><ul>\n<li><code>TypeScript</code> 里，<code>undefined</code> 和 <code>null</code> 两者各有自己的类型分别叫做 <code>undefined</code> 和 <code>null</code>。和 <code>void</code> 相似，它们本身的类型用处不是很大。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> u: <span class=\"literal\">undefined</span> = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> n: <span class=\"literal\">null</span> = <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认情况下 <code>null</code> 和 <code>undefined</code> 是所有类型的子类型。就是说你可以把 <code>null</code> 和 <code>undefined</code> 赋值给 <code>number</code> 类型的变量。</li>\n<li>然而，当你指定了一个 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给 <code>void</code> 和它们各自。这能避免很多常见的问题。也许在某处你想传入一个 <code>string</code> 或 <code>null</code> 或 <code>undefined</code>，你可以使用联合类型 <code>string | null | undefined</code>。</li>\n</ul>\n<h4 id=\"1-2-10-Never\"><a href=\"#1-2-10-Never\" class=\"headerlink\" title=\"1.2.10 Never\"></a>1.2.10 Never</h4><ul>\n<li><code>never</code> 类型表示的是那些永不存在的值的类型。例如：<code>never</code> 类型是那些总会抛出异常或根本不会有返回值的函数表达式或箭头函数表达式的返回值类型；</li>\n<li>变量也可能是 <code>never</code> 类型，当它们被永不为真的类型保护所约束时。</li>\n<li><code>never</code> 类型是任何类型的子类型，也可以赋值给任何类型；</li>\n</ul>\n<blockquote>\n<p>然而，没有类型是 <code>never</code> 的子类型或可以赋值给 <code>never</code> 类型(除了 <code>never</code> 本身之外)。即使 <code>any</code> 也不可以赋值给 <code>never</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 返回 never 的函数必须存在无法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">error</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 推断的返回值类型为never</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fail</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> error(<span class=\"string\">&quot;Something failed&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 返回 never 的函数必须存在法达到的终点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">infiniteLoop</span>(<span class=\"params\"></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-2-11-Object\"><a href=\"#1-2-11-Object\" class=\"headerlink\" title=\"1.2.11 Object\"></a>1.2.11 Object</h4><ul>\n<li><code>Object</code> 表示非原始类型，也就是除 <code>number</code>, <code>string</code>, <code>boolean</code>, <code>symbol</code>, <code>null</code> 或 <code>undefined</code> 之外的类型。</li>\n<li>使用 <code>Object</code> 类型，就可以更好的表示像 <code>Object.create</code> 这样的 <code>API</code>。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>(<span class=\"params\">o: <span class=\"built_in\">object</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\">create(&#123; <span class=\"attr\">prop</span>: <span class=\"number\">0</span> &#125;); <span class=\"comment\">// Ok</span></span><br><span class=\"line\">create(<span class=\"literal\">null</span>); <span class=\"comment\">// Ok</span></span><br><span class=\"line\">create(<span class=\"number\">42</span>); <span class=\"comment\">//Error</span></span><br><span class=\"line\">create(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"literal\">false</span>); <span class=\"comment\">// Error</span></span><br><span class=\"line\">create(<span class=\"literal\">undefined</span>); <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、变量声明\"><a href=\"#二、变量声明\" class=\"headerlink\" title=\"二、变量声明\"></a>二、变量声明</h2><h3 id=\"2-1-介绍\"><a href=\"#2-1-介绍\" class=\"headerlink\" title=\"2.1 介绍\"></a>2.1 介绍</h3><blockquote>\n<p><code>let</code> 和 <code>const</code> 是 <code>JavaScript</code> 里相对较新的变量声明方式。 像我们之前提到过的， <code>let</code> 在很多方面与 <code>var</code> 是相似的，但是可以帮助大家避免在 <code>JavaScript</code> 里常见一些问题。 <code>const</code> 是对 <code>let</code> 的一个增强，它能阻止对一个变量再次赋值。<br>因为 <code>TypeScript</code> 是 <code>JavaScript</code> 的超集，所以它本身就支持 <code>let</code> 和 <code>const</code> 。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 <code>var</code>。<br>如果你之前使用 <code>JavaScript</code> 时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 <code>var</code> 声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p>\n</blockquote>\n<h3 id=\"2-2-var-声明\"><a href=\"#2-2-var-声明\" class=\"headerlink\" title=\"2.2 var 声明\"></a>2.2 var 声明</h3><blockquote>\n<p>一直以来我们都是通过 <code>var</code> 关键字定义 <code>JavaScript</code> 变量。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>大家都能理解，这里定义了一个名为 <code>a</code> 值为 <code>10</code> 的变量。<br>我们也可以在函数内部定义变量：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> message = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>并且我们也可以在其它函数内部访问相同的变量。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\">g(); <span class=\"comment\">// returns 11;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的例子里，<code>g</code> 可以获取到 <code>f</code> 函数里定义的 <code>a</code> 变量。 每当 <code>g</code> 被调用时，它都可以访问到 <code>f</code> 里的 <code>a</code> 变量。 即使当 <code>g</code> 在 <code>f</code> 已经执行完后才被调用，它仍然可以访问及修改 <code>a</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  a = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = g();</span><br><span class=\"line\">  a = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(); <span class=\"comment\">// returns 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-作用域规则\"><a href=\"#2-3-作用域规则\" class=\"headerlink\" title=\"2.3 作用域规则\"></a>2.3 作用域规则</h3><blockquote>\n<p>对于熟悉其它语言的人来说，<code>var</code> 声明有些奇怪的作用域规则。 看下面的例子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">shouldInitialize: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldInitialize) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">true</span>); <span class=\"comment\">// returns &#x27;10&#x27;</span></span><br><span class=\"line\">f(<span class=\"literal\">false</span>); <span class=\"comment\">// returns &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有些读者可能要多看几遍这个例子。 变量 <code>x</code> 是定义在 <code>if</code> 语句里面_，但是我们却可以在语句的外面访问它。 这是因为 <code>var</code> 声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为 <code>var</code> 作用域或函数作用域。函数参数也使用函数作用域。<br>这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里很容易看出一些问题，里层的 <code>for</code> 循环会覆盖变量 <code>i</code>，因为所有 <code>i</code> 都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p>\n</blockquote>\n<h3 id=\"2-4-捕获变量怪异之处\"><a href=\"#2-4-捕获变量怪异之处\" class=\"headerlink\" title=\"2.4 捕获变量怪异之处\"></a>2.4 捕获变量怪异之处</h3><blockquote>\n<p>快速的猜一下下面的代码会返回什么：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>介绍一下，<code>setTimeout</code> 会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。<br>好吧，看一下结果：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>很多 <code>JavaScript</code> 程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>还记得我们上面提到的捕获变量吗？<br>我们传给 <code>setTimeout</code> 的每一个函数表达式实际上都引用了相同作用域里的同一个 <code>i</code>。<br>让我们花点时间思考一下这是为什么。 <code>setTimeout</code> 在若干毫秒后执行一个函数，并且是在 <code>for</code> 循环结束后。 <code>for</code> 循环结束后，<code>i</code> 的值为 <code>10</code>。 所以当函数被调用的时候，它会打印出 <code>10！</code><br>一个通常的解决方法是使用立即执行的函数表达式（<code>IIFE</code>）来捕获每次迭代时 <code>i</code> 的值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// capture the current state of &#x27;i&#x27;</span></span><br><span class=\"line\">  <span class=\"comment\">// by invoking a function with its current value</span></span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">    &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">  &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这种奇怪的形式我们已经司空见惯了。 参数 <code>i</code> 会覆盖 <code>for</code> 循环里的 i，但是因为我们起了同样的名字，所以我们不用怎么改 <code>for</code> 循环体里的代码。</p>\n</blockquote>\n<h3 id=\"2-5-let-声明\"><a href=\"#2-5-let-声明\" class=\"headerlink\" title=\"2.5 let 声明\"></a>2.5 let 声明</h3><blockquote>\n<p>现在你已经知道了 <code>var</code> 存在一些问题，这恰好说明了为什么用 <code>let</code> 语句来声明变量。 除了名字不同外， let 与 <code>var</code> 的写法一致。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>主要的区别不在语法上，而是语义，我们接下来会深入研究。</p>\n</blockquote>\n<h3 id=\"2-6-块作用域\"><a href=\"#2-6-块作用域\" class=\"headerlink\" title=\"2.6 块作用域\"></a>2.6 块作用域</h3><blockquote>\n<p>当用 <code>let</code> 声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 <code>var</code> 声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或 <code>for</code> 循环之外是不能访问的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">input: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (input) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Still okay to reference &#x27;a&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> b = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Error: &#x27;b&#x27; doesn&#x27;t exist here</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里我们定义了<code>2</code>个变量 <code>a</code> 和 <code>b</code> 。 <code>a</code> 的作用域是 <code>f</code> 函数体内，而 <code>b</code> 的作用域是 <code>if</code> 语句块里。<br>在 <code>catch</code> 语句里声明的变量也具有同样的作用域规则。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"string\">&quot;oh no!&quot;</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Oh well.&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: &#x27;e&#x27; doesn&#x27;t exist here</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(e);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 <code>let</code> 语句之前访问它们，幸运的是 <code>TypeScript</code> 可以告诉我们这些信息。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a++; <span class=\"comment\">// illegal to use &#x27;a&#x27; before it&#x27;s declared;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为 <code>ES2015</code>，现代的运行时会抛出一个错误；然而，现今 <code>TypeScript</code> 是不会报错的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// okay to capture &#x27;a&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不能在&#x27;a&#x27;被声明前调用&#x27;foo&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 运行时应该抛出错误</span></span><br><span class=\"line\">foo();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>关于暂时性死区的更多信息，查看这里 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let\">Mozilla Developer Network.</a></p>\n</blockquote>\n<h3 id=\"2-7-重定义及屏蔽\"><a href=\"#2-7-重定义及屏蔽\" class=\"headerlink\" title=\"2.7 重定义及屏蔽\"></a>2.7 重定义及屏蔽</h3><blockquote>\n<p>我们提过使用 <code>var</code> 声明时，它不在乎你声明多少次；你只会得到 <code>1</code> 个。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在上面的例子里，所有 <code>x</code> 的声明实际上都引用一个相同的 <code>x</code>，并且这是完全有效的代码。 这经常会成为<code>bug</code> 的来源。 好的是， <code>let</code> 声明就不会这么宽松了。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">20</span>; <span class=\"comment\">// 错误，不能在1个作用域里多次声明`x</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>并不是要求两个均是块级作用域的声明 <code>TypeScript</code> 才会给出一个错误的警告。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// error: interferes with parameter declaration</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">100</span>; <span class=\"comment\">// error: can&#x27;t have both declarations of &#x27;x&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">condition, x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (condition) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"literal\">false</span>, <span class=\"number\">0</span>); <span class=\"comment\">// returns 0</span></span><br><span class=\"line\">f(<span class=\"literal\">true</span>, <span class=\"number\">0</span>); <span class=\"comment\">// returns 100</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 <code>let</code> 重写之前的 <code>sumMatrix</code> 函数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sumMatrix</span>(<span class=\"params\">matrix: <span class=\"built_in\">number</span>[][]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentRow = matrix[i];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; currentRow.length; i++) &#123;</span><br><span class=\"line\">      sum += currentRow[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个版本的循环能得到正确的结果，因为内层循环的 i 可以屏蔽掉外层循环的 <code>i</code>。<br>通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p>\n</blockquote>\n<h3 id=\"2-8-块级作用域变量的获取\"><a href=\"#2-8-块级作用域变量的获取\" class=\"headerlink\" title=\"2.8 块级作用域变量的获取\"></a>2.8 块级作用域变量的获取</h3><blockquote>\n<p>在我们最初谈及获取用 <code>var</code> 声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">theCityThatAlwaysSleeps</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> getCity;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> city = <span class=\"string\">&quot;Seattle&quot;</span>;</span><br><span class=\"line\">    getCity = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> city;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getCity();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因为我们已经在 <code>city</code> 的环境里获取到了 <code>city</code> ，所以就算 if 语句执行结束后我们仍然可以访问它。<br>回想一下前面 <code>setTimeout</code> 的例子，我们最后需要使用立即执行的函数表达式来获取每次 <code>for</code> 循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在 <code>TypeScript</code> 里这样做了。<br>当 <code>let</code> 声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 <code>setTimeout</code> 例子里我们仅使用 <code>let</code> 声明就可以了。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;, <span class=\"number\">100</span> * i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>会输出与预料一致的结果：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"number\">6</span>;</span><br><span class=\"line\"><span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-9-const-声明\"><a href=\"#2-9-const-声明\" class=\"headerlink\" title=\"2.9 const 声明\"></a>2.9 const 声明</h3><blockquote>\n<p><code>const</code> 声明是声明变量的另一种方式。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它们与 <code>let</code> 声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 <code>let</code> 相同的作用域规则，但是不能对它们重新赋值。<br>这很好理解，它们引用的值是不可变的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numLivesForCat = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;Aurora&quot;</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">kitty = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;Danielle&quot;</span>,</span><br><span class=\"line\">  numLives: numLivesForCat</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// all &quot;okay&quot;</span></span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Rory&quot;</span>;</span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Kitty&quot;</span>;</span><br><span class=\"line\">kitty.name = <span class=\"string\">&quot;Cat&quot;</span>;</span><br><span class=\"line\">kitty.numLives--;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>除非你使用特殊的方法去避免，实际上 <code>const</code> 变量的内部状态是可修改的。 幸运的是，<code>TypeScript</code> 允许你将对象的成员设置成只读的。 接口一章有详细说明。</p>\n</blockquote>\n<h3 id=\"2-10-let-vs-const\"><a href=\"#2-10-let-vs-const\" class=\"headerlink\" title=\"2.10 let vs. const\"></a>2.10 let vs. const</h3><blockquote>\n<p>现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。<br>使用最小特权原则，所有变量除了你计划去修改的都应该使用 <code>const</code>。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 <code>const</code> 也可以让我们更容易的推测数据的流动。<br>跟据你的自己判断，如果合适的话，与团队成员商议一下。<br>这个手册大部分地方都使用了 <code>let</code> 声明。</p>\n</blockquote>\n<h3 id=\"2-11-解构\"><a href=\"#2-11-解构\" class=\"headerlink\" title=\"2.11 解构\"></a>2.11 解构</h3><blockquote>\n<p><code>Another TypeScript</code> 已经可以解析其它 <code>ECMAScript 2015</code> 特性了。 完整列表请参见 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">the article on the Mozilla Developer Network</a>。 本章，我们将给出一个简短的概述。</p>\n</blockquote>\n<h4 id=\"2-11-1-解构数组\"><a href=\"#2-11-1-解构数组\" class=\"headerlink\" title=\"2.11.1 解构数组\"></a>2.11.1 解构数组</h4><blockquote>\n<p>最简单的解构莫过于数组的解构赋值了：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> input = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> [first, second] = input;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(second); <span class=\"comment\">// outputs 2</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这创建了 <code>2</code> 个命名变量 <code>first</code> 和 <code>second</code>。 相当于使用了索引，但更为方便：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">first = input[<span class=\"number\">0</span>];</span><br><span class=\"line\">second = input[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>解构作用于已声明的变量会更好：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// swap variables</span></span><br><span class=\"line\">[first, second] = [second, first];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>作用于函数参数：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">[first, second]: [<span class=\"built_in\">number</span>, <span class=\"built_in\">number</span>]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(first);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(second);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(input);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>你可以在数组里使用 <code>...</code> 语法创建剩余变量：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first, ...rest] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rest); <span class=\"comment\">// outputs [ 2, 3, 4 ]</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然，由于是 <code>JavaScript</code>, 你可以忽略你不关心的尾随元素：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [first] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(first); <span class=\"comment\">// outputs 1</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>或其它元素：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, second, , fourth] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-11-2-对象解构\"><a href=\"#2-11-2-对象解构\" class=\"headerlink\" title=\"2.11.2 对象解构\"></a>2.11.2 对象解构</h4><blockquote>\n<p>你也可以解构对象：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> o = &#123;</span><br><span class=\"line\">  a: <span class=\"string\">&quot;foo&quot;</span>,</span><br><span class=\"line\">  b: <span class=\"number\">12</span>,</span><br><span class=\"line\">  c: <span class=\"string\">&quot;bar&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这通过 <code>o.a and o.b</code> 创建了 <code>a</code> 和 <code>b</code> 。 注意，如果你不需要 <code>c</code> 你可以忽略它。<br>就像数组解构，你可以用没有声明的赋值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123; a, b &#125; = &#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;baz&quot;</span>, <span class=\"attr\">b</span>: <span class=\"number\">101</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，我们需要用括号将它括起来，因为 <code>Javascript</code> 通常会将以 <code>&#123;</code> 起始的语句解析为一个块。<br>你可以在对象里使用 <code>...</code> 语法创建剩余变量：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, ...passthrough &#125; = o;</span><br><span class=\"line\"><span class=\"keyword\">let</span> total = passthrough.b + passthrough.c.length;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-11-3-属性重命名\"><a href=\"#2-11-3-属性重命名\" class=\"headerlink\" title=\"2.11.3 属性重命名\"></a>2.11.3 属性重命名</h4><blockquote>\n<p>你也可以给属性以不同的名字：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; <span class=\"attr\">a</span>: newName1, <span class=\"attr\">b</span>: newName2 &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的语法开始变得混乱。 你可以将 <code>a: newName1</code> 读做 “<code>a</code> 作为 <code>newName1</code>“。 方向是从左到右，好像你写成了以下样子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> newName1 = o.a;</span><br><span class=\"line\"><span class=\"keyword\">let</span> newName2 = o.b;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> &#123; a, b &#125;: &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; b: <span class=\"built_in\">number</span> &#125; = o;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-11-4-默认值\"><a href=\"#2-11-4-默认值\" class=\"headerlink\" title=\"2.11.4 默认值\"></a>2.11.4 默认值</h4><blockquote>\n<p>默认值可以让你在属性为 <code>undefined</code> 时使用缺省值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">keepWholeObject</span>(<span class=\"params\">wholeObject: &#123; a: <span class=\"built_in\">string</span>; b?: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> &#123; a, b = <span class=\"number\">1001</span> &#125; = wholeObject;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>现在，即使 <code>b</code> 为 <code>undefined</code> ， <code>keepWholeObject</code> 函数的变量 <code>wholeObject</code> 的属性 <code>a</code> 和 <code>b</code> 都会有值。</p>\n</blockquote>\n<h4 id=\"2-11-5-函数声明\"><a href=\"#2-11-5-函数声明\" class=\"headerlink\" title=\"2.11.5 函数声明\"></a>2.11.5 函数声明</h4><blockquote>\n<p>解构也能用于函数声明。 看以下简单的情况：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> C = &#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; b?: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b &#125;: C</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a = <span class=\"string\">&quot;&quot;</span>, b = <span class=\"number\">0</span> &#125; = &#123;&#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的代码是一个类型推断的例子，将在本手册后文介绍。<br>其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 <code>C</code> 的定义有一个 <code>b</code> 可选属性：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">&#123; a, b = <span class=\"number\">0</span> &#125; = &#123; a: <span class=\"string\">&quot;&quot;</span> &#125;</span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(&#123; <span class=\"attr\">a</span>: <span class=\"string\">&quot;yes&quot;</span> &#125;); <span class=\"comment\">// ok, default b = 0</span></span><br><span class=\"line\">f(); <span class=\"comment\">// ok, default to &#123;a: &quot;&quot;&#125;, which then defaults b = 0</span></span><br><span class=\"line\">f(&#123;&#125;); <span class=\"comment\">// error, &#x27;a&#x27; is required if you supply an argument</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p>\n</blockquote>\n<h4 id=\"2-11-6-展开\"><a href=\"#2-11-6-展开\" class=\"headerlink\" title=\"2.11.6 展开\"></a>2.11.6 展开</h4><blockquote>\n<p>展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> first = [<span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> second = [<span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> bothPlus = [<span class=\"number\">0</span>, ...first, ...second, <span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这会令 <code>bothPlus</code> 的值为 <code>[0, 1, 2, 3, 4, 5]</code>。 展开操作创建了 <code>first</code> 和 <code>second</code> 的一份浅拷贝。 它们不会被展开操作所改变。<br>你还可以展开对象：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; <span class=\"attr\">food</span>: <span class=\"string\">&quot;spicy&quot;</span>, <span class=\"attr\">price</span>: <span class=\"string\">&quot;$$&quot;</span>, <span class=\"attr\">ambiance</span>: <span class=\"string\">&quot;noisy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; ...defaults, <span class=\"attr\">food</span>: <span class=\"string\">&quot;rich&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>search</code> 的值为 <code>&#123; food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; &#125;</code>。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaults = &#123; <span class=\"attr\">food</span>: <span class=\"string\">&quot;spicy&quot;</span>, <span class=\"attr\">price</span>: <span class=\"string\">&quot;$$&quot;</span>, <span class=\"attr\">ambiance</span>: <span class=\"string\">&quot;noisy&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> search = &#123; <span class=\"attr\">food</span>: <span class=\"string\">&quot;rich&quot;</span>, ...defaults &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>那么，<code>defaults</code> 里的 <code>food</code> 属性会重写 <code>food: &quot;rich&quot;</code>，在这里这并不是我们想要的结果。<br>对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties\">自身的可枚举属性</a>。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  p = <span class=\"number\">12</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">m</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> clone = &#123; ...c &#125;;</span><br><span class=\"line\">clone.p; <span class=\"comment\">// ok</span></span><br><span class=\"line\">clone.m(); <span class=\"comment\">// error!</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其次，<code>TypeScript</code> 编译器不允许展开泛型函数上的类型参数。 这个特性会在 <code>TypeScript</code> 的未来版本中考虑实现。</p>\n</blockquote>\n<h2 id=\"三、接口\"><a href=\"#三、接口\" class=\"headerlink\" title=\"三、接口\"></a>三、接口</h2><h3 id=\"3-1-实现一个简单的接口\"><a href=\"#3-1-实现一个简单的接口\" class=\"headerlink\" title=\"3.1 实现一个简单的接口\"></a>3.1 实现一个简单的接口</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelledValue &#123;</span><br><span class=\"line\">  label: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(labelledObj.label);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123; <span class=\"attr\">size</span>: <span class=\"number\">10</span>, <span class=\"attr\">label</span>: <span class=\"string\">&quot;size 10 Object&quot;</span> &#125;;</span><br><span class=\"line\">printLabel(myObj);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-可选属性\"><a href=\"#3-2-可选属性\" class=\"headerlink\" title=\"3.2 可选属性\"></a>3.2 可选属性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createConfig</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;white&quot;</span>, <span class=\"attr\">area</span>: <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createConfig(&#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;black&quot;</span>, <span class=\"attr\">width</span>: <span class=\"number\">20</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mySquare);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-只读属性\"><a href=\"#3-3-只读属性\" class=\"headerlink\" title=\"3.3 只读属性\"></a>3.3 只读属性</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Point &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p1: Point = &#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">20</span> &#125;;</span><br><span class=\"line\">p1.x = <span class=\"number\">5</span>; <span class=\"comment\">// error! 因为属性是只读的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-额外的属性检查\"><a href=\"#3-4-额外的属性检查\" class=\"headerlink\" title=\"3.4 额外的属性检查\"></a>3.4 额外的属性检查</h3><blockquote>\n<p>问题：将” <em>可选属性</em> “与” <code>option bags</code> “模式相结合而引发</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createConfig</span>(<span class=\"params\">config: SquareConfig</span>): </span>&#123; color: <span class=\"built_in\">string</span>; area: <span class=\"built_in\">number</span> &#125; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> newSquare = &#123; <span class=\"attr\">color</span>: <span class=\"string\">&quot;white&quot;</span>, <span class=\"attr\">area</span>: <span class=\"number\">100</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.color) &#123;</span><br><span class=\"line\">    newSquare.color = config.color;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (config.width) &#123;</span><br><span class=\"line\">    newSquare.area = config.width * config.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newSquare;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>let mySquare = createConfig(&#123; colour: &quot;red&quot;, width: 100 &#125;); //报错</code></p>\n</blockquote>\n<ul>\n<li>解决方案一：采用类型断言</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> mySquare = createConfig(&#123; <span class=\"attr\">width</span>: <span class=\"number\">100</span>, <span class=\"attr\">opacity</span>: <span class=\"number\">0.5</span> &#125; <span class=\"keyword\">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解决方案二：采用添加一个字符串索引签名(最佳方案)</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> _SquareConfig &#123;</span><br><span class=\"line\">  color?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  width?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  [propName: <span class=\"built_in\">string</span>]: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解决方案三：变量赋值</li>\n</ul>\n<h3 id=\"3-5-函数类型\"><a href=\"#3-5-函数类型\" class=\"headerlink\" title=\"3.5 函数类型\"></a>3.5 函数类型</h3><h4 id=\"3-5-1-函数类型\"><a href=\"#3-5-1-函数类型\" class=\"headerlink\" title=\"3.5.1 函数类型\"></a>3.5.1 函数类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc &#123;</span><br><span class=\"line\">  (source: <span class=\"built_in\">string</span>, <span class=\"attr\">subString</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = source.search(subString);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-5-2-函数类型\"><a href=\"#3-5-2-函数类型\" class=\"headerlink\" title=\"3.5.2 函数类型\"></a>3.5.2 函数类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> add: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> add2 = (x: <span class=\"built_in\">number</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">number</span>): <span class=\"function\"><span class=\"params\">number</span> =&gt;</span> x + y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buildNameFun: <span class=\"function\">(<span class=\"params\">fname: <span class=\"built_in\">string</span>, ...rest: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">string</span>&gt;</span>) =&gt;</span> <span class=\"built_in\">string</span> = <span class=\"function\">(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">string</span>&gt;</span>) =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;firstName&#125;</span>, <span class=\"subst\">$&#123;restOfName.join(<span class=\"string\">&quot; &quot;</span>)&#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> fn = (a: <span class=\"built_in\">number</span>, <span class=\"attr\">b</span>: <span class=\"built_in\">number</span>): <span class=\"function\"><span class=\"params\">number</span> =&gt;</span> a + b;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-5-3-函数类型\"><a href=\"#3-5-3-函数类型\" class=\"headerlink\" title=\"3.5.3 函数类型\"></a>3.5.3 函数类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> func &#123;</span><br><span class=\"line\">  (x: <span class=\"built_in\">string</span>, <span class=\"attr\">y</span>: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> func: func = <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span>, y: <span class=\"built_in\">string</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x.search(y) &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-6-可索引类型\"><a href=\"#3-6-可索引类型\" class=\"headerlink\" title=\"3.6 可索引类型\"></a>3.6 可索引类型</h3><ul>\n<li>例如：<code>a[10]</code> 或 <code>ageMap[&quot;daniel&quot;]</code></li>\n<li>可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray &#123;</span><br><span class=\"line\">  [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray: StringArray;</span><br><span class=\"line\">myArray = [<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Fred&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> myStr: <span class=\"built_in\">string</span> = myArray[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myStr);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Ts</code> 支持两种索引签名：字符串 和 数字。可以同时使用两种类型的索引，但数字索引的返回值必须是字符串索引返回值类型的子类型。</p>\n</blockquote>\n<h3 id=\"3-7-类类型\"><a href=\"#3-7-类类型\" class=\"headerlink\" title=\"3.7 类类型\"></a>3.7 类类型</h3><blockquote>\n<p>接口描述了类的公共部分，而不是类的公有和私有两部分。它不会帮你检查类是否具有某些私有成员</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">  setTime(d: <span class=\"built_in\">Date</span>); <span class=\"comment\">// 在接口中描述的方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Clock</span> <span class=\"title\">implements</span> <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">setTime</span>(<span class=\"params\">d: <span class=\"built_in\">Date</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在类中的具体实现</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.currentTime = d;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当操作类的时候，我们需要知道类是具有两个类型的：<em>静态部分的类型</em> 和 _实例的类型_。<br>当用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误。<br>因为当一个类实现了一个接口时，只对其实例部分进行类型检查。<code>constructor</code> 存在于类的静态部分，所以不在检查的范围内。</p>\n</blockquote>\n<ul>\n<li>因此应当直接操作 <em>类的静态部分</em></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> err_ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, <span class=\"attr\">minute</span>: <span class=\"built_in\">number</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">err_Clock</span> <span class=\"title\">implements</span> <span class=\"title\">err_ClockConstructor</span> </span>&#123;</span><br><span class=\"line\">  currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下面是实现对 <em>静态类型</em> 的检查工作</li>\n</ul>\n<blockquote>\n<p>因为 <code>createClock</code> 的第一个参数是 <code>ClockConstructor</code> 类型，在 <code>createClock(AnalogClock, 7, 32)</code> 里，会检查 <code>AnalogClock</code> 是否符合构造函数签名</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockConstructor &#123;</span><br><span class=\"line\">  <span class=\"keyword\">new</span> (hour: <span class=\"built_in\">number</span>, <span class=\"attr\">minute</span>: <span class=\"built_in\">number</span>): ClockInterface;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface &#123;</span><br><span class=\"line\">  tick();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createClock</span>(<span class=\"params\">ctor: ClockConstructor, hour: <span class=\"built_in\">number</span>, minute: <span class=\"built_in\">number</span></span>): <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ctor(hour, minute);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DigitalClock</span> <span class=\"title\">implements</span> <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">tick</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;beep beep&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnalogClock</span> <span class=\"title\">implements</span> <span class=\"title\">ClockInterface</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">tick</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;tick tick&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> digital = createClock(DigitalClock, <span class=\"number\">12</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> analog = createClock(AnalogClock, <span class=\"number\">7</span>, <span class=\"number\">32</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(digital);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(analog);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-8-接口继承\"><a href=\"#3-8-接口继承\" class=\"headerlink\" title=\"3.8 接口继承\"></a>3.8 接口继承</h3><ul>\n<li>和类一样，接口也可以相互继承。可以灵活地将接口分割到可重用的模块里。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一个接口可以继承多个接口，创建出多个接口的合成接口</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape &#123;</span><br><span class=\"line\">  color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke &#123;</span><br><span class=\"line\">  penWidth: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape, PenStroke &#123;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">square.color = <span class=\"string\">&quot;blue&quot;</span>;</span><br><span class=\"line\">square.sideLength = <span class=\"number\">10</span>;</span><br><span class=\"line\">square.penWidth = <span class=\"number\">5.0</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>目的: <code>=&gt;</code> 灵活地将接口分割到可重用的模块中</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lamp &#123;</span><br><span class=\"line\">  lampOn(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  lampOff(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> wx &#123;</span><br><span class=\"line\">  wxNumber: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  showWxNumber(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Photo <span class=\"keyword\">extends</span> Lamp, wx &#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuaWeiPhone</span> <span class=\"title\">implements</span> <span class=\"title\">Photo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wxNumber: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;华为手机&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  lampOn(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  lampOff(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">wxNumber: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.wxNumber = wxNumber;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  showWxNumber(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;我的微信号：123&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> huaWeiPhone = <span class=\"keyword\">new</span> HuaWeiPhone(<span class=\"number\">12345678910</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(huaWeiPhone.showWxNumber());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(huaWeiPhone.photo());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-9-混合类型\"><a href=\"#3-9-混合类型\" class=\"headerlink\" title=\"3.9 混合类型\"></a>3.9 混合类型</h3><blockquote>\n<p>一个对象可以同时做为函数和对象使用，并带有额外的属性</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Counter &#123;</span><br><span class=\"line\">  (start: <span class=\"built_in\">number</span>): <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  interval: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  reset(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getCounter</span>(<span class=\"params\"></span>): <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> counter = &lt;Counter&gt;<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// return start + &#x27;string&#x27;;</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  counter.interval = <span class=\"number\">123</span>;</span><br><span class=\"line\">  counter.reset = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> counter;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = getCounter();</span><br><span class=\"line\">c(<span class=\"number\">10</span>);</span><br><span class=\"line\">c.interval = <span class=\"number\">5.0</span>;</span><br><span class=\"line\">c.reset();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-10-接口继承类\"><a href=\"#3-10-接口继承类\" class=\"headerlink\" title=\"3.10 接口继承类\"></a>3.10 接口继承类</h3><ol>\n<li>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。</li>\n<li>就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。</li>\n<li>接口同样会继承到类的 <code>private</code> 和 <code>protected</code> 成员。</li>\n<li>这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现( <code>implement</code> )。</li>\n<li>当你有一个庞大的继承接口时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。这个子类除了继承至基类外与基类没有任何关系。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Control</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> state: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> SelectableControl <span class=\"keyword\">extends</span> Control &#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">Control</span> <span class=\"title\">implements</span> <span class=\"title\">SelectableControl</span> </span>&#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextBox</span> <span class=\"keyword\">extends</span> <span class=\"title\">Control</span> </span>&#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误：&quot;Image&quot;类型缺少&quot;state&quot;属性</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Image</span> <span class=\"title\">implements</span> <span class=\"title\">SelectableControl</span> </span>&#123;</span><br><span class=\"line\">  select(): <span class=\"built_in\">void</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Location</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在上面的例子中，<code>SelectableControl</code> 包含了 <code>Control</code> 的所有成员。包括私有成员 <code>state</code>。因为 <code>state</code> 是私有成员，所以只能够是 <code>Control</code> 的子类们才能实现 <code>SelectableControl</code> 接口，因为只有 <code>Control</code> 的子类才能够拥有一个声明于 <code>Control</code> 的私有成员 <code>state</code>，这对私有成员的兼容性是必需的。<br>在 <code>Control</code> 类内部，是允许通过 <code>SelectableControl</code> 的实例来访问私有成员 <code>state</code> 的。实际上，<code>SelectableControl</code> 接口和拥有 <code>select</code> 方法的 <code>Control</code> 类是一样的。<code>Button</code> 和 <code>TextBox</code> 类是 <code>SelectableControl</code> 的子类(因为它们都继承自 <code>Control</code> 并有 <code>select</code> 方法，但 <code>Image</code> 和 <code>Location</code> 类并不是这样的。)</p>\n</blockquote>\n<h3 id=\"3-11-接口继承接口\"><a href=\"#3-11-接口继承接口\" class=\"headerlink\" title=\"3.11 接口继承接口\"></a>3.11 接口继承接口</h3><blockquote>\n<p>目的: <code>=&gt;</code> 灵活地将接口分割到可重用的模块中</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lamp &#123;</span><br><span class=\"line\">  lampOn(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  lampOff(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> wx &#123;</span><br><span class=\"line\">  wxNumber: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  showWxNumber(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Photo <span class=\"keyword\">extends</span> Lamp, wx &#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuaWeiPhone</span> <span class=\"title\">implements</span> <span class=\"title\">Photo</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> wxNumber: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;华为手机&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOn</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOff</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">wxNumber: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.wxNumber = wxNumber;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">showWxNumber</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;我的微信号是：123&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> huaWeiPhone = <span class=\"keyword\">new</span> HuaWeiPhone(<span class=\"number\">13100970071</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(huaWeiPhone.showWxNumber());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(huaWeiPhone.photo());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-12-类接口实现\"><a href=\"#3-12-类接口实现\" class=\"headerlink\" title=\"3.12 类接口实现\"></a>3.12 类接口实现</h3><blockquote>\n<p>手机类是一个大类<br>华为是手机类下的一个类<br>华为手机有拍照和闪光灯功能，照相机也有拍照和闪光灯功能<br>因此华为手机和照相机的公共特性就是拍照和闪光灯<br>所以通过关键字 <code>implements</code> 来标识提取出来的接口</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 拍照</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Photo &#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 闪光灯</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Lamp &#123;</span><br><span class=\"line\">  lampOn(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  lampOff(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Phone</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuaWei</span> <span class=\"keyword\">extends</span> <span class=\"title\">Phone</span> <span class=\"title\">implements</span> <span class=\"title\">Photo</span>, <span class=\"title\">Lamp</span> </span>&#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;华为拍照&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOn</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOff</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DigitalCamera</span> <span class=\"title\">implements</span> <span class=\"title\">Photo</span>, <span class=\"title\">Lamp</span> </span>&#123;</span><br><span class=\"line\">  photo(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;照相机拍照&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOn</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">lampOff</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"四、类\"><a href=\"#四、类\" class=\"headerlink\" title=\"四、类\"></a>四、类</h2><h3 id=\"4-1-创建一个基本类\"><a href=\"#4-1-创建一个基本类\" class=\"headerlink\" title=\"4.1 创建一个基本类\"></a>4.1 创建一个基本类</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gretter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> gretting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.gretting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.gretting&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> gretter: Gretter = <span class=\"keyword\">new</span> Gretter(<span class=\"string\">&quot;world!&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gretter);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-继承\"><a href=\"#4-2-继承\" class=\"headerlink\" title=\"4.2 继承\"></a>4.2 继承</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">move</span>(<span class=\"params\">distanceInMeters: <span class=\"built_in\">number</span> = <span class=\"number\">0</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Snake</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">move</span>(<span class=\"params\">distanceInMeters = <span class=\"number\">5</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Slithering...&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.move(distanceInMeters);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Horse</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">move</span>(<span class=\"params\">distanceInMeters = <span class=\"number\">45</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Galloping&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">super</span>.move(distanceInMeters);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> sam = <span class=\"keyword\">new</span> Snake(<span class=\"string\">&quot;Sammy the Python&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> tom: Animal = <span class=\"keyword\">new</span> Horse(<span class=\"string\">&quot;Tommy the Palomino&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">sam.move();</span><br><span class=\"line\">tom.move(<span class=\"number\">34</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-public-关键字\"><a href=\"#4-3-public-关键字\" class=\"headerlink\" title=\"4.3 public 关键字\"></a>4.3 public 关键字</h3><blockquote>\n<p>默认为 <code>public</code><br>在 <code>TypeScript</code> 中,成员都默认为 <code>public</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal_public</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">move</span>(<span class=\"params\">distanceInMeters: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span> moved <span class=\"subst\">$&#123;distanceInMeters&#125;</span>m.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-4-private-关键字\"><a href=\"#4-4-private-关键字\" class=\"headerlink\" title=\"4.4 private 关键字\"></a>4.4 private 关键字</h3><blockquote>\n<p>理解 <code>private</code></p>\n<ol>\n<li>当成员被标记成 <code>private</code> 时，它就不能在声明它的类的外部访问</li>\n<li>如果其中一个类型里包含一个 <code>private</code> 成员，那么只有当另外一个类型中也存在这样一个 <code>private</code> 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal_private</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> cat = <span class=\"keyword\">new</span> Animal_private(<span class=\"string\">&quot;Cat&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// cat.name; // 错误：&#x27;name&#x27;是私有的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal_private_1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rhino</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal_private_1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(<span class=\"string\">&quot;Rhino&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> animal = <span class=\"keyword\">new</span> Animal_private_1(<span class=\"string\">&quot;Goat&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> rhino = <span class=\"keyword\">new</span> Rhino();</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">animal = rhino;</span><br><span class=\"line\"><span class=\"comment\">// animal = employee; //错误：Animal与Employee不兼容</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-5-protected-关键字\"><a href=\"#4-5-protected-关键字\" class=\"headerlink\" title=\"4.5 protected 关键字\"></a>4.5 protected 关键字</h3><ul>\n<li>理解 <code>protected</code></li>\n</ul>\n<blockquote>\n<p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为很相似，但是有一点不同，<code>protected</code> 成员在派生类中仍然可以访问。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.department = department;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">getElevatorPitch</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span> and I work in <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.department&#125;</span>`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> howard = <span class=\"keyword\">new</span> _Employee(<span class=\"string\">&quot;Howard&quot;</span>, <span class=\"string\">&quot;Sales&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(howard.getElevatorPitch());</span><br><span class=\"line\"><span class=\"comment\">// console.log(howard.name); // 错误，因为 name 无法在外部访问，但是可以在派生类中访问</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>构造函数也可以被标记成 <code>protected</code></li>\n</ul>\n<blockquote>\n<p>这意味着这个类不能在包含它的类外被实例化。但是能被继承。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">__Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// __Employee 能够继承 Person</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">__Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">__Person</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> department: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, department: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.department = department;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">getElevatorPitch</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`Hello, my name is <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span> and I work in <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.department&#125;</span>.`</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> __howard = <span class=\"keyword\">new</span> __Employee(<span class=\"string\">&quot;Howard&quot;</span>, <span class=\"string\">&quot;Sales&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// let __join = new __Person(&quot;John&quot;);// 错误：&#x27;Person&#x27;的构造函数是被保护的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-6-readonly-修饰符\"><a href=\"#4-6-readonly-修饰符\" class=\"headerlink\" title=\"4.6 readonly 修饰符\"></a>4.6 readonly 修饰符</h3><ul>\n<li>你可以使用 <code>readonly</code> 关键字将属性设置为只读的。只读属性必须在声明时或构造函数里被初始化</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Octopus</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> numberOfLegs: <span class=\"built_in\">number</span> = <span class=\"number\">8</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">theName: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.name = theName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> dad = <span class=\"keyword\">new</span> Octopus(<span class=\"string\">&quot;Man with the 8 strong legs&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// dad.name = &quot;Man with the 3-piece suit&quot;;// 错误，name是只读的</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数属性</li>\n</ul>\n<blockquote>\n<ol>\n<li>参数属性可以方便地让我们在一个地方定义并初始化一个成员。</li>\n<li>参数属性通过给构造函数参数前面添加一个访问限定符来声明。</li>\n<li>使用 <code>private</code> 限定一个参数属性会声明并初始化一个私有成员；对于 <code>public</code> 和 <code>protected</code> 来说也是一样。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_Octopus</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> numberOfLegs: <span class=\"built_in\">number</span> = <span class=\"number\">9</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">readonly</span> name: <span class=\"built_in\">string</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-7-存取器-get-amp-set\"><a href=\"#4-7-存取器-get-amp-set\" class=\"headerlink\" title=\"4.7 存取器 get &amp; set\"></a>4.7 存取器 get &amp; set</h3><blockquote>\n<p>存取器 支持 <code>es5+</code>，不支持 <code>es3</code></p>\n</blockquote>\n<ol>\n<li><code>TypeScript</code> 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。它能帮助你有效的控制对对象成员的访问。</li>\n<li>没有存取器的例子</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_Employee</span> </span>&#123;</span><br><span class=\"line\">  fullName: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _employee = <span class=\"keyword\">new</span> _Employee();</span><br><span class=\"line\">_employee.fullName = <span class=\"string\">&quot;Bob Smith&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (_employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(_employee.fullName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>拥有存取器的例子</li>\n</ol>\n<blockquote>\n<ol>\n<li>我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。</li>\n<li>只带有 <code>get</code> 不带有 <code>set</code> 的存取器自动被推断为 <code>readonly</code>。</li>\n<li>这在从代码生成 <code>.d.ts</code> 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> passcode = <span class=\"string\">&quot;secret passcode&quot;</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _fullName: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">fullName</span>(): <span class=\"title\">string</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._fullName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">fullName</span>(<span class=\"params\">newName: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (passcode &amp;&amp; passcode === <span class=\"string\">&quot;secret passcode&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>._fullName = newName;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Error: Unauthorized update of employee!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> employee = <span class=\"keyword\">new</span> Employee();</span><br><span class=\"line\">employee.fullName = <span class=\"string\">&quot;Bob smith&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (employee.fullName) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(employee.fullName);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-8-静态属性\"><a href=\"#4-8-静态属性\" class=\"headerlink\" title=\"4.8 静态属性\"></a>4.8 静态属性</h3><blockquote>\n<p>我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> origin = &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">calculateDistanceFromOrigin</span>(<span class=\"params\">point: &#123; x: <span class=\"built_in\">number</span>; y: <span class=\"built_in\">number</span> &#125;</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> xDist = point.x - Gird.origin.x;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> yDist = point.y - Gird.origin.y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class=\"built_in\">this</span>.scale;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> scale: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Gird.origin.x);</span><br><span class=\"line\"><span class=\"keyword\">let</span> grid1 = <span class=\"keyword\">new</span> Gird(<span class=\"number\">1.0</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> gird2 = <span class=\"keyword\">new</span> Gird(<span class=\"number\">5.0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(grid1.calculateDistanceFromOrigin(&#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">10</span> &#125;));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gird2.calculateDistanceFromOrigin(&#123; <span class=\"attr\">x</span>: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">10</span> &#125;));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-9-抽象类\"><a href=\"#4-9-抽象类\" class=\"headerlink\" title=\"4.9 抽象类\"></a>4.9 抽象类</h3><ol>\n<li>抽象类作为其他派生类的基类使用，它们一般不会直接被实例化。</li>\n<li>不同于接口，抽象类可以包含成员的实现细节</li>\n<li><code>abstract</code> 关键字是用于定义抽象类和在抽象类内部定义抽象方法</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> makeSound(): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  move(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;roaming the earth ...&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。</li>\n<li>抽象方法的语法于接口方法相似，二者都是定义方法签名但不包含方法体。然而抽象方法必须包含 <code>abstract</code> 关键字并且可以包含访问修饰符</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> name: <span class=\"built_in\">string</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">  printName(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`Department name: <span class=\"subst\">$&#123;<span class=\"built_in\">this</span>.name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">abstract</span> printMeeting(): <span class=\"built_in\">void</span>; <span class=\"comment\">// 必须在派生类中实现</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountingDepartment</span> <span class=\"keyword\">extends</span> <span class=\"title\">Department</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(<span class=\"string\">&quot;Accounting and Auditing&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  printMeeting(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The Accounting Department meets each Monday at 10am.&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  generateReports(): <span class=\"built_in\">void</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Generating accounting reports...&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> department: Department; <span class=\"comment\">// 允许创建一个对抽象类的引用</span></span><br><span class=\"line\"><span class=\"comment\">// department = new Departmemnt(); // 错误，不能创建一个抽象类的实例</span></span><br><span class=\"line\">department = <span class=\"keyword\">new</span> AccountingDepartment(); <span class=\"comment\">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class=\"line\">department.printName();</span><br><span class=\"line\">department.printMeeting();</span><br><span class=\"line\"><span class=\"comment\">// department.generateReports(); // 错误，方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-10-高级技巧-构造函数\"><a href=\"#4-10-高级技巧-构造函数\" class=\"headerlink\" title=\"4.10 高级技巧(构造函数)\"></a>4.10 高级技巧(构造函数)</h3><blockquote>\n<p>当在 <code>TypeScript</code> 里声明了一个类的时候，实际上声明了很多东西。首先就是类的实例类型</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello,&quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> greeter: Greeter; <span class=\"comment\">// =&gt;意思：Greeter类的实例的类型是Greeter</span></span><br><span class=\"line\">greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greeter.greet());</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以认为类具有 <em>实例部分</em> 与 <em>静态部分</em></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_Greeter</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> standardGreeting = <span class=\"string\">&quot;Hello, there&quot;</span>;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.greeting) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello,&quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _Greeter.standardGreeting;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _greeter: _Greeter;</span><br><span class=\"line\">_greeter = <span class=\"keyword\">new</span> _Greeter();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_greeter.greet());</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此处创建了一个 <code>greeterMaker</code> 的变量，这个变量保存了这个 <em>类</em> 或者说保存了 _类构造函数_。然后使用 <code>typeof _Greeter</code>，意思是取 <code>Greeter</code> 类的类型，而不是实例的类型。或者更确切的说，”告诉我 <code>Greeter</code> 标识符的类型”，也就是构造函数的类型。这个类型包含了类的所有静态成员和构造函数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _greeterMaker: <span class=\"keyword\">typeof</span> _Greeter = _Greeter;</span><br><span class=\"line\">_greeterMaker.standardGreeting = <span class=\"string\">&quot;Hey there!&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _greeter2: _Greeter = <span class=\"keyword\">new</span> _greeterMaker();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_greeter2.greet());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-11-高级技巧-把类当作接口使用\"><a href=\"#4-11-高级技巧-把类当作接口使用\" class=\"headerlink\" title=\"4.11 高级技巧(把类当作接口使用)\"></a>4.11 高级技巧(把类当作接口使用)</h3><blockquote>\n<p>类定义会创建两个东西：<em>类的实例类型</em> 和 _一个构造函数_。<br>因为类可以创建出类型，所以能够在允许使用接口的地方使用类</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Point3d <span class=\"keyword\">extends</span> Point &#123;</span><br><span class=\"line\">  z: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> point3d: Point3d = &#123; <span class=\"attr\">x</span>: <span class=\"number\">1</span>, <span class=\"attr\">y</span>: <span class=\"number\">2</span>, <span class=\"attr\">z</span>: <span class=\"number\">4</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"五、函数\"><a href=\"#五、函数\" class=\"headerlink\" title=\"五、函数\"></a>五、函数</h2><h3 id=\"5-1-介绍\"><a href=\"#5-1-介绍\" class=\"headerlink\" title=\"5.1 介绍\"></a>5.1 介绍</h3><blockquote>\n<p>函数是 <code>JavaScript</code> 应用程序的基础。它帮助你实现抽象层，模拟层，信息隐藏和模块。在 <code>TypeScript</code> 里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。<code>TypeScript</code> 为 <code>JavaScript</code> 函数添加了额外的功能，让我们可以更容易的使用。</p>\n</blockquote>\n<h3 id=\"5-2-函数类型\"><a href=\"#5-2-函数类型\" class=\"headerlink\" title=\"5.2 函数类型\"></a>5.2 函数类型</h3><h4 id=\"5-2-1-为函数定义类型\"><a href=\"#5-2-1-为函数定义类型\" class=\"headerlink\" title=\"5.2.1 为函数定义类型\"></a>5.2.1 为函数定义类型</h4><blockquote>\n<p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。</p>\n</blockquote>\n<blockquote>\n<p><code>TypeScript</code> 能够根据返回语句自动推断出返回值类型，因此我们通常省略它。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-2-书写完整的函数类型\"><a href=\"#5-2-2-书写完整的函数类型\" class=\"headerlink\" title=\"5.2.2 书写完整的函数类型\"></a>5.2.2 书写完整的函数类型</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd1: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>函数类型分为两个部分：<em>参数类型</em> 和 _返回值类型_。当写出完整函数类型的时候，这两部分都是需要的。我们以参数列表的形式写出参数类型，为每一个参数指定一个名字和类型。这个名字只是为了增加可读性。</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</li>\n<li>第二部分是返回值类型。对于返回值，我们在函数和返回值类型之间使用 <code>=&gt;</code> 符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 <code>void</code>,而不能留空。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>函数的类型只是由参数类型和返回值组成的。函数中使用的捕获变量不会体现在类型里。实际上，这些变量是函数的隐藏状态并不是组成 <code>API</code> 的一部分。</p>\n</blockquote>\n<ul>\n<li>我们也可以这么写：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAdd2: <span class=\"function\">(<span class=\"params\">baseValue: <span class=\"built_in\">number</span>, increment: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">number</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-2-3-推断类型\"><a href=\"#5-2-3-推断类型\" class=\"headerlink\" title=\"5.2.3 推断类型\"></a>5.2.3 推断类型</h4><blockquote>\n<p>在尝试下面这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型。这叫做：”按上下文归类”，是类型推论的一种。它帮助我们更好地为程序指定类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myAdd has the full function type</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd3 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123; <span class=\"keyword\">return</span> x + y &#125;;</span><br><span class=\"line\"><span class=\"comment\">// The parameters `x` and `y` have the type number</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myAdd4: (baseValue: <span class=\"built_in\">number</span>, <span class=\"attr\">increment</span>: <span class=\"built_in\">number</span>) =<span class=\"built_in\">number</span> = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-3-可选参数和默认参数\"><a href=\"#5-3-可选参数和默认参数\" class=\"headerlink\" title=\"5.3 可选参数和默认参数\"></a>5.3 可选参数和默认参数</h3><blockquote>\n<p><code>TypeScript</code> 里的每个函数参数都是必须的。这不是指不能传递 <code>null</code> 或 <code>undefined</code> 作为参数，而是说编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。</p>\n</blockquote>\n<ol>\n<li>简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// let result1 =  buildName(&quot;Bob&quot;); // error</span></span><br><span class=\"line\"><span class=\"comment\">// let result2 = buildName(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result3 = buildName(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>JavaScript</code>里，每个参数都是可选的，可传可不传。没传参的时候，它的值就是 <code>undefined</code>。在 <code>TypeScript</code> 里我们可以在参数旁边使用 <code>?</code> 实现可选参数的功能。</li>\n<li>注意：可选参数必须跟在必选参数后面，不能放在前面</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName1</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName?: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lastName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> result_1 = buildName1(<span class=\"string\">&quot;Bob&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result_2 = buildName1(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// let result_3 = buildName1(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // error</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>可以设置默认初始化的参数</li>\n<li>在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。也就是说，可选参数与末尾的默认参数共享参数类型。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName2</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastName = <span class=\"string\">&quot;Smith&quot;</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>与普通可选参数参数不同的是，带默认值的参数不需要放在必须参数的后面。如果带默认值的参数出现在必须参数的前面，用户必须明确的传入 <code>undefined</code> 值来获得默认值。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName3</span>(<span class=\"params\">firstName = <span class=\"string\">&quot;Will&quot;</span>, lastName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + lastName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// let result__1 = buildName3(&quot;Bob&quot;); // error</span></span><br><span class=\"line\"><span class=\"comment\">// let result__2 = buildName3(&quot;Bob&quot;, &quot;Jack&quot;, &quot;Sr.&quot;); // error</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result__3 = buildName3(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result__4 = buildName3(<span class=\"literal\">undefined</span>, <span class=\"string\">&quot;Jack&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-4-剩余参数\"><a href=\"#5-4-剩余参数\" class=\"headerlink\" title=\"5.4 剩余参数\"></a>5.4 剩余参数</h3><blockquote>\n<p>必要参数，默认参数 和 可选参数 有个共同点：它们表示某一个参数。有时，你想同时操作多个参数，或者你并不知道会有多少参数传进来。在 <code>JavaScript</code> 里，你可以使用 <code>arguments</code> 来访问所有传入的参数。在 <code>TypeScript</code> 里，你可以把所有参数收集到一个变量里</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + restOfName.join(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> employeeName = buildName(<span class=\"string\">&quot;Jose&quot;</span>, <span class=\"string\">&quot;Smith&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>剩余参数会被当作个数不限的可选参数。可以一个都没有，也可以有任意个。编译器创建参数数组，名字是你在省略号后面给定的名字，你可以在函数体内使用这个数组。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName1</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, ...restOfName: <span class=\"built_in\">string</span>[]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> firstName + <span class=\"string\">&quot; &quot;</span> + restOfName.join(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> buildNameFun: <span class=\"function\">(<span class=\"params\">fName: <span class=\"built_in\">string</span>, ...rest: <span class=\"built_in\">string</span>[]</span>) =&gt;</span> <span class=\"built_in\">string</span> = buildName1;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>this</code> 参数。在使用了 <code>--noImplicitThis</code> 标记之后，<code>this</code> 类型可能会是 <code>any</code>。此时需要提供一个显示的 <code>this</code> 参数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Card &#123;</span><br><span class=\"line\">  suit: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  card: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Deck &#123;</span><br><span class=\"line\">  suits: <span class=\"built_in\">string</span>[];</span><br><span class=\"line\">  cards: <span class=\"built_in\">number</span>[];</span><br><span class=\"line\"></span><br><span class=\"line\">  createCardPicker(<span class=\"built_in\">this</span>: Deck): <span class=\"function\">() =&gt;</span> Card;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> deck: Deck = &#123;</span><br><span class=\"line\">  suits: [<span class=\"string\">&quot;hearts&quot;</span>, <span class=\"string\">&quot;spades&quot;</span>, <span class=\"string\">&quot;clubs&quot;</span>, <span class=\"string\">&quot;diamonds&quot;</span>],</span><br><span class=\"line\">  cards: <span class=\"built_in\">Array</span>(<span class=\"number\">52</span>),</span><br><span class=\"line\">  createCardPicker(): <span class=\"function\">(<span class=\"params\"><span class=\"built_in\">this</span>: Deck</span>) =&gt;</span> Card &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedCard = <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">52</span>);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> pickedSuit = <span class=\"built_in\">Math</span>.floor(pickedCard / <span class=\"number\">13</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123; <span class=\"attr\">suit</span>: <span class=\"built_in\">this</span>.suits[pickedSuit], <span class=\"attr\">card</span>: pickedCard % <span class=\"number\">13</span> &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> cardPicker = deck.createCardPicker();</span><br><span class=\"line\"><span class=\"keyword\">let</span> pickedCard = cardPicker();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`card: <span class=\"subst\">$&#123;pickedCard.card&#125;</span> of <span class=\"subst\">$&#123;pickedCard.suit&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"六、泛型\"><a href=\"#六、泛型\" class=\"headerlink\" title=\"六、泛型\"></a>六、泛型</h2><h3 id=\"6-1-介绍\"><a href=\"#6-1-介绍\" class=\"headerlink\" title=\"6.1 介绍\"></a>6.1 介绍</h3><blockquote>\n<p>在软件工程中，我们不仅要创建一致的定义良好的 <code>API</code>，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>在像 <code>C#</code> 和 <code>Java</code> 这样的语言中，可以使用 <code>泛型</code> 来创建可重用组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。<br>除了泛型接口，我们还可以创建泛型类。注意，无法创建泛型枚举和泛型命名空间。</p>\n</blockquote>\n<h3 id=\"6-2-泛型之-hello-world\"><a href=\"#6-2-泛型之-hello-world\" class=\"headerlink\" title=\"6.2 泛型之 hello world\"></a>6.2 泛型之 hello world</h3><blockquote>\n<p>创建一个 <code>identity</code> 函数，这个函数会返回任何传入它的值。</p>\n</blockquote>\n<ul>\n<li>如果不使用泛型，函数可能是：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>(<span class=\"params\">arg: <span class=\"built_in\">number</span></span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>也可以使用 <code>any</code> 类型定义函数，但是这样可能会导致传入的类型与返回的类型不相同。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity1</span>(<span class=\"params\">arg: <span class=\"built_in\">any</span></span>): <span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。</p>\n</blockquote>\n<ul>\n<li>这里我们使用了类型变量，它是一种特殊的变量，只能用于表示类型而不是值。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity2</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用方式一：传入所有的参数，包括类型参数</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output = identity2&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用方式二(更普遍)：利用了类型推论-即编译器会根据传入的参数自动地帮助我们确定 <code>T</code> 的类型。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> output2 = identity2(<span class=\"string\">&quot;myString&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-3-使用泛型变量\"><a href=\"#6-3-使用泛型变量\" class=\"headerlink\" title=\"6.3 使用泛型变量\"></a>6.3 使用泛型变量</h3><blockquote>\n<p>使用泛型创建像 <code>identity</code> 这样的函数时，编译器要求你在函数体必须正确的使用这个通用的类型。换句话说，你必须把这些参数当作是任意或所有类型。</p>\n</blockquote>\n<ul>\n<li>如果我们想打印出 <code>arg</code> 的长度，也许会这样做。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length); <span class=\"comment\">// 错误，T 类型也许不会有.length属性</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果我们像操作 <code>T</code> 类型的数组</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T[]</span>): <span class=\"title\">T</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity2</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: <span class=\"built_in\">Array</span>&lt;T&gt;</span>): <span class=\"title\">Array</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-4-泛型类型-泛型接口\"><a href=\"#6-4-泛型类型-泛型接口\" class=\"headerlink\" title=\"6.4 泛型类型(泛型接口)\"></a>6.4 泛型类型(泛型接口)</h3><ol>\n<li>泛型函数的类型和非泛型函数的类型一样，首先列出类型参数，类似于函数声明。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity: &lt;T&gt;<span class=\"function\">(<span class=\"params\">arg: T</span>) =&gt;</span> T = identity;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>我们也可以为类型中的泛型类型参数使用不同的名称，只要在数量上和使用方式上能对应上就可以。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity1</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity1: &lt;U&gt;<span class=\"function\">(<span class=\"params\">arg: U</span>) =&gt;</span> U = identity;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity2</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity2: &#123; &lt;T&gt;(arg: T): T &#125; = identity;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>这引导我们去写第一个泛型接口了。我们把上面例子里的对象字面量拿出来做为一个接口：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> GenericIdentityFn &#123;</span><br><span class=\"line\">  &lt;T&gt;(arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identity3</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myIdentity3: GenericIdentityFn = identity3;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>我们可能想把泛型参数当作整个接口的一个参数。这样我们就能清楚的知道使用的具体是哪个泛型类型(比如：<code>Dictionary&lt;string&gt;</code> 而不只是 <code>Dictionary</code>)。这样接口里的其它成员也能知道这个参数的类型了。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> _GenericIdentityFn&lt;T&gt; &#123;</span><br><span class=\"line\">  (arg: T): T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_identity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _myIdentity: _GenericIdentityFn&lt;<span class=\"built_in\">number</span>&gt; = _identity;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，我们的示例做了少许改动。不再描述泛型函数，而是把非泛型函数签名作为泛型类型的一部分。</p>\n</blockquote>\n<blockquote>\n<p>当我们使用 <code>GenericIdentityFn</code> 的时候，还得传入一个类型参数来指定泛型类型(这里是：<code>number</code>)，从而锁定之后代码里使用的类型。</p>\n</blockquote>\n<blockquote>\n<p>对于描述哪部分类型属于泛型部分来说，理解何时把参数 “放在调用签名里” 和何时 “放在接口上” 是很有帮助的。</p>\n</blockquote>\n<h3 id=\"6-5-泛型类\"><a href=\"#6-5-泛型类\" class=\"headerlink\" title=\"6.5 泛型类\"></a>6.5 泛型类</h3><blockquote>\n<p>泛型类和泛型接口差不多。泛型类使用 <code>&lt;&gt;</code> 括起泛型类型，跟在类名后面。类分为两部分：静态部分 和 实例部分。泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>\n</blockquote>\n<blockquote>\n<p><code>enericNumber</code> 类的使用是非常直观的，并没有什么去限制它只能使用 <code>number</code> 类型。</p>\n</blockquote>\n<ul>\n<li>也可以使用字符串或其它更复杂的类型。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GenericNumber</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  zeroValue: T;</span><br><span class=\"line\">  add: <span class=\"function\">(<span class=\"params\">x: T, y: T</span>) =&gt;</span> T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myGenericNumber = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">number</span>&gt;();</span><br><span class=\"line\">myGenericNumber.zeroValue = <span class=\"number\">0</span>;</span><br><span class=\"line\">myGenericNumber.add = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> stringNumeric = <span class=\"keyword\">new</span> GenericNumber&lt;<span class=\"built_in\">string</span>&gt;();</span><br><span class=\"line\">stringNumeric.zeroValue = <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">stringNumeric.add = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> x + y;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class=\"string\">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-6-泛型约束\"><a href=\"#6-6-泛型约束\" class=\"headerlink\" title=\"6.6 泛型约束\"></a>6.6 泛型约束</h3><blockquote>\n<p>我们应该记得之前的一个例子，我们有时候想要操作某类型的一组值，并且我们知道这组值具有什么样的属性。</p>\n</blockquote>\n<blockquote>\n<p>在 <code>loggingIdentity</code> 例子中，我们想访问 <code>arg</code> 的 <code>length</code> 属性，但是编译器并不能证明每种类型都有 length 属性。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相比与操作 <code>any</code> 所有类型，我们想要限制函数去处理任意带有 <code>.length</code> 属性的所有类型。只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。为此，我们需要列出对于 <code>T</code> 的约束要求。</p>\n</blockquote>\n<blockquote>\n<p>为此，我们需要定义一个接口来描述约束条件。创建一个包含 <code>.length</code> 属性的接口，使用这个接口和 <code>extends</code> 关键字来实现约束。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Lengthwise &#123;</span><br><span class=\"line\">  length: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loggingIdentity</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Lengthwise</span>&gt;(<span class=\"params\">arg: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(arg.length);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>此时这个泛型函数被定义了约束。因此它不再适用于任意类型：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(<span class=\"number\">3</span>); <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们需要传入符合约束类型的值，必须包含的属性。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loggingIdentity(&#123; <span class=\"attr\">length</span>: <span class=\"number\">10</span>, <span class=\"attr\">value</span>: <span class=\"number\">3</span> &#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-7-在泛型约束中使用类型参数\"><a href=\"#6-7-在泛型约束中使用类型参数\" class=\"headerlink\" title=\"6.7 在泛型约束中使用类型参数\"></a>6.7 在泛型约束中使用类型参数</h3><blockquote>\n<p>你可以声明一个类型参数，且它被另一个类型参数所约束。例如，现在我们需想要用属性名从对象里获取这个属性。并且我们想要确保这个属性存在于对象 <code>obj</code> 上，因此我们需要在这两个类型之间使用约束。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T, key: K</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj[key];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span>, <span class=\"attr\">c</span>: <span class=\"number\">3</span>, <span class=\"attr\">d</span>: <span class=\"number\">4</span> &#125;;</span><br><span class=\"line\">getProperty(x, <span class=\"string\">&quot;a&quot;</span>);</span><br><span class=\"line\">getProperty(x, <span class=\"string\">&quot;m&quot;</span>); <span class=\"comment\">// error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-8-在泛型里使用类类型\"><a href=\"#6-8-在泛型里使用类类型\" class=\"headerlink\" title=\"6.8 在泛型里使用类类型\"></a>6.8 在泛型里使用类类型</h3><blockquote>\n<p>在 <code>TypeScript</code> 使用泛型创建工厂函数时，需要引用构造函数的类类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">create</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">c: &#123; <span class=\"keyword\">new</span> (): T &#125;</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> c();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>下面是一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BeeKeeper</span> </span>&#123;</span><br><span class=\"line\">  hasMask: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZooKeeper</span> </span>&#123;</span><br><span class=\"line\">  nameTag: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  numLegs: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  keeper: BeeKeeper;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Lion</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  keeper: ZooKeeper;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createInstance</span>&lt;<span class=\"title\">A</span> <span class=\"title\">extends</span> <span class=\"title\">Animal</span>&gt;(<span class=\"params\">c: <span class=\"keyword\">new</span> () =&gt; A</span>): <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> c();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">createInstance(Lion).keeper.nameTag;</span><br><span class=\"line\">createInstance(Bee).keeper.hasMask;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-9-多个类型变量\"><a href=\"#6-9-多个类型变量\" class=\"headerlink\" title=\"6.9 多个类型变量\"></a>6.9 多个类型变量</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">info</span>&lt;<span class=\"title\">S</span>, <span class=\"title\">N</span>&gt;(<span class=\"params\">name: S, age: N</span>): [<span class=\"title\">S</span>, <span class=\"title\">N</span>] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [name, age];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(info(<span class=\"string\">&quot;pr&quot;</span>, <span class=\"number\">10</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(info&lt;<span class=\"built_in\">string</span>, <span class=\"built_in\">number</span>&gt;(<span class=\"string\">&quot;pr&quot;</span>, <span class=\"number\">18</span>));</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"七、枚举\"><a href=\"#七、枚举\" class=\"headerlink\" title=\"七、枚举\"></a>七、枚举</h2><h3 id=\"7-1-介绍\"><a href=\"#7-1-介绍\" class=\"headerlink\" title=\"7.1 介绍\"></a>7.1 介绍</h3><blockquote>\n<p>使用枚举我们可以定义一些带有名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。<code>TypeScript</code> 支持数字的和基于字符串的枚举。</p>\n</blockquote>\n<h3 id=\"7-2-数字枚举\"><a href=\"#7-2-数字枚举\" class=\"headerlink\" title=\"7.2 数字枚举\"></a>7.2 数字枚举</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Direction &#123;</span><br><span class=\"line\">  Up = <span class=\"number\">1</span>,</span><br><span class=\"line\">  Down,</span><br><span class=\"line\">  Left,</span><br><span class=\"line\">  Right</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如上，我们定义了一个数字枚举，<code>Up</code>使用初始化为 <code>1</code>，其余成员会从 <code>1</code> 开始自动增长。 换句话说，<code>Direction.Up</code> 的值为 <code>1</code>，<code>Down</code> 值为 <code>2</code>，<code>Left</code> 值为 <code>3</code>，<code>Right</code> 值为 <code>4</code>。</p>\n</blockquote>\n<ol>\n<li>我们还可以完全不使用初始化器</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Direction2 &#123;</span><br><span class=\"line\">  Up,</span><br><span class=\"line\">  Down,</span><br><span class=\"line\">  Left,</span><br><span class=\"line\">  Right</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>现在，<code>Up</code> 的值为 <code>0</code>，<code>Down</code> 的值为 <code>1</code> 等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。</p>\n</blockquote>\n<ol start=\"2\">\n<li>使用枚举很简单：通过枚举的属性来访问枚举成员，和枚举的名字来访问枚举类型：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> _Response &#123;</span><br><span class=\"line\">  No = <span class=\"number\">0</span>,</span><br><span class=\"line\">  Yes = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">respond</span>(<span class=\"params\">recipient: <span class=\"built_in\">string</span>, message: _Response</span>): <span class=\"title\">void</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">respond(<span class=\"string\">&quot;Princess Caroline&quot;</span>, _Response.Yes);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>数字枚举可以被混入到计算过的和常量成员（如下所示）。</li>\n</ol>\n<blockquote>\n<p>简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。换句话说，下面的情况是不被允许的：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E &#123;</span><br><span class=\"line\">  A = getSomeValue(),</span><br><span class=\"line\">  B <span class=\"comment\">// error! &#x27;A&#x27; is not constant-initialized, so &#x27;B&#x27; needs an initializer</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-3-字符串枚举\"><a href=\"#7-3-字符串枚举\" class=\"headerlink\" title=\"7.3 字符串枚举\"></a>7.3 字符串枚举</h3><blockquote>\n<p>字符串枚举的概念很简单，但是有细微的运行时的差别。在一个字符串枚举里，每个成员都必须使用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Direction &#123;</span><br><span class=\"line\">  Up = <span class=\"string\">&quot;UP&quot;</span>,</span><br><span class=\"line\">  Down = <span class=\"string\">&quot;DOWN&quot;</span>,</span><br><span class=\"line\">  Left = <span class=\"string\">&quot;LEFT&quot;</span>,</span><br><span class=\"line\">  Right = <span class=\"string\">&quot;RIGHT&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。</p>\n</blockquote>\n<h3 id=\"7-4-异构枚举\"><a href=\"#7-4-异构枚举\" class=\"headerlink\" title=\"7.4 异构枚举\"></a>7.4 异构枚举</h3><blockquote>\n<p>从技术的角度来说，枚举可以混合字符串和数字成员，但是你似乎并不会这么做：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> BooleanLikeHeterogeneousEnum &#123;</span><br><span class=\"line\">  No = <span class=\"number\">0</span>,</span><br><span class=\"line\">  Yes = <span class=\"string\">&quot;YES&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>除非你真的想要利用 <code>JavaScript</code> 运行时的行为，否则我们不建议这样做。</p>\n</blockquote>\n<h3 id=\"7-5-计算的和常量成员\"><a href=\"#7-5-计算的和常量成员\" class=\"headerlink\" title=\"7.5 计算的和常量成员\"></a>7.5 计算的和常量成员</h3><blockquote>\n<p>每个枚举成员都带有一个值，它可以是常量或计算出来的。当满足如下条件时，枚举成员被当作是常量</p>\n</blockquote>\n<ol>\n<li>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 <code>0</code>：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E &#123;</span><br><span class=\"line\">  X</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>它不带有初始化器且它之前的枚举成员是一个数字常量。这种情况下，当前枚举成员的值为它上一个枚举成员的值加 <code>1</code>。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E1 &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">enum</span> E2 &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>枚举成员使用 常量枚举表达式进行初始化。常量枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。</li>\n</ol>\n<blockquote>\n<p>当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p>\n<ol>\n<li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li>\n<li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li>\n<li>带括号的常量枚举表达式</li>\n<li>一元运算符 +，-，～ 其中之一应用在了常量枚举表达式</li>\n<li>常量枚举表达式作为二元运算符 <code>+，-，*，/，%，&lt;&lt;，&gt;&gt;，&gt;&gt;&gt;，&amp;，|，^</code> 的操作对象</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>若常量枚举表达式求值后为 <code>NaN</code> 或 <code>Infinity</code>，则会在编译阶段报错。</p>\n</blockquote>\n<blockquote>\n<p>所有其它情况的枚举成员被当作是需要计算得出的值</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> FileAccess &#123;</span><br><span class=\"line\">  <span class=\"comment\">// constant numbers</span></span><br><span class=\"line\">  None,</span><br><span class=\"line\">  Read = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">1</span>,</span><br><span class=\"line\">  White = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">2</span>,</span><br><span class=\"line\">  ReadWhite = Read | White,</span><br><span class=\"line\">  <span class=\"comment\">// computed number</span></span><br><span class=\"line\">  G = <span class=\"string\">&quot;123&quot;</span>.length</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-6-联合枚举与枚举成员的类型\"><a href=\"#7-6-联合枚举与枚举成员的类型\" class=\"headerlink\" title=\"7.6 联合枚举与枚举成员的类型\"></a>7.6 联合枚举与枚举成员的类型</h3><blockquote>\n<p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员，或者是被初始化为：</p>\n<ol>\n<li>任何字符串字面量(例如：<code>&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>)</li>\n<li>任何数字字面量(例如：<code>1, 100</code>)</li>\n<li>应用了一元 - 符号的数字字面量(例如：<code>-1, -100</code>) 当所有枚举成员都拥有字面量枚举值时，它就有了一种特殊的含义。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>首先，枚举成员成为了类型！例如，我们可以说某些成员只能是枚举成员的值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> ShapeKind &#123;</span><br><span class=\"line\">  Circle,</span><br><span class=\"line\">  Square</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Circle &#123;</span><br><span class=\"line\">  kind: ShapeKind.Circle;</span><br><span class=\"line\">  radius: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  kind: ShapeKind.Square;</span><br><span class=\"line\">  sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c: Circle = &#123;</span><br><span class=\"line\">  kind: ShapeKind.Square, <span class=\"comment\">// error</span></span><br><span class=\"line\">  radius: <span class=\"number\">100</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另一个变化是枚举类型本身变成了每个枚举成员的联合。虽然我们还没有讨论 联合类型 。但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。因此，<code>TypeScript</code> 能够捕获在比较值的时候犯的愚蠢的错误。例如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E &#123;</span><br><span class=\"line\">  Foo,</span><br><span class=\"line\">  Bar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">x: E</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== E.Foo || x !== E.Bar) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// // Error! Operator &#x27;!==&#x27; cannot be applied to types &#x27;E.Foo&#x27; and &#x27;E.Bar&#x27;.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个例子里，我们先检查 <code>x</code> 是否不是 <code>E.Foo</code>。 如果通过了这个检查，然后 <code>||</code> 会发生短路效果，<br><code>if</code> 语句体里的内容会被执行。 然而，这个检查没有通过，那么 x 则只能为 <code>E.Foo</code>，因此没理由再去检查它是否为 <code>E.Bar</code>。</p>\n</blockquote>\n<h3 id=\"7-7-运行时的枚举\"><a href=\"#7-7-运行时的枚举\" class=\"headerlink\" title=\"7.7 运行时的枚举\"></a>7.7 运行时的枚举</h3><ul>\n<li>枚举是在运行时真正存在的对象。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> E &#123;</span><br><span class=\"line\">  X,</span><br><span class=\"line\">  Y,</span><br><span class=\"line\">  Z</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以传递给函数么？</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">obj: &#123; X: <span class=\"built_in\">number</span> &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj.X;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>没问题，因为 <code>&quot;E&quot;</code> 包含一个数值型属性 <code>&quot;X&quot;</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f(E);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-8-编译时的枚举\"><a href=\"#7-8-编译时的枚举\" class=\"headerlink\" title=\"7.8 编译时的枚举\"></a>7.8 编译时的枚举</h3><blockquote>\n<p>尽管一个枚举是在运行时真正存在的对象，但 <code>keyof</code> 关键字的行为与其作用在对象上时有所不同。应该使用 <code>keyof</code> <code>typeof</code> 来获取一个表示枚举里所有字符串 <code>key</code> 的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> LogLevel &#123;</span><br><span class=\"line\">  ERROR,</span><br><span class=\"line\">  WARN,</span><br><span class=\"line\">  INFO,</span><br><span class=\"line\">  DEBUG</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>等同于：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LogLevelStrings = <span class=\"string\">&quot;ERROR&quot;</span> | <span class=\"string\">&quot;WARN&quot;</span> | <span class=\"string\">&quot;INFO&quot;</span> | <span class=\"string\">&quot;DEBUG&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> LogLevelStrings = keyof <span class=\"keyword\">typeof</span> LogLevel;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printImportant</span>(<span class=\"params\">key: LogLevelStrings, message: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> num = LogLevel[key];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (num &lt;= LogLevel.WARN) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Log Level key is: &quot;</span>, key);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Log Level value is: &quot;</span>, num);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Log Level message is &quot;</span>, message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printImportant(<span class=\"string\">&quot;ERROR&quot;</span>, <span class=\"string\">&quot;This is a message&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-9-反向映射\"><a href=\"#7-9-反向映射\" class=\"headerlink\" title=\"7.9 反向映射\"></a>7.9 反向映射</h3><blockquote>\n<p>除了创建一个以属性名作为对象成员的对象外，数字枚举成员还具有了反向映射，从枚举值到枚举名字。</p>\n</blockquote>\n<ul>\n<li>例如在下面的例子中：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> _Enum &#123;</span><br><span class=\"line\">  A</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _a = _Enum.A;</span><br><span class=\"line\"><span class=\"keyword\">let</span> _nameOfA = _Enum[_a]; <span class=\"comment\">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>TypeScript</code> 可能会将这段代码编译为下面的 <code>JavaScript</code>：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Enum;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Enum</span>) </span>&#123;</span><br><span class=\"line\">  Enum[(Enum[<span class=\"string\">&quot;A&quot;</span>] = <span class=\"number\">0</span>)] = <span class=\"string\">&quot;A&quot;</span>;</span><br><span class=\"line\">&#125;)(Enum || (Enum = &#123;&#125;));</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = Enum.A;</span><br><span class=\"line\"><span class=\"keyword\">var</span> nameOfA = Enum[a]; <span class=\"comment\">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（<code>name -&gt; value</code>）和反向映射（<code>value -&gt; name</code>）。</p>\n</blockquote>\n<blockquote>\n<p>引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p>\n</blockquote>\n<blockquote>\n<p>要注意的是不会为字符串枚举成员生成反向映射。</p>\n</blockquote>\n<h3 id=\"7-10-const-枚举\"><a href=\"#7-10-const-枚举\" class=\"headerlink\" title=\"7.10 const 枚举\"></a>7.10 const 枚举</h3><blockquote>\n<p>大多数情况下，枚举是十分有效的方案。然而在某些情况下需求很严格。为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 <code>const</code> 枚举。</p>\n</blockquote>\n<blockquote>\n<p>常量枚举通过在枚举上使用 <code>const</code> 修饰符来定义。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">enum</span> Enum &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B = A * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">enum</span> Directions &#123;</span><br><span class=\"line\">  Up,</span><br><span class=\"line\">  Down,</span><br><span class=\"line\">  Left,</span><br><span class=\"line\">  Right</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class=\"line\"><span class=\"comment\">// 生成后的代码为：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> directions1 = [<span class=\"number\">0</span> <span class=\"comment\">/* Up */</span>, <span class=\"number\">1</span> <span class=\"comment\">/* Down */</span>, <span class=\"number\">2</span> <span class=\"comment\">/* Left */</span>, <span class=\"number\">3</span> <span class=\"comment\">/* Right */</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-11-外部枚举\"><a href=\"#7-11-外部枚举\" class=\"headerlink\" title=\"7.11 外部枚举\"></a>7.11 外部枚举</h3><blockquote>\n<p>外部枚举 用来描述已经存在的枚举类型的形状。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">enum</span> Enum &#123;</span><br><span class=\"line\">  A = <span class=\"number\">1</span>,</span><br><span class=\"line\">  B,</span><br><span class=\"line\">  C = <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>外部枚举 和 非外部枚举 之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常量成员。</p>\n</blockquote>\n<blockquote>\n<p>对于非常量的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p>\n</blockquote>\n<h2 id=\"八、类型别名\"><a href=\"#八、类型别名\" class=\"headerlink\" title=\"八、类型别名\"></a>八、类型别名</h2><h3 id=\"8-1-类型别名\"><a href=\"#8-1-类型别名\" class=\"headerlink\" title=\"8.1 类型别名\"></a>8.1 类型别名</h3><ol>\n<li>创建别名需要使用关键字 <code>type</code></li>\n<li>使用别名通常用在有 联合类型 的场景下</li>\n</ol>\n<blockquote>\n<p>注意：不要混淆了 <code>TypeScript</code> 中的 <code>=&gt;</code>; 和 <code>ES6</code> 中的 <code>=&gt;</code> 在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义。(左边是输入类型，需要用括号扩起来，右边是输出类型)；在 <code>ES6</code> 中，<code>=&gt;</code> 叫做箭头函数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Name = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ShowName = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> NameOrShowName = Name | ShowName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getName = <span class=\"function\">(<span class=\"params\">name: NameOrShowName</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> name === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> name();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> showName = <span class=\"function\">() =&gt;</span> <span class=\"string\">&quot;pr is a boy&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getName(<span class=\"string\">&quot;pr&quot;</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getName(showName()));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-2-字符串字面量类型\"><a href=\"#8-2-字符串字面量类型\" class=\"headerlink\" title=\"8.2 字符串字面量类型\"></a>8.2 字符串字面量类型</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> EventNames = <span class=\"string\">&quot;click&quot;</span> | <span class=\"string\">&quot;scroll&quot;</span> | <span class=\"string\">&quot;mousemove&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handleEvent: <span class=\"function\">(<span class=\"params\">a: Element, b: EventNames</span>) =&gt;</span> <span class=\"built_in\">string</span> = <span class=\"function\">(<span class=\"params\">ele: Element, event: EventNames</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;ele&#125;</span> <span class=\"subst\">$&#123;event&#125;</span>`</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">handleEvent(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;header&quot;</span>), <span class=\"string\">&quot;scroll&quot;</span>);</span><br><span class=\"line\">handleEvent(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;footer&quot;</span>), <span class=\"string\">&quot;click&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"九、类型推论\"><a href=\"#九、类型推论\" class=\"headerlink\" title=\"九、类型推论\"></a>九、类型推论</h2><h3 id=\"9-1-基础\"><a href=\"#9-1-基础\" class=\"headerlink\" title=\"9.1 基础\"></a>9.1 基础</h3><blockquote>\n<p>在 <code>TypeScript</code> 里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>变量 <code>x</code> 的类型被推断为数字。这种推断发生在初始化变量和成员，设置默认参数和决定函数返回值时。</p>\n</blockquote>\n<blockquote>\n<p>大多数情况下，类型推论是直接了当地。</p>\n</blockquote>\n<h3 id=\"9-2-最佳通用类型\"><a href=\"#9-2-最佳通用类型\" class=\"headerlink\" title=\"9.2 最佳通用类型\"></a>9.2 最佳通用类型</h3><blockquote>\n<p>当需要从几个表达式中推断类型的时候，会使用这些表达式的类型来推断出一个最合适的通用类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"literal\">null</span>];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为了推断 <code>x</code> 的类型，我们必须考虑所有元素的类型。这里有两种选择: <code>number</code> 和 <code>null</code>。计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>\n</blockquote>\n<blockquote>\n<p>由于最终的通用类型取自候选类型，有些时候候选类型共享相同的通用类型，但是却没有一个类型能做为所有候选类型的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zoo = [<span class=\"keyword\">new</span> Rhino(), <span class=\"keyword\">new</span> Elephant(), <span class=\"keyword\">new</span> Snake()];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里，我们想让 <code>zoo</code> 被推断为 <code>Animal[]</code> 类型，但是这个数组里没有对象是 <code>Animal</code> 类型的，因此不能推断出这个结果。</p>\n</blockquote>\n<blockquote>\n<p>为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> zoo: Animal[] = [<span class=\"keyword\">new</span> Rhino(), <span class=\"keyword\">new</span> Elephant(), <span class=\"keyword\">new</span> Snake()];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，<code>(Rhino | Elephant | Snake)[]</code>。</p>\n</blockquote>\n<h3 id=\"9-3-上下文归类\"><a href=\"#9-3-上下文归类\" class=\"headerlink\" title=\"9.3 上下文归类\"></a>9.3 上下文归类</h3><ol>\n<li><code>TypeScript</code> 类型推论也可能按照相反的方向进行，这被叫做”上下文归类”。按上下文归类会发生在表达式类型与所处的位置相关时。</li>\n</ol>\n<blockquote>\n<p>在下面这个例子里，<code>TypeScript</code> 类型检查器会使用 <code>Window.onmousedown</code> 函数的类型来推断右边函数表达式的类型。所以它能够推断出 <code>mouseEvent</code> 参数的类型中包含了 <code>button</code> 属性而不包含 <code>kangaroo</code> 属性。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onmousedown = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mouseEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.button); <span class=\"comment\">// &lt;- Ok</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(mouseEvent.kangaroo); <span class=\"comment\">// &lt;- error</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>TypeScript</code> 还能够很好地推断出其它上下文中的类型。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">uiEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(uiEvent.button); <span class=\"comment\">// Error</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的函数被赋给 <code>window.onscroll``，TypeScript</code> 能够知道 <code>uiEvent</code> 是 <code>UIEvent</code>，而不是 <code>MouseEvent。UIEvent</code> 对象不包含 <code>button</code> 属性，因此 <code>TypeScript</code> 会报错。</p>\n</blockquote>\n<ol>\n<li>如果这个函数不是在上下文归类的位置上，那么这个函数的参数类型将隐式的成为 <code>any</code> 类型，而且也不会报错(除非你开启了 <code>--noImplicitAny</code> 选项)</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> handler = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">uiEvent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(uiEvent.button); <span class=\"comment\">// &lt;- Ok</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们也可以明确地为函数参数类型赋值来覆写上下文类型：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">uiEvent: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(uiEvent.button); <span class=\"comment\">// &lt;- Now, no error is given</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但这段代码会打印 <code>undefined</code>，因为 <code>uiEvent</code> 并不包含 <code>button</code> 属性。</p>\n</blockquote>\n<blockquote>\n<p>上下文归类会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员和数组字面量和返回值语句。</p>\n</blockquote>\n<ul>\n<li>上下文类型也会做为最佳通用类型的候选类型。比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createZoo</span>(<span class=\"params\"></span>): <span class=\"title\">Animal</span>[] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"keyword\">new</span> Rhino(), <span class=\"keyword\">new</span> Elephant(), <span class=\"keyword\">new</span> Snake()];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面这个例子里，最佳通用类型有 <code>4</code> 个候选者：<code>Animal, Rhino, Elephant, Snake</code>。当然，<code>Animal</code> 会被作为最佳通用类型。</p>\n</blockquote>\n<h2 id=\"十、类型兼容性\"><a href=\"#十、类型兼容性\" class=\"headerlink\" title=\"十、类型兼容性\"></a>十、类型兼容性</h2><h3 id=\"10-1-介绍\"><a href=\"#10-1-介绍\" class=\"headerlink\" title=\"10.1 介绍\"></a>10.1 介绍</h3><blockquote>\n<p><code>TypeScript</code> 里的兼容性是基于结构子类型的。结构类型是一种只使用其成员来描述类型的方式。它正好与名义( <code>nominal</code> )类型形成对比。(译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。)看下面的例子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Named &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> p: Named;</span><br><span class=\"line\"><span class=\"comment\">// Ok, because of structural typing</span></span><br><span class=\"line\">p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在使用基于名义类型的断言，比如 <code>C#</code> 或 <code>Java</code> 中，这段代码会报错， 因为 <code>Person</code> 类没有明确说明其实现了 <code>Named</code> 接口。<br><code>TypeScript</code> 的结构性子类型是根据 <code>JavaScript</code> 代码的典型写法来设计的。 因为 <code>JavaScript</code> 里广泛地使用匿名对象，例如函数表达式和对象字面量， 所以使用结构类型系统来描述这些类型比使用名义类型系统更好。</p>\n</blockquote>\n<h3 id=\"10-2-关于可靠性的注意事项\"><a href=\"#10-2-关于可靠性的注意事项\" class=\"headerlink\" title=\"10.2 关于可靠性的注意事项\"></a>10.2 关于可靠性的注意事项</h3><blockquote>\n<p><code>TypeScript</code> 的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript 允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p>\n</blockquote>\n<h3 id=\"10-3-开始\"><a href=\"#10-3-开始\" class=\"headerlink\" title=\"10.3 开始\"></a>10.3 开始</h3><ul>\n<li><code>TypeScript</code> 结构化类型系统的基本规则是，如果 <code>x</code> 要兼容 <code>y</code>，那么 <code>y</code> 至少具有与 <code>x</code> 相同的属性。比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Named &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: Named;</span><br><span class=\"line\"><span class=\"comment\">// y&#x27;s inferred type is &#123; name: string; location: string &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> y = &#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">location</span>: <span class=\"string\">&quot;Seattle&quot;</span> &#125;;</span><br><span class=\"line\">x = y;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里要检查 <code>y</code> 是否能赋值给 <code>x</code>，编译器检查 <code>x</code> 中的每个属性，看是否能在 <code>y</code> 中也找到对应属性。</p>\n</blockquote>\n<blockquote>\n<p>在这个例子中，<code>y</code> 必须包含名字是 <code>name</code> 的 <code>string</code> 类型成员。<code>y</code> 满足条件，因此赋值正确。</p>\n</blockquote>\n<ul>\n<li>检查函数参数时使用相同的规则</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">n: Named</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Hello, &quot;</span> + n.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">greet(y); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意，<code>y</code> 有个额外的 <code>location</code> 属性，但这不会引发错误。<br>只有目标类型（这里是 <code>Named</code>）的成员会被一一检查是否兼容。<br>这个比较过程是递归进行的，检查每个成员及子成员。</p>\n</blockquote>\n<h3 id=\"10-4-比较两个函数\"><a href=\"#10-4-比较两个函数\" class=\"headerlink\" title=\"10.4 比较两个函数\"></a>10.4 比较两个函数</h3><ol>\n<li>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。</li>\n</ol>\n<ul>\n<li>下面我们从两个简单的函数入手，它们仅是参数列表略有不同：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"function\">(<span class=\"params\">a: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"function\">(<span class=\"params\">b: <span class=\"built_in\">number</span>, s: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">y = x; <span class=\"comment\">// &lt;- Ok</span></span><br><span class=\"line\"><span class=\"comment\">// x = y; // &lt;- Error</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>要查看 <code>x</code> 是否能赋值给 <code>y</code>，首先看它们的参数列表。 <code>x</code> 的每个参数必须能在 <code>y</code> 里找到对应类型的参数。注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，<code>x</code> 的每个参数在 <code>y</code> 中都能找到对应的参数，所以允许赋值。第二个赋值错误，因为 <code>y</code> 有个必需的第二个参数，但是 <code>x</code> 并没有，所以不允许赋值。<br>你可能会疑惑为什么允许忽略参数，像例子 <code>y = x</code> 中那样。 原因是忽略额外的参数在 <code>JavaScript</code> 里是很常见的。<br>例如，<code>Array.forEach</code> 给回调函数传 <code>3</code> 个参数：数组元素，索引 和 整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> items = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"comment\">// Don&#x27;t force these extra arguments</span></span><br><span class=\"line\">items.forEach(<span class=\"function\">(<span class=\"params\">item, index, array</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(item));</span><br><span class=\"line\"><span class=\"comment\">// Should be Ok</span></span><br><span class=\"line\">items.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">console</span>.log(item));</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x1 = <span class=\"function\">() =&gt;</span> (&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> y1 = <span class=\"function\">() =&gt;</span> (&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"attr\">location</span>: <span class=\"string\">&quot;Seattle&quot;</span> &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">x1 = y1; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">y1 = x1; <span class=\"comment\">// Error, because x() lacks a location property</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</li>\n</ol>\n<h3 id=\"10-5-函数参数双向协变\"><a href=\"#10-5-函数参数双向协变\" class=\"headerlink\" title=\"10.5 函数参数双向协变\"></a>10.5 函数参数双向协变</h3><blockquote>\n<p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。实际上，这极少会发声错误，并且能够实现很多 <code>JavaScript</code> 里的常见模式。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> EventType &#123;</span><br><span class=\"line\">  Mouse,</span><br><span class=\"line\">  Keyboard</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Event &#123;</span><br><span class=\"line\">  timestamp: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> MouseEvent <span class=\"keyword\">extends</span> Event &#123;</span><br><span class=\"line\">  x1: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  y1: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> keyEvent <span class=\"keyword\">extends</span> Event &#123;</span><br><span class=\"line\">  keyCode: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">listenEvent</span>(<span class=\"params\">eventType: EventType, handler: (n: Event) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* …… */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unsound, but useful and common 不完整，但是常用常见</span></span><br><span class=\"line\">listenEvent(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;e.x1&#125;</span>,<span class=\"subst\">$&#123;e.y1&#125;</span>`</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Undesirable alternatives in presence of soundness 完整但是不受欢迎</span></span><br><span class=\"line\">listenEvent(EventType.Mouse, <span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;(&lt;MouseEvent&gt;e).x1&#125;</span>,<span class=\"subst\">$&#123;(&lt;MouseEvent&gt;e).y1&#125;</span>`</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">listenEvent(EventType.Mouse, &lt;<span class=\"function\">(<span class=\"params\">e: Event</span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;(<span class=\"function\">(<span class=\"params\">e: MouseEvent</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;e.x1&#125;</span>,<span class=\"subst\">$&#123;e.y1&#125;</span>`</span>)));</span><br><span class=\"line\"><span class=\"comment\">// Still disallowed (clear error). Type safety enforced for wholly incompatible types</span></span><br><span class=\"line\"><span class=\"comment\">// 仍然不允许（清除错误）。完全不兼容类型所强制规定的类型安全</span></span><br><span class=\"line\"><span class=\"comment\">// listenEvent(EventType.Mouse, (e: number) =&gt; console.log(e));</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-6-可选参数和剩余参数\"><a href=\"#10-6-可选参数和剩余参数\" class=\"headerlink\" title=\"10.6 可选参数和剩余参数\"></a>10.6 可选参数和剩余参数</h3><ol>\n<li>比较函数兼容性的时候，可选参数与必须参数是可互换的。源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。</li>\n<li>当一个函数有剩余参数时，它被当做无限个可选参数。</li>\n<li>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些 undefined 。</li>\n</ol>\n<blockquote>\n<p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数 但对类型系统来说是不确定的参数来调用：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">invokeLater</span>(<span class=\"params\">args: <span class=\"built_in\">any</span>[], callback: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... Invoke callback with &#x27;args&#x27; ... 通过args调用callback */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Unsound - invokeLater &quot;might&quot; provide any number of arguments</span></span><br><span class=\"line\"><span class=\"comment\">// 不健全的是 - 被调用时候可能会提供任意数量的参数</span></span><br><span class=\"line\">invokeLater([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(x + <span class=\"string\">&quot;,&quot;</span> + y));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Confusing (x and y are actually required) and unrecoverable</span></span><br><span class=\"line\"><span class=\"comment\">// 令我们困惑(是否需要 x 和 y) 并且 不可恢复</span></span><br><span class=\"line\">invokeLater([<span class=\"number\">1</span>, <span class=\"number\">2</span>], <span class=\"function\">(<span class=\"params\">x?, y?</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(x + <span class=\"string\">&quot;,&quot;</span> + y));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-7-函数重载\"><a href=\"#10-7-函数重载\" class=\"headerlink\" title=\"10.7 函数重载\"></a>10.7 函数重载</h3><blockquote>\n<p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。这确保了目标函数可以在所有源函数可调用的地方调用。</p>\n</blockquote>\n<h3 id=\"10-8-枚举\"><a href=\"#10-8-枚举\" class=\"headerlink\" title=\"10.8 枚举\"></a>10.8 枚举</h3><blockquote>\n<p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p>\n</blockquote>\n<ul>\n<li>比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Status &#123;</span><br><span class=\"line\">  Ready,</span><br><span class=\"line\">  Waiting</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;</span><br><span class=\"line\">  Red,</span><br><span class=\"line\">  Blue,</span><br><span class=\"line\">  Green</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _status = Status.Ready;</span><br><span class=\"line\"><span class=\"comment\">// _status = Color.Green; // Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-9-类\"><a href=\"#10-9-类\" class=\"headerlink\" title=\"10.9 类\"></a>10.9 类</h3><blockquote>\n<p>类与对象字面量和接口差不多，但是有一点不同：类的静态部分和实例部分的类型。比较两个类类型的对象时，只有实例的成员会被比较。静态成员和构造函数不在比较的范围内。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  feet: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">name: <span class=\"built_in\">string</span>, numFeet: <span class=\"built_in\">number</span>, c: <span class=\"built_in\">boolean</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Size</span> </span>&#123;</span><br><span class=\"line\">  feet: <span class=\"built_in\">number</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">numFeet: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a: Animal;</span><br><span class=\"line\"><span class=\"keyword\">let</span> s: Size;</span><br><span class=\"line\">a = s; <span class=\"comment\">//Ok</span></span><br><span class=\"line\">s = a; <span class=\"comment\">//Ok</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*  */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-10-类的私有和受保护成员\"><a href=\"#10-10-类的私有和受保护成员\" class=\"headerlink\" title=\"10.10 类的私有和受保护成员\"></a>10.10 类的私有和受保护成员</h3><blockquote>\n<p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>\n</blockquote>\n<h3 id=\"10-11-泛型\"><a href=\"#10-11-泛型\" class=\"headerlink\" title=\"10.11 泛型\"></a>10.11 泛型</h3><blockquote>\n<p>因为 <code>TypeScript</code> 是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。</p>\n</blockquote>\n<ul>\n<li>比如</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Empty&lt;T&gt; &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x: Empty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y: Empty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">x = y; <span class=\"comment\">// Ok, because y matches structure of x</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面代码里，<code>x</code> 和 <code>y</code> 是兼容的，因为它们的结构使用类型参数时，并没有什么不同。</p>\n</blockquote>\n<ul>\n<li>把这个例子改变一下，增加一个成员，就能看出是如何工作的了。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class=\"line\">  data: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> x1: NotEmpty&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y1: NotEmpty&lt;<span class=\"built_in\">string</span>&gt;;</span><br><span class=\"line\">x1 = y1; <span class=\"comment\">// Error，because x and y are not compatible</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p>\n</blockquote>\n<blockquote>\n<p>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成 <code>any</code> 比较。然后用结果类型进行比较，就像上面第一个例子。</p>\n</blockquote>\n<ul>\n<li>比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> identity = <span class=\"function\"><span class=\"keyword\">function</span> &lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">x: T</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> reverse = <span class=\"function\"><span class=\"keyword\">function</span> &lt;<span class=\"title\">U</span>&gt;(<span class=\"params\">y: U</span>): <span class=\"title\">U</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">identity = reverse; <span class=\"comment\">// Ok, because (x: any) =&gt; any matches (y: any) =&gt; any</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-12-高级主题\"><a href=\"#10-12-高级主题\" class=\"headerlink\" title=\"10.12 高级主题\"></a>10.12 高级主题</h3><ul>\n<li>子类型和赋值</li>\n</ul>\n<blockquote>\n<p>目前为止，我们使用了”兼容性”，它在语言规范里没有定义，在 <code>TypeScript</code> 里，有两种兼容性：子类型 和 赋值。它们的不同点在于：赋值扩展了子类型兼容性，增加了一些规则，允许和 <code>any</code> 来回赋值，以及 enum 和对应数字值之间的来回赋值。<br>语言里的不同地方分别使用了它们之中的机制。实际上，类型兼容性是由赋值兼容性来控制的，即使在 <code>implements</code> 和 <code>extends</code> 语句也不例外。</p>\n</blockquote>\n<h2 id=\"十一、高级类型\"><a href=\"#十一、高级类型\" class=\"headerlink\" title=\"十一、高级类型\"></a>十一、高级类型</h2><h3 id=\"11-1-交叉类型\"><a href=\"#11-1-交叉类型\" class=\"headerlink\" title=\"11.1 交叉类型\"></a>11.1 交叉类型</h3><blockquote>\n<p>交叉类型 是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。例如，<code>Person &amp; Serializable &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Serializable</code> 和 <code>Loggable</code>。就是说这个类型的对象同时拥有了这三种类型的成员。<br>我们大多数是在混入( <code>mixins</code> )或其它不适合典型面向对象模型的地方看到交叉类型的使用。(在 <code>JavaScript</code> 里发生这种情况的场合很多！)</p>\n</blockquote>\n<h4 id=\"11-1-1-ReadOnly-的实现\"><a href=\"#11-1-1-ReadOnly-的实现\" class=\"headerlink\" title=\"11.1.1 ReadOnly 的实现\"></a>11.1.1 <code>ReadOnly</code> 的实现</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ReadOnly&lt;T&gt; = &#123;</span><br><span class=\"line\">    readOnly [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-1-2-Partial-的实现\"><a href=\"#11-1-2-Partial-的实现\" class=\"headerlink\" title=\"11.1.2 Partial 的实现\"></a>11.1.2 <code>Partial</code> 的实现</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-1-3-Pick-的实现\"><a href=\"#11-1-3-Pick-的实现\" class=\"headerlink\" title=\"11.1.3 Pick 的实现\"></a>11.1.3 <code>Pick</code> 的实现</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> K]: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-1-4-Record-的实现\"><a href=\"#11-1-4-Record-的实现\" class=\"headerlink\" title=\"11.1.4 Record 的实现\"></a>11.1.4 <code>Record</code> 的实现</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Record&lt;K <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span>, T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> K]: T;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>下面是如何创建混入的一个简单的例子(<code>&quot;target&quot;: &quot;es5&quot;</code>):</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extend</span>&lt;<span class=\"title\">First</span>, <span class=\"title\">Second</span>&gt;(<span class=\"params\">first: First, second: Second</span>): <span class=\"title\">First</span> &amp; <span class=\"title\">Second</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result: Partial&lt;First &amp; Second&gt;= &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> prop <span class=\"keyword\">in</span> first) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (first.hasOwnProperty(prop)) &#123;</span><br><span class=\"line\">            (&lt;First&gt;result)[prop] = first[prop];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> prop <span class=\"keyword\">in</span> second) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (second.hasOwnProperty(prop)) &#123;</span><br><span class=\"line\">            (&lt;Second&gt;result)[prop] = second[prop];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">First</span> &amp; <span class=\"attr\">Second</span>&gt;</span>result;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">&gt;</span></span><br><span class=\"line\"><span class=\"xml\">class Person &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    constructor(public name: string) &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">interface Loggable &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    log(name: string): void;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">class ConsoleLogger implements Loggable &#123;</span></span><br><span class=\"line\"><span class=\"xml\">    log(name) &#123;</span></span><br><span class=\"line\"><span class=\"xml\">        console.log(`Hello, I&#x27;m $&#123;name&#125;`)</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br><span class=\"line\"><span class=\"xml\">const jim = extend(new Person(&quot;Jim&quot;), ConsoleLogger.prototype);</span></span><br><span class=\"line\"><span class=\"xml\">let c = jim.log(jim.name);</span></span><br><span class=\"line\"><span class=\"xml\">console.log(c);</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-2-联合类型\"><a href=\"#11-2-联合类型\" class=\"headerlink\" title=\"11.2 联合类型\"></a>11.2 联合类型</h3><blockquote>\n<p>联合类型 和 交叉类型 很有关联，但是使用上却完全不同。偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。例如下面的函数：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Takes a string and adds &quot;padding&quot; to the left.</span></span><br><span class=\"line\"><span class=\"comment\"> * If &#x27;padding&#x27; is a string, then &#x27;padding&#x27; is appended to the left side.</span></span><br><span class=\"line\"><span class=\"comment\"> * If &#x27;padding&#x27; is a number, then that number of spaces is added to the left side.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">any</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">&quot; &quot;</span>) + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, got &#x27;<span class=\"subst\">$&#123;padding&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">padLeft(<span class=\"string\">&quot;Hello World&quot;</span>, <span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>padLeft</code> 存在一个问题，<code>padding</code> 参数的类型指定成了 <code>any</code>。这就是说我们可以传入一个既不是 <code>number</code> 也不是 <code>string</code> 类型的参数，但是 <code>TypeScript</code> 却不会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> indentedString = padLeft(<span class=\"string\">&quot;Hello World&quot;</span>, <span class=\"literal\">true</span>); <span class=\"comment\">// 编译阶段通过，运行时报错。</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;  在传统的面向对象语言里，我们可能会将这两种类型抽象成有层级的类型。这么做显然是非常清晰的，但同时也存在了过度设计。&#96;padLeft&#96; 原始版本的好处之一就是允许我们传入原始类型。这样做的话使用起来既简单又方便。如果我们就是想使用已经存在的函数的话，这种新的方式就不适用了。代替 &#96;any&#96;，我们可以使用 联合类型 作为 &#96;padding&#96; 的参数。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;typescript</span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Takes a string and adds &quot;padding&quot; to the left.</span><br><span class=\"line\"> * If &#39;padding&#39; is a string, then &#39;padding&#39; is appended to the left side.</span><br><span class=\"line\"> * If &#39;padding&#39; is a number, then that number of spaces is added to the left side.</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function padLeft1(value: string, padding: string | number) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; let indentedString1 &#x3D; padLeft1(&quot;Hello world&quot;, true); &#x2F;&#x2F; errors during compilation</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>联合类型 表示一个值可以是几种类型之一。我们使用竖线(<code>|</code>)分隔每个类型，所以 <code>number | string | boolean</code> 表示一个值可能是 <code>number</code>, <code>string</code>, <code>boolean</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly();</span><br><span class=\"line\"></span><br><span class=\"line\">  lagEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim();</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet();</span><br><span class=\"line\">pet.layEggs(); <span class=\"comment\">// &lt;- ok</span></span><br><span class=\"line\"><span class=\"comment\">// pet.swim(); // &lt;- errors</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的联合类型可能有点复杂，但是你很容易就习惯了。如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，<code>Bird</code> 具有一个 <code>fly</code> 成员。我们不能确定一个 <code>Bird | Fish</code> 类型的变量是否有 <code>fly</code> 方法。如果变量在运行时是 <code>Fish</code> 类型，那么调用 <code>pet.fly()</code> 就出错了。</p>\n</blockquote>\n<h3 id=\"11-3-类型守卫与类型区分\"><a href=\"#11-3-类型守卫与类型区分\" class=\"headerlink\" title=\"11.3 类型守卫与类型区分\"></a>11.3 类型守卫与类型区分</h3><blockquote>\n<p>联合类型适用于那些值可以为不同类型的情况。但当我们想确切地了解是否为 <code>Fish</code> 时怎么办？<code>JavaScript</code> 里常用来区分 <code>2</code> 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim();</span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly();</span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSmallPet</span>(<span class=\"params\"></span>): <span class=\"title\">Fish</span> | <span class=\"title\">Bird</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> pet = getSmallPet();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>每一个访问的成员都会报错</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (pet.swim) &#123;</span><br><span class=\"line\">  pet.swim();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pet.fly) &#123;</span><br><span class=\"line\">  pet.fly();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>为了让这段代码工作，我们需要使用类型断言</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class=\"line\">  (&lt;Fish&gt;pet).swim();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((&lt;Bird&gt;pet).fly) &#123;</span><br><span class=\"line\">  (&lt;Bird&gt;pet).fly();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-4-用户自定义的类型守卫\"><a href=\"#11-4-用户自定义的类型守卫\" class=\"headerlink\" title=\"11.4 用户自定义的类型守卫\"></a>11.4 用户自定义的类型守卫</h3><blockquote>\n<p>这里我们注意到不得不多次使用类型断言。假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</p>\n</blockquote>\n<blockquote>\n<p><code>TypeScript</code> 里的类型守卫机制让它成为了现实。类型守卫就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。要想定义一个类型守卫，我们只需要简单地定义一个函数，它的返回值是一个类型谓词：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Fish &#123;</span><br><span class=\"line\">  swim();</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Bird &#123;</span><br><span class=\"line\">  fly();</span><br><span class=\"line\"></span><br><span class=\"line\">  layEggs();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (&lt;Fish&gt;pet).swim !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。<br>每当使用一些变量调用 <code>isFish</code> <code>时，TypeScript</code> 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的<br><code>swim</code> 和 <code>fly</code> 的调用都没有问题了</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (isFish(pet)) &#123;</span><br><span class=\"line\">  pet.swim();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  pet.fly();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>TypeScript</code> 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在 <code>else</code> 分之里，一定不是 <code>Fish</code> 类型，一定是 Bird 类型。</p>\n</blockquote>\n<h3 id=\"11-5-typeof-类型守卫\"><a href=\"#11-5-typeof-类型守卫\" class=\"headerlink\" title=\"11.5 typeof 类型守卫\"></a>11.5 typeof 类型守卫</h3><blockquote>\n<p>现在我们回过头来看看怎么使用联合类型书写 <code>padLeft</code> 代码。 我们可以像下面这样利用类型断言来写：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span>(<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">&quot;number&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isString</span>(<span class=\"params\">x: <span class=\"built_in\">any</span></span>): <span class=\"title\">x</span> <span class=\"title\">is</span> <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> x === <span class=\"string\">&quot;string&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">padLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isNumber(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">&quot; &quot;</span>) + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isString(padding)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, go <span class=\"subst\">$&#123;padding&#125;</span>.`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。幸运的是，现在我们不必将 <code>typeof x === &quot;number&quot;</code> 抽象成一个函数，因为 <code>TypeScript</code> 可以将它识别为一个类型守卫。也就是说，我们可以直接在代码里检查类型了。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">newPadLeft</span>(<span class=\"params\">value: <span class=\"built_in\">string</span>, padding: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;number&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(padding + <span class=\"number\">1</span>).join(<span class=\"string\">&quot; &quot;</span>) + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> padding === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> padding + value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Expected string or number, go <span class=\"subst\">$&#123;padding&#125;</span>.`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这些 <code>typeof</code> 类型守卫只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>, <code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。但是 <code>TypeScript</code> 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型守卫。</p>\n</blockquote>\n<h3 id=\"11-6-instanceof-类型守卫\"><a href=\"#11-6-instanceof-类型守卫\" class=\"headerlink\" title=\"11.6 instanceof 类型守卫\"></a>11.6 instanceof 类型守卫</h3><blockquote>\n<p><code>instanceof</code> 类型守卫是通过构造函数来细化类型的一种方式。比如，我们借鉴一下之前字符串填充的例子：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Padder &#123;</span><br><span class=\"line\">  getPaddingString(): <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpaceRepeatingPadder</span> <span class=\"title\">implements</span> <span class=\"title\">Padder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> numSpaces: <span class=\"built_in\">number</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getPaddingString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>(<span class=\"built_in\">this</span>.numSpaces + <span class=\"number\">1</span>).join(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringPadder</span> <span class=\"title\">implements</span> <span class=\"title\">Padder</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">private</span> value: <span class=\"built_in\">string</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">getPaddingString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRandomPadder</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &lt; <span class=\"number\">0.5</span> ? <span class=\"keyword\">new</span> SpaceRepeatingPadder(<span class=\"number\">4</span>) : <span class=\"keyword\">new</span> StringPadder(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 类型为 SpaceRepeatingPadder | StringPadder</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> padder: Padder = getRandomPadder();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (padder <span class=\"keyword\">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class=\"line\">  padder; <span class=\"comment\">// 类型细化为 &#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (padder <span class=\"keyword\">instanceof</span> StringPadder) &#123;</span><br><span class=\"line\">  padder; <span class=\"comment\">// 类型细化为 &#x27;StringPadder&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>instanceof</code> 的右侧要求是一个构造函数，<code>TypeScript</code> 将细化为:</p>\n</blockquote>\n<ol>\n<li>此构造函数的 <code>prototype</code> 属性的类型，如果它的类型不为 <code>any</code> 的话</li>\n<li>标签签名所返回的类型的联合</li>\n</ol>\n<blockquote>\n<p>以此顺序。</p>\n</blockquote>\n<h3 id=\"11-7-可为-null-的类型\"><a href=\"#11-7-可为-null-的类型\" class=\"headerlink\" title=\"11.7 可为 null 的类型\"></a>11.7 可为 null 的类型</h3><blockquote>\n<p><code>TypeScript</code> 具有两种特殊的类型，<code>null</code> 和 <code>undefined</code> ，它们分别具有值 <code>null</code> 和 <code>undefined</code>。默认情况下，类型检查器会认为 <code>null</code> 和 <code>undefined</code> 可以赋值给任何类型。<code>null</code> 和 <code>undefined</code> 是所有其它类型的一个有效值。这意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。</p>\n</blockquote>\n<blockquote>\n<p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 <code>null</code> 或 <code>undefined</code>。</p>\n</blockquote>\n<ul>\n<li>你可以使用联合类型明确的包含它们：```typescript<br>let s = “foo”;<br>s = null; // –strictNullChecks 模式下 错误， ‘null’ 不能赋值给 ‘string’<br>let sn: string | null = “bar”;<br>sn = null; // Ok<br>sn = undefined; // –strictNullChecks 模式下 error, 因为’undefined’不能赋值给’string | null’</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;  注意：按照 &#96;JavaScript&#96; &#96;的语义，TypeScript&#96; 会把 &#96;null&#96; 和 &#96;undefined&#96; 区别对待。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; &#96;string | null&#96;，&#96;string | undefined&#96; 和 &#96;string | undefined | null&#96; 是不同的类型。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 11.8 可选参数和可选属性</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- 使用了 &#96;--strictNullChecks&#96; ，可选参数会被自动地加上 &#96;| undefined&#96;:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;typescript</span><br><span class=\"line\">function f(x: number, y?: number) &#123;</span><br><span class=\"line\">    return x + (y || 0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(1, 2);</span><br><span class=\"line\">f(1);</span><br><span class=\"line\">f(1, undefined);</span><br><span class=\"line\">f(1, null); &#x2F;&#x2F; error, &#39;null&#39; is not assignable to &#39;number | undefined&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可选属性也会有同样的处理</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  a: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  b?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\">c.a = <span class=\"number\">12</span>;</span><br><span class=\"line\">c.a = <span class=\"literal\">undefined</span>; <span class=\"comment\">// error, &#x27;undefined&#x27; is not assignable to &#x27;number&#x27;</span></span><br><span class=\"line\">c.b = <span class=\"number\">13</span>;</span><br><span class=\"line\">c.b = <span class=\"literal\">undefined</span>; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">c.b = <span class=\"literal\">null</span>; <span class=\"comment\">// error, &#x27;null&#x27; is not assignable to &#x27;number | undefined&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-9-类型守卫和类型断言\"><a href=\"#11-9-类型守卫和类型断言\" class=\"headerlink\" title=\"11.9 类型守卫和类型断言\"></a>11.9 类型守卫和类型断言</h3><blockquote>\n<p>由于可以为 <code>null</code> 的类型是通过联合类型实现，那么你需要使用类型守卫来去除 <code>null</code>。幸运地是这与在 <code>JavaScript</code> 里写的代码一致：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (sn == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;default&quot;</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里很明显地去除了 <code>null</code>, 你也可以使用短路运算符:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">sn: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sn || <span class=\"string\">&quot;default&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果编译器不能够去除 <code>null</code> 或 <code>undefined</code>，你可以使用类型断言手动去除。语法是添加 <code>!</code> 后缀：<code>identifier!</code> 从 <code>identifier</code> 的类型里去除了 <code>null</code> 和 <code>undefined</code>：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">broken</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epihet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name.charAt(<span class=\"number\">0</span>) + <span class=\"string\">&quot;. the&quot;</span> + epihet; <span class=\"comment\">// error, &#x27;name&#x27; is possibly null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">&quot;Bob&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">&quot;great&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fixed</span>(<span class=\"params\">name: <span class=\"built_in\">string</span> | <span class=\"literal\">null</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postfix</span>(<span class=\"params\">epihet: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name!.charAt(<span class=\"number\">0</span>) + <span class=\"string\">&quot;. the&quot;</span> + epihet; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = name || <span class=\"string\">&quot;Bob&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> postfix(<span class=\"string\">&quot;great&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 <code>null</code> (除非是立即调用的函数表达式)。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数作为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 <code>name</code> 的类型。</p>\n</blockquote>\n<h3 id=\"11-10-类型别名\"><a href=\"#11-10-类型别名\" class=\"headerlink\" title=\"11.10 类型别名\"></a>11.10 类型别名</h3><ol>\n<li>类型别名会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于 原始值，联合类型，元组 以及其它任何你需要手写的类型。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Name = <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> NameResolver = <span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> NameOrResolver = Name | NameResolver;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\">n: NameOrResolver</span>): <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> n === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。</li>\n</ol>\n<p>3.给原始类型起别名通常没有什么用，尽管可以作为文档的一种形式使用。</p>\n<ol start=\"4\">\n<li>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Container&lt;T&gt; = &#123; <span class=\"attr\">value</span>: T &#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>我们也可以使用类型别名来在属性里引用自己：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Tree&lt;T&gt; = &#123;</span><br><span class=\"line\">  value: T;</span><br><span class=\"line\">  left: Tree&lt;T&gt;;</span><br><span class=\"line\">  right: Tree&lt;T&gt;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> LinkedList&lt;T&gt; = T &amp; &#123; <span class=\"attr\">next</span>: LinkedList&lt;T&gt; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> people: LinkedList&lt;Person&gt;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = people.name;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = people.next.name;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = people.next.next.name;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = people.next.next.next.name;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>然而，类型别名不能出现在声明右侧的任何地方</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type Yikes = Array&lt;Yikes&gt;; // error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-11-接口-vs-类型别名\"><a href=\"#11-11-接口-vs-类型别名\" class=\"headerlink\" title=\"11.11 接口 vs 类型别名\"></a>11.11 接口 vs 类型别名</h3><blockquote>\n<p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p>\n</blockquote>\n<ol>\n<li>接口创建了一个新的名字，可以在其它任何地方使用。类型别名并不创建新名字 - 比如，错误信息就不会使用别名。</li>\n</ol>\n<blockquote>\n<p>在下面的示例代码里，在编译器中将鼠标悬停在 <code>interfaced</code> 上，显示它返回的是 <code>Interface</code>，但悬停在 <code>aliased</code> 上时，显示的却是对象字面量类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Alias = &#123; <span class=\"attr\">num</span>: <span class=\"built_in\">number</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Interface &#123;</span><br><span class=\"line\">  num: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aliased</span>(<span class=\"params\">arg: Alias</span>): <span class=\"title\">Alias</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">interfaced</span>(<span class=\"params\">arg: Interface</span>): <span class=\"title\">Interface</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>另一个重要区别是类型别名不能被 <code>extends</code> 和 <code>implements</code> (自己也不能 <code>extends</code> 和 <code>implements</code> 其它类型)。因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。</li>\n<li>另一方面，如果你无法通过接口来描述一个类型并且需要使用 联合类型 或 元组类型，这时通常会使用类型别名。</li>\n</ol>\n<h3 id=\"11-12-字符串字面量类型\"><a href=\"#11-12-字符串字面量类型\" class=\"headerlink\" title=\"11.12 字符串字面量类型\"></a>11.12 字符串字面量类型</h3><blockquote>\n<p>字符串字面量类型允许你指定字符串必须的固定值。在实际应用中，字符串字面量类型可以与联合类型，类型守卫和类型别名很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Easing = <span class=\"string\">&quot;ease-in&quot;</span> | <span class=\"string\">&quot;ease-out&quot;</span> | <span class=\"string\">&quot;ease-in-out&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UIElement</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">animate</span>(<span class=\"params\">dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span>, easing: Easing</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (easing === <span class=\"string\">&quot;ease-in&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">&quot;ease-out&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (easing === <span class=\"string\">&quot;ease-in-out&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// error! should not pass null or undefined.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> button = <span class=\"keyword\">new</span> UIElement();</span><br><span class=\"line\">button.animate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"string\">&quot;ease-in&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// button.animate(0, 0,&quot;uneasy&quot;); // error: &quot;uneasy&quot; is not allowed here</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>你只能从三种允许的字符中选择其一来作为参数传递，传入其它值则会产生错误。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Argument of type &#x27;&quot;uneasy&quot;&#x27; is not assignable to parameter of type &#x27;&quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>字符串字面量类型还可以用于区分函数重载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: <span class=\"string\">&quot;img&quot;</span></span>): <span class=\"title\">HTMLImageElement</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createELement</span>(<span class=\"params\">tagName: <span class=\"string\">&quot;input&quot;</span></span>): <span class=\"title\">HTMLInputElement</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// ... more overloads ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tagName: <span class=\"string\">&quot;string&quot;</span></span>): <span class=\"title\">Element</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... code goes here ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-13-数字字面量类型\"><a href=\"#11-13-数字字面量类型\" class=\"headerlink\" title=\"11.13 数字字面量类型\"></a>11.13 数字字面量类型</h3><ul>\n<li><code>TypeScript</code> 还具有数字字面量类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rollDice</span>(<span class=\"params\"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们很少直接这样使用，但它们可以用在缩小范围调试 <code>bug</code> 的时候。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (x !== <span class=\"number\">1</span> || x !== <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ~~~~~~</span></span><br><span class=\"line\">    <span class=\"comment\">// Operator &#x27;!==&#x27; cannot be applied to types &#x27;1&#x27; and &#x27;2&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>换句话说，当 <code>x</code> 与 <code>2</code> 进行比较的时候，它的值必须为 <code>1</code>，这就意味着上面的比较检查是非法的。</p>\n</blockquote>\n<h3 id=\"11-14-枚举成员类型\"><a href=\"#11-14-枚举成员类型\" class=\"headerlink\" title=\"11.14 枚举成员类型\"></a>11.14 枚举成员类型</h3><blockquote>\n<p>如我们在枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。在我们谈及“单例类型”的时候，多数是指 枚举成员类型 和 数字/字符串 字面量类型，尽管大多数用户会互换使用“单例类型”和“字面量类型”。</p>\n</blockquote>\n<h3 id=\"11-15-可辨识联合\"><a href=\"#11-15-可辨识联合\" class=\"headerlink\" title=\"11.15 可辨识联合\"></a>11.15 可辨识联合</h3><blockquote>\n<p>你可以合并 单例类型，联合类型，类型守卫 和 类型别名 来创建一个叫做 可辨识联合 的高级模式，它也称作 标签联合 或 代数数据类型。可辨识联合 在函数式编程里很有用处。一些语言会自动地为你辨识联合；而 <code>TypeScript</code> 则基于已有的 <code>JavaScript</code> 模式，。它具有 <code>3</code> 个要素：</p>\n</blockquote>\n<ol>\n<li>具有普通的单例类型属性 - 可辨识的特征</li>\n<li>一个类型别名包含了那些类型的联合 - 联合。</li>\n<li>此属性上的类型守卫</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  size: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Rectangle &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;rectangle&quot;</span>;</span><br><span class=\"line\">  width: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  height: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Circle &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  radius: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>首先我们声明了将要联合的接口。每个接口都有 <code>kind</code> 属性但有不同的字符串字面量类型。<code>kind</code> 属性称作 可辨识的特征或标签。其它的属性则特定于各个接口。注意，目前各个接口间是没有联系的。</p>\n</blockquote>\n<ul>\n<li>下面我们将它们联合到一起。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Shape = Square | Rectangle | Circle;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在我们使用可辨识联合</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.width * s.height;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> areaSquare = area(&#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;square&quot;</span>, <span class=\"attr\">size</span>: <span class=\"number\">12</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> areaRectangle = area(&#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;rectangle&quot;</span>, <span class=\"attr\">width</span>: <span class=\"number\">14</span>, <span class=\"attr\">height</span>: <span class=\"number\">13</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> areaCircle = area(&#123; <span class=\"attr\">kind</span>: <span class=\"string\">&quot;circle&quot;</span>, <span class=\"attr\">radius</span>: <span class=\"number\">5</span> &#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(areaSquare, areaRectangle, areaCircle);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-16-完整性检查\"><a href=\"#11-16-完整性检查\" class=\"headerlink\" title=\"11.16 完整性检查\"></a>11.16 完整性检查</h3><blockquote>\n<p>当没有涵盖所有 可辨识联合 的变化时，我们想让编译器可以通知我们。比如，如果我们添加了 <code>Triangle</code> 和 <code>Shape</code>，我们同时还需要更新 <code>area</code>：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Square &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;square&quot;</span>;</span><br><span class=\"line\">  size: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Rectangle &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;rectangle&quot;</span>;</span><br><span class=\"line\">  width: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  height: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Circle &#123;</span><br><span class=\"line\">  kind: <span class=\"string\">&quot;circle&quot;</span>;</span><br><span class=\"line\">  radius: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// interface Triangle &#123; kind: &quot;triangle&quot;, bottom: number, height: number &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Shape = Square | Rectangle | Circle;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.width * s.height;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// should error here - we didn&#x27;t handle case &quot;triangle&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>有两种方式可以实现。</li>\n</ul>\n<ol>\n<li>首先是启用 <code>--strictNullChecks</code> 并且指定一个返回值类型:</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area1</span>(<span class=\"params\">s: Shape</span>): <span class=\"title\">number</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.height * s.width;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因为 <code>switch</code> 没有包含所有情况，所以 <code>TypeScript</code> 认为这个函数有时候会返回 <code>undefined</code>。如果你明确地指定了返回值类型为 <code>number</code>，那么你会看到一个错误，因为实际上返回值类型为 <code>number | undefined</code>。然而，这种方法存在些微妙之处且 <code>--strictNullChecks</code> 对旧代码支持不好。</p>\n</blockquote>\n<ol start=\"2\">\n<li>第二种方法使用 <code>never</code> 类型，编译器用它来进行完整性检查</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">assertNever</span>(<span class=\"params\">x: <span class=\"built_in\">never</span></span>): <span class=\"title\">never</span> </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;Unexpected object: &quot;</span> + x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">area2</span>(<span class=\"params\">s: Shape</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">switch</span> (s.kind) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">case</span> <span class=\"string\">&quot;square&quot;</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s.size * s.size;</span><br><span class=\"line\">     <span class=\"keyword\">case</span> <span class=\"string\">&quot;rectangle&quot;</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s.width * s.height;</span><br><span class=\"line\">     <span class=\"keyword\">case</span> <span class=\"string\">&quot;circle&quot;</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.PI * s.radius ** <span class=\"number\">2</span>;</span><br><span class=\"line\">     <span class=\"keyword\">default</span>:</span><br><span class=\"line\">         <span class=\"keyword\">return</span> assertNever(s); <span class=\"comment\">// error here if there are missing cases</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里，<code>assertNever</code> 检查 <code>s</code> 是否为 <code>never</code> 类型 - 即为除去所有可能情况后剩下的类型。如果你忘记了某个 <code>case</code>，那么 <code>s</code> 将具有一个真实的类型并且你会得到一个错误。这种方式需要你定义一个额外的函数，但是在你忘记某个 <code>case</code> 的时候也更加明显。</p>\n</blockquote>\n<h3 id=\"11-17-多态的-this-类型\"><a href=\"#11-17-多态的-this-类型\" class=\"headerlink\" title=\"11.17 多态的 this 类型\"></a>11.17 多态的 this 类型</h3><blockquote>\n<p>多态的 <code>this</code> 类型表示的是某个包含类或接口的子类型。这被称作是 <code>F-bounded</code> 多态性。它能很容易的表现连贯接口间的继承。</p>\n</blockquote>\n<ul>\n<li>比如，在计算器的例子里，在每个操作之后都返回 <code>this</code> 类型。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BasicCalculator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">protected</span> value: <span class=\"built_in\">number</span> = <span class=\"number\">0</span></span>)</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> currentValue(): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> add(operand: <span class=\"built_in\">number</span>): <span class=\"built_in\">this</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value += operand;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> multiply(operand: <span class=\"built_in\">number</span>): <span class=\"built_in\">this</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value *= operand;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//...other operations go here...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> v = <span class=\"keyword\">new</span> BasicCalculator(<span class=\"number\">2</span>).multiply(<span class=\"number\">5</span>).add(<span class=\"number\">1</span>).currentValue();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(v);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于这个类使用了 <code>this</code> 类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何改变。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ScientificCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">BasicCalculator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">value = <span class=\"number\">0</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">sin</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = <span class=\"built_in\">Math</span>.sin(<span class=\"built_in\">this</span>.value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ... other operations go here ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> v1 = <span class=\"keyword\">new</span> ScientificCalculator(<span class=\"number\">2</span>).multiply(<span class=\"number\">5</span>).sin().add(<span class=\"number\">1</span>).currentValue();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(v1);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果没有 <code>this</code> 类型，<code>ScientificCalculator</code> 就不能够在继承 <code>BasicCalculator</code> 的同时还保持接口的连贯性。<code>multiply</code> 将会返回 <code>BasicCalculator</code>，它并没有 <code>sin</code> 方法。然而，使用 <code>this</code> 类型，<code>multiply</code> 会返回 <code>this</code>，在这里就是 <code>ScientificCalculator</code>。</p>\n</blockquote>\n<h3 id=\"11-18-索引类型\"><a href=\"#11-18-索引类型\" class=\"headerlink\" title=\"11.18 索引类型\"></a>11.18 索引类型</h3><blockquote>\n<p>使用索引类型，编译器就能够检查使用了动态属性名的代码。</p>\n</blockquote>\n<ul>\n<li>例如，一个常见的 <code>JavaScript</code> 模式是从对象中选取属性的子集。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">js_pluck</span>(<span class=\"params\">o, names</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> names.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> o[n]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下面是如何在 <code>TypeScript</code> 里使用此函数，通过 索引类型查询和 索引访问 操作符：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pluck</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">o: T, names: K[]</span>): <span class=\"title\">T</span>[<span class=\"title\">K</span>][] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> names.map(<span class=\"function\"><span class=\"params\">n</span> =&gt;</span> o[n]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person: Person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">&quot;Jarid&quot;</span>,</span><br><span class=\"line\">  age: <span class=\"number\">35</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings: <span class=\"built_in\">string</span>[] = pluck(person, [<span class=\"string\">&quot;name&quot;</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strings);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译器会检查 <code>name</code> 是否真的是 <code>Person</code> 的一个属性。本例还引入了几个新的类型操作符。</p>\n</blockquote>\n<h4 id=\"11-18-1-首先是-keyof-T，索引类型查询操作符。\"><a href=\"#11-18-1-首先是-keyof-T，索引类型查询操作符。\" class=\"headerlink\" title=\"11.18.1 首先是 keyof T，索引类型查询操作符。\"></a>11.18.1 首先是 <code>keyof T</code>，索引类型查询操作符。</h4><blockquote>\n<p>对于任何类型 <code>T</code> ，<code>keyof T</code> 的结果为 <code>T</code> 上已知的公共属性名的联合。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> personProps: keyof Person; <span class=\"comment\">// &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>keyof Person</code> 是完全可以与 <code>&#39;name&#39; \\| &#39;age&#39;</code> 互相替换的。不同的是如果你添加了其它的属性到 <code>Person</code>, 例如 <code>address: string</code>，那么<code>keyof Person</code> 会自动变为 <code>&#39;name&#39; | &#39;age&#39; | &#39;address&#39;</code>。你可以像 <code>pluck</code> 函数这类上下文里使用 <code>keyof</code> ，因为在使用之前你并不清楚可能出现的属性名。但编译器会检查你是否传入了正确的属性名给 <code>pluck</code>：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pluck(person, [&#x27;age&#x27;, &#x27;unknown&#x27;]); // error, &#x27;unknown&#x27; is not in &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-18-2-第二个操作符是-T-K-索引访问操作符。\"><a href=\"#11-18-2-第二个操作符是-T-K-索引访问操作符。\" class=\"headerlink\" title=\"11.18.2 第二个操作符是 T[K], 索引访问操作符。\"></a>11.18.2 第二个操作符是 <code>T[K]</code>, 索引访问操作符。</h4><blockquote>\n<p>在这里，类型语法反应了表达式语法。这意味着 <code>person[&#39;name&#39;]</code> 具有类型 <code>Person[&#39;name&#39;]</code> – 在我们的例子里则为 <code>string</code> 类型。然而，就像索引类型查询一样，你可以在普通的上下文里使用 <code>T[K]</code>，这正是它的强大所在。你只要确保类型变量 <code>K extends keyof T</code> 就可以了。</p>\n</blockquote>\n<ul>\n<li>例如下面 <code>getProperty</code> 函数的例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getProperty</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span> <span class=\"title\">extends</span> <span class=\"title\">keyof</span> <span class=\"title\">T</span>&gt;(<span class=\"params\">o: T, name: K</span>): <span class=\"title\">T</span>[<span class=\"title\">K</span>] </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> o[name]; <span class=\"comment\">// o[name] is of type T[K]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>getProperty</code> 里的 <code>o: T</code> 和 <code>name: K</code>，意味着 <code>o[name]: T[K]</code>。当你返回 <code>T[K]</code> 的结果，</p>\n</blockquote>\n<blockquote>\n<p>编译器会是实例化键的真实类型，因此 <code>getProperty</code> 的返回值类型会随着你需要的属性改变。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _name: <span class=\"built_in\">string</span> = getProperty(person, <span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> _age: <span class=\"built_in\">number</span> = getProperty(person, <span class=\"string\">&quot;age&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// let unknown = getProperty(person, &quot;unknown&quot;); // error, &#x27;unknown&#x27; is not in &#x27;name&#x27; | &#x27;age&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_name, <span class=\"string\">&quot; &quot;</span>, _age);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-19-索引类型和字符串索引签名\"><a href=\"#11-19-索引类型和字符串索引签名\" class=\"headerlink\" title=\"11.19 索引类型和字符串索引签名\"></a>11.19 索引类型和字符串索引签名</h3><blockquote>\n<p><code>keyof</code> 和 <code>T[K]</code> 与字符串索引签名进行交互。如果你有一个带有字符串索引签名的类型，那么 <code>keyof T</code> 会是 <code>string</code>。并且 <code>T[string]</code> 为索引签名的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Dictionary&lt;T&gt; &#123;</span><br><span class=\"line\">  [key: <span class=\"built_in\">string</span>]: T;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> keys: keyof Dictionary&lt;<span class=\"built_in\">number</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> value: Dictionary&lt;<span class=\"built_in\">number</span>&gt;[<span class=\"string\">&quot;foo&quot;</span>]; <span class=\"comment\">// number</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-20-映射类型\"><a href=\"#11-20-映射类型\" class=\"headerlink\" title=\"11.20 映射类型\"></a>11.20 映射类型</h3><ul>\n<li>一个常见的任务是将一个已知的类型每个属性都变为可选的。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PersonPartial &#123;</span><br><span class=\"line\">  name?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  age?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>或者我们只想要一个只读版本</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PersonReadonly &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这在 <code>JavaScript</code> 里经常出现。<code>TypeScript</code> 提供了从旧类型中创建新类型的一种方式 <code>--</code> 映射类型。在映射类型里，新类型以相同的形式去转换旧类型里每个属性。假如，你可以令每个属性成为 <code>readonly</code> 类型或可选的。</p>\n</blockquote>\n<ul>\n<li>下面是一些例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class=\"line\">  <span class=\"keyword\">readonly</span> [P <span class=\"keyword\">in</span> keyof T]: T[P];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>像下面这样使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonPartial = Partial;</span><br><span class=\"line\"><span class=\"keyword\">type</span> PersonReadonly = Readonly;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是，这个语法描述的是类型而非成员。若想添加额外的成员，则可以使用 交叉类型。</p>\n</blockquote>\n<ul>\n<li>这样使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PartialWithNewMember&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">&#125; &amp; &#123; <span class=\"attr\">newMember</span>: <span class=\"built_in\">boolean</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不要这样使用</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> PartialWithNewMember&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]?: T[P];</span><br><span class=\"line\">  newMember: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>下面来看看最简单的映射类型和它的组成部分</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Keys = <span class=\"string\">&quot;option1&quot;</span> | <span class=\"string\">&quot;option2&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Flags = &#123; [K <span class=\"keyword\">in</span> Keys]: <span class=\"built_in\">boolean</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它的语法与索引签名的语法类型，内部使用了 <code>for...in</code>。具有三个部分：</p>\n</blockquote>\n<ol>\n<li>类型变量 <code>K</code>，它会依次绑定到每个属性。</li>\n<li>字符串字面量联合的 <code>Keys</code>，它包含了要迭代的属性名的集合。</li>\n<li>属性的结果类型。</li>\n</ol>\n<blockquote>\n<p>在上面这个简单的例子里，<code>Keys</code> 是硬编码的属性列表并且属性类型永远是 <code>boolean</code>，因此这个映射类型</p>\n</blockquote>\n<ul>\n<li>等同于：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> _FLags = &#123;</span><br><span class=\"line\">  option1: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  option2: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在真正的应用里，可能不同于上面的 <code>Readonly</code> 或 <code>Partial</code>。它们会基于一些已存在的类型，且按照一定的方式转换字段。这就是 <code>keyof</code> 和 <code>索引访问类型</code> 要做的事情。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> NullablePerson = &#123; [P <span class=\"keyword\">in</span> keyof Person]: Person[P] | <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> PartialPerson = &#123; [P <span class=\"keyword\">in</span> keyof Person]?: Person[P] &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但它更有用的地方是可以有一些通用版本。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Nullable&lt;T&gt; = &#123; [P <span class=\"keyword\">in</span> keyof T]: T[P] | <span class=\"literal\">null</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Partial1&lt;T&gt; = &#123; [P <span class=\"keyword\">in</span> keyof T]?: T[P] &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在这些例子里，属性列表是 <code>keyof T</code> 且结果类型是 <code>T[P]</code> 的变体。这是使用通用映射类型的一个好模版。因为这类转换是同态的，映射只作用于 <code>T</code> 的属性而没有其它的。编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。假如，假设 <code>Person.name</code> 是只读的，那么 <code>Partial1&lt;Person&gt;.name</code> 也将是只读的且为可选的。</p>\n</blockquote>\n<blockquote>\n<p>下面是另一个例子，<code>T[P]</code> 被包装在 <code>Proxy&lt;T&gt;</code> 类里：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> <span class=\"built_in\">Proxy</span>&lt;T&gt; = &#123;</span><br><span class=\"line\">  get(): T;</span><br><span class=\"line\">  set(value: T): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]: <span class=\"built_in\">Proxy</span>&lt;T[P]&gt;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">proxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">o: T</span>): <span class=\"title\">Proxify</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...wrap proxies</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> proxyProps = proxify(props);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>Readonly&lt;T&gt;</code> 和 <code>Partial&lt;T&gt;</code> 用处不小，因此它们于 <code>pick</code> 和 <code>Record</code> 一同被包含进了 <code>TypeScript</code> 的标准库里：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> K]: T[P];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">type</span> Record&lt;K <span class=\"keyword\">extends</span> keyof <span class=\"built_in\">any</span>, T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> K]: T;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Readonly</code>, <code>Partial</code> 和 <code>Pick</code> 是同态的，但 <code>Record</code> 不是。因为 <code>Record</code> 并不需要输入类型来拷贝属性，所以它不属于同态：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ThreeStringProps = Record&lt;<span class=\"string\">&quot;prop1&quot;</span> | <span class=\"string\">&quot;prop2&quot;</span> | <span class=\"string\">&quot;prop3&quot;</span>, <span class=\"built_in\">string</span>&gt;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。</p>\n</blockquote>\n<h3 id=\"11-21-由映射类型进行判断\"><a href=\"#11-21-由映射类型进行判断\" class=\"headerlink\" title=\"11.21 由映射类型进行判断\"></a>11.21 由映射类型进行判断</h3><blockquote>\n<p>现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。其实这也非常容易：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class=\"line\">  get(): T;</span><br><span class=\"line\">  set(value: T): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unproxify</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">t: Proxify&lt;T&gt;</span>): <span class=\"title\">T</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = &#123;&#125; <span class=\"keyword\">as</span> T;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> t) &#123;</span><br><span class=\"line\">    result[k] = t[k].get();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// let originalProps = unproxify(proxyProps);</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意这个拆包推断只适用于同态的映射类型。如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。</p>\n</blockquote>\n<h3 id=\"11-22-有条件类型\"><a href=\"#11-22-有条件类型\" class=\"headerlink\" title=\"11.22 有条件类型\"></a>11.22 有条件类型</h3><blockquote>\n<p><code>TypeScript 2.8</code> 引入了有条件类型，它能够表示非统一的类型。有条件的类型会以一个条件表达式进行类型关系检测，从而在两种类型中选择其一：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T <span class=\"keyword\">extends</span> U ? X : Y</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的类型意思是：若 <code>T</code> 能够赋值给 <code>U</code>，那么类型是 <code>X</code>，否则为 <code>Y</code></p>\n</blockquote>\n<blockquote>\n<p>有条件的类型 <code>T extends U ? X : Y</code> 或者解析为 <code>X</code>，或者解析为 <code>Y</code>，再或者延迟解析，因为它可能依赖一个或多个类型变量。若 <code>T</code> 或 <code>U</code> 包含类型参数，那么是否解析为 <code>X</code> 或 <code>Y</code> 或推迟，取决于类型系统是否有足够的信息来确定 <code>T</code> 总是可以赋值给 <code>U</code>。</p>\n</blockquote>\n<ul>\n<li>下面是一些类型可以被立即解析的例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">boolean</span>&gt;(<span class=\"params\">x: T</span>): <span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">true</span> ? <span class=\"title\">string</span> : <span class=\"title\">number</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Type is &#x27;string&#x27; | &#x27;number&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> x = f(<span class=\"built_in\">Math</span>.random() &lt; <span class=\"number\">0.5</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另外一个例子涉及 <code>TypeName</code> 类型别名，它使用了嵌套了有条件类型</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> TypeName&lt;T&gt; = T <span class=\"keyword\">extends</span> <span class=\"built_in\">string</span> ? <span class=\"string\">&quot;string&quot;</span> : T <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span> ? <span class=\"string\">&quot;number&quot;</span> : T <span class=\"keyword\">extends</span> <span class=\"built_in\">boolean</span> ? <span class=\"string\">&quot;boolean&quot;</span> : T <span class=\"keyword\">extends</span> <span class=\"literal\">undefined</span> ? <span class=\"string\">&quot;undefined&quot;</span> : T <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span> ? <span class=\"string\">&quot;function&quot;</span> : <span class=\"string\">&quot;object&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T0 = TypeName&lt;<span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T1 = TypeName&lt;<span class=\"string\">&quot;a&quot;</span>&gt;; <span class=\"comment\">// &quot;string&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T2 = TypeName&lt;<span class=\"literal\">true</span>&gt;; <span class=\"comment\">// &quot;boolean&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T3 = TypeName&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>&gt;; <span class=\"comment\">// &quot;function&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T4 = TypeName&lt;<span class=\"built_in\">string</span>[]&gt;; <span class=\"comment\">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下面是一个有条件类型被推迟解析的例子</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Foo &#123;</span><br><span class=\"line\">  propA: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  propB: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">x: T</span>): <span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">Foo</span> ? <span class=\"title\">string</span> : <span class=\"title\">number</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>&lt;<span class=\"title\">U</span>&gt;(<span class=\"params\">x: U</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Has type &#x27;U extends Foo ? string : number&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = f(x);</span><br><span class=\"line\">  <span class=\"comment\">// This assignment is allowed though!</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> b: <span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> = a;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里，<code>a</code> 变量含有未确定的有条件类型。当有另一段代码调用 <code>foo</code>，它会用其它类型替换 <code>U</code>，<code>TypeScript</code> 将重新计算有条件类型，决定它是否可以选择一个分支。与此同时，我们可以将有条件类型赋值给其它类型，只要有条件类型的每个分支，都可以赋值给目标类型。因此在我们的例子里，我们可以将 <code>U extends Foo ? string : number</code> 赋值给 <code>string | number</code>，因为不管这个有条件类型最终结果是什么，它只能是 <code>string | number</code>。</p>\n</blockquote>\n<h3 id=\"11-23-分布式有条件类型\"><a href=\"#11-23-分布式有条件类型\" class=\"headerlink\" title=\"11.23 分布式有条件类型\"></a>11.23 分布式有条件类型</h3><blockquote>\n<p>如果有条件类型里待检查的类型是 <code>naked type parameter</code> ，那么它也被称为”分布式有条件类型”。分布式有条件类型在实例化时会自动分发成联合类型。例如：实例化 <code>T extends U ? X : Y</code>，<code>T</code> 的类型为 <code>A | B | C</code>，会被解析为 <code>(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)</code>。</p>\n</blockquote>\n<ul>\n<li>例子：```typescript<br>type TypeName<T> =<br>T extends string ? “string” :<br>T extends number ? “number” :<br>T extends boolean ? “boolean” :<br>T extends undefined ? “undefined” :<br>T extends Function ? “function” : “object”;<br>type T10 = TypeName&lt;string | (() =&gt; void)&gt;; // “string” | “function”<br>type T11 = TypeName&lt;string | string[] | undefined&gt;; // “string” | “object” | “undefined”<br>type T12 = TypeName&lt;string[] | number[]&gt;; // “object”</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt;  在 &#96;T extends U ? X : Y&#96; 的实例化里，对 &#96;T&#96; 的引用被解析为联合类型的一部分(比如，&#96;T&#96; 指向某一单个部分，在有条件类型分布到联合类型之后)。此外，在 &#96;X&#96; 内对 &#96;T&#96; 的引用有一个附加的类型参数约束 &#96;U&#96;(例如，&#96;T&#96; 被当成在 &#96;X&#96; 内可赋值给 &#96;U&#96;)。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">- 例子：</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;typescript</span><br><span class=\"line\">type BoxedValue&lt;T&gt; &#x3D; &#123; value: T &#125;;</span><br><span class=\"line\">type BoxedArray&lt;T&gt; &#x3D; &#123; array: T[] &#125;;</span><br><span class=\"line\">type Boxed&lt;T&gt; &#x3D; T extends any[] ? BoxedArray&lt;T[number]&gt; : BoxedValue&lt;T&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">type T20 &#x3D; Boxed&lt;string&gt;; &#x2F;&#x2F; BoxedValue&lt;string&gt;;</span><br><span class=\"line\">type T21 &#x3D; Boxed&lt;number[]&gt;; &#x2F;&#x2F; BoxedArray&lt;number&gt;;</span><br><span class=\"line\">type T22 &#x3D; Boxed&lt;string | number[]&gt;; &#x2F;&#x2F; BoxedValue&lt;string&gt; | BoxedArray&lt;number&gt;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-23-1-有条件类型的分布式的属性可以方便地用来过滤联合类型：\"><a href=\"#11-23-1-有条件类型的分布式的属性可以方便地用来过滤联合类型：\" class=\"headerlink\" title=\"11.23.1 有条件类型的分布式的属性可以方便地用来过滤联合类型：\"></a>11.23.1 有条件类型的分布式的属性可以方便地用来过滤联合类型：</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Diff&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? <span class=\"built_in\">never</span> : T; <span class=\"comment\">// Remove types from T that are assignable to U(从 T 中删除可分配给 U 的类型)</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Filter&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? T : <span class=\"built_in\">never</span>; <span class=\"comment\">// Remove types from T that are not assignable to U(从 T 中删除不可赋值给 U 的类型)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T30 = Diff&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;b&quot; | &quot;d&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T31 = Filter&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;a&quot; | &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T32 = Diff&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T33 = Filter&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// () =&gt; void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> _NonNullable&lt;T&gt; = Diff&lt;T, <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// Remove null and undefined from T</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T34 = _NonNullable&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T35 = _NonNullable&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string | string[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">x: T, y: _NonNullable&lt;T&gt;</span>) </span>&#123;</span><br><span class=\"line\">  x = y; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">  <span class=\"comment\">// y = x ;// Error</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> <span class=\"title\">string</span> | <span class=\"title\">undefined</span>&gt;(<span class=\"params\">x: T, y: _NonNullable&lt;T&gt;</span>) </span>&#123;</span><br><span class=\"line\">  x = y; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">  <span class=\"comment\">// y = x; //Error</span></span><br><span class=\"line\">  <span class=\"comment\">// let s1: string = x; // Error</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> s2: <span class=\"built_in\">string</span> = y; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-23-2-有条件类型与映射类型结合时特别有用\"><a href=\"#11-23-2-有条件类型与映射类型结合时特别有用\" class=\"headerlink\" title=\"11.23.2 有条件类型与映射类型结合时特别有用\"></a>11.23.2 有条件类型与映射类型结合时特别有用</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> FunctionPropertyNames&lt;T&gt; = &#123; [K <span class=\"keyword\">in</span> keyof T]: T[K] <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span> ? K : <span class=\"built_in\">never</span> &#125;[keyof T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> FunctionProperties&lt;T&gt; = Pick&lt;T, FunctionPropertyNames&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> NonFunctionPropertyNames&lt;T&gt; = &#123; [K <span class=\"keyword\">in</span> keyof T]: T[K] <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span> ? <span class=\"built_in\">never</span> : K &#125;[keyof T];</span><br><span class=\"line\"><span class=\"keyword\">type</span> NonFunctionProperties&lt;T&gt; = Pick&lt;T, NonFunctionPropertyNames&lt;T&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Part &#123;</span><br><span class=\"line\">  id: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  subparts: Part[];</span><br><span class=\"line\">  updatePart(newName: <span class=\"built_in\">string</span>): <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T40 = FunctionPropertyNames&lt;Part&gt;; <span class=\"comment\">// &quot;updatePart&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T41 = NonFunctionPropertyNames&lt;Part&gt;; <span class=\"comment\">// &quot;id&quot; | &quot;name&quot; | &quot;subparts&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T42 = FunctionProperties&lt;Part&gt;; <span class=\"comment\">// &#123; updatePart(newName: string): void &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T43 = NonFunctionProperties&lt;Part&gt;; <span class=\"comment\">// &#123; id: number, name: string, suparts: Part[] &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-23-3-与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。\"><a href=\"#11-23-3-与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。\" class=\"headerlink\" title=\"11.23.3 与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。\"></a>11.23.3 与联合类型和可交叉类型相似，有条件类型不允许递归地引用自己。</h4><ul>\n<li>比如下面的错误：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type ElementType&lt;T&gt; = T extends any[] ? ElementType&lt;T[number]&gt;: T; // Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-24-有条件类型中的类型推断\"><a href=\"#11-24-有条件类型中的类型推断\" class=\"headerlink\" title=\"11.24 有条件类型中的类型推断\"></a>11.24 有条件类型中的类型推断</h3><blockquote>\n<p>现在有条件类型的 <code>extends</code> 子语句中，允许出现 <code>infer</code> 声明，它会引入一个待推断的类型变量。这个推断的类型变量可以在有条件类型的 <code>true</code> 分支中被引用。允许出现多个同类型变量的 <code>infer</code>。</p>\n</blockquote>\n<blockquote>\n<p>例如：下面代码会提取函数类型的返回值</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> _ReturnType&lt;T&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有条件类型 可以嵌套来构成一系列的匹配模式，按顺序进行求值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Unpacked&lt;T&gt; = T <span class=\"keyword\">extends</span> (infer U)[] ? U : T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer U ? U : T <span class=\"keyword\">extends</span> <span class=\"built_in\">Promise</span>&lt;infer U&gt; ? U : T;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T0 = Unpacked&lt;<span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T1 = Unpacked&lt;<span class=\"built_in\">string</span>[]&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T2 = Unpacked&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T3 = Unpacked&lt;<span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T4 = Unpacked&lt;<span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">string</span>&gt;[]&gt;; <span class=\"comment\">// Promise&lt;string&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T5 = Unpacked&lt;Unpacked&lt;<span class=\"built_in\">Promise</span>&lt;<span class=\"built_in\">string</span>&gt;[]&gt;&gt;; <span class=\"comment\">// string</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>下面的例子解释了在协变位置上，同一个类型变量的多个候选类型会被推断为联合类型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Foo&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">a</span>: infer U; b: infer U &#125; ? U : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> T10 = Foo&lt;&#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; b: <span class=\"built_in\">string</span> &#125;&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T11 = Foo&lt;&#123; <span class=\"attr\">a</span>: <span class=\"built_in\">string</span>; b: <span class=\"built_in\">number</span> &#125;&gt;; <span class=\"comment\">// string | number</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相似地，在抗变位置上同一个类型变量的多个候选类型会被推断为交叉类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Bar&lt;T&gt; = T <span class=\"keyword\">extends</span> &#123; <span class=\"attr\">a</span>: <span class=\"function\">(<span class=\"params\">x: infer U</span>) =&gt;</span> <span class=\"built_in\">void</span>; b: <span class=\"function\">(<span class=\"params\">x: infer U</span>) =&gt;</span> <span class=\"built_in\">void</span> &#125; ? U : <span class=\"built_in\">never</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> T20 = Bar&lt;&#123; <span class=\"attr\">a</span>: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>; b: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span> &#125;&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T21 = Bar&lt;&#123; <span class=\"attr\">a</span>: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>; b: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">number</span></span>) =&gt;</span> <span class=\"built_in\">void</span> &#125;&gt;; <span class=\"comment\">// string &amp; number</span></span><br></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&gt; 当推断具有多个调用签名(例如函数重载类型)的类型时，用最后的签名(大概是最自由的包含所有情况的签名) 进行推断。无法根据参数类型列表来进行解析重载。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#96;&#96;&#96;typescript</span><br><span class=\"line\">declare function foo(x: string): number;</span><br><span class=\"line\">declare function foo(x: number): string;</span><br><span class=\"line\">declare function foo(x: string | number): string | number;</span><br><span class=\"line\"></span><br><span class=\"line\">type T30 &#x3D; ReturnType&lt;typeof foo&gt;; &#x2F;&#x2F; string | number</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>无法在正常类型参数的约束子语句中使用 <code>infer</code> 声明：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type ReturnType1&lt;T extends (...args: any[]) =&gt; infer R&gt; = R; // Error</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是，可以这样达到同样的效果，在约束里删掉类型变量，用 有条件类型 来替换：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> AnyFunction = <span class=\"function\">(<span class=\"params\">...args: <span class=\"built_in\">any</span>[]</span>) =&gt;</span> <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">type</span> ReturnType2&lt;T <span class=\"keyword\">extends</span> AnyFunction&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>[]) =&gt; infer R ? R : <span class=\"built_in\">any</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>实际上，就是 <code>ReturnType</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> __ReturnType&lt;T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>) =&gt; <span class=\"built_in\">any</span>&gt; = T <span class=\"keyword\">extends</span> (...args: <span class=\"built_in\">any</span>) =&gt; infer R ? R : <span class=\"built_in\">never</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"11-25-预定义的有条件类型\"><a href=\"#11-25-预定义的有条件类型\" class=\"headerlink\" title=\"11.25 预定义的有条件类型\"></a>11.25 预定义的有条件类型</h3><blockquote>\n<p><code>TypeScript 2.8</code> 在 <code>lib.d.ts</code> 里增加了一些预定义的有条件类型</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>Exclude&lt;T, U&gt;</code> – 从 <code>T</code> 中剔除可以赋值给 <code>U</code> 的类型</li>\n<li><code>Extract&lt;T, U&gt;</code> – 提取 <code>T</code> 中可以赋值给 <code>U</code> 的类型</li>\n<li><code>NonNullable&lt;T&gt;</code> – 从 <code>T</code> 中剔除 <code>null</code> 和 <code>undefined</code></li>\n<li><code>ReturnType&lt;T&gt;</code> – 获取函数返回值类型</li>\n<li><code>InstanceType&lt;T&gt;</code> – 获取构造函数类型的实例类型</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>Example</code>:</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T00 = Exclude&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;b&quot; | &quot;d&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T01 = Extract&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;d&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;c&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;a&quot; | &quot;c&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T02 = Exclude&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// &quot;string&quot; | &quot;number&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T03 = Extract&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// () =&gt; void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T04 = NonNullable&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T05 = NonNullable&lt;(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>) | <span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// (() =&gt; string) | string[]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: s &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T10 = ReturnType&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T11 = ReturnType&lt;<span class=\"function\">(<span class=\"params\">s: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;; <span class=\"comment\">// void</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T12 = ReturnType&lt;&lt;T&gt;<span class=\"function\">() =&gt;</span> T&gt;; <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T13 = ReturnType&lt;&lt;T <span class=\"keyword\">extends</span> U, U <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span>[]&gt;<span class=\"function\">() =&gt;</span> T&gt;; <span class=\"comment\">// number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T14 = ReturnType&lt;<span class=\"keyword\">typeof</span> f1&gt;; <span class=\"comment\">// &#123; a: number, b: string &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T15 = ReturnType&lt;<span class=\"built_in\">any</span>&gt;; <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T16 = ReturnType&lt;<span class=\"built_in\">never</span>&gt;; <span class=\"comment\">// never</span></span><br><span class=\"line\"><span class=\"comment\">// type T17 = ReturnType&lt;string&gt;; // Error</span></span><br><span class=\"line\"><span class=\"comment\">// type T18 = ReturnType&lt;Function&gt;; // Error</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> T20 = InstanceType&lt;<span class=\"keyword\">typeof</span> C&gt;; <span class=\"comment\">// C</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T21 = InstanceType&lt;<span class=\"built_in\">any</span>&gt;; <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T22 = InstanceType&lt;<span class=\"built_in\">never</span>&gt;; <span class=\"comment\">// never</span></span><br><span class=\"line\"><span class=\"comment\">// type T23 = InstanceType&lt;string&gt;; // Error</span></span><br><span class=\"line\"><span class=\"comment\">// type T24 = InstanceType&lt;Function&gt;; // Error</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：<code>Exclude</code> 类型是建议的 <code>Diff</code> 类型的一种实现，我们使用 <code>Exclude</code> 这个名字是为了避免破坏已经定义了的 <code>Diff</code> 的代码，并且我们感觉这个名字能更好地表达类型的语义。我们没有增加 <code>Omit&lt;T, K&gt;</code> 类型，因为它可以很容易的用 <code>Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</code> 来表示</p>\n</blockquote>\n<h2 id=\"十二、实用工具类型\"><a href=\"#十二、实用工具类型\" class=\"headerlink\" title=\"十二、实用工具类型\"></a>十二、实用工具类型</h2><blockquote>\n<p><code>TypeScript</code> 提供一些工具类型来帮助常见的类型转换。这些类型是全局可见的。</p>\n</blockquote>\n<h3 id=\"12-1-Partial-局部的\"><a href=\"#12-1-Partial-局部的\" class=\"headerlink\" title=\"12.1 Partial 局部的\"></a>12.1 Partial 局部的</h3><blockquote>\n<p>构造类型 <code>T</code>, 并将它所有的属性设置成可选的，它的返回类型表示输入类型的所有子类型。</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PartialTodo &#123;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  description: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">updateTodo</span>(<span class=\"params\">todo: PartialTodo, fieldsToUpdate: Partial&lt;PartialTodo&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partialTodo1 = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">&quot;organize desk&quot;</span>,</span><br><span class=\"line\">  description: <span class=\"string\">&quot;clear clutter&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> partialTodo2 = updateTodo(partialTodo1, &#123;</span><br><span class=\"line\">  description: <span class=\"string\">&quot;throw out trash&quot;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-2-Readonly-只读的\"><a href=\"#12-2-Readonly-只读的\" class=\"headerlink\" title=\"12.2 Readonly 只读的\"></a>12.2 Readonly 只读的</h3><blockquote>\n<p>构造类型 T<strong>，并将它所有的属性设置为</strong> readonly<strong>，也就是说构造出的类型的属性不能被再次赋值</strong></p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ReadonlyTodo &#123;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> readonlyTodo: Readonly&lt;ReadonlyTodo&gt; = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">&quot;Delete inactive users&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">readonlyTodo.title = <span class=\"string\">&quot;Hello&quot;</span>; <span class=\"comment\">// Error: cannot reassign a readonly property</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.freeze</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">freeze</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">obj: T</span>): <span class=\"title\">Readonly</span>&lt;<span class=\"title\">T</span>&gt;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-3-Record-lt-T-K-gt-记录\"><a href=\"#12-3-Record-lt-T-K-gt-记录\" class=\"headerlink\" title=\"12.3 Record&lt;T, K&gt; 记录\"></a>12.3 Record&lt;T, K&gt; 记录</h3><blockquote>\n<p>构造一个类型，其属性名的类型为 <code>K</code>，属性值的类型为 <code>T</code>。这个工具可用来将某个类型的属性映射到另一个类型上。</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PageInfo &#123;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Page = <span class=\"string\">&quot;home&quot;</span> | <span class=\"string\">&quot;about&quot;</span> | <span class=\"string\">&quot;contact&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> x: Record&lt;Page, PageInfo&gt; = &#123;</span><br><span class=\"line\">  about: &#123; <span class=\"attr\">title</span>: <span class=\"string\">&quot;about&quot;</span> &#125;,</span><br><span class=\"line\">  contact: &#123; <span class=\"attr\">title</span>: <span class=\"string\">&quot;concat&quot;</span> &#125;,</span><br><span class=\"line\">  home: &#123; <span class=\"attr\">title</span>: <span class=\"string\">&quot;home&quot;</span> &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-4-Pick-lt-T-K-gt-挑选\"><a href=\"#12-4-Pick-lt-T-K-gt-挑选\" class=\"headerlink\" title=\"12.4 Pick&lt;T, K&gt; 挑选\"></a>12.4 Pick&lt;T, K&gt; 挑选</h3><blockquote>\n<p>从类型 <code>T</code> 中挑选部分属性 <code>K</code> 来构造类型</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> PickTodo &#123;</span><br><span class=\"line\">  title: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  description: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  completed: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> TodoPreview = Pick&lt;PickTodo, <span class=\"string\">&quot;title&quot;</span> | <span class=\"string\">&quot;completed&quot;</span>&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> pickTodo: TodoPreview = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">&quot;Clean room&quot;</span>,</span><br><span class=\"line\">  completed: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-5-Exclude-lt-T-U-gt-剔除\"><a href=\"#12-5-Exclude-lt-T-U-gt-剔除\" class=\"headerlink\" title=\"12.5 Exclude&lt;T, U&gt; 剔除\"></a>12.5 Exclude&lt;T, U&gt; 剔除</h3><blockquote>\n<p>从类型 <code>T</code> 中剔除所有可以赋值给 <code>U</code> 的属性，然后构造一个类型。</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T0 = Exclude&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span>&gt;; <span class=\"comment\">// &quot;b&quot; | &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T1 = Exclude&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span>&gt;; <span class=\"comment\">// &quot;c&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T2 = Exclude&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// string | number</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-6-Extract-lt-T-U-gt-提取\"><a href=\"#12-6-Extract-lt-T-U-gt-提取\" class=\"headerlink\" title=\"12.6 Extract&lt;T, U&gt; 提取\"></a>12.6 Extract&lt;T, U&gt; 提取</h3><blockquote>\n<p>从类型 <code>T</code> 中提取所有可以赋值给 <code>U</code> 的类型，然后构造一个类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T01 = Extract&lt;<span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;b&quot;</span> | <span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;a&quot;</span> | <span class=\"string\">&quot;f&quot;</span>&gt;; <span class=\"comment\">// &quot;a&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T02 = Extract&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | (<span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>), <span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// () =&gt; void</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-7-NonNullable\"><a href=\"#12-7-NonNullable\" class=\"headerlink\" title=\"12.7 NonNullable\"></a>12.7 NonNullable</h3><blockquote>\n<p>从类型 <code>T</code> 中剔除 <code>null</code> 和 <code>undefined</code>，然后构造一个类型</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> T10 = NonNullable&lt;<span class=\"built_in\">string</span> | <span class=\"built_in\">number</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string | number</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> T11 = NonNullable&lt;<span class=\"built_in\">string</span>[] | <span class=\"literal\">null</span> | <span class=\"literal\">undefined</span>&gt;; <span class=\"comment\">// string[]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-8-ReturnType-返回值类型\"><a href=\"#12-8-ReturnType-返回值类型\" class=\"headerlink\" title=\"12.8 ReturnType 返回值类型\"></a>12.8 ReturnType 返回值类型</h3><blockquote>\n<p>由函数类型 <code>T</code> 的返回值类型构造一个类型</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: s &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T0 = ReturnType&lt;<span class=\"function\">() =&gt;</span> <span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T1 = ReturnType&lt;<span class=\"function\">(<span class=\"params\">s: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">void</span>&gt;; <span class=\"comment\">// void</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T2 = ReturnType&lt;&lt;T&gt;<span class=\"function\">() =&gt;</span> T&gt;; <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T3 = ReturnType&lt;&lt;T <span class=\"keyword\">extends</span> U, U <span class=\"keyword\">extends</span> <span class=\"built_in\">number</span>[]&gt;<span class=\"function\">() =&gt;</span> T&gt;; <span class=\"comment\">// number[]</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T4 = ReturnType&lt;<span class=\"keyword\">typeof</span> f1&gt;; <span class=\"comment\">// &#123; a: number, b: string &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T5 = ReturnType&lt;<span class=\"built_in\">any</span>&gt;; <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T6 = ReturnType&lt;<span class=\"built_in\">never</span>&gt;; <span class=\"comment\">// never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T7 = ReturnType&lt;<span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T8 = ReturnType&lt;<span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-9-InstanceType-构造函数-实例类型\"><a href=\"#12-9-InstanceType-构造函数-实例类型\" class=\"headerlink\" title=\"12.9 InstanceType 构造函数 实例类型\"></a>12.9 InstanceType 构造函数 实例类型</h3><blockquote>\n<p>由构造函数类型 <code>T</code> 的实例类型构造一个类型。</p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  x = <span class=\"number\">0</span>;</span><br><span class=\"line\">  y = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T01 = InstanceType&lt;<span class=\"keyword\">typeof</span> C&gt;; <span class=\"comment\">// C</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T02 = InstanceType&lt;<span class=\"built_in\">any</span>&gt;; <span class=\"comment\">// any</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T03 = InstanceType&lt;<span class=\"built_in\">never</span>&gt;; <span class=\"comment\">// never</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T04 = InstanceType&lt;<span class=\"built_in\">string</span>&gt;; <span class=\"comment\">// Error</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> _T05 = InstanceType&lt;<span class=\"built_in\">Function</span>&gt;; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-10-Required\"><a href=\"#12-10-Required\" class=\"headerlink\" title=\"12.10 Required\"></a>12.10 Required</h3><blockquote>\n<p>构造一个类型，使类型 <code>T</code> 的所有属性为 <code>required</code></p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Props &#123;</span><br><span class=\"line\">  a?: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  b?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj: Props = &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;; <span class=\"comment\">// Ok</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2: Required&lt;Props&gt; = &#123; <span class=\"attr\">a</span>: <span class=\"number\">5</span> &#125;; <span class=\"comment\">// Error, property &#x27;b&#x27; missing</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-11-ThisType-this\"><a href=\"#12-11-ThisType-this\" class=\"headerlink\" title=\"12.11 ThisType this\"></a>12.11 ThisType this</h3><blockquote>\n<p>这个工具不会返回一个转换后的类型。它作为上下文的 <code>this</code> 类型的一个标记。<br>注意：若想要使用此类型，必须启用 <code>--noImplicitThis</code></p>\n</blockquote>\n<ul>\n<li>例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Compile with --noImplicitThis</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> ObjectDescriptor&lt;D, M&gt; = &#123;</span><br><span class=\"line\">  data?: D;</span><br><span class=\"line\">  methods?: M &amp; ThisType&lt;D &amp; M&gt;; <span class=\"comment\">// Type of &#x27;this&#x27; in methods is D &amp; M</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeObject</span>&lt;<span class=\"title\">D</span>, <span class=\"title\">M</span>&gt;(<span class=\"params\">desc: ObjectDescriptor&lt;D, M&gt;</span>): <span class=\"title\">D</span> &amp; <span class=\"title\">M</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data: <span class=\"built_in\">object</span> = desc.data || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> methods: <span class=\"built_in\">object</span> = desc.methods || &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...data, ...methods &#125; <span class=\"keyword\">as</span> D &amp; M;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> _obj = makeObject(&#123;</span><br><span class=\"line\">  data: &#123; <span class=\"attr\">x</span>: <span class=\"number\">0</span>, <span class=\"attr\">y</span>: <span class=\"number\">0</span> &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">moveBy</span>(<span class=\"params\">dx: <span class=\"built_in\">number</span>, dy: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.x += dx; <span class=\"comment\">// Strongly typed this</span></span><br><span class=\"line\">      <span class=\"built_in\">this</span>.y += dy; <span class=\"comment\">// Strongly typed this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">_obj.x = <span class=\"number\">10</span>;</span><br><span class=\"line\">_obj.y = <span class=\"number\">10</span>;</span><br><span class=\"line\">_obj.moveBy(<span class=\"number\">5</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面例子中，<code>makeObject</code> 参数里的 <code>methods</code> 对象具有一个上下文类型 <code>ThisType&lt;D &amp; M&gt;</code>，因此 <code>methods</code> 对象的方法里 this 的类型为 <code>&#123; x: number, y: number &#125; &amp; &#123; moveBy(dx: number, dy: number): number &#125;</code>。<br>在 <code>lib.d.ts</code> 里，<code>ThisType&lt;T&gt;</code> 标识接口是个简单的空接口声明。除了在被识别为对象字面量的上下文类型之外，这个接口与一般的空接口没有什么不同。</p>\n</blockquote>\n<h2 id=\"十三、Symbols\"><a href=\"#十三、Symbols\" class=\"headerlink\" title=\"十三、Symbols\"></a>十三、Symbols</h2><blockquote>\n<p>介绍：自 <code>ECMAScript 2015</code> 起，<code>symbol</code> 成为了一种新的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。</p>\n</blockquote>\n<h3 id=\"13-1-symbol-类型的值是通过-Symbol-构造函数创建的。\"><a href=\"#13-1-symbol-类型的值是通过-Symbol-构造函数创建的。\" class=\"headerlink\" title=\"13.1 symbol 类型的值是通过 Symbol 构造函数创建的。\"></a>13.1 <code>symbol</code> 类型的值是通过 <code>Symbol</code> 构造函数创建的。</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym1 = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym2 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>); <span class=\"comment\">// 可选的字符串 key</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-2-Symbols-是不可改变且唯一的\"><a href=\"#13-2-Symbols-是不可改变且唯一的\" class=\"headerlink\" title=\"13.2 Symbols 是不可改变且唯一的\"></a>13.2 <code>Symbols</code> 是不可改变且唯一的</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sym3 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> sym4 = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;key&quot;</span>);</span><br><span class=\"line\">sym3 === sym4; <span class=\"comment\">// false symbols 是唯一的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-3-像字符串一样，symbols-也可以被用作对象属性的键。\"><a href=\"#13-3-像字符串一样，symbols-也可以被用作对象属性的键。\" class=\"headerlink\" title=\"13.3 像字符串一样，symbols 也可以被用作对象属性的键。\"></a>13.3 像字符串一样，<code>symbols</code> 也可以被用作对象属性的键。</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sym = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">  [sym]: <span class=\"string\">&quot;value&quot;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj[sym]); <span class=\"comment\">// &quot;value&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-4-Symbols-也可以与计算出的属性名相结合来声明对象的属性和类成员。\"><a href=\"#13-4-Symbols-也可以与计算出的属性名相结合来声明对象的属性和类成员。\" class=\"headerlink\" title=\"13.4 Symbols 也可以与计算出的属性名相结合来声明对象的属性和类成员。\"></a>13.4 <code>Symbols</code> 也可以与计算出的属性名相结合来声明对象的属性和类成员。</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> getClassNameSymbol = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  [getClassNameSymbol]() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;C&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> className = c[getClassNameSymbol](); <span class=\"comment\">// &quot;C&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-5-众所周知的-Symbols\"><a href=\"#13-5-众所周知的-Symbols\" class=\"headerlink\" title=\"13.5 众所周知的 Symbols\"></a>13.5 众所周知的 <code>Symbols</code></h3><blockquote>\n<p>除了用户定义的 <code>Symbols</code>，还有一些已经众所周知的内置 <code>symbols</code>。内置 <code>symbols</code> 用来表示语言内部的行为。<br>以下为这些 <code>symbols</code> 的列表：</p>\n</blockquote>\n<ul>\n<li><code>Symbol.hasInstance</code></li>\n</ul>\n<blockquote>\n<p>该方法会被 <code>instanceof</code> 运算符调用。构造器对象用来识别一个对象是否是其实例。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.isConcatSpreadable</code></li>\n</ul>\n<blockquote>\n<p>布尔值，表示当在一个对象上调用 <code>Array.prototype.concat</code> 时，这个对象的数组元素是否可展开。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.iterator</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>for-of</code> 语句调用，。返回对象的默认迭代器</p>\n</blockquote>\n<ul>\n<li><code>Symbol.match</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>String.prototype.match</code> 调用。正则表达式用来匹配字符串</p>\n</blockquote>\n<ul>\n<li><code>Symbol.replace</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>String.prototype.replac</code>e 调用。正则表达式用来替换字符串中匹配的子串。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.search</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>String.prototype.search</code> 调用。正则表达式返回被匹配部分在字符串中的索引。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.species</code></li>\n</ul>\n<blockquote>\n<p>函数值，为一个构造函数。用来创建派生对象。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.split</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>String.prototype.split</code> 调用。正则表达式用来分割字符串。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.toPrimitive</code></li>\n</ul>\n<blockquote>\n<p>方法，被 <code>ToPrimitive</code> 抽象操作调用。把对象转换为相应的原始值。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.toStringTag</code></li>\n</ul>\n<blockquote>\n<p>方法，被内置方法 <code>Object.prototype.toString</code> 调用。返回创建对象时默认的字符串描述。</p>\n</blockquote>\n<ul>\n<li><code>Symbol.unscopables</code></li>\n</ul>\n<blockquote>\n<p>对象，它自己拥有的属性会被 <code>with</code> 作用域排除在外。</p>\n</blockquote>\n<h2 id=\"十四、迭代器和生成器\"><a href=\"#十四、迭代器和生成器\" class=\"headerlink\" title=\"十四、迭代器和生成器\"></a>十四、迭代器和生成器</h2><ul>\n<li>可迭代性</li>\n</ul>\n<blockquote>\n<p>当一个对象实现了 <code>Symbol.iterator</code> 属性时，我们认为它是可迭代的。一些内置的类型如 <code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code> 等都已经实现了各自的 <code>Symbol.iterator</code>。对象上的 <code>Symbol.iterator</code> 函数负责返回供迭代的值。</p>\n</blockquote>\n<h3 id=\"14-1-for-…-of-语句\"><a href=\"#14-1-for-…-of-语句\" class=\"headerlink\" title=\"14.1 for … of 语句\"></a>14.1 for … of 语句</h3><blockquote>\n<p><code>for ... of</code> 会遍历可迭代对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p>\n</blockquote>\n<ul>\n<li>下面是在数组上使用 <code>for ... of</code> 的简单例子</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> someArray = [<span class=\"number\">1</span>, <span class=\"string\">&quot;string&quot;</span>, <span class=\"literal\">false</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> entry <span class=\"keyword\">of</span> someArray) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(entry); <span class=\"comment\">// 1, &quot;string&quot;, false</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-2-for-…-of-Vs-for-…-in-语句\"><a href=\"#14-2-for-…-of-Vs-for-…-in-语句\" class=\"headerlink\" title=\"14.2 for … of Vs for … in 语句\"></a>14.2 for … of Vs for … in 语句</h3><blockquote>\n<p><code>for ... of</code> 和 <code>for ... in</code> 均可迭代一个列表；但是用于迭代的值却不同，<code>for ... in</code> 迭代的是对象的 <code>键</code> 的列表，而 <code>for ... of</code> 则迭代对象的键对应的值。</p>\n</blockquote>\n<ul>\n<li>下面的例子展示了两者之间的区别：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> list = [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">in</span> list) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// &quot;0&quot; &quot;1&quot; &quot;2&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i <span class=\"keyword\">of</span> list) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// &quot;4&quot; &quot;5&quot; &quot;6&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>另一个区别是 <code>for ... in</code> 可以操作任何对象；它提供了查看对象属性的一种方法。但是 <code>for ... of</code> 关注于迭代对象的值。内置对象 <code>Map</code> 和 <code>Set</code> 已经实现了 <code>Symbol.iterator</code> 方法，让我们可以访问它们保存的值。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> pets = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"string\">&quot;Cat&quot;</span>, <span class=\"string\">&quot;Dog&quot;</span>, <span class=\"string\">&quot;Hamster&quot;</span>]);</span><br><span class=\"line\">pets[<span class=\"string\">&quot;species&quot;</span>] = <span class=\"string\">&quot;mammals&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">in</span> pets) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(pet);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> pet <span class=\"keyword\">of</span> pets) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(pet); <span class=\"comment\">// &quot;Cat&quot;, &quot;Dog&quot;, &quot;Hamster&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-3-代码生成目标为-ES5-和-ES3\"><a href=\"#14-3-代码生成目标为-ES5-和-ES3\" class=\"headerlink\" title=\"14.3 代码生成目标为 ES5 和 ES3\"></a>14.3 代码生成目标为 <code>ES5</code> 和 <code>ES3</code></h3><blockquote>\n<p>当生成目标为 <code>ES5</code> 或 <code>ES3</code>，迭代器只允许在 <code>Array</code> 类型上使用。在非数组值上使用 <code>for ... of</code> 语句会得到一个错误，就算这些非数组值已经实现了 <code>Symbol.iterator</code> 属性。</p>\n</blockquote>\n<blockquote>\n<p>编译器会生成一个简单的 <code>for</code> 循环做为 <code>for ... of</code> 循环，比如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> num <span class=\"keyword\">of</span> numbers) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 生成的代码为：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">number</span> = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> _i = <span class=\"number\">0</span>; _i &lt; numbers.length; _i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> num = numbers[_i];</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"14-4-目标为-ECMAScript-2015-或更高\"><a href=\"#14-4-目标为-ECMAScript-2015-或更高\" class=\"headerlink\" title=\"14.4 目标为 ECMAScript 2015 或更高\"></a>14.4 目标为 <code>ECMAScript 2015</code> 或更高</h3><blockquote>\n<p>当目标为兼容 <code>ECMAScript 2015</code> 的引擎时，编译器会生成相应引擎的 <code>for ... of</code> 内置迭代器实现方式。</p>\n</blockquote>\n<h2 id=\"十五、模块\"><a href=\"#十五、模块\" class=\"headerlink\" title=\"十五、模块\"></a>十五、模块</h2><h3 id=\"15-1-关于术语的一点说明\"><a href=\"#15-1-关于术语的一点说明\" class=\"headerlink\" title=\"15.1 关于术语的一点说明\"></a>15.1 关于术语的一点说明</h3><blockquote>\n<p>请务必注意一点：<code>TypeScript 1.5</code> 里术语名已经发生了变化。”<code>内部模块</code>“ 现在被称作 “<code>命名空间</code>“。”<code>外部模块</code>“ 现在则简称为 “<code>模块</code>“。这是为了与 <code>ECMAScript 2015</code> 里的术语保持已一致， (也就是说 <code>module X</code> { 相当于现在推荐的写法 <code>namespace X</code> })</p>\n</blockquote>\n<h3 id=\"15-2-介绍\"><a href=\"#15-2-介绍\" class=\"headerlink\" title=\"15.2 介绍\"></a>15.2 介绍</h3><ol>\n<li>从 <code>ECMAScript 2015</code> 开始，<code>JavaScript</code> 引入了模块的概念。<code>TypeScript</code> 也沿用这个概念。</li>\n<li>模块在其自身的作用域里执行，而不是在全局作用域；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用 <code>export</code> 形式之一导出它们。相反，如果想使用其它模块导出的 <code>变量</code>，<code>函数</code>，<code>类</code>，<code>接口</code> 等的时候，你必须要导入它们，可以使用 <code>import</code> 形式之一。</li>\n<li>模块是自声明的；两个模块之间的关系是通过在文件级别上使用 <code>import</code> 和 <code>exports</code> 建立的。</li>\n<li>模块使用模块加载器去导入其它的模块。在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。大家最熟知的 <code>JavaScript</code> 模块加载器是服务与 <code>Node.js</code> 的 <code>CommonJS</code> 和 服务于 <code>Web</code> 应用的 <code>Require.js</code>。</li>\n<li><code>TypeScript</code> 和 <code>ECMAScript 2015</code> 一样，任何包含顶级 <code>import</code> 或者 <code>export</code> 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 <code>import</code> 或者 <code>export</code> 声明，那么它的内容将被视为全局可见的 (因此对模块也是可见的)。</li>\n</ol>\n<h3 id=\"15-3-导出\"><a href=\"#15-3-导出\" class=\"headerlink\" title=\"15.3 导出\"></a>15.3 导出</h3><h4 id=\"15-3-1-导出声明\"><a href=\"#15-3-1-导出声明\" class=\"headerlink\" title=\"15.3.1. 导出声明\"></a>15.3.1. 导出声明</h4><blockquote>\n<p>任何声明( 比如 <code>变量</code>，<code>函数</code>，<code>类</code>，<code>类型别名</code> 或 <code>接口</code> )都能够通过添加 <code>export</code> 关键字来导出。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> numberRegexp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-3-2-导出语句\"><a href=\"#15-3-2-导出语句\" class=\"headerlink\" title=\"15.3.2 导出语句\"></a>15.3.2 导出语句</h4><blockquote>\n<p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator1</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegexp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ZipCodeValidator1 &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ZipCodeValidator1 <span class=\"keyword\">as</span> mainValidator &#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-3-3-重新导出\"><a href=\"#15-3-3-重新导出\" class=\"headerlink\" title=\"15.3.3 重新导出\"></a>15.3.3 重新导出</h4><blockquote>\n<p>我们经常会去扩展其它模块，并且只导出那个模块的那部分内容。</p>\n</blockquote>\n<blockquote>\n<p>重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseIntBasedZipCodeValidator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isAcceptable</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; <span class=\"built_in\">parseInt</span>();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 导出原先的验证器但做了重命名</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ZipCodeValidator <span class=\"keyword\">as</span> RegExpBasedZipCodeValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>或者一个模块可以包裹多个模块，并把它们导出的内容联合在一起，通过语法：<code>export * from &quot;module&quot;</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StringValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./LetterOnlyValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-4-导入\"><a href=\"#15-4-导入\" class=\"headerlink\" title=\"15.4 导入\"></a>15.4 导入</h3><blockquote>\n<p>模块的导入操作与导出一样简单，可以使用以下 <code>import</code> 形式之一来导入其它模块中的导出内容。</p>\n</blockquote>\n<h4 id=\"15-4-1-导入一个模块中的某个导出内容\"><a href=\"#15-4-1-导入一个模块中的某个导出内容\" class=\"headerlink\" title=\"15.4.1 导入一个模块中的某个导出内容\"></a>15.4.1 导入一个模块中的某个导出内容</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以对导入内容重命名</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator <span class=\"keyword\">as</span> ZCV &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> ZCV();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分\"><a href=\"#15-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分\" class=\"headerlink\" title=\"15.4.2 将整个模块导入到一个变量，并通过它来访问模块的导出部分\"></a>15.4.2 将整个模块导入到一个变量，并通过它来访问模块的导出部分</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> validator <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> validator.ZipCodeValidator();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-4-3-具有副作用的导入模块\"><a href=\"#15-4-3-具有副作用的导入模块\" class=\"headerlink\" title=\"15.4.3 具有副作用的导入模块\"></a>15.4.3 具有副作用的导入模块</h4><blockquote>\n<p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。这些模块可能没有任何的导出或用户根本</p>\n</blockquote>\n<blockquote>\n<p>就不关注它的导出。使用下面的方法来导入这些模块。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./my-module.js&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-5-默认导出\"><a href=\"#15-5-默认导出\" class=\"headerlink\" title=\"15.5 默认导出\"></a>15.5 默认导出</h3><blockquote>\n<p>每个模块都可以有一个 <code>default</code> 导出。默认导出使用 <code>default</code> 关键字标记；并且一个模块只能够有一个 <code>default</code> 导出。需要使用 一种特殊的导入形式来导入 <code>default</code> 导出。</p>\n</blockquote>\n<blockquote>\n<p><code>default</code> 导出十分便利。比如，像 <code>JQuery</code> 这样的类库可能有一个默认导出 <code>jQuery</code> 或 <code>$</code>，并且我们基本上也会使用同样的名字 <code>jQuery</code> 或 <code>$</code> 导出 <code>JQuery</code>。</p>\n</blockquote>\n<ul>\n<li><code>JQuery.d.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">let</span> $: JQuery;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> $;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>App.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&quot;JQuery&quot;</span>;</span><br><span class=\"line\">$(<span class=\"string\">&quot;button.continue&quot;</span>).html(<span class=\"string\">&quot;Next step ...&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>类和函数声明可以直接被标记为默认导出。标记为默认导出的类和函数的名字是可以省略的。</p>\n</blockquote>\n<ul>\n<li><code>ZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isAcceptable</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; ZipCodeValidator.numberRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> validator <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myValidator = <span class=\"keyword\">new</span> validator();</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>或者</code></p>\n</blockquote>\n<ul>\n<li><code>StaticZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> validate <span class=\"keyword\">from</span> <span class=\"string\">&quot;./StaticZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"comment\">// use function validate</span></span><br><span class=\"line\">strings.forEach(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; <span class=\"subst\">$&#123;validate(s)&#125;</span> ? &quot; matches&quot; : &quot; does not match&quot;`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>default</code> 导出也可以是一个值</p>\n</blockquote>\n<ul>\n<li><code>OneTwoThree.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Log.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> num <span class=\"keyword\">from</span> <span class=\"string\">&quot;./OneTwoThree&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num); <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>export =</code> 和 <code>import = require()</code></p>\n</blockquote>\n<ol>\n<li><code>CommonJS</code> 和 <code>AMD</code> 的环境里都有一个 <code>exports</code> 变量，这个变量包含了一个模块的所有导出内容。</li>\n<li><code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code> 都可以被赋值为一个对象，这种情况下其作用就类似于 es6 语法里的默认导出，即 <code>export default</code> 语法了。虽然作用相似，但是 <code>export default</code> 语法并不能兼容 <code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code>。</li>\n<li>为了支持 <code>CommonJS</code> 和 <code>AMD</code> 的 <code>exports</code>，<code>TypeScript</code> 提供了 <code>export =</code> 语法。</li>\n<li><code>export =</code> 语法定义一个模块的导出对象。这里的对象一词指的是类，接口，命名空间，函数或枚举。</li>\n<li>若使用 <code>export =</code> 导出一个模块，则必须使用 <code>TypeScript</code> 的特定语法 <code>import module = require(&#39;module&#39;)</code> 来导入此模块。</li>\n</ol>\n<ul>\n<li><code>ZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">isAcceptable</span>(<span class=\"params\">s: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> = ZipCodeValidator; <span class=\"comment\">// 重点</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> zip = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>); <span class=\"comment\">// 重点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98502&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> zip();</span><br><span class=\"line\">strings.forEach(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;validator.isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span>`</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-6-生成模块代码\"><a href=\"#15-6-生成模块代码\" class=\"headerlink\" title=\"15.6 生成模块代码\"></a>15.6 生成模块代码</h3><blockquote>\n<p>根据编译时指定的模块目标参数，编译器会生成相应的供 <code>Node.js\\(CommonJS\\)，Require.js\\(AMD\\)</code>，<code>UMD</code>，<code>SystemJS</code> 或 <code>ECMAScript 2015 native module\\(ES6\\)</code> 模块加载系统使用的代码。</p>\n</blockquote>\n<blockquote>\n<p>想要了解生成代码中 <code>define</code>，<code>require</code> 和 <code>register</code> 的意义，需要参考相应的模块加载器的文档。</p>\n</blockquote>\n<ul>\n<li><code>SimpleModule.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> m = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;mod&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> t = m.something + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>AMD / RequireJS SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./mod&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>, mod_1</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.t = mod_1.something + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>CommonJS / Node SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> mod_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./mod&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">exports</span>.t = mod_1.something + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>UMD SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">factory</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span>.exports === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> v = factory(<span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (v !== <span class=\"literal\">undefined</span>) <span class=\"built_in\">module</span>.exports = v;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;./mod&quot;</span>], factory);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mod_1 = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./mod&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.t = mod_1.something + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>System SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System.register([<span class=\"string\">&quot;./mod&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">exports_1</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> mod_1;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> t;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    setters: [</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">mod_1_1</span>) </span>&#123;</span><br><span class=\"line\">        mod_1 = mod_1_1;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    execute: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      exports_1(<span class=\"string\">&quot;t&quot;</span>, (t = mod_1.something + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Native ECMAScript 2015 modules SimpleModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; something &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./mod&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> t = something + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-7-简单示例\"><a href=\"#15-7-简单示例\" class=\"headerlink\" title=\"15.7 简单示例\"></a>15.7 简单示例</h3><blockquote>\n<p>下面我们来整理一下前面的验证器实现，每个模块只有一个命名的导出。</p>\n</blockquote>\n<blockquote>\n<p>为了编译，我们必须要在命令行上指定一个模块目标。对于 <code>Node.js</code> 来说，使用 <code>--module commonjs</code>；对于 <code>Require.js</code> 来说，使用 <code>--module amd</code>。</p>\n</blockquote>\n<ul>\n<li>比如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc --<span class=\"built_in\">module</span> commonjs Test.ts</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译完成后，每个模块会生成一个单独的 <code>.js</code> 文件。好比使用了 <code>reference</code> 标签，编译器会根据 <code>import</code> 语句编译相应的文件。</p>\n</blockquote>\n<ul>\n<li><code>Validation.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>LetterOnlyValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; StringValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> lettersRegExp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LetterOnlyValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lettersRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; StringValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; StringValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Validation&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; LetterOnlyValidator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./LetterOnlyValidator&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Some samples to try</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Validators to use</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> validators: &#123; [s: <span class=\"built_in\">string</span>]: StringValidator &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> LetterOnlyValidator();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Show whether each string passed each validator</span></span><br><span class=\"line\">strings.forEach(<span class=\"function\"><span class=\"params\">s</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-8-可选的模块加载和其它高级加载场景\"><a href=\"#15-8-可选的模块加载和其它高级加载场景\" class=\"headerlink\" title=\"15.8 可选的模块加载和其它高级加载场景\"></a>15.8 可选的模块加载和其它高级加载场景</h3><ol>\n<li>有时候，你只想在某种条件下才加载某个模块。在 <code>TypeScript</code> 里，使用下面的方式来实现它和其它的高级加载场景，我们可以直接调用模块加载器并且保证类型完全。</li>\n<li>编译器会检测是否每个模块都会在生成的 <code>JavaScript</code> 中用到。如果一个模块标识符只在类型注解部分使用，并且完全没有在表达式中使用时，就不会生成 <code>require</code> 这个模块的代码。省略掉没有用到的引用对性能提升是很有益的，并同时提供了选择性加载模块的能力。</li>\n<li>这种模式的核心是 <code>import id = require(&quot;...&quot;)</code> 语句可以让我们访问模块导出的类型。模块加载器会被动态调用(通过 <code>require</code>)，就像下面的 <code>if</code> 代码块里那样。它利用了省略引用的优化，所以模块只在被需要时加载。为了让这个模块工作，一定要注意 <code>import</code> 定义的标识符只能在表示类型处使用(不能在会转换成 <code>JavaScript</code> 的地方。)</li>\n<li>为了确保类型安全性，我们可以使用 <code>typeof</code> 关键字。<code>typeof</code> 关键字，当在表示类型的地方使用时，会得出一个类型值，这里就表示模块的类型。</li>\n</ol>\n<ul>\n<li><code>示例 1</code>. <code>Node.js</code> 里的动态模块加载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">require</span>(<span class=\"params\">moduleName: <span class=\"built_in\">string</span></span>): <span class=\"title\">any</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator <span class=\"keyword\">as</span> Zip &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidator) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ZipCodeValidator: <span class=\"keyword\">typeof</span> Zip = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (validator.isAcceptable(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">    /!* ... *!/;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>示例 2</code>. <code>require.js</code> 里的动态模块加载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">require</span>(<span class=\"params\">moduleNames: <span class=\"built_in\">string</span>[], onLoad: (...args: <span class=\"built_in\">any</span>[]) =&gt; <span class=\"built_in\">void</span></span>): <span class=\"title\">void</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> Zip <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidator) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">require</span>([<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>], <span class=\"function\">(<span class=\"params\">ZipCodeValidator: <span class=\"keyword\">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> validator = <span class=\"keyword\">new</span> ZipCodeValidator.ZipCodeValidator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (validator.isAcceptable(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">      /!* ... *!/;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>示例 3</code>. <code>System.js</code> 里的动态模块加载</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">const</span> System: <span class=\"built_in\">any</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; ZipCodeValidator <span class=\"keyword\">as</span> Zip &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ZipCodeValidator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (needZipValidator) &#123;</span><br><span class=\"line\">  System.import(<span class=\"string\">&quot;./ZipCodeValidator&quot;</span>).then(<span class=\"function\">(<span class=\"params\">ZipCodeValidator: <span class=\"keyword\">typeof</span> Zip</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x.isAcceptable(<span class=\"string\">&quot;...&quot;</span>)) &#123;</span><br><span class=\"line\">      /!*...*!/;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-9-使用其它的-JavaScript-库\"><a href=\"#15-9-使用其它的-JavaScript-库\" class=\"headerlink\" title=\"15.9 使用其它的 JavaScript 库\"></a>15.9 使用其它的 JavaScript 库</h3><blockquote>\n<p>要想描述非 <code>TypeScript</code> 编写的类库的类型，我们需要声明类库所暴露的 <code>API</code>。</p>\n</blockquote>\n<blockquote>\n<p>我们叫它声明因为它不是’外部程序’的具体实现，它们通常是在 <code>.d.ts</code> 文件里定义的。类似于 <code>C/C++</code> 里的 <code>.h</code> 文件。</p>\n</blockquote>\n<h4 id=\"15-9-1-外部模块\"><a href=\"#15-9-1-外部模块\" class=\"headerlink\" title=\"15.9.1 外部模块\"></a>15.9.1 外部模块</h4><blockquote>\n<p>在 <code>Node.js</code> 里大部分工作是通过加载一个或多个模块实现的。我们可以使用顶级的 <code>export</code> 声明来为每个模块都定义一个 <code>.d.ts</code> 文件，但最好还是写在一个大的 <code>.d.ts</code> 文件里。我们使用与构造一个外部命名空间相似的方法，但是这里使用 <code>module</code> 关键字并且把名字用引号括起来，方便之后 <code>import</code>。</p>\n</blockquote>\n<ul>\n<li><code>例如：</code></li>\n<li><code>node.d.ts(simplified except)</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;url&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Url &#123;</span><br><span class=\"line\">    protocol?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    hostname?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    pathname?: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parse</span>(<span class=\"params\">urlStr: <span class=\"built_in\">string</span>, parseQueryString?, slashesDenoteHost?</span>): <span class=\"title\">Url</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;path&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">normalize</span>(<span class=\"params\">p: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">join</span>(<span class=\"params\">...paths: <span class=\"built_in\">any</span>[]</span>): <span class=\"title\">string</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> sep: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>现在我们可以 <code>/// &lt;reference&gt; node.d.ts</code> 并且使用 <code>import url = require(&#39;url&#39;)</code>；或 <code>import * as URl from &quot;url&quot;</code> 加载模块。`</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;node.d.ts&quot;&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> URL <span class=\"keyword\">from</span> <span class=\"string\">&quot;url&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myUrl = URL.parse(<span class=\"string\">&quot;http://www.typescriptlang.org&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-9-2-外部模块简写\"><a href=\"#15-9-2-外部模块简写\" class=\"headerlink\" title=\"15.9.2 外部模块简写\"></a>15.9.2 外部模块简写</h4><blockquote>\n<p>假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。</p>\n</blockquote>\n<blockquote>\n<p><code>declarations.d.ts</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;hot-new-module&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>简写模块里所有导出类型将是 <code>any</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> x, &#123; y &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;hot-new-module&quot;</span>;</span><br><span class=\"line\">x(y);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-9-3-模块声明通配符\"><a href=\"#15-9-3-模块声明通配符\" class=\"headerlink\" title=\"15.9.3 模块声明通配符\"></a>15.9.3 模块声明通配符</h4><blockquote>\n<p>某些模块加载器如 <code>SystemJS</code> 和 <code>AMD</code> 支持导入非 <code>JavaScript</code> 内容。它们通常会使用一个前缀或后缀来表示特殊的加载语法，模块声明通配符可以用来表示这些情况。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;*!text&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> content: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>some do it the other way around</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;json!*&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> value: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在你可以就导入匹配 <code>&quot;!text&quot;</code> 或 <code>&quot;json!&quot;</code> 的内容了。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> fileContent <span class=\"keyword\">from</span> <span class=\"string\">&quot;./xyz.txt!txt&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> data <span class=\"keyword\">from</span> <span class=\"string\">&quot;json!http://example.com/data.json&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data, fileContent);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-9-4-UMD-模块\"><a href=\"#15-9-4-UMD-模块\" class=\"headerlink\" title=\"15.9.4 UMD 模块\"></a>15.9.4 <code>UMD</code> 模块</h4><blockquote>\n<p>有些模块被设计成兼容多个模块加载器，或者不使用模块加载器(全局变量)。它们以 <code>UMD</code> 模块为代表。这些库可以通过导入的形式或全局变量的形式访问。</p>\n</blockquote>\n<ul>\n<li><code>例如：</code></li>\n<li><code>math-lib.d.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isPrime</span>(<span class=\"params\">x: <span class=\"built_in\">number</span></span>): <span class=\"title\">boolean</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">as</span> <span class=\"keyword\">namespace</span> mathLib;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>之后，这个库可以在某个模块里通过导入来使用:</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; isPrime &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;math-lib&quot;</span>;</span><br><span class=\"line\">isPrime(<span class=\"number\">2</span>);</span><br><span class=\"line\">mathLib.isPrime(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>它同样可以通过全局变量的形式使用，但只能在某个脚本(指不带有模块导入或导出的脚本文件)里。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mathLib.isPrime(<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"15-10-创建模块结构指导\"><a href=\"#15-10-创建模块结构指导\" class=\"headerlink\" title=\"15.10 创建模块结构指导\"></a>15.10 创建模块结构指导</h3><h4 id=\"15-10-1-尽可能地在顶层导出\"><a href=\"#15-10-1-尽可能地在顶层导出\" class=\"headerlink\" title=\"15.10.1 尽可能地在顶层导出\"></a>15.10.1 尽可能地在顶层导出</h4><ol>\n<li>用户应该更容易地使用你模块导出的内容。嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</li>\n<li>从你的模块中导出一个命名空间就是一个增加嵌套的例子。虽然命名空间有时候有它们的用处，在使用模块的时候它们额外地增加了一层。这对用户来说是很不方便的并且通常是多余的。</li>\n<li>导出类的静态方法也有同样的问题 - 这个类本身就增加了一层嵌套。除非它能方便地表述或便于清晰使用，否则请考虑直接导出一个辅助方法。</li>\n</ol>\n<h4 id=\"15-10-2-如果仅导出单个-class-或-function，使用-export-default\"><a href=\"#15-10-2-如果仅导出单个-class-或-function，使用-export-default\" class=\"headerlink\" title=\"15.10.2 如果仅导出单个 class 或 function，使用 export default\"></a>15.10.2 如果仅导出单个 <code>class</code> 或 <code>function</code>，使用 <code>export default</code></h4><blockquote>\n<p>就像” <code>在顶层导出</code> “帮助减少用户使用的难度，一个默认的导出也能起到这个效果。如果一个模块就是为了导出特定的内容，那么你应该考虑使用一个默认导出。这会令模块的导入和使用变得些许简单，比如：</p>\n</blockquote>\n<ul>\n<li><code>MyClass.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeType</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    /!* ... *!/;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>MyFunc.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getThing</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;thing&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Consumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> t <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyClass&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> f <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyFunc&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> t();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(f());</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对用户来说这是最理想的。他们可以随意命名导入模块的类型 (本例为 <code>t</code> ) 并且不需要多余的 ( <code>.</code> ) 来找到相关对象。</p>\n</blockquote>\n<h4 id=\"15-10-3-如果要导出多个对象，把它们放在顶层里导出\"><a href=\"#15-10-3-如果要导出多个对象，把它们放在顶层里导出\" class=\"headerlink\" title=\"15.10.3 如果要导出多个对象，把它们放在顶层里导出\"></a>15.10.3 如果要导出多个对象，把它们放在顶层里导出</h4><ul>\n<li><code>MyThings.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SomeType</span> </span>&#123;/!*...*!/&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">someFunc</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*...*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-10-4-相反地，当导入的时候-明确地列出导入的名字。\"><a href=\"#15-10-4-相反地，当导入的时候-明确地列出导入的名字。\" class=\"headerlink\" title=\"15.10.4 (相反地，当导入的时候)明确地列出导入的名字。\"></a>15.10.4 (相反地，当导入的时候)明确地列出导入的名字。</h4><ul>\n<li><code>Consumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; SomeType, someFunc &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyThings&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> SomeType();</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = someFunc();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-10-5-使用命名空间导入模式当你要导出大量内容的时候\"><a href=\"#15-10-5-使用命名空间导入模式当你要导出大量内容的时候\" class=\"headerlink\" title=\"15.10.5 使用命名空间导入模式当你要导出大量内容的时候\"></a>15.10.5 使用命名空间导入模式当你要导出大量内容的时候</h4><ul>\n<li><code>MyLargeModule.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Flower</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Consumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> myLargeModule <span class=\"keyword\">from</span> <span class=\"string\">&quot;./MyLargeModule.ts&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"keyword\">new</span> myLargeModule.Dog();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-10-6-使用重新导出进行扩展\"><a href=\"#15-10-6-使用重新导出进行扩展\" class=\"headerlink\" title=\"15.10.6 使用重新导出进行扩展\"></a>15.10.6 使用重新导出进行扩展</h4><blockquote>\n<p>你可能经常需要扩展一个模块的功能。<code>JS</code> 里常用的一个模式是 <code>JQuery</code> 那样去扩展原对象。如我们之前提到的，模块不会像全局命名空间那样去合并。推荐的方案是 不要去改变原来的对象，而是导出一个新的实体来提供新的功能。</p>\n</blockquote>\n<blockquote>\n<p>假设 <code>Calculator.ts</code> 模块里定义了一个简单的计算器实现。这个模块同样提供了一个辅助函数来测试计算器的功能，通过传入一系列输入的字符串并在最后给出结果。</p>\n</blockquote>\n<ul>\n<li><code>Calculator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> memory = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> operator: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">processDigit</span>(<span class=\"params\">digit: <span class=\"built_in\">string</span>, currentValue: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (digit &gt;= <span class=\"string\">&quot;0&quot;</span> &amp;&amp; digit &lt;= <span class=\"string\">&quot;9&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> currentValue * <span class=\"number\">10</span> + (digit.charCodeAt(<span class=\"number\">0</span>) - <span class=\"string\">&quot;0&quot;</span>.charCodeAt(<span class=\"number\">0</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">processOperator</span>(<span class=\"params\">operator: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ([<span class=\"string\">&quot;+&quot;</span>, <span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;/&quot;</span>].indexOf(operator) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> operator;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">protected</span> evaluateOperator(operator: <span class=\"built_in\">string</span>, <span class=\"attr\">left</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">right</span>: <span class=\"built_in\">number</span>): <span class=\"built_in\">number</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">this</span>.operator) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;+&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;-&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left - right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;*&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left * right;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">&quot;/&quot;</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left / right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"title\">evaluate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.operator) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.memory = <span class=\"built_in\">this</span>.evaluateOperator(<span class=\"built_in\">this</span>.operator, <span class=\"built_in\">this</span>.memory, <span class=\"built_in\">this</span>.current);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.memory = <span class=\"built_in\">this</span>.current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.current = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">handleChar</span>(<span class=\"params\">char: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (char === <span class=\"string\">&quot;=&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.evaluate();</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> value = Calculator.processDigit(char, <span class=\"built_in\">this</span>.current);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.current = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = Calculator.processOperator(char);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.evaluate();</span><br><span class=\"line\">          <span class=\"built_in\">this</span>.operator = value;</span><br><span class=\"line\">          <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`Unsupported input: &#x27;<span class=\"subst\">$&#123;char&#125;</span>&#x27;`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">getResult</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.memory;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">c: Calculator, input: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; input.length; i++) &#123;</span><br><span class=\"line\">    c.handleChar(input[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`result of &#x27;<span class=\"subst\">$&#123;input&#125;</span>&#x27; is &#x27;<span class=\"subst\">$&#123;c.getResult()&#125;</span>&#x27;`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>下面使用导出的 <code>test</code> 函数来测试计算器</li>\n<li><code>TestCalculator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Calculator, test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> Calculator();</span><br><span class=\"line\">test(c, <span class=\"string\">&quot;1+2*33/11=&quot;</span>); <span class=\"comment\">// prints 9</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>现在扩展它，添加支持输入其它进制(十进制以外)。</li>\n<li><code>ProgrammerCalculator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Calculator &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ProgrammerCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">Calculator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> digits = [<span class=\"string\">&quot;0&quot;</span>, <span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;3&quot;</span>, <span class=\"string\">&quot;4&quot;</span>, <span class=\"string\">&quot;5&quot;</span>, <span class=\"string\">&quot;6&quot;</span>, <span class=\"string\">&quot;7&quot;</span>, <span class=\"string\">&quot;8&quot;</span>, <span class=\"string\">&quot;9&quot;</span>, <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>, <span class=\"string\">&quot;F&quot;</span>];</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"><span class=\"keyword\">public</span> base: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> maxBase = ProgrammerCalculator.digits.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (base &lt;= <span class=\"number\">0</span> || base &gt; maxBase) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`base has to be within 0 to <span class=\"subst\">$&#123;maxBase&#125;</span> inclusive`</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">protected</span> <span class=\"function\"><span class=\"title\">processDigit</span>(<span class=\"params\">digit: <span class=\"built_in\">string</span>, currentValue: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ProgrammerCalculator.digits.indexOf(digit) &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> currentValue * <span class=\"built_in\">this</span>.base + ProgrammerCalculator.digits.indexOf(digit);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; ProgrammerCalculator <span class=\"keyword\">as</span> Calculator &#125;;</span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./Calculator&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>新的 <code>ProgrammerCalculator</code> 模块导出的 API 与原先的 <code>Calculator</code> 模块很相似，但却没有改变原模块里的对象。</p>\n</blockquote>\n<ul>\n<li><code>TestProgrammerCalculator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Calculator, test &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./ProgrammerCalculator&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> Calculator(<span class=\"number\">2</span>);</span><br><span class=\"line\">test(c, <span class=\"string\">&quot;001+010=&quot;</span>); <span class=\"comment\">// prints 3</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"15-10-7-模块里不要使用命名空间\"><a href=\"#15-10-7-模块里不要使用命名空间\" class=\"headerlink\" title=\"15.10.7 模块里不要使用命名空间\"></a>15.10.7 模块里不要使用命名空间</h4><blockquote>\n<p>当初次进入基于模块的开发模式时，可能总会控制不住要将导出包裹在一个命名空间里。模块具有其自己的作用域，并且只有导出的声明才会在模块外部可见。记住这点，命名空间在使用模块时几乎没什么价值。</p>\n</blockquote>\n<blockquote>\n<p>在组织方面，命名空间对于在全局作用域内对逻辑上相关的对象和类型分组是很便利的。例如，在 <code>C\\#</code> 里，你会从 <code>System.Collections</code> 里找到所有集合的类型。通过将类型有层次地组织在命名空间里，可以方便用户找到与使用那些类型。然而，模块本身已经存在于文件系统之中，这是必须的。我们必须通过路径和文件名找到它们，这已经提供了一种逻辑上的组织形式。我们可以创建 <code>/collections/generic/</code> 文件夹，把相应模块放在这里。</p>\n</blockquote>\n<blockquote>\n<p>命名空间对解决全局作用域里命名冲突来说是很重要的。比如，你有一个 <code>My.Application.Customer.AddFrom</code> 和 <code>My.Application.Order.AddForm</code> <code>--</code> 两个类型的名字相同，但命名空间不同。然而，这对于模块来说却不是一个问题。在一个模块里，没有理由两个对象拥有同一个名字。从模块的使用角度来说，使用者会挑出它们用来引用模块的名字，所以也没有理由发声重名的情况。</p>\n</blockquote>\n<h4 id=\"15-10-8-危险信号\"><a href=\"#15-10-8-危险信号\" class=\"headerlink\" title=\"15.10.8 危险信号\"></a>15.10.8 危险信号</h4><blockquote>\n<p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间。</p>\n</blockquote>\n<ol>\n<li>文件的顶层声明是 <code>export namespace Foo &#123;...&#125;</code> ( 删除 <code>Foo</code> 并把所有内容向上层移动一层)</li>\n<li>文件只有一个 <code>export class</code> 或 <code>export function</code> (考虑使用 <code>export default</code>)</li>\n<li>多个文件的顶层具有同样的 <code>export namespace Foo</code> {( 不要以为这些会合并到一个 <code>Foo</code> 中! )}</li>\n</ol>\n<h2 id=\"十六、命名空间\"><a href=\"#十六、命名空间\" class=\"headerlink\" title=\"十六、命名空间\"></a>十六、命名空间</h2><h3 id=\"16-1-介绍\"><a href=\"#16-1-介绍\" class=\"headerlink\" title=\"16.1 介绍\"></a>16.1 介绍</h3><blockquote>\n<p>这篇文章描述了如何在 <code>TypeScript</code> 里使用命名空间(之前叫做”内部模块”)来组织你的代码。就像我们在术语说明里提到的那样，<code>&quot;内部模块&quot;</code> 现在叫做 <code>&quot;命名空间&quot;</code>。另外，任何使用 <code>module</code> 关键字来声明一个内部模块的地方都应该使用 <code>namespace</code> 关键字来替换。这就避免了让新的使用者被相似的名称所迷惑。</p>\n</blockquote>\n<ul>\n<li><code>第一步</code></li>\n</ul>\n<blockquote>\n<p>我们先来写一段程序并将在整篇文章中都使用这个例子。我们定义几个简单的字符串验证器，</p>\n</blockquote>\n<blockquote>\n<p>假设你会使用它们来验证表单里的用户输入或验证外部数据。</p>\n</blockquote>\n<ul>\n<li><code>所有验证器都放在一个文件里</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> letterRegExp = <span class=\"regexp\">/^[A-Za-z]$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LetterOnlyValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> letterRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">  isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> validators: &#123; [s: <span class=\"built_in\">string</span>]: StringValidator &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> ZipCodeValidator();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters Only&quot;</span>] = <span class=\"keyword\">new</span> LetterOnlyValidator();</span><br><span class=\"line\"><span class=\"comment\">// show whether each string passed each validator</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> isMatch = validators[name].isAcceptable(s);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`&#x27;<span class=\"subst\">$&#123;s&#125;</span>&#x27; <span class=\"subst\">$&#123;isMatch ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> &#x27;<span class=\"subst\">$&#123;name&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-2-命名空间\"><a href=\"#16-2-命名空间\" class=\"headerlink\" title=\"16.2 命名空间\"></a>16.2 命名空间</h3><blockquote>\n<p>随着更多验证器的加入，我们需要一种手段来组织代码，以便于在记录它们类型的同时还不用担心与其它对象产生命名冲突。因此，我们把验证器包裹到一个命名空间里内，而不是把它们放在全局空间下。</p>\n</blockquote>\n<blockquote>\n<p>下面的例子里，把所有与验证器相关的类型都放到一个叫做 <code>Validation</code> 的命名空间里。因为我们想让这些接口和类在命名空间之外也是可访问的，所以需要使用 <code>export</code>。相反的，变量 <code>LetterRegExp</code> 和 <code>numberRegExp</code> 是实现的细节，不需要导出，因此它们在命名空间外是不能访问的。在文件末尾的测试代码里，由于是在命名空间之外访问的，因此需要限定类型的名称，比如 <code>Validation.LettersOnlyValidator</code>。</p>\n</blockquote>\n<ul>\n<li>使用命名空间的验证器</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Validation &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> LetterRegExp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LetterOnlyValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> LetterRegExp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> validators: &#123; [s: <span class=\"built_in\">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP Code&quot;</span>] = <span class=\"keyword\">new</span> Validation.ZipCodeValidator();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters Only&quot;</span>] = <span class=\"keyword\">new</span> Validation.LetterOnlyValidator();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`&#x27;<span class=\"subst\">$&#123;s&#125;</span>&#x27; <span class=\"subst\">$&#123;validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> &#x27;<span class=\"subst\">$&#123;name&#125;</span>&#x27;.`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-3-分离到多文件\"><a href=\"#16-3-分离到多文件\" class=\"headerlink\" title=\"16.3 分离到多文件\"></a>16.3 分离到多文件</h3><blockquote>\n<p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以方便维护。</p>\n</blockquote>\n<h4 id=\"16-3-1-多文件中的命名空间\"><a href=\"#16-3-1-多文件中的命名空间\" class=\"headerlink\" title=\"16.3.1 多文件中的命名空间\"></a>16.3.1 多文件中的命名空间</h4><blockquote>\n<p>现在，我们把 <code>Validation</code> 命名空间分割成多个文件。尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。</p>\n</blockquote>\n<ul>\n<li><code>Validation.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Validation &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator &#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>LetterOnlyValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;;</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Validation &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lettersRegExp = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LettersOnlyValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> lettersRegExp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>ZipCodeValidator.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Validation &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> numberRegExp = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZipCodeValidator</span> <span class=\"title\">implements</span> <span class=\"title\">StringValidator</span> </span>&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> s.length === <span class=\"number\">5</span> &amp;&amp; numberRegExp.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Test.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;Validation.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;LettersOnlyValidator.ts&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;ZipCodeValidator.ts&quot; /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Some samples to try</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> strings = [<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;98052&quot;</span>, <span class=\"string\">&quot;101&quot;</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Validators to use</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> validators: &#123; [s: <span class=\"built_in\">string</span>]: Validation.StringValidator &#125; = &#123;&#125;;</span><br><span class=\"line\">validators[<span class=\"string\">&quot;ZIP code&quot;</span>] = <span class=\"keyword\">new</span> Validation.ZipCodeValidator();</span><br><span class=\"line\">validators[<span class=\"string\">&quot;Letters only&quot;</span>] = <span class=\"keyword\">new</span> Validation.LettersOnlyValidator();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Show whether each string passed each validator</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> s <span class=\"keyword\">of</span> strings) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> name <span class=\"keyword\">in</span> validators) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`&quot;<span class=\"subst\">$&#123;s&#125;</span>&quot; - <span class=\"subst\">$&#123;validators[name].isAcceptable(s) ? <span class=\"string\">&quot;matches&quot;</span> : <span class=\"string\">&quot;does not match&quot;</span>&#125;</span> <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。我们有两种方式。</p>\n</blockquote>\n<ol>\n<li>第一种方式，把所有的输入文件编译为一个输出文件，需要使用 <code>--outFile</code> 标记： <code>tsc --outFile sample.js Test.ts</code> 编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。 <code>tsc --outFile sample.js Validation.ts LetterOnlyValidator.ts ZipCodeValidator.ts Test.ts</code></li>\n<li>第二种方式，我们可以编写每一个文件(默认方式)，那么每个源文件都会对应生成一个 <code>JavaScript</code> 文件。然后，在页面上通过 <code>&lt;script&gt;</code> 标签把所有生成的 <code>JavaScript</code> 文件按正确的顺序引进来，比如：</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyTestPage.html (excerpt)</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;Validation.js&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;LettersOnlyValidator.js&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> /&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;ZipCodeValidator.js&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> /&gt;</span></span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;Test.js&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> /&gt;</span></span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"16-4-别名\"><a href=\"#16-4-别名\" class=\"headerlink\" title=\"16.4 别名\"></a>16.4 别名</h3><blockquote>\n<p>另一种简化命名空间操作的方法是用 <code>import q = x.y.z</code> 给常用的对象起一个短的名字。不要与用来加载模块的 <code>import x = require(&#39;name&#39;)</code> 语法弄混了，这里的语法是为指定的符号创建一个别名。你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Shapes &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> Polygons &#123;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Polygons = Shapes.Polygons;</span><br><span class=\"line\"><span class=\"keyword\">let</span> sq = <span class=\"keyword\">new</span> Polygons.Square(); <span class=\"comment\">// Same as &quot;new Shapes.Polygons.Square()&quot;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：我们并没有使用 <code>require</code> 关键字，而是直接使用导入符号的限定名赋值。这与使用 <code>var</code> 相似，但它还适用于类型和导入的具有命名空间含义的符号。重要的是，对于值来讲，<code>import</code> 会生成与原始符号不同的引用，所以改变别名的 <code>var</code> 值并不会影响原始变量的值。</p>\n</blockquote>\n<h3 id=\"16-5-使用其它的-JavaScript-库\"><a href=\"#16-5-使用其它的-JavaScript-库\" class=\"headerlink\" title=\"16.5 使用其它的 JavaScript 库\"></a>16.5 使用其它的 JavaScript 库</h3><blockquote>\n<p>为了描述不是用 <code>TypeScript</code> 编写的类库的类型，我们需要声明类库导出的 <code>API</code>。由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。我们称其为声明是因为它不是外部程序的具体实现。我们通常在 <code>.d.ts</code> 里写这些声明。如果你熟悉 <code>C/C+</code>+，你可以把它们当作 <code>.h</code> 文件。</p>\n</blockquote>\n<blockquote>\n<p>外部命名空间 (<code>declare namespace =&gt;</code>; 声明全局对象)</p>\n</blockquote>\n<blockquote>\n<p>流行的程序库 <code>D3</code> 在全局对象 <code>d3</code> 里定义它的功能。因为这个库通过一个<code>&lt;script&gt;</code> 标签加载 (不是通过模块加载器)，它的声明文件使用内部模块来定义它的类型。为了让 <code>TypeScript</code> 编译器识别它的类型，我们使用外部命名空间声明。</p>\n</blockquote>\n<ul>\n<li>比如，我们可以像下面这样写</li>\n<li><code>D3.d.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> D3 &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Selectors &#123;</span><br><span class=\"line\">    select: &#123;</span><br><span class=\"line\">      (selector: <span class=\"built_in\">string</span>): Selection;</span><br><span class=\"line\">      (element: EventTarget): Selection;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Event &#123;</span><br><span class=\"line\">    x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Base <span class=\"keyword\">extends</span> Selectors &#123;</span><br><span class=\"line\">    event: Event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> d3: D3.Base;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"十七、命名空间和模块\"><a href=\"#十七、命名空间和模块\" class=\"headerlink\" title=\"十七、命名空间和模块\"></a>十七、命名空间和模块</h2><h3 id=\"17-1-介绍\"><a href=\"#17-1-介绍\" class=\"headerlink\" title=\"17.1 介绍\"></a>17.1 介绍</h3><blockquote>\n<p>这篇文章将概括介绍在 <code>TypeScript</code> 里使用模块与命名空间来组织代码的方法。我们也会谈及命名空间和模块的高级使用场景，和在使用它们的过程中常见的陷阱。</p>\n</blockquote>\n<h3 id=\"17-2-使用命名空间\"><a href=\"#17-2-使用命名空间\" class=\"headerlink\" title=\"17.2 使用命名空间\"></a>17.2 使用命名空间</h3><blockquote>\n<p>命名空间是位于全局命名空间下的一个普通的带有名字的 <code>JavaScript</code> 对象。这令命名空间十分容易使用。它们可以在多文件中同时使用，并通过 <code>--outFile</code> 结合在一起。命名空间是帮你组织 <code>Web</code> 应用不错的方式，你可以把所有依赖都放在 <code>HTML</code> 页面的 <code>&lt;script&gt;</code> 标签里。但就像其它的全局命名空间污染一样，它很难去识别组件之间的依赖关系，尤其是在大型应用中。</p>\n</blockquote>\n<h3 id=\"17-3-使用模块\"><a href=\"#17-3-使用模块\" class=\"headerlink\" title=\"17.3 使用模块\"></a>17.3 使用模块</h3><ol>\n<li>像命名空间一样，模块可以包含代码和声明。不同的模块可以声明它的依赖。</li>\n<li>模块会把依赖添加到模块加载器上(像是 <code>CommonJS</code> / <code>RequireJS</code>)。对于小型的 JS 应用来说可能没必要，但是对于大型应用，这一点点的花费会带来长久的模块化和可维护性上的便利。模块也提供了更好的代码重用，更强的封闭性以及更好的使用工具进行优化。</li>\n<li>对于 <code>Node.js</code> 应用来说，模块是默认并推荐的组织代码的方式。</li>\n<li>从 <code>ECMAScript 2015</code> 开始，模块成为了语言内置的部分，应该会被所有正常的解释引擎所支持。</li>\n</ol>\n<blockquote>\n<p>因此，对于新项目来说推荐使用模块作为组织代码的方式。</p>\n</blockquote>\n<h3 id=\"17-4-命名空间和模块的陷阱\"><a href=\"#17-4-命名空间和模块的陷阱\" class=\"headerlink\" title=\"17.4 命名空间和模块的陷阱\"></a>17.4 命名空间和模块的陷阱</h3><blockquote>\n<p>这部分我们会描述常见的命名空间和模块的使用陷阱和如何其避免它们。</p>\n</blockquote>\n<h4 id=\"17-4-1-对模块使用-lt-reference-gt\"><a href=\"#17-4-1-对模块使用-lt-reference-gt\" class=\"headerlink\" title=\"17.4.1 对模块使用 /// &lt;reference&gt;\"></a>17.4.1 对模块使用 <code>/// &lt;reference&gt;</code></h4><blockquote>\n<p>一个常见的错误是使用 <code>/// &lt;reference&gt;</code> 引用模块文件，应该使用 <code>import</code>。要理解这之间的差别，我们首先应该弄清编译器是如何根据 <code>import</code> 路径(例如：<code>import x from &quot;...&quot;</code>；或 <code>import x = require(&quot;...&quot;)</code> 里面的 <code>...</code>，等等)来定位模块的类型信息的。</p>\n</blockquote>\n<blockquote>\n<p>编译器首先尝试去查找相应路径下的 <code>.ts</code>，<code>.tsx</code> 再或者 <code>.d.ts</code>。如果这些文件都找不到，编译器会查找外部模块声明。回想一下，它们是在 <code>.d.ts</code> 文件里声明的。</p>\n</blockquote>\n<ul>\n<li><code>myModules.d.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// In a .d.ts file or .ts file that is not a module</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;SomeModule&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>): <span class=\"title\">string</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>myOtherModule.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;myModules.d.ts&quot;&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> m <span class=\"keyword\">from</span> <span class=\"string\">&quot;SomeModule&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的引用标签指定了外来模块的位置。这就是一些 <code>TypeScript</code> 例子中引用 <code>node.d.ts</code> 的方法。</p>\n</blockquote>\n<h4 id=\"17-4-2-不必要的命名空间\"><a href=\"#17-4-2-不必要的命名空间\" class=\"headerlink\" title=\"17.4.2 不必要的命名空间\"></a>17.4.2 不必要的命名空间</h4><blockquote>\n<p>如果你想把命名空间转换为模块，它可能会像下面这个文件一样。</p>\n</blockquote>\n<ul>\n<li><code>shapes.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">namespace</span> Shapes &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>顶层的模块 <code>Shapes</code> 包裹了 <code>Triangle</code> 和 <code>Square</code>。对于使用它的人来说这是令人迷惑和讨厌的。</p>\n</blockquote>\n<ul>\n<li><code>shapeConsumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> shapes <span class=\"keyword\">from</span> <span class=\"string\">&quot;./shapes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> shapes.Shapes.Triangle(); <span class=\"comment\">// shapes.Shapes?</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>TypeScript</code> 里模块的一个特点是不同的模块永远也不会在相同的作用域内使用相同的名字。因为使用模块的人会为它们命名，所以完全没有必要把导出的符号包裹在一个命名空间里。再次重申，不应该对模块使用命名空间。使用命名空间是为了提供逻辑分组和避免命名冲突。模块文件本身已经是一个逻辑分组，并且它的名字是由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层。</p>\n</blockquote>\n<ul>\n<li>下面是改进的例子：</li>\n<li><code>shape.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Triangle</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>shapeConsumer.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> shapes <span class=\"keyword\">from</span> <span class=\"string\">&quot;./shapes&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> t = <span class=\"keyword\">new</span> shapes.Triangle();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"17-4-3-模块的取舍\"><a href=\"#17-4-3-模块的取舍\" class=\"headerlink\" title=\"17.4.3 模块的取舍\"></a>17.4.3 模块的取舍</h4><blockquote>\n<p>就像每个 <code>JS</code> 文件对应一个模块一样，<code>TypeScript</code> 里模块文件与生成的 <code>JS</code> 文件也是一一对应的。这会产生一种影响，根据你指定的目标模块系统的不同，你可能无法连接多个模块源文件。例如当目标模块系统为 <code>commonjs</code> 或 <code>umd</code> 时，无法使用 <code>outFile</code> 选项，但是 <code>TypeScript 1.8</code> 以上的版本能够使用 <code>outFile</code> 当目标为 <code>amd</code> 或 <code>system</code>。</p>\n</blockquote>\n<h2 id=\"十八、模块解析\"><a href=\"#十八、模块解析\" class=\"headerlink\" title=\"十八、模块解析\"></a>十八、模块解析</h2><h3 id=\"18-1-说明\"><a href=\"#18-1-说明\" class=\"headerlink\" title=\"18.1 说明\"></a>18.1 说明</h3><ol>\n<li>模块解析是指编译器在查找导入模块内容时所遵循的流程。假设有一个导入语句 <code>import &#123; a &#125; from &quot;moduleA&quot;</code>; 为了去检查任何对 <code>a</code> 的使用，编译器需要准确的知道它表示什么，并且需要检查它的定义 <code>moduleA</code>。</li>\n<li>这时候，编译器会有个疑问“ <code>moduleA</code> 的结构是怎样的？” 这听上去很简单，但 moduleA 可能在你写的某个 .ts/.tsx 文件里或者在你的代码所依赖的 <code>.d.ts</code> 里。</li>\n<li>首先，编译器会尝试定位表示导入模块的文件。编译器会遵循以下二种策略之一： <code>Classic</code> 或 <code>Node</code>。这些策略会告诉编译器到哪里去查找 <code>moduleA</code>。</li>\n<li>如果上面的解析失败了并且模块名是非相对的（且是在” <code>moduleA</code> “的情况下），编译器会尝试定位一个外部模块声明。我们接下来会讲到非相对导入。</li>\n</ol>\n<p><code>5</code>. 最后，如果编译器还是不能解析这个模块，它会记录一个错误。 在这种情况下，错误可能为 <code>error TS2307: Cannot find module &#39;moduleA&#39;.</code></p>\n<h3 id=\"18-2-相对-vs-非相对模块导入\"><a href=\"#18-2-相对-vs-非相对模块导入\" class=\"headerlink\" title=\"18.2 相对 vs. 非相对模块导入\"></a>18.2 相对 vs. 非相对模块导入</h3><blockquote>\n<p>根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。</p>\n</blockquote>\n<ol>\n<li>相对导入是以 <code>/，./</code> 或 <code>../</code> 开头的。 下面是一些例子：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Entry <span class=\"keyword\">from</span> <span class=\"string\">&quot;./components/Entry&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Default &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;../constants/http&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;/mod&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>所有其它形式的导入被当作非相对的。下面是一些例子：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> $ <span class=\"keyword\">from</span> <span class=\"string\">&quot;JQuery&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@angular/core&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>相对导入在解析时是相对于导入它的文件，并不能解析为一个外部模块声明。你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。</p>\n</blockquote>\n<blockquote>\n<p>非相对模块的导入可以相对于 baseUrl 或 通过下文会讲到的路径映射来解析。它们还可以被解析成 外部模块声明。</p>\n</blockquote>\n<blockquote>\n<p>使用非相对路径来导入你的外部依赖。</p>\n</blockquote>\n<h3 id=\"18-3-模块解析策略\"><a href=\"#18-3-模块解析策略\" class=\"headerlink\" title=\"18.3 模块解析策略\"></a>18.3 模块解析策略</h3><blockquote>\n<p>共有两种可用的模块解析策略：<code>Node</code> 和 <code>Classic</code>。 你可以使用 <code>--moduleResolution</code> 标记来指定使用哪种模块解析策略。若未指定，那么在使用了 -<code>-module AMD \\| System \\| ES2015</code> 时的默认值为 <code>Classic</code>，其它情况时则为 <code>Node</code>。</p>\n</blockquote>\n<h4 id=\"18-3-1-Classic\"><a href=\"#18-3-1-Classic\" class=\"headerlink\" title=\"18.3.1 Classic\"></a>18.3.1 Classic</h4><blockquote>\n<p>这种策略在以前是 <code>TypeScript</code> 默认的解析策略。 现在，它存在的理由主要是为了向后兼容。</p>\n</blockquote>\n<blockquote>\n<p>相对导入的模块是相对于导入它的文件进行解析的。 因此 <code>/root/src/folder/A.ts</code> 文件里的 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code> 会使用下面的查找流程：</p>\n</blockquote>\n<ol>\n<li>/root/src/folder/moduleB.ts``</li>\n<li>/root/src/folder/moduleB.d.ts``</li>\n</ol>\n<blockquote>\n<p>对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。</p>\n</blockquote>\n<ul>\n<li><code>比如：</code></li>\n</ul>\n<blockquote>\n<p>有一个对 <code>moduleB</code> 的非相对导入 <code>import &#123; b &#125; from &quot;moduleB&quot;</code>，它是在 <code>/root/src/folder/A.ts</code> 文件里，会以如下的方式来定位”<code>moduleB</code>“：</p>\n</blockquote>\n<blockquote>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/moduleB.ts</code></li>\n<li><code>/root/moduleB.d.ts</code></li>\n<li><code>/moduleB.ts</code></li>\n<li><code>/moduleB.d.ts</code></li>\n</ol>\n</blockquote>\n<h4 id=\"18-3-2-Node\"><a href=\"#18-3-2-Node\" class=\"headerlink\" title=\"18.3.2 Node\"></a>18.3.2 Node</h4><blockquote>\n<p>这个解析策略试图在运行时模仿 <code>Node.js</code> 模块解析机制。完整的 <code>Node.js</code> 解析算法可以在 <code>Node.js module documentation</code> 找到。</p>\n</blockquote>\n<ul>\n<li>Node.js 如何解析模块</li>\n</ul>\n<blockquote>\n<p>为了理解 <code>TypeScript</code> 编译依照的解析步骤，先弄明白<code>Node.js</code>模块是非常重要的。</p>\n</blockquote>\n<blockquote>\n<p>通常，在 <code>Node.js</code> 里导入是通过 <code>require</code> 函数调用进行的。 <code>Node.js</code> 会根据 <code>require</code> 是相对路径还是非相对路径做出不同的行为。</p>\n</blockquote>\n<blockquote>\n<p>相对路径很简单。 例如，假设有一个文件路径为 <code>/root/src/moduleA.js</code>，包含了一个导入 <code>var x = require(&quot;./moduleB&quot;)</code>;</p>\n</blockquote>\n<ul>\n<li>Node.js 以下面的顺序解析这个导入</li>\n</ul>\n<ol>\n<li>检查 <code>/root/src/moduleB.js</code> 文件是否存在。</li>\n<li>检查 <code>/root/src/moduleB</code> 目录是否包含一个 <code>package.json</code> 文件，且 <code>package.json</code> 文件指定了一个”<code>main</code>“模块。</li>\n</ol>\n<blockquote>\n<p>在我们的例子里，如果 <code>Node.js</code> 发现文件 <code>/root/src/moduleB/package.json</code> 包含了 <code>&#123; &quot;main&quot;: &quot;lib/mainModule.js&quot; &#125;</code>，那么 <code>Node.js</code> 会引用 <code>/root/src/moduleB/lib/mainModule.js</code>。</p>\n</blockquote>\n<ol start=\"3\">\n<li>检查 <code>/root/src/moduleB</code> 目录是否包含一个 <code>index.js</code> 文件。 这个文件会被隐式地当作那个文件夹下的”<code>main</code>“模块。</li>\n</ol>\n<p>你可以阅读 <code>Node.js</code> 文档了解更多详细信息：<a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">file modules</a> 和 <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">folder modules</a>。</p>\n<blockquote>\n<p>但是，非相对模块名的解析是个完全不同的过程。<code>Node</code> 会在一个特殊的文件夹 <code>node\\_modules</code> 里查找你的模块。<code>node\\_modules</code> 可能与当前文件在同一级目录下，或者在上层目录里。<code>Node</code> 会向上级目录遍历，查找每个 <code>node\\_modules</code>直到它找到要加载的模块。<br>还是用上面例子，但假设 <code>/root/src/moduleA.js</code> 里使用的是非相对路径导入 <code>var x = require(&quot;moduleB&quot;)</code>;</p>\n</blockquote>\n<ul>\n<li><code>Node</code> 则会以下面的顺序去解析 <code>moduleB</code>，直到有一个匹配上。</li>\n</ul>\n<blockquote>\n<p>1.<code>/root/src/node_modules/moduleB.js</code> 2.<code>/root/src/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 3.<code>/root/src/node_modules/moduleB/index.js</code> 4.<code>/root/node_modules/moduleB.js</code> 5.<code>/root/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 6.<code>/root/node_modules/moduleB/index.js</code> 7.<code>/node_modules/moduleB.js</code> 8.<code>/node_modules/moduleB/package.json (如果指定了&quot;main&quot;属性)</code> 9.<code>/node_modules/moduleB/index.js</code></p>\n</blockquote>\n<blockquote>\n<p>注意 <code>Node.js</code> 在步骤（<code>4</code>）和（<code>7</code>）会向上跳一级目录。<br>你可以阅读 <code>Node.js</code> 文档了解更多详细信息：<a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\">loading modules from node_modules</a>。</p>\n</blockquote>\n<ul>\n<li>TypeScript 如何解析模块</li>\n</ul>\n<blockquote>\n<p><code>TypeScript</code> 是模仿 <code>Node.js</code> 运行时的解析策略来在编译阶段定位模块定义文件。因此，<code>TypeScript</code> 在 <code>Node</code> 解析逻辑基础上增加了 TypeScript 源文件的扩展名（ <code>.ts</code>，<code>.tsx</code> 和 <code>.d.ts</code>）。同时，<code>TypeScript</code> 在 <code>package.json</code> 里使用字段”<code>types</code>“来表示类似”<code>main</code>“的意义 <code>-</code> 编译器会使用它来找到要使用的”<code>main</code>“定义文件。</p>\n</blockquote>\n<blockquote>\n<p>比如，有一个导入语句 <code>import &#123; b &#125; from &quot;./moduleB&quot;</code> 在 <code>/root/src/moduleA.ts</code> 里，会以下面的流程来定位 <code>&quot;./moduleB&quot;</code> ：</p>\n<ol>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.tsx</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li>\n<li><code>/root/src/moduleB/index.ts</code></li>\n<li><code>/root/src/moduleB/index.tsx</code></li>\n<li><code>/root/src/moduleB/index.d.ts</code></li>\n</ol>\n</blockquote>\n<blockquote>\n<p>回想一下 <code>Node.js</code> 先查找 <code>moduleB.js</code> 文件，然后是合适的 <code>package.json</code>，再之后是 <code>index.js</code>。</p>\n</blockquote>\n<blockquote>\n<p>类似地，非相对的导入会遵循 <code>Node.js</code> 的解析逻辑，首先查找文件，然后是合适的文件夹。因此 <code>/root/src/moduleA.ts</code> 件里的 <code>import &#123; b &#125; from &quot;moduleB&quot;</code> 会以下面的查找顺序解析：</p>\n<ol>\n<li><code>/root/src/node_modules/moduleB.ts</code></li>\n<li><code>/root/src/node_modules/moduleB.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB.d.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li>\n<li><code>/root/src/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/index.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB/index.d.ts</code></li>\n<li><code>/root/node_modules/moduleB.ts</code></li>\n<li><code>/root/node_modules/moduleB.tsx</code></li>\n<li><code>/root/node_modules/moduleB.d.ts</code></li>\n<li><code>/root/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li>\n<li><code>/root/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/node_modules/moduleB/index.tsx</code></li>\n<li><code>/root/node_modules/moduleB/index.d.ts</code></li>\n<li><code>/node_modules/moduleB.ts</code></li>\n<li><code>/node_modules/moduleB.tsx</code></li>\n<li><code>/node_modules/moduleB.d.ts</code></li>\n<li><code>/node_modules/moduleB/package.json (如果指定了&quot;types&quot;属性)</code></li>\n<li><code>/node_modules/moduleB/index.ts</code></li>\n<li><code>/node_modules/moduleB/index.tsx</code></li>\n<li><code>/node_modules/moduleB/index.d.ts</code></li>\n</ol>\n</blockquote>\n<blockquote>\n<p>不要被这里步骤的数量吓到 <code>-</code> <code>TypeScript</code> 只是在步骤（<code>8</code>）和（<code>15</code>）向上跳了两次目录。 这并不比 <code>Node.js</code> 里的流程复杂。</p>\n</blockquote>\n<h3 id=\"18-4-附加的模块解析标记\"><a href=\"#18-4-附加的模块解析标记\" class=\"headerlink\" title=\"18.4 附加的模块解析标记\"></a>18.4 附加的模块解析标记</h3><blockquote>\n<ol>\n<li>有时工程源码结构与输出结构不同。 通常是要经过一系统的构建步骤最后生成输出。 它们包括将 <code>.ts</code> 编译成 <code>.js</code>，将不同位置的依赖拷贝至一个输出位置。 最终结果就是运行时的模块名与包含它们声明的源文件里的模块名不同。 或者最终输出文件里的模块路径与编译时的源文件路径不同了。</li>\n<li><code>TypeScript</code> 编译器有一些额外的标记用来通知编译器在源码编译成最终输出的过程中都发生了哪个转换。</li>\n<li>有一点要特别注意的是编译器不会进行这些转换操作；它只是利用这些信息来指导模块的导入。</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>Base URL</code></li>\n</ul>\n<blockquote>\n<p>在利用 <code>AMD</code> 模块加载器的应用里使用 <code>baseUrl</code> 是常见做法，它要求在运行时模块都被放到了一个文件夹里。这些模块的源码可以在不同的目录下，但是构建脚本会将它们集中到一起。</p>\n</blockquote>\n<blockquote>\n<p>设置 <code>baseUrl</code> 来告诉编译器到哪里去查找模块。 所有 <code>非相对模块</code> 导入都会被当做相对于 <code>baseUrl</code>。</p>\n</blockquote>\n<ul>\n<li><code>baseUrl</code> 的值由以下两者之一决定：</li>\n</ul>\n<blockquote>\n<ol>\n<li>命令行中 <code>baseUrl</code> 的值（如果给定的路径是相对的，那么将相对于当前路径进行计算）</li>\n<li><code>tsconfig.json</code>里的 <code>baseUrl</code> 属性（如果给定的路径是相对的，那么将相对于‘<code>tsconfig.json</code>’路径进行计算）</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意相对模块的导入不会被设置的 <code>baseUrl</code> 所影响，因为它们总是相对于导入它们的文件。</p>\n</blockquote>\n<blockquote>\n<p>阅读更多关于 <code>baseUrl</code> 的信息 <a href=\"https://requirejs.org/docs/api.html#config-baseUrl\">RequireJS</a> 和 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl\"><code>SystemJS</code></a>。</p>\n</blockquote>\n<h3 id=\"18-5-路径映射\"><a href=\"#18-5-路径映射\" class=\"headerlink\" title=\"18.5 路径映射\"></a>18.5 路径映射</h3><blockquote>\n<p>有时模块不是直接放在 <code>baseUrl</code> 下面。 比如，充分 “<code>jquery</code>“模块地导入，在运行时可能被解释为”<code>node\\_modules/jquery/dist/jquery.slim.min.js</code>“。 加载器使用映射配置来将模块名映射到运行时的文件，查看 <a href=\"https://requirejs.org/docs/api.html#config-paths\">RequireJs documentation</a> 和 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths\">SystemJS documentation</a>。</p>\n</blockquote>\n<blockquote>\n<p><code>TypeScript</code> 编译器通过使用 <code>tsconfig.json</code> 文件里的 “<code>paths</code>“ 来支持这样的声明映射。 下面是一个如何指定 <code>jquery</code> 的”<code>paths</code>“的例子。</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;baseUrl&quot;</span>: <span class=\"string\">&quot;.&quot;</span>, <span class=\"comment\">// This must be specified if &quot;paths&quot; is.</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;paths&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;jquery&quot;</span>: [<span class=\"string\">&quot;node_modules/jquery/dist/jquery&quot;</span>] <span class=\"comment\">// 此处映射是相对于&quot;baseUrl&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>请注意”<code>paths</code>“是相对于”<code>baseUrl</code>“进行解析。 如果 “<code>baseUrl</code>“ 被设置成了除”<code>.</code>“外的其它值，比如 <code>tsconfig.json</code> 所在的目录，那么映射必须要做相应的改变。如果你在上例中设置了 <code>&quot;baseUrl&quot;: &quot;./src&quot;</code>，那么 <code>jquery</code> 应该映射到 <code>&quot;../node\\_modules/jquery/dist/jquery&quot;</code>。</p>\n</blockquote>\n<blockquote>\n<p>通过”<code>paths</code>“我们还可以指定复杂的映射，包括指定多个回退位置。 假设在一个工程配置里，有一些模块位于一处，而其它的则在另个的位置。 构建过程会将它们集中至一处。 工程结构可能如下：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">projectRoot</span><br><span class=\"line\">├── folder1</span><br><span class=\"line\">│   ├── file1.ts (imports <span class=\"string\">&#x27;folder1/file2&#x27;</span> and <span class=\"string\">&#x27;folder2/file3&#x27;</span>)</span><br><span class=\"line\">│   └── file2.ts</span><br><span class=\"line\">├── generated</span><br><span class=\"line\">│   ├── folder1</span><br><span class=\"line\">│   └── folder2</span><br><span class=\"line\">│       └── file3.ts</span><br><span class=\"line\">└── tsconfig.json</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>相应的 <code>tsconfig.json</code> 文件如下：</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;baseUrl&quot;</span>: <span class=\"string\">&quot;.&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;paths&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;*&quot;</span>: [<span class=\"string\">&quot;*&quot;</span>, <span class=\"string\">&quot;generated/*&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它告诉编译器所有匹配 <code>&quot;\\*&quot;</code>（所有的值）模式的模块导入会在以下两个位置查找：</p>\n<ol>\n<li><code>&quot;\\*&quot;</code>： 表示名字不发生改变，所以映射为  <code>=&gt;</code> <code>/</code></li>\n<li>“<code>generated/</code>“表示模块名添加了“<code>generated</code>”前缀，所以映射为 <code>&lt;moduleName&gt; =&gt; &lt;baseUrl&gt;/generated/&lt;moduleName&gt;</code></li>\n</ol>\n</blockquote>\n<ul>\n<li><code>按照这个逻辑，编译器将会如下尝试解析这两个导入：</code></li>\n</ul>\n<blockquote>\n<p>(i). 导入<code>&#39;folder1/file2&#39;</code></p>\n<ol>\n<li>匹配 <code>&#39;\\*&#39;</code> 模式且通配符捕获到整个名字。</li>\n<li>尝试列表里的第一个替换：<code>&#39;\\*&#39; -&gt; folder1/file2</code>。</li>\n<li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&gt; projectRoot/folder1/file2.ts</code>。</li>\n<li>文件存在。完成。</li>\n</ol>\n<p>(ii). 导入<code>&#39;folder2/file3&#39;</code></p>\n<ol>\n<li>匹配 <code>&#39;\\*&#39;</code> 模式且通配符捕获到整个名字。</li>\n<li>尝试列表里的第一个替换：<code>&#39;\\*&#39; -&gt; folder2/file3</code>。</li>\n<li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&gt; projectRoot/folder2/file3.ts</code>。</li>\n<li>文件不存在，跳到第二个替换。</li>\n<li>第二个替换：<code>&#39;generated/&#39; -&gt; generated/folder2/file3</code>。</li>\n<li>替换结果为非相对名 - 与 <code>baseUrl</code> 合并 <code>-&amp;gt; projectRoot/generated/folder2/file3.ts</code>。</li>\n<li>文件存在。完成。</li>\n</ol>\n</blockquote>\n<ul>\n<li>利用 <code>rootDirs</code> 指定虚拟目录</li>\n</ul>\n<blockquote>\n<p>有时多个目录下的工程源文件在编译时会进行合并放在某个输出目录下。 这可以看做一些源目录创建了一个“虚拟”目录。 利用 <code>rootDirs</code>，可以告诉编译器生成这个虚拟目录的 <code>roots</code>； 因此编译器可以在“虚拟”目录下解析相对模块导入，就好像它们被合并在了一起一样。</p>\n</blockquote>\n<blockquote>\n<p>比如，有下面的工程结构：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src</span><br><span class=\"line\"> └── views</span><br><span class=\"line\">     └── view1.ts (imports <span class=\"string\">&#x27;./template1&#x27;</span>)</span><br><span class=\"line\">     └── view2.ts</span><br><span class=\"line\"></span><br><span class=\"line\"> generated</span><br><span class=\"line\"> └── templates</span><br><span class=\"line\">         └── views</span><br><span class=\"line\">             └── template1.ts (imports <span class=\"string\">&#x27;./view2&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>src/views</code> 里的文件是用于控制 UI 的用户代码。 <code>generated/templates</code> 是 <code>UI</code> 模版，在构建时通过模版生成器自动生成。构建中的一步会将 <code>/src/views</code> 和 <code>/generated/templates/views</code> 的输出拷贝到同一个目录下。 在运行时，视图可以假设它的模版与它同在一个目录下，因此可以使用相对导入 <code>&quot;./template&quot;</code>。</p>\n</blockquote>\n<blockquote>\n<p>可以使用”<code>rootDirs</code>“来告诉编译器。”<code>rootDirs</code>“指定了一个 <code>roots</code> 列表，列表里的内容会在运行时被合并。</p>\n</blockquote>\n<blockquote>\n<p>因此，针对这个例子， <code>tsconfig.json</code> 如下：</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDirs&quot;</span>: [<span class=\"string\">&quot;src/views&quot;</span>, <span class=\"string\">&quot;generated/templates/views&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>每当编译器在某一 <code>rootDirs</code> 的子目录下发现了相对模块导入，它就会尝试从每一个 <code>rootDirs</code> 中导入。</p>\n</blockquote>\n<blockquote>\n<p><code>rootDirs</code> 的灵活性不仅仅局限于其指定了要在逻辑上合并的物理目录列表。它提供的数组可以包含任意数量的任何名字的目录，不论它们是否存在。这允许编译器以类型安全的方式处理复杂捆绑( <code>bundles</code> )和运行时的特性，比如条件引入和工程特定的加载器插件。</p>\n</blockquote>\n<blockquote>\n<p>设想这样一个国际化的场景，构建工具自动插入特定的路径记号来生成针对不同区域的捆绑，比如将 <code>\\#&#123;locale&#125;</code> 做为相对模块路径 <code>./\\#&#123;locale&#125;/messages</code> 的一部分。在这个假定的设置下，工具会枚举支持的区域，将抽像的路径映射成 <code>./zh/messages</code>，<code>./de/messages</code> 等。</p>\n</blockquote>\n<blockquote>\n<p>假设每个模块都会导出一个字符串的数组。比如 <code>./zh/messages</code> 可能包含：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> [<span class=\"string\">&quot;您好吗&quot;</span>, <span class=\"string\">&quot;很高兴认识你&quot;</span>];</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>利用 <code>rootDirs</code> 我们可以让编译器了解这个映射关系，从而也允许编译器能够安全地解析 <code>./\\#&#123;locale&#125;/messages</code>，就算这个目录永远都不存在。比如，使用下面的 <code>tsconfig.json</code>：</p>\n</blockquote>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootDirs&quot;</span>: [<span class=\"string\">&quot;src/zh&quot;</span>, <span class=\"string\">&quot;src/de&quot;</span>, <span class=\"string\">&quot;src/#&#123;locale&#125;&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>编译器现在可以将 <code>import messages from &#39;./#&#123;locale&#125;/messages&#39;</code> 解析为 <code>import messages from &#39;./zh/messages&#39;</code> 用做工具支持的目的，并允许在开发时不必了解区域信息。</p>\n</blockquote>\n<h3 id=\"18-6-跟踪模块解析\"><a href=\"#18-6-跟踪模块解析\" class=\"headerlink\" title=\"18.6 跟踪模块解析\"></a>18.6 跟踪模块解析</h3><blockquote>\n<p>如之前讨论，编译器在解析模块时可能访问当前文件夹外的文件。 这会导致很难诊断模块为什么没有被解析，或解析到了错误的位置。 通过 <code>--traceResolution</code> 启用编译器的模块解析跟踪，它会告诉我们在模块解析过程中发生了什么。</p>\n</blockquote>\n<blockquote>\n<p>假设我们有一个使用了 <code>typescript</code> 模块的简单应用。<code>app.ts</code> 里有一个这样的导入 <code>import * as ts from &quot;typescript&quot;</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">│   tsconfig.json</span><br><span class=\"line\">├───node_modules</span><br><span class=\"line\">│   └───typescript</span><br><span class=\"line\">│       └───lib</span><br><span class=\"line\">│               typescript.d.ts</span><br><span class=\"line\">└───src</span><br><span class=\"line\">        app.ts</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 <code>--traceResolution</code> 调用编译器。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc --traceResolution</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>输出结果如下：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">======== Resolving <span class=\"built_in\">module</span> <span class=\"string\">&#x27;typescript&#x27;</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;src/app.ts&#x27;</span>. ========</span><br><span class=\"line\">Module resolution kind is not specified, using <span class=\"string\">&#x27;NodeJs&#x27;</span>.</span><br><span class=\"line\">Loading <span class=\"built_in\">module</span> <span class=\"string\">&#x27;typescript&#x27;</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;node_modules&#x27;</span> folder.</span><br><span class=\"line\">File <span class=\"string\">&#x27;src/node_modules/typescript.ts&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;src/node_modules/typescript.tsx&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;src/node_modules/typescript.d.ts&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;src/node_modules/typescript/package.json&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;node_modules/typescript.ts&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;node_modules/typescript.tsx&#x27;</span> does not exist.</span><br><span class=\"line\">File <span class=\"string\">&#x27;node_modules/typescript.d.ts&#x27;</span> does not exist.</span><br><span class=\"line\">Found <span class=\"string\">&#x27;package.json&#x27;</span> at <span class=\"string\">&#x27;node_modules/typescript/package.json&#x27;</span>.</span><br><span class=\"line\"><span class=\"string\">&#x27;package.json&#x27;</span> has <span class=\"string\">&#x27;types&#x27;</span> field <span class=\"string\">&#x27;./lib/typescript.d.ts&#x27;</span> that references <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span>.</span><br><span class=\"line\">File <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span> exist - use it <span class=\"keyword\">as</span> a <span class=\"built_in\">module</span> resolution result.</span><br><span class=\"line\">======== Module name <span class=\"string\">&#x27;typescript&#x27;</span> was successfully resolved to <span class=\"string\">&#x27;node_modules/typescript/lib/typescript.d.ts&#x27;</span>. ========</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要留意的地方：</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>导入的名字及位置 <code>======== Resolving module &#39;typescript&#39; from &#39;src/app.ts&#39;. ========</code></li>\n<li>编译器使用的策略 <code>Module resolution kind is not specified, using &#39;NodeJs&#39;.</code></li>\n<li>从 <code>npm</code> 加载 <code>types</code> <code>&#39;package.json&#39; has &#39;types&#39; field &#39;./lib/typescript.d.ts&#39; that references &#39;node\\_modules/typescript/lib/typescript.d.ts&#39;.</code></li>\n<li>最终结果 <code>======== Module name &#39;typescript&#39; was successfully resolved to &#39;node\\_modules/typescript/lib/typescript.d.ts&#39;. ========</code></li>\n</ol>\n</blockquote>\n<ul>\n<li>使用 <code>--noResolve</code></li>\n</ul>\n<blockquote>\n<p>正常来讲编译器会在开始编译之前解析模块导入。 每当它成功地解析了对一个文件 <code>import</code>，这个文件被会加到一个文件列表里，以供编译器稍后处理。<code>--noResolve</code> 编译选项告诉编译器不要添加任何不是在命令行上传入的文件到编译列表。 编译器仍然会尝试解析模块，但是只要没有指定这个文件，那么它就不会被包含在内。</p>\n</blockquote>\n<blockquote>\n<p><code>比如</code>:</p>\n</blockquote>\n<ul>\n<li><code>app.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> A <span class=\"keyword\">from</span> <span class=\"string\">&quot;moduleA&quot;</span>; <span class=\"comment\">// OK, moduleA passed on the command-line</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> B <span class=\"keyword\">from</span> <span class=\"string\">&quot;moduleB&quot;</span>; <span class=\"comment\">// Error TS2307: Cannot find module &#x27;moduleB&#x27;.</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc app.ts moduleA.ts --noResolve</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 <code>--noResolve</code> 编译 <code>app.ts</code>：</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>可能正确找到 <code>moduleA</code>，因为它在命令行上指定了。</li>\n<li>找不到 <code>moduleB</code>，因为没有在命令行上传递。</li>\n</ol>\n</blockquote>\n<h3 id=\"18-7-常见问题\"><a href=\"#18-7-常见问题\" class=\"headerlink\" title=\"18.7 常见问题\"></a>18.7 常见问题</h3><ul>\n<li>为什么在 <code>exclude</code> 列表里的模块还会被编译器使用</li>\n</ul>\n<blockquote>\n<p><code>tsconfig.json</code> 将文件夹转变一个“工程” 如果不指定任何 “<code>exclude</code>” 或 “<code>files</code>”，文件夹里的所有文件包括 <code>tsconfig.json</code> 和 所有的子目录 都会在编译列表里。 如果你想利用 “<code>exclude</code>”排除某些文件，甚至你想指定所有要编译的文件列表，请使用“<code>files</code>”。</p>\n</blockquote>\n<blockquote>\n<p>有些是被 <code>tsconfig.json</code> 自动加入的。 它不会涉及到上面讨论的模块解析。 如果编译器识别出一个文件是模块导入目标，它就会加到编译列表里，不管它是否被排除了。</p>\n</blockquote>\n<blockquote>\n<p>因此，要从编译列表中排除一个文件，你需要在排除它的同时，还要排除所有对它进行 <code>import</code> 或使用了 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令的文件。</p>\n</blockquote>\n<h2 id=\"十九、声明合并\"><a href=\"#十九、声明合并\" class=\"headerlink\" title=\"十九、声明合并\"></a>十九、声明合并</h2><h3 id=\"19-1-介绍\"><a href=\"#19-1-介绍\" class=\"headerlink\" title=\"19.1 介绍\"></a>19.1 介绍</h3><blockquote>\n<p><code>TypeScript</code> 中有些独特的概念可以在类型层面上描述 <code>JavaScript</code> 对象的模型。这其中尤其独特的一个例子 “声明合并” 的概念。</p>\n</blockquote>\n<blockquote>\n<p>理解了这个概念，将有助于操作现有的 <code>JavaScript</code> 代码。同时，也会有助于理解更多高级抽象的概念。</p>\n</blockquote>\n<blockquote>\n<p>对本文件来讲，”<code>声明合并</code>“ 是指编译器将针对同一个名字的两个独立声明合并为单一声明。合并后的声明同时拥有原先两个声明的特性。任何数量的声明都可被合并；不局限于两个声明。</p>\n</blockquote>\n<h3 id=\"19-2-基础概念\"><a href=\"#19-2-基础概念\" class=\"headerlink\" title=\"19.2 基础概念\"></a>19.2 基础概念</h3><blockquote>\n<p><code>TypeScript</code> 中的声明会创建以下三种实体之一：<code>命名空间</code>，<code>类型</code> 或 <code>值</code>。创建命名空间的声明会新建一个命名空间，它包含了用(.)符号来访问时使用的名字。创建类型的声明是：用声明的模型创建一个类型并绑定到给定的名字上。<br>最后，创建值的声明会创建在 <code>JavaScript</code> 输出中看到的值。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Declaration Type</th>\n<th align=\"left\">Namespace</th>\n<th align=\"left\">Type</th>\n<th align=\"left\">Value</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>Namespace</code></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Class</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Enum</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Interface</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>Type Alias</code></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>Function</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\"><code>Variable</code></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">X</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>理解每个声明创建了什么，有助于理解当声明合并时，有哪些东西被合并了。</p>\n</blockquote>\n<h3 id=\"19-3-合并接口\"><a href=\"#19-3-合并接口\" class=\"headerlink\" title=\"19.3 合并接口\"></a>19.3 合并接口</h3><blockquote>\n<p>最简单最常见的声明合并类型是接口合并。从根本上说，合并的机制是把双方的成员放到一个同名的接口里。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Box &#123;</span><br><span class=\"line\">  height: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  width: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Box &#123;</span><br><span class=\"line\">  scale: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> box: Box = &#123; <span class=\"attr\">height</span>: <span class=\"number\">5</span>, <span class=\"attr\">width</span>: <span class=\"number\">6</span>, <span class=\"attr\">scale</span>: <span class=\"number\">10</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>接口的非函数成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。</p>\n</blockquote>\n<blockquote>\n<p>对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。同时需要注意，当接口 <code>A</code> 与后来的接口 <code>A</code> 合并时，后面的接口具有更高的优先级。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如下例所示：</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cloner &#123;</span><br><span class=\"line\">  clone(animal: Animal): Animal;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cloner &#123;</span><br><span class=\"line\">  clone(animal: Sheep): Sheep;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cloner &#123;</span><br><span class=\"line\">  clone(animal: Dog): Dog;</span><br><span class=\"line\">  clone(animal: Cat): Cat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这三个接口合并成一个声明：</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Cloner &#123;</span><br><span class=\"line\">  clone(animal: Dog): Dog;</span><br><span class=\"line\">  clone(animal: Cat): Cat;</span><br><span class=\"line\">  clone(animal: Sheep): Sheep;</span><br><span class=\"line\">  clone(animal: Animal): Animal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意每组接口里的声明顺序保持不变，但各组接口之间的顺序是后来的接口重载出现在靠前的位置。</p>\n</blockquote>\n<blockquote>\n<p>这个规则有一个例外是当出现特殊的函数签名时。如果签名里有一个参数的类型是单一的字符串字面量(比如，不是字符串字面量的联合类型)，那么它将会被提升到重载列表的最顶端。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如，下面的接口会合并到一起</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Document &#123;</span><br><span class=\"line\">  createElement(tagName: <span class=\"built_in\">any</span>): ELement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Document &#123;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;div&quot;</span>): HTMLDivElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;span&quot;</span>): HTMLSpanElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">interface</span> Document &#123;</span><br><span class=\"line\">  createElement(tagName: <span class=\"built_in\">string</span>): HTMLElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;canvas&quot;</span>): HTMLCanvasElement;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 合并后的 Document 将会像下面这样:</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Document &#123;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;canvas&quot;</span>): HTMLCanvasElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;div&quot;</span>): HTMLDivElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"string\">&quot;span&quot;</span>): HTMLSpanElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"built_in\">string</span>): HTMLElement;</span><br><span class=\"line\">  createElement(tagName: <span class=\"built_in\">any</span>): Element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"19-4-合并命名空间\"><a href=\"#19-4-合并命名空间\" class=\"headerlink\" title=\"19.4 合并命名空间\"></a>19.4 合并命名空间</h3><ol>\n<li>与接口相似，同名的命名空间也会合并其成员。命名空间会创建出命名空间和值，我们需要知道这两者都是怎么合并的。</li>\n<li>对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。</li>\n<li>对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Animals 声明合并示例：</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Animals &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zebra</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Animals &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Legged &#123;</span><br><span class=\"line\">    numberOfLegs: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 等同于：</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Animals &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> Legged &#123;</span><br><span class=\"line\">    numberOfLegs: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Zebra</span> </span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>除了这些合并外，你还需要了解非导出成员是如何处理的。非导出成员仅在其原有的(合并前的)命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。</p>\n</blockquote>\n<ul>\n<li>下面提供了清晰的说明：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> haveMuscles = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">animalsHaveMuscles</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> haveMuscles;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Animal &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doAnimalsHaveMuscles</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> haveMuscles; <span class=\"comment\">// // Error, because haveMuscles is not accessible here</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>因为 <code>haveMuscles</code> 并没有导出，只有 <code>animalsHaveMuscles</code> 函数共享了原始未合并的命名空间可以访问这个变量。<br><code>doAnimalsHaveMuscles</code> 函数虽是合并命名空间的一部分，但是访问不了未导出的成员。</p>\n</blockquote>\n<h3 id=\"19-5-命名空间与类和函数和枚举类型合并\"><a href=\"#19-5-命名空间与类和函数和枚举类型合并\" class=\"headerlink\" title=\"19.5 命名空间与类和函数和枚举类型合并\"></a>19.5 命名空间与类和函数和枚举类型合并</h3><blockquote>\n<p>命名空间可以与其它类型的声明合并。只要命名空间的定义符合将要合并类型的定义。合并结果包含两者的声明类型。<br><code>TypeScript</code> 使用这个功能去实现一些 <code>JavaScript</code> 里的设计模式。</p>\n</blockquote>\n<h4 id=\"19-5-1-合并命名空间和类\"><a href=\"#19-5-1-合并命名空间和类\" class=\"headerlink\" title=\"19.5.1 合并命名空间和类\"></a>19.5.1 合并命名空间和类</h4><blockquote>\n<p>这让我们可以表示内部类</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Album</span> </span>&#123;</span><br><span class=\"line\">  label: Album.AlbumLabel;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Album &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AlbumLabel</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>合并规则</code> 与上面 <code>合并命名空间</code> 小节里讲的规则一致，我们必须导出 <code>AlbumLabel</code> 类，好让合并的类能访问。</p>\n</blockquote>\n<blockquote>\n<p><code>合并结果</code>是一个类并带有一个内部类。你也可以使用命名空间为类增加一些静态属性。</p>\n</blockquote>\n<blockquote>\n<p>除了内部类的模式，你在 <code>JavaScript</code> 里，创建一个函数稍后扩展它增加一些属性也是很常见的。<code>TypeScript</code> 使用声明合并来达到这个目的并保证类型安全。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildLabel</span>(<span class=\"params\">name: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> buildLabel.prefix + name + buildLabel.suffix;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> buildLabel &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> suffix = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">let</span> prefix = <span class=\"string\">&quot;Hello, &quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(buildLabel(<span class=\"string\">&quot;Sam Smith&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相似的，命名空间可以用来扩展枚举类型</span></span><br><span class=\"line\"><span class=\"built_in\">enum</span> Color &#123;</span><br><span class=\"line\">  red = <span class=\"number\">1</span>,</span><br><span class=\"line\">  green = <span class=\"number\">2</span>,</span><br><span class=\"line\">  blue = <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> Color &#123;</span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mixColor</span>(<span class=\"params\">colorName: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (colorName === <span class=\"string\">&quot;yellow&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Color.red + Color.green;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName === <span class=\"string\">&quot;white&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Color.red + Color.green + Color.blue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName === <span class=\"string\">&quot;magenta&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Color.red + Color.blue;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (colorName === <span class=\"string\">&quot;cyan&quot;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Color.green + Color.blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"19-5-2-非法的合并\"><a href=\"#19-5-2-非法的合并\" class=\"headerlink\" title=\"19.5.2 非法的合并\"></a>19.5.2 非法的合并</h4><blockquote>\n<p><code>TypeScript</code> 并非允许所有的合并。目前，类不能与其它类或变量合并。想要了解如何模仿类的合并，请参照 <a href=\"https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/Mixins%E6%B7%B7%E5%85%A5/README.md\">TypeScript 混入</a>。</p>\n</blockquote>\n<h3 id=\"19-6-模块扩展\"><a href=\"#19-6-模块扩展\" class=\"headerlink\" title=\"19.6 模块扩展\"></a>19.6 模块扩展</h3><blockquote>\n<p>虽然 <code>JavaScript</code> 不支持合并，但你可以为导入的对象打补丁以更新它们。</p>\n</blockquote>\n<ul>\n<li>让我们考察一下这个玩具性的示例：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.js</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... implementation left as an exercise for the reader...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\">Observable.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... another exercise for the reader</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它也可以很好地工作在 <code>TypeScript</code> 中，但编译器对 <code>Observable.prototype.map</code> 一无所知。你可以使用扩展模块来将它告诉编译器。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observable.ts stays the same</span></span><br><span class=\"line\"><span class=\"comment\">// map.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">module</span> <span class=\"string\">&quot;./observable&quot;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> Observable&lt;T&gt; &#123;</span><br><span class=\"line\">    map&lt;U&gt;(f: <span class=\"function\">(<span class=\"params\">x: T</span>) =&gt;</span> U): Observable&lt;U&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Observable.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... another exercise for the reader</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// consumer.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;./observable&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;./map&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> o: Observable&lt;<span class=\"built_in\">number</span>&gt;;</span><br><span class=\"line\">o.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x.toFixed());</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>模块名的解析和用 <code>import / export</code> 解析模块标识符的方式是一致的。 更多信息请参考 <a href=\"https://github.com/magicwangxuanqi/typeScript-document/tree/364ec42f004be1686f97e1b02f97c1cf1fb2ba02/%E6%A8%A1%E5%9D%97/README.md\">Modules</a>。当这些声明在扩展中合并时，就好像在原始位置被声明了一样。 但是，你不能在扩展中声明新的顶级声明(仅可以扩展模块中已经存在的声明)。</p>\n</blockquote>\n<h3 id=\"19-7-全局扩展\"><a href=\"#19-7-全局扩展\" class=\"headerlink\" title=\"19.7 全局扩展\"></a>19.7 全局扩展</h3><blockquote>\n<p>你也可以在模块内部添加声明到全局作用域中</p>\n</blockquote>\n<blockquote>\n<p><code>observable.ts</code></p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Observable</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... still no implementation ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"built_in\">global</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> Array&lt;T&gt; &#123;</span><br><span class=\"line\">    toObservable(): Observable&lt;T&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.toObservable = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>全局扩展和与模块扩展的行为和限制是相同的。</p>\n</blockquote>\n<h2 id=\"二十、JSX\"><a href=\"#二十、JSX\" class=\"headerlink\" title=\"二十、JSX\"></a>二十、JSX</h2><h3 id=\"20-1-介绍\"><a href=\"#20-1-介绍\" class=\"headerlink\" title=\"20.1 介绍\"></a>20.1 介绍</h3><blockquote>\n<p><code>JSX</code> 是一种嵌入式的类似 <code>XML</code> 的语法。它可以被转换成合法的 <code>JavaScript</code>，尽管转换的语义是根据不同的实现而定的。<br><code>JSX</code> 因 <code>React</code> 框架而流行，但也存在其它的实现。<code>TypeScript</code> 支持内嵌，类型检查以及将 <code>JSX</code> 直接编译为 JavaScript。</p>\n</blockquote>\n<h3 id=\"20-2-基本用法\"><a href=\"#20-2-基本用法\" class=\"headerlink\" title=\"20.2 基本用法\"></a>20.2 基本用法</h3><ul>\n<li>想要使用 <code>JSX</code> 必须做两件事：</li>\n</ul>\n<blockquote>\n<ol>\n<li>给文件一个 <code>.tsx</code> 扩展名</li>\n<li>启用 <code>jsx</code> 选项</li>\n</ol>\n</blockquote>\n<ul>\n<li><code>TypeScript</code> 具有三种 <code>JSX</code> 模式：<code>preserve</code>, <code>react</code> 和 <code>react-native</code>。这些模式只在代码生成阶段起作用 - 类型检查并不受影响。</li>\n</ul>\n<blockquote>\n<ol>\n<li>在 <code>preserve</code> 模式下生成代码中会保留 <code>JSX</code> 以供后续的转换操作使用( <code>比如：Babel</code> )。另外，输出文件会带有 <code>.jsx</code> 扩展名。</li>\n<li><code>react</code> 模式会生成 <code>React.createElement</code>，在使用前不需要再进行转换操作了，输出文件的扩展名为 <code>.js</code>。</li>\n<li><code>react-native</code> 相当于 <code>preserve</code>，它也保留了所有的 <code>JSX</code>，但是输出文件的扩展名是 <code>.js</code>。</li>\n</ol>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">模式</th>\n<th align=\"left\">输入</th>\n<th align=\"left\">输出</th>\n<th align=\"left\">输出文件扩展名</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">preserve</td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\">react</td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>React.createElement(&quot;div&quot;)</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n<tr>\n<td align=\"left\">react-native</td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>&lt;div /&gt;</code></td>\n<td align=\"left\"><code>.js</code></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>你可以通过在命令行里使用 <code>--jsx</code> 标记或 <code>tsconfig.json</code> 里的选项来指定模式。<br>注意：<code>React</code> 标识符是写死的硬编码，所以你必须保证 <code>React</code>（大写的<code>R</code>）是可用的。</p>\n</blockquote>\n<h3 id=\"20-3-as-操作符\"><a href=\"#20-3-as-操作符\" class=\"headerlink\" title=\"20.3 as 操作符\"></a>20.3 as 操作符</h3><blockquote>\n<p>回想一下怎么写类型断言</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &lt;foo&gt;bar;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里断言 <code>bar</code> 变量是 <code>foo</code> 类型的。 因为 <code>TypeScript</code> 也使用尖括号来表示类型断言，在结合 <code>JSX</code> 的语法后将带来解析上的困难。因此，<code>TypeScript</code> 在 <code>.tsx</code> 文件里禁用了使用尖括号的类型断言。</p>\n</blockquote>\n<blockquote>\n<p>由于不能够在 <code>.tsx</code> 文件里使用上述语法，因此我们应该使用另一个类型断言操作符：<code>as</code>。</p>\n</blockquote>\n<ul>\n<li>上面的例子可以很容易地使用 <code>as</code> 操作符改写：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = bar <span class=\"keyword\">as</span> foo;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>as</code> 操作符在 <code>.ts</code> 和 <code>.tsx</code> 里都可用，并且与尖括号类型断言行为是等价的。</p>\n</blockquote>\n<h3 id=\"20-4-类型检查\"><a href=\"#20-4-类型检查\" class=\"headerlink\" title=\"20.4 类型检查\"></a>20.4 类型检查</h3><blockquote>\n<p>为了理解 <code>JSX</code> 的类型检查，你必须首先理解 <code>固有元素</code> 与 <code>基于值的元素</code> 之间的区别。假设有这样一个 <code>JSX</code> 表达式 <code>&lt;expr /&gt;</code>，<code>expr</code> 可能引用环境自带的某些东西(比如，在 <code>DOM</code> 环境里的 <code>div</code> 或 <code>span</code>)或者是你自定义的组件。这是非常重要的。原因有如下两点：</p>\n</blockquote>\n<ol>\n<li>对于 <code>React</code>，固有元素会生成字符串 (<code>React.createElement(&quot;div&quot;)</code> )，然后由你自定义的组件却不会生成( <code>React.createElement(MyComponent)</code>)。</li>\n<li>传入 <code>JSX</code> 元素里的属性类型的查找方式不同。固有元素总以一个小写字母开头，基于值的元素总是以一个大写字母开头。</li>\n</ol>\n<h4 id=\"20-4-1-固有元素\"><a href=\"#20-4-1-固有元素\" class=\"headerlink\" title=\"20.4.1 固有元素\"></a>20.4.1 固有元素</h4><blockquote>\n<p>固有元素使用特殊的接口 <code>JSX.IntrinsicElements</code> 来查找。默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。然而，如果这个接口存在，那么固有元素的名字需要在 <code>JSX.IntrinsicElements</code> 接口的属性里查找。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface IntrinsicElements &#123;</span><br><span class=\"line\">        foo: any;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;foo /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;bar /&gt;; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在上例中，``没有问题，但是<code>会报错，因为它没在 JSX.IntrinsicElements</code> 里指定。</p>\n</blockquote>\n<blockquote>\n<p>注意：你也可以在 <code>JSX.IntrinsicElements</code> 上指定一个用来捕获所有字符串索引：</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface IntrinsicElements &#123;</span><br><span class=\"line\">        [elemName: string]: any;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"20-4-2-基于值的元素\"><a href=\"#20-4-2-基于值的元素\" class=\"headerlink\" title=\"20.4.2 基于值的元素\"></a>20.4.2 基于值的元素</h4><blockquote>\n<p>基于值的元素会简单的在它所在的作用域里按标识符查找。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> MyComponent <span class=\"keyword\">from</span> <span class=\"string\">&quot;./myComponent&quot;</span>;</span><br><span class=\"line\">&lt;MyComponent /&gt; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;SomeOtherComponent /&gt; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>有两种方式可以定义基于值的元素：</p>\n<ol>\n<li>无状态函数组件 (<code>SFC</code>)</li>\n<li>类组件</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>由于这两种基于值的元素在 <code>JSX</code> 表达式里无法区分，因此 <code>TypeScript</code> 首先会尝试将表达式作为无状态函数组件进行解析。如果解析成功，那么 <code>TypeScript</code> 就完成了表达式到其声明的解析操作。如果按照无状态函数组件解析失败，那么 <code>TypeScript</code> 会继续尝试以类组件的形式进行解析。如果依旧失败，那么将输出一个错误。</p>\n</blockquote>\n<h5 id=\"1-无状态函数组件\"><a href=\"#1-无状态函数组件\" class=\"headerlink\" title=\"(1) 无状态函数组件\"></a>(1) 无状态函数组件</h5><blockquote>\n<p>正如其名，组件被定义成 <code>JavaScript</code> 函数，它的第一个参数是 <code>props</code> 对象。<code>TypeScript</code> 会强制它的返回值可以赋值给 <code>JSX.Element</code>。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface FooProp &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    X: number;</span><br><span class=\"line\">    Y: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">declare <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">AnotherComponent</span>(<span class=\"params\">prop: &#123; name: string &#125;</span>)</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ComponentFoo</span>(<span class=\"params\">prop: FooProp</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">AnotherComponent</span> <span class=\"attr\">name</span>=<span class=\"string\">&#123;prop.name&#125;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> Button = <span class=\"function\">(<span class=\"params\">prop: &#123; value: string &#125;, context: &#123; color: string &#125;</span>) =&gt;</span> &lt;button&gt;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>由于无状态函数组件是简单的 <code>JavaScript</code> 函数，所以我们还可以利用函数重载。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface ClickableProps &#123;</span><br><span class=\"line\">    children: JSX.Element[] | JSX.Element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface HomeProps <span class=\"keyword\">extends</span> ClickableProps &#123;</span><br><span class=\"line\">    home: JSX.Element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">interface SlideProps <span class=\"keyword\">extends</span> ClickableProps &#123;</span><br><span class=\"line\">    side: JSX.Element | string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MainButton</span>(<span class=\"params\">prop: HomeProps</span>): <span class=\"title\">JSX</span>.<span class=\"title\">Element</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MainButton</span>(<span class=\"params\">prop: SlideProps</span>): <span class=\"title\">JSX</span>.<span class=\"title\">Element</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"2-类组件\"><a href=\"#2-类组件\" class=\"headerlink\" title=\"(2) 类组件\"></a>(2) 类组件</h5><blockquote>\n<ol>\n<li>我们可以定义类组件的类型。然而，我们首先最好弄懂两个新的术语：<code>元素类的类型</code> 和 <code>元素实例的类型</code>。</li>\n<li>现在有 <code>&lt;Expr /&gt;</code>，元素类的类型为 <code>Expr</code> 的类型。所以在上面的例子里，如果 <code>MyComponent</code> 是 <code>ES6</code> 的类，那么类类型就是类的构造函数和静态部分。如果 <code>MyComponent</code> 是个工厂函数，类类型为这个函数。</li>\n<li>一旦建立起了类类型，实例类型由构造器或调用签名(如果存在的话)的返回值的联合构成。再次说明，在 <code>ES6</code> 类的情况下，实例类型为这个类的实例的类型，并且如果是工厂函数，实例类型为这个函数返回值类型。</li>\n</ol>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用构造签名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myComponent = <span class=\"keyword\">new</span> MyComponent();</span><br><span class=\"line\"><span class=\"comment\">// 元素类的类型 =&gt; MyComponent;</span></span><br><span class=\"line\"><span class=\"comment\">// 元素实例的类型 =&gt; &#123; render: () =&gt; void &#125;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyFactoryFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render: <span class=\"function\">() =&gt;</span> &#123;&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 使用调用签名</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myComponent = MyFactoryFunction();</span><br><span class=\"line\"><span class=\"comment\">// 元素类的类型 =&gt; FactoryFunction</span></span><br><span class=\"line\"><span class=\"comment\">// 元素实例的类型 =&gt; &#123; render: () =&gt; void &#125;</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>元素的实例类型很有趣，因为它必须赋值给 <code>JSX.ElementClass</code> 或 <code>抛出一个错误</code>。默认的 <code>JSX.ElementClass</code> 为 <code>&#123;&#125;</code>，但是它可以被扩展用来限制 <code>JSX</code> 的类型以符合相应的接口。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface ElementClass &#123;</span><br><span class=\"line\">        render: any</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyFactoryFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        render: <span class=\"function\">() =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;MyComponent /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;MyFactoryFunction /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NotAValidComponent</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">NotAValidFactoryFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;NotAValidComponent /&gt;; <span class=\"comment\">// 错误</span></span><br><span class=\"line\">&lt;NotAValidFactoryFunction /&gt;; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-5-属性类型检查\"><a href=\"#20-5-属性类型检查\" class=\"headerlink\" title=\"20.5 属性类型检查\"></a>20.5 属性类型检查</h3><ol>\n<li>属性类型检查的第一步是 确定元素类型。这在 <code>固有元素</code> 和 <code>基于值的元素</code> 之间稍有不同。</li>\n<li>对于固有元素，这是 <code>JSX.IntrinsicElements</code> 属性的类型。</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface IntrinsicElements &#123;</span><br><span class=\"line\">        foo: &#123;</span><br><span class=\"line\">            bar?: boolean;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// `foo` 的元素属性类型为 `&#123;bar?: boolean&#125;`</span></span><br><span class=\"line\">&lt;foo bar /&gt;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>对于基于值的元素，就稍微复杂些。它取决于先前确定的在元素实例类型上的某个属性的类型。至于该使用哪个属性来确定类型取决于 <code>JSX.ElementAttributesProperty</code>。它应该使用单一的属性来定义。这个属性名之后会被使用。<code>TypeScript 2.8</code>，如果未指定 <code>JSX.ElementAttributesProperty</code>，那么将使用 <code>类元素构造函数</code> 或 <code>SFC</code> 调用的第一个参数类型。</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">  interface ElementAttributesProperty &#123;</span><br><span class=\"line\">      props; <span class=\"comment\">// 指定用来使用的属性名</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在元素实例上指定类型</span></span><br><span class=\"line\">  props: &#123;</span><br><span class=\"line\">      foo?: string;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// `MyComponent` 的元素属性类型为 `&#123;foo?: string&#125;`</span></span><br><span class=\"line\">&lt;MyComponent foo=<span class=\"string\">&quot;bar&quot;</span> /&gt;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>元素属性类型用于 <code>JSX</code> 里进行属性的类型检查。支持可选属性和必须属性</li>\n</ol>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">declare namespace JSX &#123;</span><br><span class=\"line\">    interface IntrinsicElements &#123;</span><br><span class=\"line\">        foo: &#123;</span><br><span class=\"line\">            requiredProp: string;</span><br><span class=\"line\">            optionalProp?: number;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> optionalProp=&#123;<span class=\"number\">0</span>&#125; /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;foo /&gt;; <span class=\"comment\">// 错误，缺少requiredProp</span></span><br><span class=\"line\">&lt;foo requiredProp=&#123;<span class=\"number\">0</span>&#125; /&gt;; <span class=\"comment\">// 错误，requiredProp 应该是字符串</span></span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> unknownProp /&gt;; <span class=\"comment\">// 错误，unknownProp 属性不存在</span></span><br><span class=\"line\">&lt;foo requiredProp=<span class=\"string\">&quot;bar&quot;</span> some-unknown-prop /&gt;; <span class=\"comment\">// 正确，`some-unknown-prop` 不是合法的标识符</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果一个属性名不是个合法的 <code>JS</code> 标识符(像 <code>data-\\*</code> 属性)，并且它没出现在元素属性类型里时不会当作一个错误。</p>\n</blockquote>\n<blockquote>\n<p>另外，<code>JSX</code> 还会使用 <code>JSX.IntrinsicAttributes</code> 接口来指定额外的属性，这些额外的属性通常不会被组件的 <code>props</code> 或 <code>arguments</code> 使用 - 比如 <code>React</code> 里的 <code>key</code>。还有，<code>JSX.IntrinsicClassAttributes&lt;T&gt;</code> 泛型类型也可以用来做同样的事情。这里的泛型参数表示类实例类型。在 <code>React</code> 里，它用来允许 <code>Ref&lt;T&gt;</code> 类型上的 <code>ref</code> 属性。通常来讲，这些接口上的所有属性都是可选的，除非你想要用户在每个 <code>JSX</code> 标签上都提供一些属性。</p>\n</blockquote>\n<blockquote>\n<p>延展操作符也可以使用</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> props = &#123; <span class=\"attr\">requiredProp</span>: <span class=\"string\">&quot;bar&quot;</span> &#125;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> badProps = &#123;&#125;;</span><br><span class=\"line\">&lt;foo &#123;...badProps&#125; /&gt;; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-6-子孙类型检查\"><a href=\"#20-6-子孙类型检查\" class=\"headerlink\" title=\"20.6 子孙类型检查\"></a>20.6 子孙类型检查</h3><blockquote>\n<p>从 <code>TypeScript 2.3</code> 开始，我们引入了 <code>children</code> 类型检查。<code>children</code> 是元素属性(<code>attribute</code>)类型的一个特殊属性(<code>property</code>)，子 <code>JSXExpression</code> 将会被插入到属性里。与使用 <code>JSX.ElementAttributesProperty</code> 来决定 <code>props</code> 名类似，我们可以利用 <code>JSX.ElementChildrenAttribute</code> 来决定 <code>children</code> 名。<code>JSX.ElementChildrenAttribute</code> 应该被声明在单一的属性(<code>property</code>)里。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">namespace</span> JSX &#123;</span><br><span class=\"line\">  <span class=\"keyword\">interface</span> ElementChildrenAttribute &#123;</span><br><span class=\"line\">    children: &#123;&#125;; <span class=\"comment\">// specify children name to use</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如不特殊指定子孙的类型，我们将使用 <code>React typings</code> 里的默认类型</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">  World</span><br><span class=\"line\">&lt;/div&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> CustomComp = <span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>props.children<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;CustomComp&gt;</span><br><span class=\"line\">  &lt;div&gt;Hello World&lt;/div&gt;</span><br><span class=\"line\">  &#123;<span class=\"string\">&quot;This is just a JS expression...&quot;</span> + <span class=\"number\">1000</span>&#125;</span><br><span class=\"line\">&lt;/CustomComp&gt;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface PropsType &#123;</span><br><span class=\"line\">  children: JSX.Element;</span><br><span class=\"line\">  name: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Component</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">PropsType</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;h2&gt;</span><br><span class=\"line\">              &#123;<span class=\"built_in\">this</span>.props.children&#125;</span><br><span class=\"line\">          &lt;/h2&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Ok</span></span><br><span class=\"line\">&lt;Component&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class=\"line\">&lt;/Component&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: children is of type JSX.Element not array of JSX.Element</span></span><br><span class=\"line\">&lt;Component&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class=\"line\">  &lt;h2&gt;Hello World&lt;/h2&gt;</span><br><span class=\"line\">&lt;/Component&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Error: children is of type JSX.Element not array of JSX.Element or string.</span></span><br><span class=\"line\">&lt;Component&gt;</span><br><span class=\"line\">  &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">  World</span><br><span class=\"line\">&lt;/Component&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-7-JSX-结果类型\"><a href=\"#20-7-JSX-结果类型\" class=\"headerlink\" title=\"20.7 JSX 结果类型\"></a>20.7 JSX 结果类型</h3><blockquote>\n<p>默认地 <code>JSX</code> 表达式结果的类型为 <code>any</code>。你可以自定义这个类型，通过指定 <code>JSX.Element</code> 接口。然而，不能够从接口里检索元素，属性或 <code>JSX</code> 的子元素的类型信息。它是一个黑盒。</p>\n</blockquote>\n<h3 id=\"20-8-嵌入的表达式\"><a href=\"#20-8-嵌入的表达式\" class=\"headerlink\" title=\"20.8 嵌入的表达式\"></a>20.8 嵌入的表达式</h3><blockquote>\n<p><code>JSX</code> 允许你使用 <code>&#123;&#125;</code> 标签来内嵌表达式</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map(i &#x3D;&gt; (</span><br><span class=\"line\">      &lt;span&gt;&#123;i &#x2F; 2&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">    ))&#125;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">);</span><br><span class=\"line\">&#x2F;&#x2F; 上面的代码产生一个错误，因为你不能用数字来除以一个字符串。输出如下，若你使用了 preserve 选项</span><br><span class=\"line\">var a &#x3D; (</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &#123;[&quot;foo&quot;, &quot;bar&quot;].map(function (i) &#123;</span><br><span class=\"line\">      return &lt;span&gt;&#123;i &#x2F; 2&#125;&lt;&#x2F;span&gt;;</span><br><span class=\"line\">    &#125;)&#125;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-9-react-整合\"><a href=\"#20-9-react-整合\" class=\"headerlink\" title=\"20.9 react 整合\"></a>20.9 react 整合</h3><blockquote>\n<p>要想一起使用 <code>JSX</code> 和 <code>React</code>，你应该使用 <code>React</code> 类型定义。这些类型声明定义了 <code>JSX</code> 合适命名空间来使用 <code>React</code>。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;react.d.ts&quot; /&gt;</span></span><br><span class=\"line\">interface Props &#123;</span><br><span class=\"line\">  foo: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span>&lt;<span class=\"title\">Props</span>, </span>&#123;&#125;&gt; &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>&#123;this.props.foo&#125;<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;MyComponent foo=<span class=\"string\">&quot;bar&quot;</span> /&gt;; <span class=\"comment\">// 正确</span></span><br><span class=\"line\">&lt;MyComponent foo=&#123;<span class=\"number\">0</span>&#125; /&gt;; <span class=\"comment\">// 错误</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"20-10-工厂函数\"><a href=\"#20-10-工厂函数\" class=\"headerlink\" title=\"20.10 工厂函数\"></a>20.10 工厂函数</h3><blockquote>\n<p><code>jsx</code>：<code>react</code> 编译选项使用的工厂函数是可以配置的。可以使用 <code>jsxFactory</code> 命令行选项，或内联的 <code>@jsx</code> 注释指令在每个文件上设置。比如，给 <code>createElement</code> 设置 <code>jsxFactory</code>，<code>&lt;div /&gt;</code> 会使用 <code>createElement(&quot;div&quot;)</code> 来生成，而不是 <code>React.createElement(&quot;div&quot;)</code>。</p>\n</blockquote>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注释指令可以像下面这样使用：(在 TypeScript 2.8 里)</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> preact = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;preact&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">/* @jsx preact.h */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> x = <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>/&gt;</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> preact = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;preact&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> x = preact.h(<span class=\"string\">&quot;div&quot;</span>, <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>工厂函数的选择同样会影响 <code>JSX</code> 命名空间的查找(类型检查)。如果工厂函数使用 <code>React.createElement</code> 定义(默认)，编译器会先检查 <code>React.JSX</code>，之后才检查全局的 <code>JSX</code>。如果工厂函数定义为 <code>h</code>，那么在检查全局的 <code>JSX</code> 之前先检查 <code>h.JSX</code>。</p>\n</blockquote>\n<h2 id=\"二十一、装饰器\"><a href=\"#二十一、装饰器\" class=\"headerlink\" title=\"二十一、装饰器\"></a>二十一、装饰器</h2><h3 id=\"21-1-介绍\"><a href=\"#21-1-介绍\" class=\"headerlink\" title=\"21.1 介绍\"></a>21.1 介绍</h3><blockquote>\n<p>随着 <code>TypeScript</code> 和 <code>ES6</code> 里引入了类，在一些场景下我们需要额外的特定来支持标注或修改类及其成员。装饰器(<code>Decorators</code>)为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。<code>JavaScript</code> 里的装饰器目前处在 建议征集的第二阶段，但在 <code>TypeScript</code> 里已作为一项实验性特性予以支持。<br>注意：装饰器是一项实验性特性，在未来的版本中可能会发生改变<br>若要启用实验性的装饰器特性，你必须在命令行或 <code>tsconfig.json</code> 里启用 <code>experimentalDecorators</code> 编译器选项。<br>命令行： <code>tsc --target ES5 --experimentalDecorators</code></p>\n</blockquote>\n<ul>\n<li>tsconfig.json</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span>: <span class=\"string\">&quot;ES5&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;experimentalDecorators&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-2-装饰器\"><a href=\"#21-2-装饰器\" class=\"headerlink\" title=\"21.2 装饰器\"></a>21.2 装饰器</h3><blockquote>\n<p>装饰器是一种特殊的声明，它能够被附加到 <code>类声明</code>、<code>方法</code>、<code>访问符</code>、<code>属性或参数上</code>。装饰器使用 <code>@expression</code> 这种形式，<code>expression</code> 求值后必须为一个函数，它会在运行时被调用，被装饰器的声明信息作为参数传入。<br>例如，有一个 <code>@sealed</code> 装饰器，我们会这样定义 <code>sealed</code> 函数</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sealed</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something with target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：后面类装饰器小节里有一个更加详细的例子。</p>\n</blockquote>\n<h3 id=\"21-3-装饰器工厂\"><a href=\"#21-3-装饰器工厂\" class=\"headerlink\" title=\"21.3 装饰器工厂\"></a>21.3 装饰器工厂</h3><blockquote>\n<p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p>\n</blockquote>\n<ul>\n<li>我们可以通过下面的方式来写一个装饰器工厂函数：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">color</span>(<span class=\"params\">value: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这是一个装饰器工厂</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是装饰器</span></span><br><span class=\"line\">    <span class=\"comment\">// do something with &quot;target&quot; and &quot;value&quot; ...</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：下面方法装饰器小节里有一个更加详细的例子。</p>\n</blockquote>\n<h3 id=\"21-4-装饰器组合\"><a href=\"#21-4-装饰器组合\" class=\"headerlink\" title=\"21.4 装饰器组合\"></a>21.4 装饰器组合</h3><blockquote>\n<p>多个装饰器可以同时应用到一个声明上，就像下面的实例：</p>\n</blockquote>\n<ol>\n<li>书写在同一行：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@f</span> <span class=\"meta\">@g</span> x</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>书写在多行上：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@f</span></span><br><span class=\"line\"><span class=\"meta\">@g</span></span><br><span class=\"line\">x</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当多个装饰器应用于一个声明上，它们求值方式与 复合函数 相似。在这个模型下，当复合 f 和 g 时，复合的结果 <code>\\(f∘g\\)\\(x\\)</code> 等同于 <code>f\\(g\\(x\\)\\)</code>。</p>\n</blockquote>\n<blockquote>\n<p>同样的，在 <code>TypeScript</code> 里，当多个装饰器应用在一个声明上时会进行如下步骤的操作： <code>1</code>. 由上至下依次对装饰器表达式求值 <code>2</code>. 求值的结果会被当作函数，由下至上依次被调用。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果我们使用 装饰器工厂 的话，可以通过下面的例子来观察它们求值的顺序：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;f(): evaluated&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, prototypeKey: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;f(): called&quot;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;g(): evaluated&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, prototypeKey: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;g(): called&quot;</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@f</span>()</span><br><span class=\"line\">  <span class=\"meta\">@g</span>()</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在控制台里会打印出如下结果：</span></span><br><span class=\"line\">f(): evaluated</span><br><span class=\"line\">g(): evaluated</span><br><span class=\"line\">g(): called</span><br><span class=\"line\">f(): called</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-5-装饰器求值\"><a href=\"#21-5-装饰器求值\" class=\"headerlink\" title=\"21.5 装饰器求值\"></a>21.5 装饰器求值</h3><blockquote>\n<p>类中不同声明上的装饰器将按以下规定的顺序应用：</p>\n</blockquote>\n<ul>\n<li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个实例成员。</li>\n<li>参数装饰器，然后依次是方法装饰器，访问符装饰器，或属性装饰器应用到每个静态成员。</li>\n<li>参数装饰器应用到构造函数。</li>\n<li>类装饰器应用到类。</li>\n</ul>\n<h3 id=\"21-6-类装饰器\"><a href=\"#21-6-类装饰器\" class=\"headerlink\" title=\"21.6 类装饰器\"></a>21.6 类装饰器</h3><p>1.类装饰器在类声明之前被声明(紧靠着类声明)。类装饰器应用于类构造函数，可以用来监视修改或替换类定义。类装饰器不能用在声明文件中( <code>.d.ts</code> )，也不能用在任何外部上下文中(比如 <code>declare</code> 的类)。</p>\n<ol start=\"2\">\n<li>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</li>\n<li>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</li>\n</ol>\n<blockquote>\n<p>注意：如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。在运行时的装饰器调用逻辑中 不会为你做这些。<br>下面是使用类装饰器( <code>@sealed</code> )的例子，应用在 <code>Greeter</code> 类：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@sealed</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter1</span> </span>&#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 我们可以这样定义 @sealed 装饰器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sealed</span>(<span class=\"params\">constructor: <span class=\"built_in\">Function</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.seal(<span class=\"title\">constructor</span>);</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.seal(<span class=\"title\">constructor</span>.<span class=\"title\">prototype</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当 <code>@sealed</code> 被执行的时候，它将密闭此类的构造函数和原型。(注：参见 <code>Object.seal</code> )</p>\n</blockquote>\n<ul>\n<li>下面是一个重载构造函数的例子：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">classDecorator</span>&lt;<span class=\"title\">T</span> <span class=\"title\">extends</span> </span>&#123; <span class=\"keyword\">new</span> (...args: <span class=\"built_in\">any</span>[]): &#123;&#125; &#125;&gt;(<span class=\"title\">constructor</span>: <span class=\"title\">T</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">constructor</span> </span>&#123;</span><br><span class=\"line\">    newProperty = <span class=\"string\">&quot;new property&quot;</span>;</span><br><span class=\"line\">    hello = <span class=\"string\">&quot;override&quot;</span>;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@classDecorator</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter2</span> </span>&#123;</span><br><span class=\"line\">  property = <span class=\"string\">&quot;property&quot;</span>;</span><br><span class=\"line\">  hello: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">m: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.hello = m;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> Greeter2(<span class=\"string\">&quot;world&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-7-方法装饰器\"><a href=\"#21-7-方法装饰器\" class=\"headerlink\" title=\"21.7 方法装饰器\"></a>21.7 方法装饰器</h3><blockquote>\n<p>方法装饰器声明在一个方法的声明之前(紧靠着方法声明)。它会被应用到方法的 <code>属性描述符</code> 上，可以用来监视，修改或者替换方法定义。方法装饰器不能用在声明文件 <code>.d.ts</code> 上，重载或者任何外部上下文(比如 <code>declare</code> 的类)中。</p>\n</blockquote>\n<blockquote>\n<p>方法装饰器表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p>\n<ol>\n<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>\n<li>成员的名字</li>\n<li>成员的属性修饰符</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：如果代码输出目标代码小于 <code>ES5</code>，属性描述符 将会是 <code>undefined</code>。</p>\n</blockquote>\n<blockquote>\n<p>如果方法装饰器返回一个值，它会被用作方法的 属性描述符。</p>\n</blockquote>\n<blockquote>\n<p>注意：如果代码输出目标版本小于 <code>ES5</code>，返回值会被忽略。</p>\n</blockquote>\n<ul>\n<li>下面是一个方法装饰器 (<code>@enumerable</code>) 的例子，应用于 <code>Greeter</code> 类的方法上。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@enumerable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们可以用下面的函数声明来定义 <code>@enumerable</code> 装饰器：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enumerable</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, property: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">    descriptor.enumerable = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的 <code>@enumerable(false)</code> 是一个装饰器工厂，当装饰器 <code>@enumerable(false)</code> 被调用时，它会修改属性描述符的 <code>enumerable</code> 属性。</p>\n</blockquote>\n<h3 id=\"21-8-访问器装饰器\"><a href=\"#21-8-访问器装饰器\" class=\"headerlink\" title=\"21.8 访问器装饰器\"></a>21.8 访问器装饰器</h3><blockquote>\n<p>访问器装饰器声明在一个访问器的声明之前(紧靠着访问器声明)。访问器装饰器 应用于访问器的 <code>属性描述符</code> 并且可以用来监视，修改或替换一个访问器的定义。访问器装饰器不能用在声明文件中( <code>.d.ts</code> )，或者任何外部上下文(比如 <code>declare</code> 的类)里。</p>\n</blockquote>\n<blockquote>\n<p>注意：<code>TypeScript</code> 不允许同时装饰一个成员的 <code>get</code> 和 <code>set</code> 访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了 <code>get</code> 和 <code>set</code> 访问器，而不是分开声明的。</p>\n</blockquote>\n<blockquote>\n<p>访问器装饰器表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p>\n<ol>\n<li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象。</li>\n<li>成员的名字</li>\n<li>成员的属性描述符</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：如果代码输出目标版本小于 <code>ES5</code>，<code>Property Descriptor</code> 将会是 <code>undefined</code>。</p>\n</blockquote>\n<blockquote>\n<p>如果访问器装饰器返回一个值，它会被用作方法的 <code>属性描述符</code> 注意：如果代码输出目标版本小于 <code>ES5</code> 返回值会被忽略。</p>\n</blockquote>\n<ul>\n<li>下面是使用了访问器装饰器 (<code>@configurable</code>) 的例子，应用于 <code>Point</code> 类的成员上。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">x: <span class=\"built_in\">number</span>, y: <span class=\"built_in\">number</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._x = x;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@configurable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">x</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@configurable</span>(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">y</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> p: Point = <span class=\"keyword\">new</span> Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>我们可以通过如下函数声明来定义 <code>@configurable</code> 装饰器：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configurable</span>(<span class=\"params\">value: <span class=\"built_in\">boolean</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyKey: <span class=\"built_in\">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</span><br><span class=\"line\">    descriptor.configurable = value;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"21-9-属性装饰器\"><a href=\"#21-9-属性装饰器\" class=\"headerlink\" title=\"21.9 属性装饰器\"></a>21.9 属性装饰器</h3><blockquote>\n<p>属性装饰器声明在一个属性声明之前(紧靠着属性声明)。属性装饰器不能用在声明文件中（<code>.d.ts</code>），或者任何外部上下文（比如 <code>declare</code> 的类）里。</p>\n</blockquote>\n<blockquote>\n<p>属性装饰器表达式会在运行时当作函数被调用，传入下列 <code>2</code> 个参数：</p>\n<ol>\n<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>\n<li>成员的名字。</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：<code>属性描述符</code> 不会作为参数传入属性装饰器，这与 <code>TypeScript</code> 是如何初始化属性装饰器有关。因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p>\n</blockquote>\n<ul>\n<li>我们可以用它来记录这个属性的元数据，如下例所示：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@format</span>(<span class=\"string\">&quot;Hello, %s&quot;</span>)</span><br><span class=\"line\">    greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> formatString = getFormat(<span class=\"built_in\">this</span>, <span class=\"string\">&quot;greeting&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> formatString.replace(<span class=\"string\">&quot;%s&quot;</span>, <span class=\"built_in\">this</span>.greeting);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"keyword\">let</span> g: Greeter = <span class=\"keyword\">new</span> Greeter(<span class=\"string\">&quot;鼓励&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"comment\">// 然后定义 @format 装饰器 和 getFormat 函数</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> formatMetadataKey = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;format&quot;</span>);</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">format</span>(<span class=\"params\">formatString: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.metadata(formatMetadataKey, formatString);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFormat</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyKey: <span class=\"built_in\">string</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Reflect</span>.getMetadata(formatMetadataKey, target, propertyKey);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这个 <code>@format(&quot;Hello, %s&quot;)</code> 装饰器是个 <code>装饰器工厂</code>。当 <code>@format(&quot;Hello, %s&quot;)</code> 被调用时，它添加一条这个属性的元数据，通过 <code>reflect-metadata</code> 库里的 <code>Reflect.metadata</code> 函数。当 <code>getFormat</code> 被调用时，它读取格式的元数据。</p>\n</blockquote>\n<blockquote>\n<p>注意：这个例子需要使用 <code>reflect-metadata</code> 库。查看 元数据 了解 <code>reflect-metadata</code> 库更详细的信息。</p>\n</blockquote>\n<h3 id=\"21-10-参数装饰器\"><a href=\"#21-10-参数装饰器\" class=\"headerlink\" title=\"21.10 参数装饰器\"></a>21.10 参数装饰器</h3><blockquote>\n<p><code>参数装饰器</code> 声明在一个参数声明之前(紧靠着参数声明)。参数装饰器应用于 <code>类构造函数</code> 或 <code>方法声明</code>。参数装饰器 不能用在声明文件（<code>.d.ts</code>），重载或其它外部上下文（比如 <code>declare</code> 的类）里。<br><code>参数装饰器</code> 表达式会在运行时当作函数被调用，传入下列 <code>3</code> 个参数：</p>\n<ol>\n<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>\n<li>成员的名字</li>\n<li>参数在函数参数列表的索引</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>注意：参数装饰器只能用来监视一个方法的参数是否被传入。</p>\n</blockquote>\n<blockquote>\n<p>参数装饰器的返回值会被忽略</p>\n</blockquote>\n<ul>\n<li>下面定义了参数装饰器( <code>@required</code> )并应用于 <code>Greeter</code> 类方法的一个参数：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Greeter</span> </span>&#123;</span><br><span class=\"line\">  greeting: <span class=\"built_in\">string</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">message: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.greeting = message;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">greet</span>(<span class=\"params\"><span class=\"meta\">@required</span> name: <span class=\"built_in\">string</span></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello &quot;</span> + name + <span class=\"string\">&quot;, &quot;</span> + <span class=\"built_in\">this</span>.greeting;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>然后我们使用下面的函数定义 <code>@required</code> 和 <code>@validate</code> 装饰器</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> requiredMetadataKey = <span class=\"built_in\">Symbol</span>(<span class=\"string\">&quot;required&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">required</span>(<span class=\"params\">target: <span class=\"built_in\">Object</span>, propertyKey: <span class=\"built_in\">string</span> | symbol, parameterIndex: <span class=\"built_in\">number</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> existingRequiredParameters: <span class=\"built_in\">number</span>[] = <span class=\"built_in\">Reflect</span>.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];</span><br><span class=\"line\">  existingRequiredParameters.push(parameterIndex);</span><br><span class=\"line\">  <span class=\"built_in\">Reflect</span>.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">validate</span>(<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyName: <span class=\"built_in\">string</span>, descriptor: TypedPropertyDescriptor&lt;<span class=\"built_in\">Function</span>&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> method = descriptor.value;</span><br><span class=\"line\">  descriptor.value = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> requiredParameters: <span class=\"built_in\">number</span>[] = <span class=\"built_in\">Reflect</span>.getOwnMetadata(requiredMetadataKey, target, propertyName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (requiredParameters) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> parameterIndex <span class=\"keyword\">of</span> requiredParameters) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parameterIndex &gt;= <span class=\"built_in\">arguments</span>.length || <span class=\"built_in\">arguments</span>[parameterIndex] === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;Missing required argument.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> method.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>@required</code> 装饰器添加了元数据实体把参数标记为必须的。<br><code>@validate</code> 装饰器把 <code>greet</code> 方法包裹在一个函数里，在调用原先的函数前验证函数参数。<br><code>注意：</code>这个例子使用了 <code>reflect-metadata</code> 库。 查看 元数据 了解 <code>reflect-metadata</code> 库的更多信息。</p>\n</blockquote>\n<h3 id=\"21-11-元数据\"><a href=\"#21-11-元数据\" class=\"headerlink\" title=\"21.11 元数据\"></a>21.11 元数据</h3><blockquote>\n<p>一部分例子使用了 <code>reflect-metadata</code> 库来支持实现性的 <code>metadata API</code>。这个库还不是 <code>ECMAScript\\( JavaScript \\)</code> 标准的一部分。然而，当装饰器被 <code>ECMAScript</code> 官方标准采纳后，这些扩展也将被推荐给 <code>ECMAScript</code> 以采纳。</p>\n</blockquote>\n<ul>\n<li>你可以通过 <code>npm</code> 安装这个库</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i reflect-metadata --save</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>TypeScript</code> 支持为带有装饰器的声明生成元数据。你需要在 <code>命令行</code> 或 <code>tsconfig.json</code> 里启用 <code>emitDecoratorMetadata</code> 编译器选项。</p>\n</blockquote>\n<ul>\n<li>命令行：</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tsc --target ES5 --experimentalDecorators --emitDecoratorMetadata</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>tsconfig.json</code></li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;target&quot;</span>: <span class=\"string\">&quot;ES5&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;experimentalDecorators&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;emitDecoratorMetadata&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当启用了，只要 <code>reflect-metadata</code> 库被引入了，设计阶段添加的类型信息可以在运行时使用。</p>\n</blockquote>\n<ul>\n<li>如下例所示：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;reflect-metadata&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">  x: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">  y: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _p0: Point;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _p1: Point;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">p0</span>(<span class=\"params\">value: Point</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._p0 = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">p0</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._p0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">p1</span>(<span class=\"params\">value: Point</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._p1 = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">p1</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._p1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">validate</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">target: <span class=\"built_in\">any</span>, propertyKey: <span class=\"built_in\">string</span>, descriptor: TypedPropertyDescriptor&lt;T&gt;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> set = descriptor.set;</span><br><span class=\"line\">  descriptor.set = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value: T</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">type</span> = <span class=\"built_in\">Reflect</span>.getMetadata(<span class=\"string\">&quot;design:type&quot;</span>, target, propertyKey);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(value <span class=\"keyword\">instanceof</span> <span class=\"keyword\">type</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&quot;Invalid type.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set(value);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>TypeScript</code> 编译器可以通过 <code>@Reflect.metadata</code> 装饰器注入设计阶段的类型信息。你可以认为它相当于下面的 <code>TypeScript：</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Line1</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _p0: Point;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> _p1: Point;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.metadata(<span class=\"string\">&quot;design:type&quot;</span>, Point)</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">p0</span>(<span class=\"params\">value: Point</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._p0 = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">p0</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._p0;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@validate</span></span><br><span class=\"line\">  <span class=\"meta\">@Reflect</span>.metadata(<span class=\"string\">&quot;design:type&quot;</span>, Point)</span><br><span class=\"line\">  <span class=\"keyword\">set</span> <span class=\"title\">p1</span>(<span class=\"params\">value: Point</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>._p1 = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span> <span class=\"title\">p1</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>._p1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意： 装饰器元数据是个实验性的特性并且可能在以后的版本中发声破坏性的改变。</p>\n</blockquote>\n<h3 id=\"21-12-Reflect-metadata-库\"><a href=\"#21-12-Reflect-metadata-库\" class=\"headerlink\" title=\"21.12 Reflect-metadata 库\"></a>21.12 Reflect-metadata 库</h3><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Reflect &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用于装饰器</span></span><br><span class=\"line\">    metadata(k, v): <span class=\"function\">(<span class=\"params\">target, property?</span>) =&gt;</span> <span class=\"built_in\">void</span></span><br><span class=\"line\">    <span class=\"comment\">// 在对象上面定义元数据</span></span><br><span class=\"line\">    defineMetadata(k, v, o, p?): <span class=\"built_in\">void</span></span><br><span class=\"line\">    <span class=\"comment\">// 是否存在元数据</span></span><br><span class=\"line\">    hasMetadata(k, o, p?): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">    hasOwnMetadata(k, o, p?): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取元数据</span></span><br><span class=\"line\">    getMetadata(k, o, p?): <span class=\"built_in\">any</span></span><br><span class=\"line\">    getOwnMetadata(k, o, p?): <span class=\"built_in\">any</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取所有元数据的 Key</span></span><br><span class=\"line\">    getMetadataKeys(o, p?): <span class=\"built_in\">any</span>[]</span><br><span class=\"line\">    getOwnMetadataKeys(o, p?): <span class=\"built_in\">any</span>[]</span><br><span class=\"line\">    <span class=\"comment\">// 删除元数据</span></span><br><span class=\"line\">    deleteMetadata(k, o, p?): <span class=\"built_in\">boolean</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"21-12-1-安装\"><a href=\"#21-12-1-安装\" class=\"headerlink\" title=\"21.12.1 安装\"></a>21.12.1 安装</h4><h5 id=\"Metadata-Reflection-API\"><a href=\"#Metadata-Reflection-API\" class=\"headerlink\" title=\"Metadata Reflection API\"></a>Metadata Reflection API</h5><ul>\n<li><a href=\"%5Bhttps://rbuckton.github.io/reflect-metadata%5D(https://rbuckton.github.io/reflect-metadata)\">Detailed proposal</a></li>\n</ul>\n<ol>\n<li>Installation</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install reflect-metadata</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>Background</li>\n</ol>\n<ul>\n<li>Decorators add the ability to augment a class and its members as the class is defined, through a declarative syntax.</li>\n<li>Traceur attaches annotations to a static property on the class.</li>\n<li>Languages like C# (.NET), and Java support attributes or annotations that add metadata to types, along with a reflective API for reading metadata.</li>\n</ul>\n<ol start=\"3\">\n<li>Goals</li>\n</ol>\n<ul>\n<li>A number of use cases (Composition/Dependency Injection, Runtime Type Assertions, Reflection/Mirroring, Testing) want the ability to add additional metadata to a class in a consistent manner.</li>\n<li>A consistent approach is needed for various tools and libraries to be able to reason over metadata.</li>\n<li>Metadata-producing decorators (nee. “Annotations”) need to be generally composable with mutating decorators.</li>\n<li>Metadata should be available not only on an object but also through a Proxy, with related traps.</li>\n<li>Defining new metadata-producing decorators should not be arduous or over-complex for a developer.</li>\n<li>Metadata should be consistent with other language and runtime features of ECMAScript.</li>\n</ul>\n<ol start=\"4\">\n<li>Syntax</li>\n</ol>\n<ul>\n<li>Declarative definition of metadata:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  @<span class=\"built_in\">Reflect</span>.metadata(metadataKey, metadataValue)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Imperative definition of metadata:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Reflect</span>.defineMetadata(metadataKey, metadataValue, C.prototype, <span class=\"string\">&quot;method&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Imperative introspection of metadata:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\"><span class=\"keyword\">let</span> metadataValue = <span class=\"built_in\">Reflect</span>.getMetadata(metadataKey, obj, <span class=\"string\">&quot;method&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>Semantics</li>\n</ol>\n<ul>\n<li>Object has a new [[Metadata]] internal property that will contain a Map whose keys are property keys (or <code>undefined</code> ) and whose values are Maps of metadata keys to metadata values.</li>\n<li>Object will have a number of new internal methods for [[DefineOwnMetadata]], [[GetOwnMetadata]], [[HasOwnMetadata]], etc.<ul>\n<li>These internal methods can be overridden by a Proxy to support additional traps.</li>\n<li>These internal methods will by default call a set of abstract operations to define and read metadata.</li>\n</ul>\n</li>\n<li>The Reflect object will expose the MOP operations to allow imperative access to metadata.</li>\n<li>Metadata defined on class declaration <em>C</em> is stored in <em>C</em>.[[Metadata]], with <code>undefined</code> as the key.</li>\n<li>Metadata defined on static members of class declaration <em>C</em> are stored in <em>C</em>.[[Metadata]], with the property key as the key.</li>\n<li>Metadata defined on instance members of class declaration <em>C</em> are stored in <em>C</em>.prototype.[[Metadata]], with the property key as the key.</li>\n</ul>\n<ol>\n<li>API</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// define metadata on an object or property</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.defineMetadata(metadataKey, metadataValue, target);</span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.defineMetadata(metadataKey, metadataValue, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// check for presence of a metadata key on the prototype chain of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.hasMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.hasMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// check for presence of an own metadata key of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.hasOwnMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.hasOwnMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get metadata value of a metadata key on the prototype chain of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get metadata value of an own metadata key of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getOwnMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getOwnMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get all metadata keys on the prototype chain of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getMetadataKeys(target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getMetadataKeys(target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get all own metadata keys of an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getOwnMetadataKeys(target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.getOwnMetadataKeys(target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// delete metadata from an object or property</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.deleteMetadata(metadataKey, target);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = <span class=\"built_in\">Reflect</span>.deleteMetadata(metadataKey, target, propertyKey);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// apply metadata via a decorator to a constructor</span></span><br><span class=\"line\">@<span class=\"built_in\">Reflect</span>.metadata(metadataKey, metadataValue)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// apply metadata via a decorator to a method (property)</span></span><br><span class=\"line\">  @<span class=\"built_in\">Reflect</span>.metadata(metadataKey, metadataValue)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"7\">\n<li>Alternatives</li>\n</ol>\n<ul>\n<li>Use properties rather than a separate API.<ul>\n<li>Obvious downside is that this can be a lot of code:</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ParamTypes</span>(<span class=\"params\">...types</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">target, propertyKey</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> symParamTypes = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;design:paramtypes&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (propertyKey === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      target[symParamTypes] = types;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> symProperties = <span class=\"built_in\">Symbol</span>.for(<span class=\"string\">&quot;design:properties&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">let</span> properties, property;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(target, symProperties)) &#123;</span><br><span class=\"line\">        properties = target[symProperties];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        properties = target[symProperties] = &#123;&#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(properties, propertyKey)) &#123;</span><br><span class=\"line\">        property = properties[propertyKey];</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        property = properties[propertyKey] = &#123;&#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      property[symParamTypes] = types;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>Notes</li>\n</ol>\n<ul>\n<li>Though it may seem counterintuitive, the methods on Reflect place the parameters for the metadata key and metadata value before the target or property key. This is due to the fact that the property key is the only optional parameter in the argument list. This also makes the methods easier to curry with Function#bind. This also helps reduce the overall footprint and complexity of a metadata-producing decorator that could target both a class or a property:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ParamTypes</span>(<span class=\"params\">...types</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// as propertyKey is effectively optional, its easier to use here</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">target, propertyKey</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Reflect</span>.defineMetadata(<span class=\"string\">&quot;design:paramtypes&quot;</span>, types, target, propertyKey);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// vs. having multiple overloads with the target and key in the front:</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// return (target, propertyKey) =&gt; &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//    if (propertyKey === undefined) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      Reflect.defineMetadata(target, &quot;design:paramtypes&quot;, types);</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    else &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      Reflect.defineMetadata(target, propertyKey, &quot;design:paramtypes&quot;, types);</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// vs. having a different methods for the class or a property:</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// return (target, propertyKey) =&gt; &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//    if (propertyKey === undefined) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      Reflect.defineMetadata(target, &quot;design:paramtypes&quot;, types);</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">//    else &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      Reflect.definePropertyMetadata(target, propertyKey, &quot;design:paramtypes&quot;, types);</span></span><br><span class=\"line\">  <span class=\"comment\">//    &#125;</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>To enable experimental support for metadata decorators in your TypeScript project, you must add <code>&quot;experimentalDecorators&quot;: true</code> to your tsconfig.json file.</li>\n<li>To enable experimental support for auto-generated type metadata in your TypeScript project, you must add <code>&quot;emitDecoratorMetadata&quot;: true</code> to your tsconfig.json file.<ul>\n<li>Please note that auto-generated type metadata may have issues with circular or forward references for types.</li>\n</ul>\n</li>\n</ul>\n<ol start=\"9\">\n<li>Issues</li>\n</ol>\n<ul>\n<li>A poorly written mutating decorator for a class constructor could cause metadata to become lost if the prototype chain is not maintained. Though, not maintaining the prototype chain in a mutating decorator for a class constructor would have other negative side effects as well. <a href=\"/rbuckton\">@rbuckton </a><ul>\n<li>This is mitigated if the mutating decorator returns a class expression that extends from the target, or returns a proxy for the decorator. <a href=\"/rbuckton\">@rbuckton </a></li>\n</ul>\n</li>\n<li>Metadata for a method is attached to the class (or prototype) via the property key. It would not then be available if trying to read metadata on the function of the method (e.g. “tearing-off” the method from the class). <a href=\"/rbuckton\">@rbuckton </a></li>\n</ul>\n<h2 id=\"二十二、Mixins-混入\"><a href=\"#二十二、Mixins-混入\" class=\"headerlink\" title=\"二十二、Mixins 混入\"></a>二十二、Mixins 混入</h2><h3 id=\"22-1-介绍\"><a href=\"#22-1-介绍\" class=\"headerlink\" title=\"22.1 介绍\"></a>22.1 介绍</h3><blockquote>\n<p>除了传统的面向对象继承方式，还流行一种通用可重用组件创建类的方式，就是联合另一个简单类的代码。<br>你可能在 <code>Scala</code> 等语言里对 <code>mixins</code> 及其特性已经很熟悉了，但它在 <code>JavaScript</code> 中也是很流行的。</p>\n</blockquote>\n<h3 id=\"22-2-混入示例\"><a href=\"#22-2-混入示例\" class=\"headerlink\" title=\"22.2 混入示例\"></a>22.2 混入示例</h3><blockquote>\n<p>下面的代码演示了如何在 <code>TypeScript</code> 里使用混入。后面我们还会解释这段代码是如何工作的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposable Mixin</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Disposable</span> </span>&#123;</span><br><span class=\"line\">  isDisposed: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">dispose</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isDisposed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Activatable Mixin</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activatable</span> </span>&#123;</span><br><span class=\"line\">  isActive: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">activate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isActive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">deactivate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isActive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartObject</span> <span class=\"title\">implements</span> <span class=\"title\">Disposable</span>, <span class=\"title\">Activatable</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setInterval</span>(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.isActive + <span class=\"string\">&quot;:&quot;</span> + <span class=\"built_in\">this</span>.isDisposed), <span class=\"number\">500</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">interact</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.activate();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Disposable</span></span><br><span class=\"line\">  isDisposed: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  dispose: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Activatable</span></span><br><span class=\"line\">  isActive: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  activate: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  deactivate: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">applyMixins(SmartObject, [Disposable, Activatable]);</span><br><span class=\"line\"><span class=\"keyword\">let</span> smartObj = <span class=\"keyword\">new</span> SmartObject();</span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> smartObj.interact(), <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">////////////////////////////////////////</span></span><br><span class=\"line\"><span class=\"comment\">// In your runtime library somewhere</span></span><br><span class=\"line\"><span class=\"comment\">////////////////////////////////////////</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMixins</span>(<span class=\"params\">derivedCtor: <span class=\"built_in\">any</span>, baseCtors: <span class=\"built_in\">any</span>[]</span>) </span>&#123;</span><br><span class=\"line\">  baseCtors.forEach(<span class=\"function\"><span class=\"params\">baseCtor</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"22-3-理解这个例子\"><a href=\"#22-3-理解这个例子\" class=\"headerlink\" title=\"22.3 理解这个例子\"></a>22.3 理解这个例子</h3><ol>\n<li>代码里首先定义了两个类，它们将做为 <code>mixins</code>。可以看到每个类都只定义了一个特定的行为或功能。稍后我们使用它们来创建一个新类，同时具有这两种功能。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposable Mixin</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Disponsable</span> </span>&#123;</span><br><span class=\"line\">  isDisponsed: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">dispose</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isDisponsed = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Activatable Mixin</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Activatable</span> </span>&#123;</span><br><span class=\"line\">  isActive: <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">activate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isActive = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">deactivate</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.isActive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>下面创建一个类，结合了这两个 <code>mixins</code>。 下面来看一下具体是怎么操作的：</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmartObject</span> <span class=\"title\">implements</span> <span class=\"title\">Disposable</span>, <span class=\"title\">Activatable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>首先应该注意到的是，没使用 <code>extends</code> 而是使用 <code>implements</code>。 把类当成了接口，仅使用 <code>Disposable</code> 和 <code>Activatable</code> 的类型而非其实现。 这意味着我们需要在类里面实现接口。但是这是我们在用 <code>mixin</code> 时想避免的。</li>\n<li>我们可以这么做来达到目的，为将要 <code>mixin</code> 进来的属性方法创建出占位属性。这告诉编译器这些成员在运行时是可用的。 这样就能使用 <code>mixin</code> 带来的便利，虽说需要提前定义一些占位属性。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Disposable</span></span><br><span class=\"line\">  isDisposed: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  dispose: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"comment\">// Activatable</span></span><br><span class=\"line\">  isActive: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  activate: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">  deactivate: <span class=\"function\">() =&gt;</span> <span class=\"built_in\">void</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>最后，把 <code>mixins</code> 混入定义的类，完成全部实现部分。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyMixins(SmartObject, [Disposable, Activatable]);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>最后，创建这个帮助函数，帮我们做混入操作。 它会遍历 <code>mixins</code> 上的所有属性，并复制到目标上去，把之前的占位属性替换成真正的实现代码。</li>\n</ol>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMixins</span>(<span class=\"params\">derivedCtor: <span class=\"built_in\">any</span>, baseCtors: <span class=\"built_in\">any</span>[]</span>) </span>&#123;</span><br><span class=\"line\">  baseCtors.forEach(<span class=\"function\"><span class=\"params\">baseCtor</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class=\"function\"><span class=\"params\">name</span> =&gt;</span> &#123;</span><br><span class=\"line\">      derivedCtor.prototype[name] = baseCtor.prototype[name];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二十三、三斜线指令\"><a href=\"#二十三、三斜线指令\" class=\"headerlink\" title=\"二十三、三斜线指令\"></a>二十三、三斜线指令</h2><ul>\n<li>三斜线指令是包含单个 <code>XML</code> 标签的单行注释。注释内容会做为编译器指令使用。</li>\n<li>三斜线指令仅可放在包含它的文件最顶端。一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。如果它们出现在一个语句或声明之后，那么它们会被当作普通的单行注释，并且不具有特殊的含义。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;...&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"comment\">/// &lt;reference path=&quot;...&quot; /&gt; 指令是三斜线指令中最常见的一种。 它用于声明文件间的 依赖。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>三斜线引用告诉编译器在编译过程中要引入的额外文件。</li>\n<li>当使用 <code>--out</code> 或 <code>--outFile</code> 时，它也可以做为调整输出内容顺序的一种方法。文件在输出文件内容中的位置与经过预处理后的输入顺序一致。</li>\n</ul>\n<h3 id=\"23-1-预处理输入文件\"><a href=\"#23-1-预处理输入文件\" class=\"headerlink\" title=\"23.1 预处理输入文件\"></a>23.1 预处理输入文件</h3><blockquote>\n<p>编译器会对输入文件进行预处理来解析所有三斜线引用指令。在这个过程中，额外的文件会加到编译过程中。<br>这个过程会以一些根文件开始；它们是在命令行中指定的文件或是在 <code>tsconfig.json</code> 中的 <code>&quot;files&quot;</code> 列表里的文件。这些根文件按指定的顺序进行预处理。在一个文件被加入列表前，它包含的所有三斜线引用都要被处理，还有它们包含的目标。三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析。<br>  一个三斜线引用路径是相对于包含它的文件的，如果不是根文件。</p>\n</blockquote>\n<h3 id=\"23-2-错误\"><a href=\"#23-2-错误\" class=\"headerlink\" title=\"23.2 错误\"></a>23.2 错误</h3><blockquote>\n<p>引用不存在的文件会报错。一个文件用三斜线指令引用自己会报错。</p>\n</blockquote>\n<h3 id=\"23-3-使用-noResolve\"><a href=\"#23-3-使用-noResolve\" class=\"headerlink\" title=\"23.3 使用 --noResolve\"></a>23.3 使用 <code>--noResolve</code></h3><blockquote>\n<p>如果指定了 <code>--noResolve</code> 编译选项，三斜线指令会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;reference types=&quot;...&quot; /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>与 <code>/// &lt;reference path=&quot;...&quot; /&gt;</code> 指令相似，这个指令是用来声明依赖的；一个 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 指令则声明了对某个包的依赖。</li>\n<li>对这些包的名字的解析与在 <code>import</code> 语句里对模块名的解析类似。可以简单地把三斜线类型引用指令当做 <code>import</code> 声明的包。</li>\n<li>例如，把 <code>/// &lt;reference types=&quot;node&quot; /&gt;</code>引入到声明文件，表明这个文件使用了<code>@types/node/index.d.ts</code> 里面声明的名字；并且，这个包需要在编译阶段与声明文件一起被包含进来。</li>\n<li>仅当在你需要写一个 <code>.d.ts</code> 文件时才使用这个指令。</li>\n<li>对于那些在编译阶段生成的声明文件，编译器会自动地添加 <code>/// &lt;reference types=&quot;...&quot; /&gt;</code>；当且仅当结果文件中使用了引用的包里的声明时才会在生成的声明文件里添加  <code>/// &lt;reference types=&quot;...&quot; /&gt;</code> 语句。</li>\n<li>若要在 <code>.ts</code> 文件里声明一个对 <code>@types</code> 包的依赖，使用 <code>--types</code> 命令行选项 或在 <code>tsconfig.json</code> 里指定。查看 在 <code>tsconfig.json</code> 里使用 <code>@types</code>，<code>typeRoots</code> 和 <code>types</code> 了解详情。</li>\n<li><code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 这个指令把一个文件标记成默认库。你会在 <code>lib.d.ts</code> 文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中不要包含这个默认库（比如，<code>lib.d.ts</code>）。 这与在命令行上使用 -<code>-noLib</code> 相似。</li>\n<li>还要注意，当传递了 <code>--skipDefaultLibCheck</code> 时，编译器只会忽略检查带有 <code>/// &lt;reference no-default-lib=&quot;true&quot;/&gt;</code> 的文件。</li>\n</ul>\n<h3 id=\"23-4-lt-amd-module-gt\"><a href=\"#23-4-lt-amd-module-gt\" class=\"headerlink\" title=\"23.4 &lt;amd-module /&gt;\"></a>23.4 <code>&lt;amd-module /&gt;</code></h3><blockquote>\n<p>默认情况下生成的 <code>AMD</code> 模块 都是匿名的。但是，当一些工具需要处理生成的模块时会产生问题，比如 <code>r.js。amd-module</code> 指令允许给编译器传入一个可选的模块名：</p>\n</blockquote>\n<ul>\n<li><code>amdModule.ts</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;amd-module name=&quot;NamedModule&quot; /&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这会将 <code>NamedModule</code> 传入到 <code>AMD define</code> 函数里：</p>\n</blockquote>\n<ul>\n<li><code>amdModule.js</code></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">&quot;NamedModule&quot;</span>, [<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> C = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> C;</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">  <span class=\"built_in\">exports</span>.C = C;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"23-5-lt-amd-dependency-gt\"><a href=\"#23-5-lt-amd-dependency-gt\" class=\"headerlink\" title=\"23.5 &lt;amd-dependency /&gt;\"></a>23.5 <code>&lt;amd-dependency /&gt;</code></h3><ul>\n<li>注意：这个指令被废弃了。使用 <code>import &quot;moduleName&quot;;</code> 语句代替。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;amd-dependency path=&quot;x&quot; /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 告诉编译器有一个非 TypeScript 模块依赖需要被注入，做为目标模块 require 调用的一部分。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>amd-dependency</code> 指令也可以带一个可选的 <code>name</code> 属性；它允许我们为 <code>amd-dependency</code> 传入一个可选名字：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/// &lt;amd-dependency path=&quot;legacy/moduleA&quot; name=&quot;moduleA&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">var</span> moduleA: MyType;</span><br><span class=\"line\">moduleA.callStuff();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>生成的 <code>JavaScript</code> 代码：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">&quot;require&quot;</span>, <span class=\"string\">&quot;exports&quot;</span>, <span class=\"string\">&quot;legacy/moduleA&quot;</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"><span class=\"built_in\">require</span>, <span class=\"built_in\">exports</span>, moduleA</span>) </span>&#123;</span><br><span class=\"line\">  moduleA.callStuff();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二十四、JavaScript-文件类型检查\"><a href=\"#二十四、JavaScript-文件类型检查\" class=\"headerlink\" title=\"二十四、JavaScript 文件类型检查\"></a>二十四、JavaScript 文件类型检查</h2><h3 id=\"24-1-JavaScript-文件类型检查\"><a href=\"#24-1-JavaScript-文件类型检查\" class=\"headerlink\" title=\"24.1 JavaScript 文件类型检查\"></a>24.1 JavaScript 文件类型检查</h3><blockquote>\n<p><code>TypeScript 2.3</code> 以后的版本支持使用 <code>--checkJs</code> 对 <code>.js</code> 文件进行类型检查和错误提示。</p>\n</blockquote>\n<blockquote>\n<p>你可以通过添加 <code>// @ts-nocheck</code> 注释来忽略类型检查；相反，你可以通过去掉 <code>--checkJs</code> 设置并添加一个 <code>// @ts-nocheck</code> 注释来选择检查某些 <code>.js</code> 文件。你还可以用 <code>// @ts-ignore</code> 来忽略本行的错误。如果你使用了 <code>tsconfig.json</code>，<code>JS</code> 检查将遵照一些严格检查标记，如 <code>noImplicitAny</code>，<code>strictNullChecks</code> 等。但因为 <code>JS</code> 检查是相对宽松的，在使用严格标记时可能会有些出乎意料的情况。</p>\n</blockquote>\n<ul>\n<li>对比 <code>.js</code>文件和 <code>.ts</code> 文件在类型检查上的差异，有如下几点需要注意</li>\n</ul>\n<h4 id=\"1-用-JSDoc-类型表示类型信息\"><a href=\"#1-用-JSDoc-类型表示类型信息\" class=\"headerlink\" title=\"(1) 用 JSDoc 类型表示类型信息\"></a>(1) 用 <code>JSDoc</code> 类型表示类型信息</h4><blockquote>\n<p><code>.js</code> 文件里，类型可以和在 <code>.ts</code> 文件里一样被推断出来。同样地，当类型不能被推断时，它们可以通过 <code>JSDoc</code> 来指定，就好比在 <code>.ts</code> 文件里那样。如同 <code>TypeScript</code>，<code>--noImplicitAny</code> 会在编译器无法推断类型的位置报错。（除了对象字面量的情况；后面会详细介绍）<code>JSDoc</code> 注解修饰的声明会被设置为这个声明的类型。比如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;number&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x;</span><br><span class=\"line\">x = <span class=\"number\">0</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">x = <span class=\"literal\">false</span>; <span class=\"comment\">// Error: boolean is not assignable to number</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>你可以在这里找到所有 <code>JSDoc</code> 支持的模式，<a href=\"https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript\">JSDoc 文档</a>。</p>\n</blockquote>\n<h4 id=\"2-属性的推断来自于类内的赋值语句\"><a href=\"#2-属性的推断来自于类内的赋值语句\" class=\"headerlink\" title=\"(2) 属性的推断来自于类内的赋值语句\"></a>(2) 属性的推断来自于类内的赋值语句</h4><blockquote>\n<p><code>ES2015</code> 没提供声明类属性的方法。属性是动态赋值的，就像对象字面量一样。在 <code>.js</code> 文件里，编译器从类内部的属性赋值语句来推断属性类型。属性的类型是在构造函数里赋的值的类型，除非它没在构造函数里定义或者在构造函数里是 <code>undefined</code> 或 <code>null</code>。若是这种情况，类型将会是所有赋值的类型的联合类型。在构造函数里定义的属性会被认为是一直存在的，然而那些在方法，存取器里定义的属性被当成可选的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.constructorOnly = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.constructorUnknown = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.constructorOnly = <span class=\"literal\">false</span>; <span class=\"comment\">// error, constructorOnly is a number</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.constructorUnknown = <span class=\"string\">&quot;plunkbat&quot;</span>; <span class=\"comment\">// ok, constructorUnknown is string | undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.methodOnly = <span class=\"string\">&quot;ok&quot;</span>; <span class=\"comment\">// ok, but y could also be undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">method2</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.methodOnly = <span class=\"literal\">true</span>; <span class=\"comment\">// also, ok, y&#x27;s type is string | boolean | undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果一个属性从没在类内设置过，它们会被当成未知的。</p>\n</blockquote>\n<blockquote>\n<p>如果类的属性只是读取用的，那么就在构造函数里用 <code>JSDoc</code> 声明它的类型。如果它稍后会被初始化，你甚至都不需要在构造函数里给它赋值：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;name | undefined&#125;</span> </span>*/</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.prop = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    <span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;number | undefined&#125;</span> </span>*/</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.count;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"keyword\">new</span> C();</span><br><span class=\"line\">c.prop = <span class=\"number\">0</span>; <span class=\"comment\">// Ok</span></span><br><span class=\"line\">c.count = <span class=\"string\">&quot;string&quot;</span>; <span class=\"comment\">// Error: string is not assignable to number | undefined</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-构造函数等同于类\"><a href=\"#3-构造函数等同于类\" class=\"headerlink\" title=\"(3) 构造函数等同于类\"></a>(3) 构造函数等同于类</h4><blockquote>\n<p><code>ES2015</code> 以前，<code>Javascript</code> 使用构造函数代替类。编译器支持这种模式并能够将构造函数识别为 <code>ES2015</code> 的类。属性类型推断机制和上面介绍的一致。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.constructorOnly = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.constructorUnknown = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">C.prototype.method = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.constructorOnly = <span class=\"literal\">false</span>; <span class=\"comment\">// error</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.constructorUnknown = <span class=\"string\">&quot;plunkbat&quot;</span>; <span class=\"comment\">// OK, the type is string | undefined</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-支持-CommonJS-模块\"><a href=\"#4-支持-CommonJS-模块\" class=\"headerlink\" title=\"(4) 支持 CommonJS 模块\"></a>(4) 支持 <code>CommonJS</code> 模块</h4><blockquote>\n<p>在 <code>.js</code> 文件里，<code>TypeScript</code> 能识别出 <code>CommonJS</code> 模块。对 <code>exports</code> 和 <code>module.exports</code> 的赋值被识别为导出声明。相似地，<code>require</code> 函数调用被识别为模块导入。例如：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// same as `import module &#x27;fs&#x27;`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// same as `export function readFile`</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports.readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fs.readFileSync(f);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对 <code>JavaScript</code> 文件里模块语法的支持比在 <code>TypeScript</code> 里宽泛多了。 大部分的赋值和声明方式都是允许的。</p>\n</blockquote>\n<h4 id=\"5-类，函数和对象字面量是命名空间\"><a href=\"#5-类，函数和对象字面量是命名空间\" class=\"headerlink\" title=\"(5) 类，函数和对象字面量是命名空间\"></a>(5) 类，函数和对象字面量是命名空间</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .js 文件里的类是命名空间。它可以用于嵌套类，比如：</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;&#125;</span><br><span class=\"line\">C.D = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// ES2015 之前的代码，它可以用来模拟静态方法。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Outer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.y = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Outer.Inner = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.yy = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 它还可以用于创建简单的命名空间：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ns = &#123;&#125;;</span><br><span class=\"line\">ns.C = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;&#125;;</span><br><span class=\"line\">ns.func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 同时还支持其它的变化</span></span><br><span class=\"line\"><span class=\"comment\">// 立即调用的函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ns = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n | &#123;&#125;;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">ns.COUNT = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// defaulting to global</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> assign =</span><br><span class=\"line\">  assign ||</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// code goes here</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">assign.extra = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-对象字面量是开放的\"><a href=\"#6-对象字面量是开放的\" class=\"headerlink\" title=\"(6) 对象字面量是开放的\"></a>(6) 对象字面量是开放的</h4><ul>\n<li><code>.ts</code> 文件里，用对象字面量初始化一个变量的同时也给它声明了类型。 新的成员不能再被添加到对象字面量中。这个规则在 <code>.js</code> 文件里被放宽了；对象字面量具有开放的类型，允许添加并访问原先没有定义的属性。例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">obj.b = <span class=\"number\">2</span>; <span class=\"comment\">// Allowed</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对象字面量的表现就好比具有一个默认的索引签名 <code>\\[x:string\\]: any</code>，它们可以被当成开放的映射而不是封闭的对象。</li>\n<li>与其它 <code>JS</code> 检查行为相似，这种行为可以通过指定 <code>JSDoc</code> 类型来改变，例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;&#123; a: number &#125;</span></span>&#125; */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">obj.b = <span class=\"number\">2</span>; <span class=\"comment\">// Error, type &#123;a: number&#125; does not have property b</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-null-undefined-和-空数组的类型是-any-或-any\"><a href=\"#7-null-undefined-和-空数组的类型是-any-或-any\" class=\"headerlink\" title=\"(7) null undefined 和 空数组的类型是 any 或 any[]\"></a>(7) null undefined 和 空数组的类型是 any 或 any[]</h4><blockquote>\n<p>任何用 <code>null</code>，<code>undefined</code> 初始化的变量，参数或属性，它们的类型是 <code>any</code>，就算是在严格 <code>null</code> 检查模式下。任何用 <code>[]</code> 初始化的变量，参数或属性，它们的类型是 <code>any[]</code>，就算是在严格 <code>null</code> 检查模式下。 唯一的例外是像上面那样有多个初始化器的属性。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\">i = <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!i) i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> j = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  j = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.l = [];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">foo.l.push(foo.i);</span><br><span class=\"line\">foo.l.push(<span class=\"string\">&quot;end&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"8-函数参数是默认可选的\"><a href=\"#8-函数参数是默认可选的\" class=\"headerlink\" title=\"(8) 函数参数是默认可选的\"></a>(8) 函数参数是默认可选的</h4><blockquote>\n<p>由于在 <code>ES2015</code> 之前无法指定可选参数，因此 <code>.js</code> 文件里所有函数参数都被当做是可选的。 使用比预期少的参数调用函数是允许的。</p>\n</blockquote>\n<blockquote>\n<p>需要注意的一点是，使用过多的参数调用函数会得到一个错误。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a + <span class=\"string\">&quot; &quot;</span> + b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(<span class=\"number\">1</span>); <span class=\"comment\">// OK, second argument considered optional</span></span><br><span class=\"line\">bar(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">bar(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>); <span class=\"comment\">// Error, too many arguments</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>JSDoc</code> 注解的函数会被从这条规则里移除。使用 <code>JSDoc</code> 可选参数语法来表示可选性。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比如：</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>[somebody] - Somebody&#x27;s name.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\">somebody</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!somebody) &#123;</span><br><span class=\"line\">    somebody = <span class=\"string\">&quot;John Doe&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Hello &quot;</span> + somebody);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">sayHello();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-由-arguments-推断出的-var-args-参数声明\"><a href=\"#9-由-arguments-推断出的-var-args-参数声明\" class=\"headerlink\" title=\"(9) 由 arguments 推断出的 var-args 参数声明\"></a>(9) 由 <code>arguments</code> 推断出的 <code>var-args</code> 参数声明</h4><blockquote>\n<p>如果一个函数的函数体内有对 <code>arguments</code> 的引用，那么这个函数会隐式地被认为具有一个 <code>var-arg</code> 参数（比如: <code>(...arg: any[]) =&gt;; any)</code>）。使用 <code>JSDoc</code> 的 <code>var-arg</code> 语法来指定 <code>arguments</code> 的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@param <span class=\"type\">&#123;...number&#125;</span> </span>args */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\"><span class=\"comment\">/* numbers */</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">    total += <span class=\"built_in\">arguments</span>[i];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"10-未指定的类型参数默认为-any\"><a href=\"#10-未指定的类型参数默认为-any\" class=\"headerlink\" title=\"(10) 未指定的类型参数默认为 any\"></a>(10) 未指定的类型参数默认为 <code>any</code></h4><blockquote>\n<p>由于 <code>JavaScript</code> 里没有一种自然的语法来指定泛型参数，因此未指定的参数类型默认为 <code>any</code>。</p>\n</blockquote>\n<h4 id=\"11-在-extends-语句中：\"><a href=\"#11-在-extends-语句中：\" class=\"headerlink\" title=\"(11) 在 extends 语句中：\"></a>(11) 在 <code>extends</code> 语句中：</h4><blockquote>\n<p>例如，<code>React.Component</code> 被定义成具有两个类型参数，<code>Props</code> 和 <code>State</code>。 在一个 <code>.js</code> 文件里，没有一个合法的方式在 <code>extends</code> 语句里指定它们。默认地参数类型为 <code>any</code>：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.props.b; <span class=\"comment\">// Allowed, since this.props is of type any</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>使用 <code>JSDoc</code> 的 <code>@augments</code> 来明确地指定类型。</p>\n</blockquote>\n<ul>\n<li>例如：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;react&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@augments <span class=\"type\">&#123;Component&lt;&#123;a: number&#125;</span></span>, State&gt;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.props.b; <span class=\"comment\">// Error: b does not exist on &#123;a:number&#125;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-在-JSDoc-引用中\"><a href=\"#12-在-JSDoc-引用中\" class=\"headerlink\" title=\"(12) 在 JSDoc 引用中\"></a>(12) 在 JSDoc 引用中</h4><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type<span class=\"type\">&#123;Array&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = [];</span><br><span class=\"line\"></span><br><span class=\"line\">x.push(<span class=\"number\">1</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\">x.push(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// OK, x is of type Array&lt;any&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type<span class=\"type\">&#123;Array.&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> y = [];</span><br><span class=\"line\"></span><br><span class=\"line\">y.push(<span class=\"number\">1</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\">y.push(<span class=\"string\">&quot;string&quot;</span>); <span class=\"comment\">// Error, string is not assignable to number</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"13-在函数调用中\"><a href=\"#13-在函数调用中\" class=\"headerlink\" title=\"(13) 在函数调用中\"></a>(13) 在函数调用中</h4><blockquote>\n<p>泛型函数的调用使用 <code>arguments</code> 来推断泛型参数。有时候，这个流程不能够推断出类型，大多是因为缺少推断的源；在这种情况下，类型参数类型默认为 <code>any</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 例如：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reject();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p; <span class=\"comment\">// Promise&lt;any&gt;;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"24-2-支持的-JSDoc\"><a href=\"#24-2-支持的-JSDoc\" class=\"headerlink\" title=\"24.2 支持的 JSDoc\"></a>24.2 支持的 JSDoc</h3><blockquote>\n<p>面的列表列出了当前所支持的 <code>JSDoc</code> 注解，你可以用它们在 <code>JavaScript</code> 文件里添加类型信息。 注意，没有在下面列出的标记（例如 <code>@async</code>）都是还不支持的。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>  <span class=\"meta\">@type</span></span><br><span class=\"line\"><span class=\"number\">2.</span>  <span class=\"meta\">@param</span> (or <span class=\"meta\">@arg</span> or <span class=\"meta\">@argument</span>)</span><br><span class=\"line\"><span class=\"number\">3.</span>  <span class=\"meta\">@returns</span> (or <span class=\"meta\">@return</span>)</span><br><span class=\"line\"><span class=\"number\">4.</span>  <span class=\"meta\">@typedef</span></span><br><span class=\"line\"><span class=\"number\">5.</span>  <span class=\"meta\">@callback</span></span><br><span class=\"line\"><span class=\"number\">6.</span>  <span class=\"meta\">@template</span></span><br><span class=\"line\"><span class=\"number\">7.</span>  <span class=\"meta\">@class</span> (or <span class=\"meta\">@constructor</span>)</span><br><span class=\"line\"><span class=\"number\">8.</span>  <span class=\"meta\">@this</span></span><br><span class=\"line\"><span class=\"number\">9.</span>  <span class=\"meta\">@extends</span> (or <span class=\"meta\">@augments</span>)</span><br><span class=\"line\"><span class=\"number\">10.</span> <span class=\"meta\">@enum</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>它们代表的意义与 <code>usejsdoc.org</code> 上面给出的通常是一致的或者是它的超集。 下面的代码描述了它们的区别并给出了一些示例。</p>\n</blockquote>\n<h4 id=\"1-type\"><a href=\"#1-type\" class=\"headerlink\" title=\"(1) @type \"></a>(1) <a href=\"/type\">@type </a></h4><blockquote>\n<p>可以使用 <code>@type</code> 标记并引用一个类型名称（原始类型，<code>TypeScript</code> 里声明的类型，或在 <code>JSDoc</code> 里 <code>@typedef</code> 标记指定的）可以使用任何 <code>TypeScript</code> 类型和大多数 <code>JSDoc</code> 类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;string&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Window&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> win;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;PromiseLike&lt;string&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promisedString;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// You can specify an HTML Element with DOM properties</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;HTMLElement&#125;</span> </span>*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myElement = <span class=\"built_in\">document</span>.querySelector(selector);</span><br><span class=\"line\">element.dataset.myData = <span class=\"string\">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>@type</code> 可以指定联合类型—例如，<code>string</code> 和 <code>boolean</code> 类型的联合。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;&#123;string | boolean&#125;</span></span>&#125; */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sb;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意：括号是可选的</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;string | boolean&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sb;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>有多种方式来指定数组类型</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;number[]&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ns;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Array.&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nds;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Array&lt;number&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nas;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还可以指定对象字面量类型。例如，一个带有 <code>a(字符串)</code> 和 <code>b(数字)</code> 属性的对象，使用下面的语法：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;&#123;a: string, b: number&#125;</span></span>&#125; */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> var9;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以使用字符串和数字索引签名来指定 <code>map-like</code> 和 <code>array-like</code> 的对象，使用标准的 <code>JSDoc</code> 语法或者 <code>TypeScript</code> 语法。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * A map-like object that maps arbitrary `string` properties to `number`s.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;Object.&lt;string, number&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> stringToNumber;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Object.&lt;number, object&gt;&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayLike;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这两个类型与 <code>TypeScript</code> 里的 <code>&#123; [x: string]: number &#125;</code> 和 <code>&#123; [x: number]: any &#125;</code> 是等同的。 编译器能识别出这两种语法。</li>\n<li>可以使用 <code>TypeScript</code> 或 <code>Closure</code> 语法指定函数类型。</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;function(string, boolean): number&#125;</span> </span>Closure syntax */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sbn;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;(s: string, b: boolean) =&gt; number&#125;</span> </span>Typescript syntax */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sbn2;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>或者直接使用未指定的 <code>Function</code> 类型：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Function&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn7;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;function&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn6;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>Closure</code> 的其它类型也可以使用：</li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;*&#125;</span> </span>- can be &#x27;any&#x27; type */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> star;</span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;?&#125;</span> </span>- unknown type (same as &#x27;any&#x27;) */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> question;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-转换\"><a href=\"#2-转换\" class=\"headerlink\" title=\"(2) 转换\"></a>(2) 转换</h4><blockquote>\n<p><code>TypeScript</code> 借鉴了 <code>Closure</code> 里的转换语法。在括号表达式前面使用 <code>@type</code> 标记，可以将一种类型转换成另一种类型</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;number | string&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> numberOrString = <span class=\"built_in\">Math</span>.random() &lt; <span class=\"number\">0.5</span> ? <span class=\"string\">&quot;hello&quot;</span> : <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> typeAssertedNumber = <span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;number&#125;</span> </span>*/</span> numberOrString;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-导入类型\"><a href=\"#3-导入类型\" class=\"headerlink\" title=\"(3) 导入类型\"></a>(3) 导入类型</h4><blockquote>\n<p>可以使用导入类型从其它文件中导入声明。 这个语法是 <code>TypeScript</code> 特有的，与 <code>JSDoc</code> 标准不同：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param </span>p &#123; import(&quot;./a&quot;).Pet &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">walk</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Walking <span class=\"subst\">$&#123;p.name&#125;</span>...`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>导入类型也可以使用在类型别名声明中：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@typedef </span>Pet &#123; import(&quot;./a&quot;).Pet &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;Pet&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myPet;</span><br><span class=\"line\">myPet.name;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>导入类型可以用在从模块中得到一个值的类型。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;typeof import(&quot;./a&quot;).x &#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;./a&quot;</span>).x;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-param-和-returns\"><a href=\"#4-param-和-returns\" class=\"headerlink\" title=\"(4) @param  和 @returns \"></a>(4) <a href=\"/param\">@param </a> 和 <a href=\"/returns\">@returns </a></h4><blockquote>\n<p><code>@param</code> 语法 和 <code>@type</code> 相同，但增加了一个参数名。 使用 <code>[]</code> 可以把参数声明为可选的：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Parameters may be declared in a variety of syntactic forms</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span>  <span class=\"variable\">p1</span></span> - A string param.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string=&#125;</span> <span class=\"variable\">p2</span></span> - An optional param (Closure syntax)</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>[p3] - Another optional param (JSDoc syntax).</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>[p4=&quot;test&quot;] - An optional param with a default value</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;string&#125;</span> </span>This is the result</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringsStringStrings</span>(<span class=\"params\">p1, p2, p3, p4</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>函数的返回值类型也是类似的：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;PromiseLike&lt;string&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ps</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns <span class=\"type\">&#123;&#123; a: string, b: number &#125;</span></span>&#125; - May use &#x27;<span class=\"doctag\">@returns</span>&#x27; as well as &#x27;<span class=\"doctag\">@return</span>&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ab</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-typedef-callback-和-param\"><a href=\"#5-typedef-callback-和-param\" class=\"headerlink\" title=\"(5) @typedef, @callback, 和 @param \"></a>(5) @typedef, @callback, 和 <a href=\"/param\">@param </a></h4><blockquote>\n<p><code>@typedef</code> 可以用来声明复杂类型。和 <code>@param</code> 类似的语法。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@typedef <span class=\"type\">&#123;Object&#125;</span> <span class=\"variable\">SpecialType</span></span> - creates a new type named &#x27;SpecialType&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">prop1</span></span> - a string property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">prop2</span></span> - a number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;number=&#125;</span> <span class=\"variable\">prop3</span></span> - an optional number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@prop <span class=\"type\">&#123;number&#125;</span> </span>[prop4] - an optional number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@prop <span class=\"type\">&#123;number&#125;</span> </span>[prop5=42] - an optional number property of SpecialType with default</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;SpecialType&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> specialTypeObject;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>可以在第一行上使用 <code>object</code> 或 <code>Object</code>。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@typedef <span class=\"type\">&#123;object&#125;</span> <span class=\"variable\">SpecialType1</span></span> - creates a new type named &#x27;SpecialType&#x27;</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">prop1</span></span> - a string property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">prop2</span></span> - a number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@property <span class=\"type\">&#123;number=&#125;</span> <span class=\"variable\">prop3</span></span> - an optional number property of SpecialType</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;SpecialType1&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> specialTypeObject1;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>@param</code> 允许使用相似的语法。 注意，嵌套的属性名必须使用参数名做为前缀：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Object&#125;</span> <span class=\"variable\">options</span></span> - The shape is the same as SpecialType above</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> </span>options.prop1</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>options.prop2</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number=&#125;</span> </span>options.prop3</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[options.prop4]</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[options.prop5=42]</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">special</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (options.prop4 || <span class=\"number\">1001</span>) + options.prop5;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>@callback</code> 与 <code>@typedef</code> 相似，但它指定函数类型而不是对象类型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@callback <span class=\"variable\">Predicate</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">data</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> </span>[index]</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@returns <span class=\"type\">&#123;boolean&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@type <span class=\"type\">&#123;Predicate&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> ok = <span class=\"function\"><span class=\"params\">s</span> =&gt;</span> !(s.length % <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>当然，所有这些类型都可以使用 <code>TypeScript</code> 的语法 <code>@typedef</code> 在一行上声明：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@typedef <span class=\"type\">&#123;&#123; prop1: string, prop2: string, prop3?: number &#125;</span></span>&#125; SpecialType */</span></span><br><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@typedef <span class=\"type\">&#123;(data: string, index?: number) =&gt; boolean&#125;</span> </span>Predicate */</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-template\"><a href=\"#6-template\" class=\"headerlink\" title=\"(6) @template \"></a>(6) <a href=\"/template\">@template </a></h4><blockquote>\n<p>使用 <code>@template</code> 声明泛型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template <span class=\"variable\">T</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;T&#125;</span> <span class=\"variable\">p1</span></span> - A generic parameter that flows through to the return type</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return <span class=\"type\">&#123;T&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">id</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>用逗号或多个标记来声明多个类型参数：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template </span>T,U,V</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template </span>W,X</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>还可以在参数名前指定类型约束。只有列表的第一项类型参数会被约束:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">K</span></span> - K must be a string or string literal</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template <span class=\"type\">&#123;&#123; serious(): string &#125;</span></span>&#125; Seriousalizable - must have a serious method</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;K&#125;</span> <span class=\"variable\">key</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;Seriousalizable&#125;</span> <span class=\"variable\">object</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">seriousalize</span>(<span class=\"params\">key, <span class=\"built_in\">object</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ????</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"7-constructor\"><a href=\"#7-constructor\" class=\"headerlink\" title=\"(7) @constructor \"></a>(7) <a href=\"/constructor\">@constructor </a></h4><blockquote>\n<p>编译器通过 <code>this</code> 属性的赋值来推断构造函数, 但你可以让检查更严格提示更友好, 你可以添加一个 <code>@constructor</code> 标记:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@constructor</span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;number&#125;</span> <span class=\"variable\">data</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">C</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.initialize(data); <span class=\"comment\">// Should error, initializer expects a string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;string&#125;</span> <span class=\"variable\">s</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">C.prototype.initialize = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.size = s.length;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> C(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = C(<span class=\"number\">1</span>); <span class=\"comment\">// C should only be called with new</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>通过 <code>@constructor</code>, <code>this</code> 将在构造函数<code>C</code>里被检查，因此你在 <code>initialize</code> 方法里得到一个提示，如果你传入一个数字你还将得到一个错误提示。如果你直接调用<code>C</code>而不是构造它，也会得到一个错误。</p>\n</blockquote>\n<blockquote>\n<p>不幸的是，这意味着那些既能构造也能直接调用的构造函数不能使用 <code>@constructor</code>。</p>\n</blockquote>\n<h4 id=\"8-this\"><a href=\"#8-this\" class=\"headerlink\" title=\"(8) @this \"></a>(8) <a href=\"/this\">@this </a></h4><blockquote>\n<p>编译器通常可以通过上下文来推断出 <code>this</code> 的类型。但你可以使用 <code>@this</code> 来明确指定它的类型：</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@this <span class=\"type\">&#123;HTMLElement&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> <span class=\"variable\">e</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callbackForLater</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.clientHeight = <span class=\"built_in\">parseInt</span>(e); <span class=\"comment\">// should be fine!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"9-extends\"><a href=\"#9-extends\" class=\"headerlink\" title=\"(9) @extends \"></a>(9) <a href=\"/extends\">@extends </a></h4><blockquote>\n<p>当 <code>JavaScript</code> 类继承了一个基类, 无处指定类型参数的类型, 而 <code>@extends</code> 标记提供了这样一种方式:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@template <span class=\"variable\">T</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@extends <span class=\"type\">&#123;Set&lt;T&gt;&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortableSet</span> <span class=\"keyword\">extends</span> <span class=\"title\">Set</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>@extends</code> 只作用于类。当前，无法实现构造函数继承类的情况。</p>\n</blockquote>\n<h4 id=\"10-enum\"><a href=\"#10-enum\" class=\"headerlink\" title=\"(10) @enum \"></a>(10) <a href=\"/enum\">@enum </a></h4><blockquote>\n<p><code>@enum</code> 标记允许你创建一个对象字面量, 它的成员都有确定的类型。不同于 <code>JavaScript</code> 里大多数的对象字面量，它不允许添加额外成员。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@enum <span class=\"type\">&#123;number&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> JSDocState = &#123;</span><br><span class=\"line\">  BeginningOfLine: <span class=\"number\">0</span>,</span><br><span class=\"line\">  SawAsterisk: <span class=\"number\">1</span>,</span><br><span class=\"line\">  SavingComments: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意 <code>@enum</code> 与 <code>TypeScript</code> 的 <code>@enum</code> 大不相同, 它更加简单。然而，不同于 <code>TypeScript</code> 的枚举, <code>@enum</code> 可以是任何类型:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** <span class=\"doctag\">@enum <span class=\"type\">&#123;function(number): number&#125;</span> </span>*/</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">Math</span> = &#123;</span><br><span class=\"line\">  add1: <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n + <span class=\"number\">1</span>,</span><br><span class=\"line\">  id: <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> -n,</span><br><span class=\"line\">  sub1: <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n - <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"11-更多示例\"><a href=\"#11-更多示例\" class=\"headerlink\" title=\"(11) 更多示例\"></a>(11) 更多示例</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var someObj &#x3D; &#123;</span><br><span class=\"line\">  &#x2F;**</span><br><span class=\"line\">   * @param &#123;string&#125; param1 - Docs on property assignments work</span><br><span class=\"line\">   *&#x2F;</span><br><span class=\"line\">  x: function (param1) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * As do docs on variable assignments</span><br><span class=\"line\"> * @return &#123;Window&#125;</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">let someFunc &#x3D; function () &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * And class methods</span><br><span class=\"line\"> * @param &#123;string&#125; greeting The greeting to use</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">Foo.prototype.sayHi &#x3D; greeting &#x3D;&gt; console.log(&quot;Hi!&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * And arrow functions expressions</span><br><span class=\"line\"> * @param &#123;number&#125; x - A multiplier</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">let myArrow &#x3D; x &#x3D;&gt; x * x;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * Which means it works for stateless function components in JSX too</span><br><span class=\"line\"> * @param &#123;&#123;a: string, b: number&#125;&#125; test - Some param</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">var sfc &#x3D; test &#x3D;&gt; &lt;div&gt;&#123;test.a.charAt(0)&#125;&lt;&#x2F;div&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * A parameter can be a class constructor, using Closure syntax.</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param &#123;&#123;new(...args: any[]): object&#125;&#125; C - The class to register</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function registerClass(C) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @param &#123;...string&#125; p1 - A &#39;rest&#39; arg (array) of strings. (treated as &#39;any&#39;)</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function fn10(p1) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;**</span><br><span class=\"line\"> * @param &#123;...string&#125; p1 - A &#39;rest&#39; arg (array) of strings. (treated as &#39;any&#39;)</span><br><span class=\"line\"> *&#x2F;</span><br><span class=\"line\">function fn9(p1) &#123;</span><br><span class=\"line\">  return p1.join();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"12-已知不支持的模式\"><a href=\"#12-已知不支持的模式\" class=\"headerlink\" title=\"(12) 已知不支持的模式\"></a>(12) 已知不支持的模式</h4><blockquote>\n<p>在值空间中将对象视为类型是不可以的, 除非对象创建了类型, 如构造函数。</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">aNormalFunction</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;aNormalFunction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wrong;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Use &#x27;typeof&#x27; instead:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;typeof aNormalFunction&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> right;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>对象字面量属性上的 <code>=</code> 后缀不能指定这个属性是可选的:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;&#123; a: string, b: number= &#125;</span></span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> wrong;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Use postfix question on the property name instead:</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;&#123; a: string, b?: number &#125;</span></span>&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> right;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Nullable</code> 类型只在启用了 <code>strictNullChecks</code> 检查时才启作用:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;?number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * With strictNullChecks: true -- number | null</span></span><br><span class=\"line\"><span class=\"comment\"> * With strictNullChecks: off  -- number</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nullable;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Non-nullable</code> 类型没有意义, 以其原类型对待:</p>\n</blockquote>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@type <span class=\"type\">&#123;!number&#125;</span></span></span></span><br><span class=\"line\"><span class=\"comment\"> * Just has type number</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> normal;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>不同于 <code>JSDoc</code> 类型系统, <code>TypeScript</code> 只允许将类型标记为包不包含 <code>null</code>。<code>Non-nullable</code> – 如果启用了 <code>strictNullChecks</code>，那么 <code>number</code> 是 <code>非null</code> 的。 如果没有启用，那么 <code>number</code> 是可以为 <code>null</code> 的。</p>\n</blockquote>\n"},{"title":"H5 相关问题收集","date":"2020-07-18T16:00:00.000Z","_content":"\n## 1. html\n\n### 设置禁止缩放\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" />\n```\n\n## 2. css\n\n### 2.1 移动端滑动问题\n\n> 设置属性 `touch-action:none;` 会导致安卓系统无法进行滑动。`ios` 系统不受影响，因为 `ios` 默认支持 `touch` 事件。\n\n```css\n/* 禁止触发默认的手势操作 */\ntouch-action: none;\n```\n\n### 2.2 视网膜屏显示问题\n\n> 设置 `border` 的宽高或者通过 `div` 设置宽高的的时候，对于视网膜屏幕 `(Retina)`，`1px` 会显示成 `2px`；\n> 如果用相对应的 `rem` 处理，部分手机会无法显示。\n> 在 `ios8` 中，已经支持 `0.5px`，在 `ios7` 以下，`android` 等其他系统里，`0.5px` 会被显示为 `0px`，所以需要写 `hack` 来兼容旧版本的系统。通常会使用以下几种方式\n\n#### 2.2.1 媒体查询的方式，需要判断系统和版本\n\n```css\ndiv {\n  border: 1px solid #000;\n}\n\n@media (-webkit-min-device-pixel-ratio: 2) {\n  div {\n    border: 0.5px solid #000;\n  }\n}\n```\n\n#### 2.2.2 在 html 的 meta 标签加上以下部分\n\n```html\n<meta name=\"viewport\" content=\"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\" />\n```\n\n#### 2.2.3 设置属性 `transform: scale(0.5)；`\n\n- 缺点\n\n> 圆角无法实现，实现 `4` 条边框比较麻烦，并且只能单独实现，如果嵌套，会对包含的效果产生不想要的效果，所以此方案配合 `:after` 和 `before` 独立使用较多。比如画一个商品的边框四条线，容器的 `after` 和 `before` 可以画 `2` 条线，利用容器的父元素的 `after`、`before` 再画 `2` 条线。\n\n```css\ndiv {\n  height: 1px;\n  -webkit-transform: scaleY(0.5);\n  -webkit-transform-origin: 0 0;\n  overflow: hidden;\n  background: #000;\n}\n```\n\n```css\ndiv {\n      position: relative;\n}\n\ndiv:after {\n  content: \"\";\n  position: absolute;\n  bottom: 0px;\n  left: 0px;\n  right: 0px;\n  border-bottom: 1px solid #000;\n  -webkit-transform: scaleY(0.5);\n  -webkit-transform-origin: 0 0;\n}\n```\n\n### 2.3 实现 0.5px 效果\n\n```css\nxx {\n  -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);\n}\n```\n\n- 优点\n\n> 基本所有场景都能满足，包含圆角的 `button`，单条，多条线。\n\n- 缺点\n\n> 颜色不好处理， 黑色 `rgba(0, 0, 0, 1)` 最深的情况了。有阴影出现，不好用。大量使用 `box-shadow` 可能会导致性能瓶颈。四条边框实现效果不理想。\n\n### 2.4 使用 background-image\n\n#### 2.4.1 渐变 `linear-gradient`   (`50%` 有颜色，`50%` 透明)\n\n```css\n  /* 单条线 */\n  div {\n      height: 1px;\n      background-image: -webkit-linear-gradient(top,transparent 50%,#000 50%);\n      background-position: top left;\n      background-repeat: no-repeat;\n      background-size: 100% 1px;\n  }\n\n  /* 多条线 */\n  div {\n      background-image:-webkit-linear-gradient(top, transparent 50%, #000 50%),-webkit-linear-gradient(bottom, transparent 50%, #000 50%),-webkit-linear-gradient(left, transparent 50%, #000 50%),-webkit-linear-gradient(right, transparent 50%, #000 50%);\n      background-size: 100% 1px,100% 1px,1px 100%,1px 100%;\n      background-repeat: no-repeat;\n      background-position: top left, bottom left, left top, right top;\n  }\n```\n\n- 优点：\n  1.  可以设置单条\n  2.  多条边框可以设置颜色\n- 缺点：\n  1.  大量使用渐变可能导致性能瓶颈；\n  2.  代码量大；\n  3.  多背景图片有兼容性问题\n\n#### 2.4.2 用图片( `base64` )：\n\n```css\ndiv {\n  border-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAB5JREFUeNpiPnH8zH/G////MzAxAAHTyRNn/wMEGABpvQm9g9TJ1QAAAABJRU5ErkJggg==\")\n    2 0 stretch;\n  border-width: 0px 0px 1px;\n}\n```\n\n- 优点：\n  1.  可以设置单条,多条边框\n  2.  没有性能瓶颈的问题\n- 缺点：\n  1.  修改颜色麻烦, 需要替换图片\n  2.  需要用到两张图片\n  3.  多背景图片有兼容性问题\n\n### 2.5 iphone X 兼容\n\n```css\n/*\n* iphone x\n*/\n@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {\n  .u-fixed-left {\n    padding-bottom: 0.6rem;\n  }\n  .u-fixed-left {\n    padding-bottom: 0.6rem;\n  }\n}\n```\n\n## 3. js\n\n### 3.1 setInterval\n\n### 3.2 ios 日期兼容\n\n- `ios`\n\n> 不支持 `-` 连接日期，需要写成\n\n```javascript\nvar d = new Date(\"2017-08-11 12:00:00\".replace(/-/g, \"/\"));\n```\n\n### 3.3 获取元素真实宽高\n\n```javascript\n// example:\nif (DOM元素.currentStyle) {\n  // IE、Opera\n  // console.log(\"支持currentStyle\");\n  // alert(oAbc.currentStyle.width);\n} else {\n  // FF、chrome、safari\n  // alert(getComputedStyle(oAbc,false).width);\n  _this.$trueWeight = (($art.getBoundingClientRect().width - $lRow[idx].getBoundingClientRect().width) / 2) * 5;\n}\n```\n\n### 3.4 jsonp 失败的回调函数\n\n```javascript\n// 可以使用timeout超时来判断\ncomplete: function (XMLHttpRequest, status) {\n    //请求完成后最终执行参数\n    if (status == 'timeout') {\n        //超时,status还有success,error等值的情况\n        xhr.abort();\n    }\n}\n```\n\n### 3.5 原生判断滑动方向\n\n```javascript\n// 获取角度\nthis.getAngle = function (angx, angy) {\n  return (Math.atan2(angy, angx) * 180) / Math.PI;\n};\n//根据起点终点返回方向 1向上 2向下 3向左 4向右 0未滑动\nthis.getDirection = function (startx, starty, endx, endy) {\n  let angx = endx - startx;\n  let angy = endy - starty;\n  let result = 0;\n  //如果滑动距离太短\n  if (Math.abs(angx) < 2 && Math.abs(angy) < 2) {\n    return result;\n  }\n  let angle = this.getAngle(angx, angy);\n  if (angle >= -135 && angle <= -45) {\n    result = 1;\n  } else if (angle > 45 && angle < 135) {\n    result = 2;\n  } else if ((angle >= 135 && angle <= 180) || (angle >= -180 && angle < -135)) {\n    result = 3;\n  } else if (angle >= -45 && angle <= 45) {\n    result = 4;\n  }\n\n  return result;\n};\n\n// 下滑的时候，失去焦点\n// jq 用e.originalEvent.touches[0];\n// zepto 用e.touches[0];\nlet startx = \"\",\n  starty = \"\";\n//手指接触屏幕\n_this.$document.on(\"touchstart\", function (e) {\n  startx = e.originalEvent.touches[0].pageX;\n  starty = e.originalEvent.touches[0].pageY;\n});\n//手指离开屏幕\n_this.$document.on(\"touchmove\", function (e) {\n  let endx = e.originalEvent.changedTouches[0].pageX,\n    endy = e.originalEvent.changedTouches[0].pageY;\n  let direction = _this.getDirection(startx, starty, endx, endy);\n  if (direction == 1) {\n    // 上滑的操作\n  }\n  if (direction == 2) {\n    // 下滑的操作\n  }\n});\n```\n","source":"_posts/前端/H5 相关问题收集.md","raw":"---\ntitle: H5 相关问题收集\ndate: 2020-07-19\ncategories: [前端, h5]\ntags:\n  - 解决方案\n---\n\n## 1. html\n\n### 设置禁止缩放\n\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" />\n```\n\n## 2. css\n\n### 2.1 移动端滑动问题\n\n> 设置属性 `touch-action:none;` 会导致安卓系统无法进行滑动。`ios` 系统不受影响，因为 `ios` 默认支持 `touch` 事件。\n\n```css\n/* 禁止触发默认的手势操作 */\ntouch-action: none;\n```\n\n### 2.2 视网膜屏显示问题\n\n> 设置 `border` 的宽高或者通过 `div` 设置宽高的的时候，对于视网膜屏幕 `(Retina)`，`1px` 会显示成 `2px`；\n> 如果用相对应的 `rem` 处理，部分手机会无法显示。\n> 在 `ios8` 中，已经支持 `0.5px`，在 `ios7` 以下，`android` 等其他系统里，`0.5px` 会被显示为 `0px`，所以需要写 `hack` 来兼容旧版本的系统。通常会使用以下几种方式\n\n#### 2.2.1 媒体查询的方式，需要判断系统和版本\n\n```css\ndiv {\n  border: 1px solid #000;\n}\n\n@media (-webkit-min-device-pixel-ratio: 2) {\n  div {\n    border: 0.5px solid #000;\n  }\n}\n```\n\n#### 2.2.2 在 html 的 meta 标签加上以下部分\n\n```html\n<meta name=\"viewport\" content=\"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no\" />\n```\n\n#### 2.2.3 设置属性 `transform: scale(0.5)；`\n\n- 缺点\n\n> 圆角无法实现，实现 `4` 条边框比较麻烦，并且只能单独实现，如果嵌套，会对包含的效果产生不想要的效果，所以此方案配合 `:after` 和 `before` 独立使用较多。比如画一个商品的边框四条线，容器的 `after` 和 `before` 可以画 `2` 条线，利用容器的父元素的 `after`、`before` 再画 `2` 条线。\n\n```css\ndiv {\n  height: 1px;\n  -webkit-transform: scaleY(0.5);\n  -webkit-transform-origin: 0 0;\n  overflow: hidden;\n  background: #000;\n}\n```\n\n```css\ndiv {\n      position: relative;\n}\n\ndiv:after {\n  content: \"\";\n  position: absolute;\n  bottom: 0px;\n  left: 0px;\n  right: 0px;\n  border-bottom: 1px solid #000;\n  -webkit-transform: scaleY(0.5);\n  -webkit-transform-origin: 0 0;\n}\n```\n\n### 2.3 实现 0.5px 效果\n\n```css\nxx {\n  -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);\n}\n```\n\n- 优点\n\n> 基本所有场景都能满足，包含圆角的 `button`，单条，多条线。\n\n- 缺点\n\n> 颜色不好处理， 黑色 `rgba(0, 0, 0, 1)` 最深的情况了。有阴影出现，不好用。大量使用 `box-shadow` 可能会导致性能瓶颈。四条边框实现效果不理想。\n\n### 2.4 使用 background-image\n\n#### 2.4.1 渐变 `linear-gradient`   (`50%` 有颜色，`50%` 透明)\n\n```css\n  /* 单条线 */\n  div {\n      height: 1px;\n      background-image: -webkit-linear-gradient(top,transparent 50%,#000 50%);\n      background-position: top left;\n      background-repeat: no-repeat;\n      background-size: 100% 1px;\n  }\n\n  /* 多条线 */\n  div {\n      background-image:-webkit-linear-gradient(top, transparent 50%, #000 50%),-webkit-linear-gradient(bottom, transparent 50%, #000 50%),-webkit-linear-gradient(left, transparent 50%, #000 50%),-webkit-linear-gradient(right, transparent 50%, #000 50%);\n      background-size: 100% 1px,100% 1px,1px 100%,1px 100%;\n      background-repeat: no-repeat;\n      background-position: top left, bottom left, left top, right top;\n  }\n```\n\n- 优点：\n  1.  可以设置单条\n  2.  多条边框可以设置颜色\n- 缺点：\n  1.  大量使用渐变可能导致性能瓶颈；\n  2.  代码量大；\n  3.  多背景图片有兼容性问题\n\n#### 2.4.2 用图片( `base64` )：\n\n```css\ndiv {\n  border-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAB5JREFUeNpiPnH8zH/G////MzAxAAHTyRNn/wMEGABpvQm9g9TJ1QAAAABJRU5ErkJggg==\")\n    2 0 stretch;\n  border-width: 0px 0px 1px;\n}\n```\n\n- 优点：\n  1.  可以设置单条,多条边框\n  2.  没有性能瓶颈的问题\n- 缺点：\n  1.  修改颜色麻烦, 需要替换图片\n  2.  需要用到两张图片\n  3.  多背景图片有兼容性问题\n\n### 2.5 iphone X 兼容\n\n```css\n/*\n* iphone x\n*/\n@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {\n  .u-fixed-left {\n    padding-bottom: 0.6rem;\n  }\n  .u-fixed-left {\n    padding-bottom: 0.6rem;\n  }\n}\n```\n\n## 3. js\n\n### 3.1 setInterval\n\n### 3.2 ios 日期兼容\n\n- `ios`\n\n> 不支持 `-` 连接日期，需要写成\n\n```javascript\nvar d = new Date(\"2017-08-11 12:00:00\".replace(/-/g, \"/\"));\n```\n\n### 3.3 获取元素真实宽高\n\n```javascript\n// example:\nif (DOM元素.currentStyle) {\n  // IE、Opera\n  // console.log(\"支持currentStyle\");\n  // alert(oAbc.currentStyle.width);\n} else {\n  // FF、chrome、safari\n  // alert(getComputedStyle(oAbc,false).width);\n  _this.$trueWeight = (($art.getBoundingClientRect().width - $lRow[idx].getBoundingClientRect().width) / 2) * 5;\n}\n```\n\n### 3.4 jsonp 失败的回调函数\n\n```javascript\n// 可以使用timeout超时来判断\ncomplete: function (XMLHttpRequest, status) {\n    //请求完成后最终执行参数\n    if (status == 'timeout') {\n        //超时,status还有success,error等值的情况\n        xhr.abort();\n    }\n}\n```\n\n### 3.5 原生判断滑动方向\n\n```javascript\n// 获取角度\nthis.getAngle = function (angx, angy) {\n  return (Math.atan2(angy, angx) * 180) / Math.PI;\n};\n//根据起点终点返回方向 1向上 2向下 3向左 4向右 0未滑动\nthis.getDirection = function (startx, starty, endx, endy) {\n  let angx = endx - startx;\n  let angy = endy - starty;\n  let result = 0;\n  //如果滑动距离太短\n  if (Math.abs(angx) < 2 && Math.abs(angy) < 2) {\n    return result;\n  }\n  let angle = this.getAngle(angx, angy);\n  if (angle >= -135 && angle <= -45) {\n    result = 1;\n  } else if (angle > 45 && angle < 135) {\n    result = 2;\n  } else if ((angle >= 135 && angle <= 180) || (angle >= -180 && angle < -135)) {\n    result = 3;\n  } else if (angle >= -45 && angle <= 45) {\n    result = 4;\n  }\n\n  return result;\n};\n\n// 下滑的时候，失去焦点\n// jq 用e.originalEvent.touches[0];\n// zepto 用e.touches[0];\nlet startx = \"\",\n  starty = \"\";\n//手指接触屏幕\n_this.$document.on(\"touchstart\", function (e) {\n  startx = e.originalEvent.touches[0].pageX;\n  starty = e.originalEvent.touches[0].pageY;\n});\n//手指离开屏幕\n_this.$document.on(\"touchmove\", function (e) {\n  let endx = e.originalEvent.changedTouches[0].pageX,\n    endy = e.originalEvent.changedTouches[0].pageY;\n  let direction = _this.getDirection(startx, starty, endx, endy);\n  if (direction == 1) {\n    // 上滑的操作\n  }\n  if (direction == 2) {\n    // 下滑的操作\n  }\n});\n```\n","slug":"前端/H5 相关问题收集","published":1,"updated":"2021-04-07T07:29:13.982Z","_id":"ckn74b69w003lyx7y79keby5p","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-html\"><a href=\"#1-html\" class=\"headerlink\" title=\"1. html\"></a>1. html</h2><h3 id=\"设置禁止缩放\"><a href=\"#设置禁止缩放\" class=\"headerlink\" title=\"设置禁止缩放\"></a>设置禁止缩放</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-css\"><a href=\"#2-css\" class=\"headerlink\" title=\"2. css\"></a>2. css</h2><h3 id=\"2-1-移动端滑动问题\"><a href=\"#2-1-移动端滑动问题\" class=\"headerlink\" title=\"2.1 移动端滑动问题\"></a>2.1 移动端滑动问题</h3><blockquote>\n<p>设置属性 <code>touch-action:none;</code> 会导致安卓系统无法进行滑动。<code>ios</code> 系统不受影响，因为 <code>ios</code> 默认支持 <code>touch</code> 事件。</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 禁止触发默认的手势操作 */</span></span><br><span class=\"line\">touch-action: none;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-视网膜屏显示问题\"><a href=\"#2-2-视网膜屏显示问题\" class=\"headerlink\" title=\"2.2 视网膜屏显示问题\"></a>2.2 视网膜屏显示问题</h3><blockquote>\n<p>设置 <code>border</code> 的宽高或者通过 <code>div</code> 设置宽高的的时候，对于视网膜屏幕 <code>(Retina)</code>，<code>1px</code> 会显示成 <code>2px</code>；<br>如果用相对应的 <code>rem</code> 处理，部分手机会无法显示。<br>在 <code>ios8</code> 中，已经支持 <code>0.5px</code>，在 <code>ios7</code> 以下，<code>android</code> 等其他系统里，<code>0.5px</code> 会被显示为 <code>0px</code>，所以需要写 <code>hack</code> 来兼容旧版本的系统。通常会使用以下几种方式</p>\n</blockquote>\n<h4 id=\"2-2-1-媒体查询的方式，需要判断系统和版本\"><a href=\"#2-2-1-媒体查询的方式，需要判断系统和版本\" class=\"headerlink\" title=\"2.2.1 媒体查询的方式，需要判断系统和版本\"></a>2.2.1 媒体查询的方式，需要判断系统和版本</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@media</span> (<span class=\"attribute\">-webkit-min-device-pixel-ratio</span>: <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0.5px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-在-html-的-meta-标签加上以下部分\"><a href=\"#2-2-2-在-html-的-meta-标签加上以下部分\" class=\"headerlink\" title=\"2.2.2 在 html 的 meta 标签加上以下部分\"></a>2.2.2 在 html 的 meta 标签加上以下部分</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-3-设置属性-transform-scale-0-5-；\"><a href=\"#2-2-3-设置属性-transform-scale-0-5-；\" class=\"headerlink\" title=\"2.2.3 设置属性 transform: scale(0.5)；\"></a>2.2.3 设置属性 <code>transform: scale(0.5)；</code></h4><ul>\n<li>缺点</li>\n</ul>\n<blockquote>\n<p>圆角无法实现，实现 <code>4</code> 条边框比较麻烦，并且只能单独实现，如果嵌套，会对包含的效果产生不想要的效果，所以此方案配合 <code>:after</code> 和 <code>before</code> 独立使用较多。比如画一个商品的边框四条线，容器的 <code>after</code> 和 <code>before</code> 可以画 <code>2</code> 条线，利用容器的父元素的 <code>after</code>、<code>before</code> 再画 <code>2</code> 条线。</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">transform</span>: <span class=\"built_in\">scaleY</span>(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">div</span>:after &#123;</span><br><span class=\"line\">  content: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">transform</span>: <span class=\"built_in\">scaleY</span>(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-实现-0-5px-效果\"><a href=\"#2-3-实现-0-5px-效果\" class=\"headerlink\" title=\"2.3 实现 0.5px 效果\"></a>2.3 实现 0.5px 效果</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xx &#123;</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">1px</span> -<span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优点</li>\n</ul>\n<blockquote>\n<p>基本所有场景都能满足，包含圆角的 <code>button</code>，单条，多条线。</p>\n</blockquote>\n<ul>\n<li>缺点</li>\n</ul>\n<blockquote>\n<p>颜色不好处理， 黑色 <code>rgba(0, 0, 0, 1)</code> 最深的情况了。有阴影出现，不好用。大量使用 <code>box-shadow</code> 可能会导致性能瓶颈。四条边框实现效果不理想。</p>\n</blockquote>\n<h3 id=\"2-4-使用-background-image\"><a href=\"#2-4-使用-background-image\" class=\"headerlink\" title=\"2.4 使用 background-image\"></a>2.4 使用 background-image</h3><h4 id=\"2-4-1-渐变-linear-gradient-50-有颜色，50-透明\"><a href=\"#2-4-1-渐变-linear-gradient-50-有颜色，50-透明\" class=\"headerlink\" title=\"2.4.1 渐变 linear-gradient   (50% 有颜色，50% 透明)\"></a>2.4.1 渐变 <code>linear-gradient</code>   (<code>50%</code> 有颜色，<code>50%</code> 透明)</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 单条线 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(top,transparent <span class=\"number\">50%</span>,<span class=\"number\">#000</span> <span class=\"number\">50%</span>);</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: top left;</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">1px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 多条线 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:<span class=\"built_in\">-webkit-linear-gradient</span>(top, transparent <span class=\"number\">50%</span>, <span class=\"number\">#000</span> <span class=\"number\">50%</span>),<span class=\"built_in\">-webkit-linear-gradient</span>(bottom, transparent <span class=\"number\">50%</span>, <span class=\"number\">#000</span> <span class=\"number\">50%</span>),<span class=\"built_in\">-webkit-linear-gradient</span>(left, transparent <span class=\"number\">50%</span>, <span class=\"number\">#000</span> <span class=\"number\">50%</span>),<span class=\"built_in\">-webkit-linear-gradient</span>(right, transparent <span class=\"number\">50%</span>, <span class=\"number\">#000</span> <span class=\"number\">50%</span>);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">1px</span>,<span class=\"number\">100%</span> <span class=\"number\">1px</span>,<span class=\"number\">1px</span> <span class=\"number\">100%</span>,<span class=\"number\">1px</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: top left, bottom left, left top, right top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优点：<ol>\n<li> 可以设置单条</li>\n<li> 多条边框可以设置颜色</li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li> 大量使用渐变可能导致性能瓶颈；</li>\n<li> 代码量大；</li>\n<li> 多背景图片有兼容性问题</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-4-2-用图片-base64-：\"><a href=\"#2-4-2-用图片-base64-：\" class=\"headerlink\" title=\"2.4.2 用图片( base64 )：\"></a>2.4.2 用图片( <code>base64</code> )：</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAB5JREFUeNpiPnH8zH/G////MzAxAAHTyRNn/wMEGABpvQm9g9TJ1QAAAABJRU5ErkJggg==&quot;</span>)</span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"number\">0</span> stretch;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">0px</span> <span class=\"number\">0px</span> <span class=\"number\">1px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优点：<ol>\n<li> 可以设置单条,多条边框</li>\n<li> 没有性能瓶颈的问题</li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li> 修改颜色麻烦, 需要替换图片</li>\n<li> 需要用到两张图片</li>\n<li> 多背景图片有兼容性问题</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-5-iphone-X-兼容\"><a href=\"#2-5-iphone-X-兼容\" class=\"headerlink\" title=\"2.5 iphone X 兼容\"></a>2.5 iphone X 兼容</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* iphone x</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">@media</span> <span class=\"keyword\">only</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">device-width</span>: <span class=\"number\">375px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">device-height</span>: <span class=\"number\">812px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">-webkit-device-pixel-ratio</span>: <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.u-fixed-left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">0.6rem</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.u-fixed-left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">0.6rem</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-js\"><a href=\"#3-js\" class=\"headerlink\" title=\"3. js\"></a>3. js</h2><h3 id=\"3-1-setInterval\"><a href=\"#3-1-setInterval\" class=\"headerlink\" title=\"3.1 setInterval\"></a>3.1 setInterval</h3><h3 id=\"3-2-ios-日期兼容\"><a href=\"#3-2-ios-日期兼容\" class=\"headerlink\" title=\"3.2 ios 日期兼容\"></a>3.2 ios 日期兼容</h3><ul>\n<li><code>ios</code></li>\n</ul>\n<blockquote>\n<p>不支持 <code>-</code> 连接日期，需要写成</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"string\">&quot;2017-08-11 12:00:00&quot;</span>.replace(<span class=\"regexp\">/-/g</span>, <span class=\"string\">&quot;/&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-获取元素真实宽高\"><a href=\"#3-3-获取元素真实宽高\" class=\"headerlink\" title=\"3.3 获取元素真实宽高\"></a>3.3 获取元素真实宽高</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example:</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (DOM元素.currentStyle) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// IE、Opera</span></span><br><span class=\"line\">  <span class=\"comment\">// console.log(&quot;支持currentStyle&quot;);</span></span><br><span class=\"line\">  <span class=\"comment\">// alert(oAbc.currentStyle.width);</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// FF、chrome、safari</span></span><br><span class=\"line\">  <span class=\"comment\">// alert(getComputedStyle(oAbc,false).width);</span></span><br><span class=\"line\">  _this.$trueWeight = (($art.getBoundingClientRect().width - $lRow[idx].getBoundingClientRect().width) / <span class=\"number\">2</span>) * <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-jsonp-失败的回调函数\"><a href=\"#3-4-jsonp-失败的回调函数\" class=\"headerlink\" title=\"3.4 jsonp 失败的回调函数\"></a>3.4 jsonp 失败的回调函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以使用timeout超时来判断</span></span><br><span class=\"line\">complete: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">XMLHttpRequest, status</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//请求完成后最终执行参数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == <span class=\"string\">&#x27;timeout&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//超时,status还有success,error等值的情况</span></span><br><span class=\"line\">        xhr.abort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-原生判断滑动方向\"><a href=\"#3-5-原生判断滑动方向\" class=\"headerlink\" title=\"3.5 原生判断滑动方向\"></a>3.5 原生判断滑动方向</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取角度</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.getAngle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">angx, angy</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">Math</span>.atan2(angy, angx) * <span class=\"number\">180</span>) / <span class=\"built_in\">Math</span>.PI;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//根据起点终点返回方向 1向上 2向下 3向左 4向右 0未滑动</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.getDirection = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">startx, starty, endx, endy</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> angx = endx - startx;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> angy = endy - starty;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//如果滑动距离太短</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.abs(angx) &lt; <span class=\"number\">2</span> &amp;&amp; <span class=\"built_in\">Math</span>.abs(angy) &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> angle = <span class=\"built_in\">this</span>.getAngle(angx, angy);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (angle &gt;= -<span class=\"number\">135</span> &amp;&amp; angle &lt;= -<span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (angle &gt; <span class=\"number\">45</span> &amp;&amp; angle &lt; <span class=\"number\">135</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((angle &gt;= <span class=\"number\">135</span> &amp;&amp; angle &lt;= <span class=\"number\">180</span>) || (angle &gt;= -<span class=\"number\">180</span> &amp;&amp; angle &lt; -<span class=\"number\">135</span>)) &#123;</span><br><span class=\"line\">    result = <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (angle &gt;= -<span class=\"number\">45</span> &amp;&amp; angle &lt;= <span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下滑的时候，失去焦点</span></span><br><span class=\"line\"><span class=\"comment\">// jq 用e.originalEvent.touches[0];</span></span><br><span class=\"line\"><span class=\"comment\">// zepto 用e.touches[0];</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> startx = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  starty = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//手指接触屏幕</span></span><br><span class=\"line\">_this.$document.on(<span class=\"string\">&quot;touchstart&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  startx = e.originalEvent.touches[<span class=\"number\">0</span>].pageX;</span><br><span class=\"line\">  starty = e.originalEvent.touches[<span class=\"number\">0</span>].pageY;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//手指离开屏幕</span></span><br><span class=\"line\">_this.$document.on(<span class=\"string\">&quot;touchmove&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> endx = e.originalEvent.changedTouches[<span class=\"number\">0</span>].pageX,</span><br><span class=\"line\">    endy = e.originalEvent.changedTouches[<span class=\"number\">0</span>].pageY;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> direction = _this.getDirection(startx, starty, endx, endy);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (direction == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 上滑的操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (direction == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下滑的操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-html\"><a href=\"#1-html\" class=\"headerlink\" title=\"1. html\"></a>1. html</h2><h3 id=\"设置禁止缩放\"><a href=\"#设置禁止缩放\" class=\"headerlink\" title=\"设置禁止缩放\"></a>设置禁止缩放</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-css\"><a href=\"#2-css\" class=\"headerlink\" title=\"2. css\"></a>2. css</h2><h3 id=\"2-1-移动端滑动问题\"><a href=\"#2-1-移动端滑动问题\" class=\"headerlink\" title=\"2.1 移动端滑动问题\"></a>2.1 移动端滑动问题</h3><blockquote>\n<p>设置属性 <code>touch-action:none;</code> 会导致安卓系统无法进行滑动。<code>ios</code> 系统不受影响，因为 <code>ios</code> 默认支持 <code>touch</code> 事件。</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 禁止触发默认的手势操作 */</span></span><br><span class=\"line\">touch-action: none;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-视网膜屏显示问题\"><a href=\"#2-2-视网膜屏显示问题\" class=\"headerlink\" title=\"2.2 视网膜屏显示问题\"></a>2.2 视网膜屏显示问题</h3><blockquote>\n<p>设置 <code>border</code> 的宽高或者通过 <code>div</code> 设置宽高的的时候，对于视网膜屏幕 <code>(Retina)</code>，<code>1px</code> 会显示成 <code>2px</code>；<br>如果用相对应的 <code>rem</code> 处理，部分手机会无法显示。<br>在 <code>ios8</code> 中，已经支持 <code>0.5px</code>，在 <code>ios7</code> 以下，<code>android</code> 等其他系统里，<code>0.5px</code> 会被显示为 <code>0px</code>，所以需要写 <code>hack</code> 来兼容旧版本的系统。通常会使用以下几种方式</p>\n</blockquote>\n<h4 id=\"2-2-1-媒体查询的方式，需要判断系统和版本\"><a href=\"#2-2-1-媒体查询的方式，需要判断系统和版本\" class=\"headerlink\" title=\"2.2.1 媒体查询的方式，需要判断系统和版本\"></a>2.2.1 媒体查询的方式，需要判断系统和版本</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">@media</span> (<span class=\"attribute\">-webkit-min-device-pixel-ratio</span>: <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0.5px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-在-html-的-meta-标签加上以下部分\"><a href=\"#2-2-2-在-html-的-meta-标签加上以下部分\" class=\"headerlink\" title=\"2.2.2 在 html 的 meta 标签加上以下部分\"></a>2.2.2 在 html 的 meta 标签加上以下部分</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-3-设置属性-transform-scale-0-5-；\"><a href=\"#2-2-3-设置属性-transform-scale-0-5-；\" class=\"headerlink\" title=\"2.2.3 设置属性 transform: scale(0.5)；\"></a>2.2.3 设置属性 <code>transform: scale(0.5)；</code></h4><ul>\n<li>缺点</li>\n</ul>\n<blockquote>\n<p>圆角无法实现，实现 <code>4</code> 条边框比较麻烦，并且只能单独实现，如果嵌套，会对包含的效果产生不想要的效果，所以此方案配合 <code>:after</code> 和 <code>before</code> 独立使用较多。比如画一个商品的边框四条线，容器的 <code>after</code> 和 <code>before</code> 可以画 <code>2</code> 条线，利用容器的父元素的 <code>after</code>、<code>before</code> 再画 <code>2</code> 条线。</p>\n</blockquote>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">transform</span>: <span class=\"built_in\">scaleY</span>(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#000</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">div</span>:after &#123;</span><br><span class=\"line\">  content: <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">left</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">right</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#000</span>;</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">transform</span>: <span class=\"built_in\">scaleY</span>(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">transform-origin</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-实现-0-5px-效果\"><a href=\"#2-3-实现-0-5px-效果\" class=\"headerlink\" title=\"2.3 实现 0.5px 效果\"></a>2.3 实现 0.5px 效果</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xx &#123;</span><br><span class=\"line\">  -webkit-<span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">1px</span> -<span class=\"number\">1px</span> <span class=\"built_in\">rgba</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.5</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优点</li>\n</ul>\n<blockquote>\n<p>基本所有场景都能满足，包含圆角的 <code>button</code>，单条，多条线。</p>\n</blockquote>\n<ul>\n<li>缺点</li>\n</ul>\n<blockquote>\n<p>颜色不好处理， 黑色 <code>rgba(0, 0, 0, 1)</code> 最深的情况了。有阴影出现，不好用。大量使用 <code>box-shadow</code> 可能会导致性能瓶颈。四条边框实现效果不理想。</p>\n</blockquote>\n<h3 id=\"2-4-使用-background-image\"><a href=\"#2-4-使用-background-image\" class=\"headerlink\" title=\"2.4 使用 background-image\"></a>2.4 使用 background-image</h3><h4 id=\"2-4-1-渐变-linear-gradient-50-有颜色，50-透明\"><a href=\"#2-4-1-渐变-linear-gradient-50-有颜色，50-透明\" class=\"headerlink\" title=\"2.4.1 渐变 linear-gradient   (50% 有颜色，50% 透明)\"></a>2.4.1 渐变 <code>linear-gradient</code>   (<code>50%</code> 有颜色，<code>50%</code> 透明)</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 单条线 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">-webkit-linear-gradient</span>(top,transparent <span class=\"number\">50%</span>,<span class=\"number\">#000</span> <span class=\"number\">50%</span>);</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: top left;</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">1px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 多条线 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:<span class=\"built_in\">-webkit-linear-gradient</span>(top, transparent <span class=\"number\">50%</span>, <span class=\"number\">#000</span> <span class=\"number\">50%</span>),<span class=\"built_in\">-webkit-linear-gradient</span>(bottom, transparent <span class=\"number\">50%</span>, <span class=\"number\">#000</span> <span class=\"number\">50%</span>),<span class=\"built_in\">-webkit-linear-gradient</span>(left, transparent <span class=\"number\">50%</span>, <span class=\"number\">#000</span> <span class=\"number\">50%</span>),<span class=\"built_in\">-webkit-linear-gradient</span>(right, transparent <span class=\"number\">50%</span>, <span class=\"number\">#000</span> <span class=\"number\">50%</span>);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">100%</span> <span class=\"number\">1px</span>,<span class=\"number\">100%</span> <span class=\"number\">1px</span>,<span class=\"number\">1px</span> <span class=\"number\">100%</span>,<span class=\"number\">1px</span> <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-repeat</span>: no-repeat;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: top left, bottom left, left top, right top;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优点：<ol>\n<li> 可以设置单条</li>\n<li> 多条边框可以设置颜色</li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li> 大量使用渐变可能导致性能瓶颈；</li>\n<li> 代码量大；</li>\n<li> 多背景图片有兼容性问题</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"2-4-2-用图片-base64-：\"><a href=\"#2-4-2-用图片-base64-：\" class=\"headerlink\" title=\"2.4.2 用图片( base64 )：\"></a>2.4.2 用图片( <code>base64</code> )：</h4><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">border-image</span>: <span class=\"built_in\">url</span>(<span class=\"string\">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAECAYAAABP2FU6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAB5JREFUeNpiPnH8zH/G////MzAxAAHTyRNn/wMEGABpvQm9g9TJ1QAAAABJRU5ErkJggg==&quot;</span>)</span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"number\">0</span> stretch;</span><br><span class=\"line\">  <span class=\"attribute\">border-width</span>: <span class=\"number\">0px</span> <span class=\"number\">0px</span> <span class=\"number\">1px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>优点：<ol>\n<li> 可以设置单条,多条边框</li>\n<li> 没有性能瓶颈的问题</li>\n</ol>\n</li>\n<li>缺点：<ol>\n<li> 修改颜色麻烦, 需要替换图片</li>\n<li> 需要用到两张图片</li>\n<li> 多背景图片有兼容性问题</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"2-5-iphone-X-兼容\"><a href=\"#2-5-iphone-X-兼容\" class=\"headerlink\" title=\"2.5 iphone X 兼容\"></a>2.5 iphone X 兼容</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* iphone x</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">@media</span> <span class=\"keyword\">only</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">device-width</span>: <span class=\"number\">375px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">device-height</span>: <span class=\"number\">812px</span>) <span class=\"keyword\">and</span> (<span class=\"attribute\">-webkit-device-pixel-ratio</span>: <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  <span class=\"selector-class\">.u-fixed-left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">0.6rem</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.u-fixed-left</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">0.6rem</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-js\"><a href=\"#3-js\" class=\"headerlink\" title=\"3. js\"></a>3. js</h2><h3 id=\"3-1-setInterval\"><a href=\"#3-1-setInterval\" class=\"headerlink\" title=\"3.1 setInterval\"></a>3.1 setInterval</h3><h3 id=\"3-2-ios-日期兼容\"><a href=\"#3-2-ios-日期兼容\" class=\"headerlink\" title=\"3.2 ios 日期兼容\"></a>3.2 ios 日期兼容</h3><ul>\n<li><code>ios</code></li>\n</ul>\n<blockquote>\n<p>不支持 <code>-</code> 连接日期，需要写成</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"string\">&quot;2017-08-11 12:00:00&quot;</span>.replace(<span class=\"regexp\">/-/g</span>, <span class=\"string\">&quot;/&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-获取元素真实宽高\"><a href=\"#3-3-获取元素真实宽高\" class=\"headerlink\" title=\"3.3 获取元素真实宽高\"></a>3.3 获取元素真实宽高</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// example:</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (DOM元素.currentStyle) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// IE、Opera</span></span><br><span class=\"line\">  <span class=\"comment\">// console.log(&quot;支持currentStyle&quot;);</span></span><br><span class=\"line\">  <span class=\"comment\">// alert(oAbc.currentStyle.width);</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// FF、chrome、safari</span></span><br><span class=\"line\">  <span class=\"comment\">// alert(getComputedStyle(oAbc,false).width);</span></span><br><span class=\"line\">  _this.$trueWeight = (($art.getBoundingClientRect().width - $lRow[idx].getBoundingClientRect().width) / <span class=\"number\">2</span>) * <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-jsonp-失败的回调函数\"><a href=\"#3-4-jsonp-失败的回调函数\" class=\"headerlink\" title=\"3.4 jsonp 失败的回调函数\"></a>3.4 jsonp 失败的回调函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以使用timeout超时来判断</span></span><br><span class=\"line\">complete: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">XMLHttpRequest, status</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//请求完成后最终执行参数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status == <span class=\"string\">&#x27;timeout&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//超时,status还有success,error等值的情况</span></span><br><span class=\"line\">        xhr.abort();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-原生判断滑动方向\"><a href=\"#3-5-原生判断滑动方向\" class=\"headerlink\" title=\"3.5 原生判断滑动方向\"></a>3.5 原生判断滑动方向</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取角度</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.getAngle = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">angx, angy</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"built_in\">Math</span>.atan2(angy, angx) * <span class=\"number\">180</span>) / <span class=\"built_in\">Math</span>.PI;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//根据起点终点返回方向 1向上 2向下 3向左 4向右 0未滑动</span></span><br><span class=\"line\"><span class=\"built_in\">this</span>.getDirection = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">startx, starty, endx, endy</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> angx = endx - startx;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> angy = endy - starty;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"comment\">//如果滑动距离太短</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Math</span>.abs(angx) &lt; <span class=\"number\">2</span> &amp;&amp; <span class=\"built_in\">Math</span>.abs(angy) &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> angle = <span class=\"built_in\">this</span>.getAngle(angx, angy);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (angle &gt;= -<span class=\"number\">135</span> &amp;&amp; angle &lt;= -<span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (angle &gt; <span class=\"number\">45</span> &amp;&amp; angle &lt; <span class=\"number\">135</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"number\">2</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((angle &gt;= <span class=\"number\">135</span> &amp;&amp; angle &lt;= <span class=\"number\">180</span>) || (angle &gt;= -<span class=\"number\">180</span> &amp;&amp; angle &lt; -<span class=\"number\">135</span>)) &#123;</span><br><span class=\"line\">    result = <span class=\"number\">3</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (angle &gt;= -<span class=\"number\">45</span> &amp;&amp; angle &lt;= <span class=\"number\">45</span>) &#123;</span><br><span class=\"line\">    result = <span class=\"number\">4</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下滑的时候，失去焦点</span></span><br><span class=\"line\"><span class=\"comment\">// jq 用e.originalEvent.touches[0];</span></span><br><span class=\"line\"><span class=\"comment\">// zepto 用e.touches[0];</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> startx = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  starty = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">//手指接触屏幕</span></span><br><span class=\"line\">_this.$document.on(<span class=\"string\">&quot;touchstart&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  startx = e.originalEvent.touches[<span class=\"number\">0</span>].pageX;</span><br><span class=\"line\">  starty = e.originalEvent.touches[<span class=\"number\">0</span>].pageY;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//手指离开屏幕</span></span><br><span class=\"line\">_this.$document.on(<span class=\"string\">&quot;touchmove&quot;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> endx = e.originalEvent.changedTouches[<span class=\"number\">0</span>].pageX,</span><br><span class=\"line\">    endy = e.originalEvent.changedTouches[<span class=\"number\">0</span>].pageY;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> direction = _this.getDirection(startx, starty, endx, endy);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (direction == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 上滑的操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (direction == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下滑的操作</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n"},{"title":"Hybrid 简介","date":"2020-07-16T16:00:00.000Z","_content":"\n## hybrid 实现原理\n\n> 原生的 `App` 中，使用 `WebView` 作为容器直接承载 `Web` 页面。 中间通过 `JSBridge` 来完成 `Native` 与 `JavaScript` 之间的通讯。\n\n## hybrid 几种方案\n\n### 基于  WebView UI  的基础方案\n\n> 例如微信 `JS-SDK`，通过 `JSBridge` 完成 `H5` 与 `Native` 的双向通讯，从而赋予 `H5` 一定程度的原生能力。\n\n### 基于  `Native UI`  的方案\n\n> 例如 `React-Native、Weex` 。在赋予 `H5` 原生 `API` 能力的基础上，进一步通过 `JSBridge` 将 `js` 解析成的虚拟节点树( `Virtual DOM` )传递到 `Native` 并使用原生渲染。\n\n### 小程序方案\n\n> 通过更加定制化的 `JSBridge`，并使用双 `WebView` 双线程的模式隔离了 `JS` 逻辑与 `UI` 渲染，形成了特殊的开发模式，加强了 `H5` 与 `Native` 混合程度，提高了页面性能及开发体验。\n\n## hybrid 和 h5 对比\n\n### h5\n\n- 优点\n  - 开发速度快，一端开发多端运行\n  - 如果需要频繁更换页面，用 `h5` 维护会更加容易\n  - 版本更新不需要打包便可发布\n- 缺点\n  - 流畅度，安全问题\n  - 性能不如原生\n  - 不能调用移动硬件设备的功能\n","source":"_posts/前端/Hybrid 简介.md","raw":"---\ntitle: Hybrid 简介\ndate: 2020-07-17\ncategories: [前端, js]\ntags:\n  - hybrid\n---\n\n## hybrid 实现原理\n\n> 原生的 `App` 中，使用 `WebView` 作为容器直接承载 `Web` 页面。 中间通过 `JSBridge` 来完成 `Native` 与 `JavaScript` 之间的通讯。\n\n## hybrid 几种方案\n\n### 基于  WebView UI  的基础方案\n\n> 例如微信 `JS-SDK`，通过 `JSBridge` 完成 `H5` 与 `Native` 的双向通讯，从而赋予 `H5` 一定程度的原生能力。\n\n### 基于  `Native UI`  的方案\n\n> 例如 `React-Native、Weex` 。在赋予 `H5` 原生 `API` 能力的基础上，进一步通过 `JSBridge` 将 `js` 解析成的虚拟节点树( `Virtual DOM` )传递到 `Native` 并使用原生渲染。\n\n### 小程序方案\n\n> 通过更加定制化的 `JSBridge`，并使用双 `WebView` 双线程的模式隔离了 `JS` 逻辑与 `UI` 渲染，形成了特殊的开发模式，加强了 `H5` 与 `Native` 混合程度，提高了页面性能及开发体验。\n\n## hybrid 和 h5 对比\n\n### h5\n\n- 优点\n  - 开发速度快，一端开发多端运行\n  - 如果需要频繁更换页面，用 `h5` 维护会更加容易\n  - 版本更新不需要打包便可发布\n- 缺点\n  - 流畅度，安全问题\n  - 性能不如原生\n  - 不能调用移动硬件设备的功能\n","slug":"前端/Hybrid 简介","published":1,"updated":"2021-04-07T07:29:06.242Z","_id":"ckn74eabc003pyx7y5tijf0d1","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"hybrid-实现原理\"><a href=\"#hybrid-实现原理\" class=\"headerlink\" title=\"hybrid 实现原理\"></a>hybrid 实现原理</h2><blockquote>\n<p>原生的 <code>App</code> 中，使用 <code>WebView</code> 作为容器直接承载 <code>Web</code> 页面。 中间通过 <code>JSBridge</code> 来完成 <code>Native</code> 与 <code>JavaScript</code> 之间的通讯。</p>\n</blockquote>\n<h2 id=\"hybrid-几种方案\"><a href=\"#hybrid-几种方案\" class=\"headerlink\" title=\"hybrid 几种方案\"></a>hybrid 几种方案</h2><h3 id=\"基于-WebView-UI-的基础方案\"><a href=\"#基于-WebView-UI-的基础方案\" class=\"headerlink\" title=\"基于  WebView UI  的基础方案\"></a>基于  WebView UI  的基础方案</h3><blockquote>\n<p>例如微信 <code>JS-SDK</code>，通过 <code>JSBridge</code> 完成 <code>H5</code> 与 <code>Native</code> 的双向通讯，从而赋予 <code>H5</code> 一定程度的原生能力。</p>\n</blockquote>\n<h3 id=\"基于-Native-UI-的方案\"><a href=\"#基于-Native-UI-的方案\" class=\"headerlink\" title=\"基于  Native UI  的方案\"></a>基于  <code>Native UI</code>  的方案</h3><blockquote>\n<p>例如 <code>React-Native、Weex</code> 。在赋予 <code>H5</code> 原生 <code>API</code> 能力的基础上，进一步通过 <code>JSBridge</code> 将 <code>js</code> 解析成的虚拟节点树( <code>Virtual DOM</code> )传递到 <code>Native</code> 并使用原生渲染。</p>\n</blockquote>\n<h3 id=\"小程序方案\"><a href=\"#小程序方案\" class=\"headerlink\" title=\"小程序方案\"></a>小程序方案</h3><blockquote>\n<p>通过更加定制化的 <code>JSBridge</code>，并使用双 <code>WebView</code> 双线程的模式隔离了 <code>JS</code> 逻辑与 <code>UI</code> 渲染，形成了特殊的开发模式，加强了 <code>H5</code> 与 <code>Native</code> 混合程度，提高了页面性能及开发体验。</p>\n</blockquote>\n<h2 id=\"hybrid-和-h5-对比\"><a href=\"#hybrid-和-h5-对比\" class=\"headerlink\" title=\"hybrid 和 h5 对比\"></a>hybrid 和 h5 对比</h2><h3 id=\"h5\"><a href=\"#h5\" class=\"headerlink\" title=\"h5\"></a>h5</h3><ul>\n<li>优点<ul>\n<li>开发速度快，一端开发多端运行</li>\n<li>如果需要频繁更换页面，用 <code>h5</code> 维护会更加容易</li>\n<li>版本更新不需要打包便可发布</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>流畅度，安全问题</li>\n<li>性能不如原生</li>\n<li>不能调用移动硬件设备的功能</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"hybrid-实现原理\"><a href=\"#hybrid-实现原理\" class=\"headerlink\" title=\"hybrid 实现原理\"></a>hybrid 实现原理</h2><blockquote>\n<p>原生的 <code>App</code> 中，使用 <code>WebView</code> 作为容器直接承载 <code>Web</code> 页面。 中间通过 <code>JSBridge</code> 来完成 <code>Native</code> 与 <code>JavaScript</code> 之间的通讯。</p>\n</blockquote>\n<h2 id=\"hybrid-几种方案\"><a href=\"#hybrid-几种方案\" class=\"headerlink\" title=\"hybrid 几种方案\"></a>hybrid 几种方案</h2><h3 id=\"基于-WebView-UI-的基础方案\"><a href=\"#基于-WebView-UI-的基础方案\" class=\"headerlink\" title=\"基于  WebView UI  的基础方案\"></a>基于  WebView UI  的基础方案</h3><blockquote>\n<p>例如微信 <code>JS-SDK</code>，通过 <code>JSBridge</code> 完成 <code>H5</code> 与 <code>Native</code> 的双向通讯，从而赋予 <code>H5</code> 一定程度的原生能力。</p>\n</blockquote>\n<h3 id=\"基于-Native-UI-的方案\"><a href=\"#基于-Native-UI-的方案\" class=\"headerlink\" title=\"基于  Native UI  的方案\"></a>基于  <code>Native UI</code>  的方案</h3><blockquote>\n<p>例如 <code>React-Native、Weex</code> 。在赋予 <code>H5</code> 原生 <code>API</code> 能力的基础上，进一步通过 <code>JSBridge</code> 将 <code>js</code> 解析成的虚拟节点树( <code>Virtual DOM</code> )传递到 <code>Native</code> 并使用原生渲染。</p>\n</blockquote>\n<h3 id=\"小程序方案\"><a href=\"#小程序方案\" class=\"headerlink\" title=\"小程序方案\"></a>小程序方案</h3><blockquote>\n<p>通过更加定制化的 <code>JSBridge</code>，并使用双 <code>WebView</code> 双线程的模式隔离了 <code>JS</code> 逻辑与 <code>UI</code> 渲染，形成了特殊的开发模式，加强了 <code>H5</code> 与 <code>Native</code> 混合程度，提高了页面性能及开发体验。</p>\n</blockquote>\n<h2 id=\"hybrid-和-h5-对比\"><a href=\"#hybrid-和-h5-对比\" class=\"headerlink\" title=\"hybrid 和 h5 对比\"></a>hybrid 和 h5 对比</h2><h3 id=\"h5\"><a href=\"#h5\" class=\"headerlink\" title=\"h5\"></a>h5</h3><ul>\n<li>优点<ul>\n<li>开发速度快，一端开发多端运行</li>\n<li>如果需要频繁更换页面，用 <code>h5</code> 维护会更加容易</li>\n<li>版本更新不需要打包便可发布</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>流畅度，安全问题</li>\n<li>性能不如原生</li>\n<li>不能调用移动硬件设备的功能</li>\n</ul>\n</li>\n</ul>\n"},{"title":"渐进式 web 应用程序 pwa 简介","date":"2020-07-15T16:00:00.000Z","_content":"\n介绍\n\n> 渐进式 Web 应用程序\n\n## progressive web app\n\n### 优点\n\n1. 显著提高应用加载速度\n2. `web` 应用可以在离线环境下使用\n3. `web` 应用能够像原生应用一样被添加到主屏幕\n4. `web` 应用能在未被激活时发起推送通知\n5. `web` 应用于操作系统集成能力进一步提高\n\n### 关键技术\n\n- w3c web app manifest\n\n> 由早期的定义在 `html` 页面头部转换成了定义在 `json` 文件中\n\n- `scope`：定义了 `web` 应用的浏览作用域，比如作用域外面的 `URL` 就会打开浏览器而不会在当前`PWA`中继续浏览\n\n- `start_url`：定义了一个 `PWA` 的入口页面\n- `orientation`：锁定屏幕旋转\n- `theme_color`/`background_color`：主题色与背景色，用于配置一些可定制的操作系统 `UI` 以提高用户体验，比如 `Android` 的状态栏、任务栏等\n\n- service worker\n  - 让`web`应用离线使用的第三次尝试\n  - 可编程的 `web worker`\n  - 像一个位于浏览器与网络之间的客户端代理，可与拦截、处理、相应流经的 `HTTP` 请求\n  - 配合 `Cache Storage API`，可以自由管理 `HTTP` 请求文件粒度的缓存\n- push notification\n  - `push api` 的出现让推送服务具备了向`web`应用推送消息的能力\n  - `push API` 不依赖`web`应用和浏览器`UI`存活\n","source":"_posts/前端/渐进式 web 应用程序 pwa 简介.md","raw":"---\ntitle: 渐进式 web 应用程序 pwa 简介\ndate: 2020-07-16\ncategories: [前端, js]\ntags: \n  - pwa\n---\n\n介绍\n\n> 渐进式 Web 应用程序\n\n## progressive web app\n\n### 优点\n\n1. 显著提高应用加载速度\n2. `web` 应用可以在离线环境下使用\n3. `web` 应用能够像原生应用一样被添加到主屏幕\n4. `web` 应用能在未被激活时发起推送通知\n5. `web` 应用于操作系统集成能力进一步提高\n\n### 关键技术\n\n- w3c web app manifest\n\n> 由早期的定义在 `html` 页面头部转换成了定义在 `json` 文件中\n\n- `scope`：定义了 `web` 应用的浏览作用域，比如作用域外面的 `URL` 就会打开浏览器而不会在当前`PWA`中继续浏览\n\n- `start_url`：定义了一个 `PWA` 的入口页面\n- `orientation`：锁定屏幕旋转\n- `theme_color`/`background_color`：主题色与背景色，用于配置一些可定制的操作系统 `UI` 以提高用户体验，比如 `Android` 的状态栏、任务栏等\n\n- service worker\n  - 让`web`应用离线使用的第三次尝试\n  - 可编程的 `web worker`\n  - 像一个位于浏览器与网络之间的客户端代理，可与拦截、处理、相应流经的 `HTTP` 请求\n  - 配合 `Cache Storage API`，可以自由管理 `HTTP` 请求文件粒度的缓存\n- push notification\n  - `push api` 的出现让推送服务具备了向`web`应用推送消息的能力\n  - `push API` 不依赖`web`应用和浏览器`UI`存活\n","slug":"前端/渐进式 web 应用程序 pwa 简介","published":1,"updated":"2021-04-07T07:27:07.656Z","_id":"ckn74f72o003qyx7y4fit8fiw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>介绍</p>\n<blockquote>\n<p>渐进式 Web 应用程序</p>\n</blockquote>\n<h2 id=\"progressive-web-app\"><a href=\"#progressive-web-app\" class=\"headerlink\" title=\"progressive web app\"></a>progressive web app</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>显著提高应用加载速度</li>\n<li><code>web</code> 应用可以在离线环境下使用</li>\n<li><code>web</code> 应用能够像原生应用一样被添加到主屏幕</li>\n<li><code>web</code> 应用能在未被激活时发起推送通知</li>\n<li><code>web</code> 应用于操作系统集成能力进一步提高</li>\n</ol>\n<h3 id=\"关键技术\"><a href=\"#关键技术\" class=\"headerlink\" title=\"关键技术\"></a>关键技术</h3><ul>\n<li>w3c web app manifest</li>\n</ul>\n<blockquote>\n<p>由早期的定义在 <code>html</code> 页面头部转换成了定义在 <code>json</code> 文件中</p>\n</blockquote>\n<ul>\n<li><p><code>scope</code>：定义了 <code>web</code> 应用的浏览作用域，比如作用域外面的 <code>URL</code> 就会打开浏览器而不会在当前<code>PWA</code>中继续浏览</p>\n</li>\n<li><p><code>start_url</code>：定义了一个 <code>PWA</code> 的入口页面</p>\n</li>\n<li><p><code>orientation</code>：锁定屏幕旋转</p>\n</li>\n<li><p><code>theme_color</code>/<code>background_color</code>：主题色与背景色，用于配置一些可定制的操作系统 <code>UI</code> 以提高用户体验，比如 <code>Android</code> 的状态栏、任务栏等</p>\n</li>\n<li><p>service worker</p>\n<ul>\n<li>让<code>web</code>应用离线使用的第三次尝试</li>\n<li>可编程的 <code>web worker</code></li>\n<li>像一个位于浏览器与网络之间的客户端代理，可与拦截、处理、相应流经的 <code>HTTP</code> 请求</li>\n<li>配合 <code>Cache Storage API</code>，可以自由管理 <code>HTTP</code> 请求文件粒度的缓存</li>\n</ul>\n</li>\n<li><p>push notification</p>\n<ul>\n<li><code>push api</code> 的出现让推送服务具备了向<code>web</code>应用推送消息的能力</li>\n<li><code>push API</code> 不依赖<code>web</code>应用和浏览器<code>UI</code>存活</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍</p>\n<blockquote>\n<p>渐进式 Web 应用程序</p>\n</blockquote>\n<h2 id=\"progressive-web-app\"><a href=\"#progressive-web-app\" class=\"headerlink\" title=\"progressive web app\"></a>progressive web app</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>显著提高应用加载速度</li>\n<li><code>web</code> 应用可以在离线环境下使用</li>\n<li><code>web</code> 应用能够像原生应用一样被添加到主屏幕</li>\n<li><code>web</code> 应用能在未被激活时发起推送通知</li>\n<li><code>web</code> 应用于操作系统集成能力进一步提高</li>\n</ol>\n<h3 id=\"关键技术\"><a href=\"#关键技术\" class=\"headerlink\" title=\"关键技术\"></a>关键技术</h3><ul>\n<li>w3c web app manifest</li>\n</ul>\n<blockquote>\n<p>由早期的定义在 <code>html</code> 页面头部转换成了定义在 <code>json</code> 文件中</p>\n</blockquote>\n<ul>\n<li><p><code>scope</code>：定义了 <code>web</code> 应用的浏览作用域，比如作用域外面的 <code>URL</code> 就会打开浏览器而不会在当前<code>PWA</code>中继续浏览</p>\n</li>\n<li><p><code>start_url</code>：定义了一个 <code>PWA</code> 的入口页面</p>\n</li>\n<li><p><code>orientation</code>：锁定屏幕旋转</p>\n</li>\n<li><p><code>theme_color</code>/<code>background_color</code>：主题色与背景色，用于配置一些可定制的操作系统 <code>UI</code> 以提高用户体验，比如 <code>Android</code> 的状态栏、任务栏等</p>\n</li>\n<li><p>service worker</p>\n<ul>\n<li>让<code>web</code>应用离线使用的第三次尝试</li>\n<li>可编程的 <code>web worker</code></li>\n<li>像一个位于浏览器与网络之间的客户端代理，可与拦截、处理、相应流经的 <code>HTTP</code> 请求</li>\n<li>配合 <code>Cache Storage API</code>，可以自由管理 <code>HTTP</code> 请求文件粒度的缓存</li>\n</ul>\n</li>\n<li><p>push notification</p>\n<ul>\n<li><code>push api</code> 的出现让推送服务具备了向<code>web</code>应用推送消息的能力</li>\n<li><code>push API</code> 不依赖<code>web</code>应用和浏览器<code>UI</code>存活</li>\n</ul>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckn72xyzx00014f7ybq9j8n0k","category_id":"ckn724nl000024d7y3eu5gt0i","_id":"ckn73inu9001e4f7y06xj2hac"},{"post_id":"ckn72xyzx00014f7ybq9j8n0k","category_id":"ckn73g6cm000v4f7y0pks8fht","_id":"ckn73inu9001f4f7yhegn2whk"},{"post_id":"ckn72xyzx00014f7ybq9j8n0k","category_id":"ckn73gnhk000x4f7y1wry0ks4","_id":"ckn73m9fu001x4f7y768s5ava"},{"post_id":"ckn7476ad001yyx7ybs7v7hez","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476af0024yx7yex7e1oep"},{"post_id":"ckn7476ad001yyx7ybs7v7hez","category_id":"ckn73y16z00012b7y8cj11ow7","_id":"ckn7476ag0027yx7ybvz70rx2"},{"post_id":"ckn7476ad001zyx7yhda41in0","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476ag0029yx7yezj30ob6"},{"post_id":"ckn7476ad001zyx7yhda41in0","category_id":"ckn73z9ui002n2b7yduwfbvhf","_id":"ckn7476ag002byx7y8d92bjfh"},{"post_id":"ckn7476ae0021yx7y45at6zsv","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476ah002cyx7y6wiz6hz0"},{"post_id":"ckn7476ae0021yx7y45at6zsv","category_id":"ckn73z9ui002n2b7yduwfbvhf","_id":"ckn7476ah002dyx7y9yhcbnkw"},{"post_id":"ckn7476af0023yx7ydfxjb6vn","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476ah002eyx7yhusr09hw"},{"post_id":"ckn7476af0023yx7ydfxjb6vn","category_id":"ckn73z9ui002n2b7yduwfbvhf","_id":"ckn7476ah002fyx7y3mp90tx0"},{"post_id":"ckn7476ai002iyx7y4htk6ur4","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476al002oyx7ya6bffuo6"},{"post_id":"ckn7476ai002iyx7y4htk6ur4","category_id":"ckn73y16z00012b7y8cj11ow7","_id":"ckn7476am002ryx7yexxebsdm"},{"post_id":"ckn7476aj002jyx7ydtbx6zny","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476an002uyx7y74yb5ur8"},{"post_id":"ckn7476aj002jyx7ydtbx6zny","category_id":"ckn73yagp00222b7yftoc34u4","_id":"ckn7476ap002wyx7y4uo274ft"},{"post_id":"ckn7476ak002lyx7y36092igs","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476ap002yyx7y0ke0h8h5"},{"post_id":"ckn7476ak002lyx7y36092igs","category_id":"ckn73yagp00222b7yftoc34u4","_id":"ckn7476as0030yx7y1d32gzpt"},{"post_id":"ckn7476ak002nyx7yfi4b9int","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476as0031yx7y7dk3hsvh"},{"post_id":"ckn7476ak002nyx7yfi4b9int","category_id":"ckn73yagp00222b7yftoc34u4","_id":"ckn7476as0032yx7y8jrr51fs"},{"post_id":"ckn7476al002qyx7y8i352o5l","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476at0033yx7yhtte4mjx"},{"post_id":"ckn7476al002qyx7y8i352o5l","category_id":"ckn73z9ui002n2b7yduwfbvhf","_id":"ckn7476at0034yx7y9wx9grmz"},{"post_id":"ckn7476am002tyx7ybva35va3","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476at0035yx7y0yt41jck"},{"post_id":"ckn7476am002tyx7ybva35va3","category_id":"ckn73yagp00222b7yftoc34u4","_id":"ckn7476at0036yx7yhrw299uj"},{"post_id":"ckn7476au0037yx7y3aac6bor","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476av0039yx7y9e0fgbch"},{"post_id":"ckn7476au0037yx7y3aac6bor","category_id":"ckn73y16z00012b7y8cj11ow7","_id":"ckn7476av003ayx7ybce406im"},{"post_id":"ckn7476aw003byx7y6rl88saa","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476aw003dyx7yg2ul3msg"},{"post_id":"ckn7476aw003byx7y6rl88saa","category_id":"ckn73yagp00222b7yftoc34u4","_id":"ckn7476aw003eyx7yc8a46bx7"},{"post_id":"ckn7476az003fyx7ybx8ffg98","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn7476b0003hyx7y6bafc7vt"},{"post_id":"ckn7476az003fyx7ybx8ffg98","category_id":"ckn747lph003jyx7ya58sbihb","_id":"ckn747lph003kyx7yd4p435vv"},{"post_id":"ckn74b69w003lyx7y79keby5p","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn74b6a0003nyx7y9lypep5a"},{"post_id":"ckn74b69w003lyx7y79keby5p","category_id":"ckn73yq2u002d2b7y8v6r4oxf","_id":"ckn74b6a1003oyx7yd1be5gox"},{"post_id":"ckn74f72o003qyx7y4fit8fiw","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn74ftut003syx7y09fm6spx"},{"post_id":"ckn74f72o003qyx7y4fit8fiw","category_id":"ckn73yagp00222b7yftoc34u4","_id":"ckn74ftuu003tyx7y1dyy5k27"},{"post_id":"ckn74eabc003pyx7y5tijf0d1","category_id":"ckn73y16y00002b7yhsgu5ukt","_id":"ckn74gjkc003wyx7ybs1nhxl4"},{"post_id":"ckn74eabc003pyx7y5tijf0d1","category_id":"ckn73yagp00222b7yftoc34u4","_id":"ckn74gjkc003xyx7y15xec0kl"}],"PostTag":[{"post_id":"ckn72xyzx00014f7ybq9j8n0k","tag_id":"ckn736mpa000k4f7yexx66xnr","_id":"ckn73ir1r001h4f7yc5ml4yha"},{"post_id":"ckn7476ad001yyx7ybs7v7hez","tag_id":"ckn73ofmm00254f7ygp0eamqs","_id":"ckn7476ae0020yx7y7dg8bh8r"},{"post_id":"ckn7476ad001zyx7yhda41in0","tag_id":"ckn73r9or002p4f7yfncxhshj","_id":"ckn7476af0022yx7y2gjeh6yg"},{"post_id":"ckn7476ae0021yx7y45at6zsv","tag_id":"ckn73paob00294f7y7ayrhnls","_id":"ckn7476af0025yx7y0qsr7055"},{"post_id":"ckn7476af0023yx7ydfxjb6vn","tag_id":"ckn73qg8l002k4f7y362zh4wm","_id":"ckn7476ag0028yx7yg091b9ic"},{"post_id":"ckn7476ai002iyx7y4htk6ur4","tag_id":"ckn72uimf0001nd7y7azr3nhz","_id":"ckn7476aj002kyx7yf6aqcfii"},{"post_id":"ckn7476aj002jyx7ydtbx6zny","tag_id":"ckn73nhpw00214f7y216bawn3","_id":"ckn7476ak002myx7y84yebkko"},{"post_id":"ckn7476aj002jyx7ydtbx6zny","tag_id":"ckn73nhpw00224f7yd0o8563q","_id":"ckn7476al002pyx7y6xwj3htx"},{"post_id":"ckn7476ak002lyx7y36092igs","tag_id":"ckn73jbgh001i4f7y8ioag4xv","_id":"ckn7476am002syx7ye2lg57ss"},{"post_id":"ckn7476ak002nyx7yfi4b9int","tag_id":"ckn736mpa000k4f7yexx66xnr","_id":"ckn7476an002vyx7yalnfaudf"},{"post_id":"ckn7476al002qyx7y8i352o5l","tag_id":"ckn73pp2c002f4f7yabxs5ch5","_id":"ckn7476ap002xyx7y0prj0jpf"},{"post_id":"ckn7476am002tyx7ybva35va3","tag_id":"ckn734h7t000h4f7yaock3v2v","_id":"ckn7476as002zyx7yb91b90ug"},{"post_id":"ckn7476au0037yx7y3aac6bor","tag_id":"ckn73pp2c002f4f7yabxs5ch5","_id":"ckn7476av0038yx7yd5b25jct"},{"post_id":"ckn7476aw003byx7y6rl88saa","tag_id":"ckn73i9p4001b4f7yc8ve2ik7","_id":"ckn7476aw003cyx7y11240y0c"},{"post_id":"ckn7476az003fyx7ybx8ffg98","tag_id":"ckn73pp2c002f4f7yabxs5ch5","_id":"ckn7476b0003gyx7ycuqte0lt"},{"post_id":"ckn74b69w003lyx7y79keby5p","tag_id":"ckn73jbgh001i4f7y8ioag4xv","_id":"ckn74b69z003myx7y3fzx4041"},{"post_id":"ckn74f72o003qyx7y4fit8fiw","tag_id":"ckn74ftus003ryx7y8oyu3ha8","_id":"ckn74ftuu003uyx7y4wspcx4n"},{"post_id":"ckn74eabc003pyx7y5tijf0d1","tag_id":"ckn74gjkc003vyx7y381c9n73","_id":"ckn74gjkd003yyx7ygi1xgntg"}],"Tag":[{"name":"测试","_id":"ckn724nl100034d7ycmdp25dp"},{"name":"react","_id":"ckn72uimf0001nd7y7azr3nhz"},{"name":"React","_id":"ckn7335m4000c4f7ydzcbcqe5"},{"name":"js","_id":"ckn734h7s000f4f7yav46ej0s"},{"name":"二进制","_id":"ckn734h7t000h4f7yaock3v2v"},{"name":"使用技巧","_id":"ckn736mpa000k4f7yexx66xnr"},{"name":"防抖和节流","_id":"ckn73ey0r000q4f7y2wiy0719"},{"name":"自动化测试","_id":"ckn73i9p4001b4f7yc8ve2ik7"},{"name":"解决方案","_id":"ckn73jbgh001i4f7y8ioag4xv"},{"name":"ajax","_id":"ckn73nhpw00214f7y216bawn3"},{"name":"fetch","_id":"ckn73nhpw00224f7yd0o8563q"},{"name":"react-hooks","_id":"ckn73ofmm00254f7ygp0eamqs"},{"name":"数据驱动","_id":"ckn73paob00294f7y7ayrhnls"},{"name":"文档","_id":"ckn73pp2c002f4f7yabxs5ch5"},{"name":"虚拟 dom","_id":"ckn73qg8l002k4f7y362zh4wm"},{"name":"diff 算法","_id":"ckn73r9or002p4f7yfncxhshj"},{"name":"pwa","_id":"ckn74ftus003ryx7y8oyu3ha8"},{"name":"hybrid","_id":"ckn74gjkc003vyx7y381c9n73"}]}}