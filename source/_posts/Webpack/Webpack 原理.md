---
title: Webpack 原理
date: 2021-04-18
categories: [Webpack]
---

## Webpack 的构建流程

Webpack 的运行流程是一个串行的流程，从启动到结束会依次执行以下流程：

- 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
- 开始编译: 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
- 确定入口：根据配置中的 entry 找出所有的入口文件
- 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行编译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过本步骤的处理
- 完成模块编译：经过上一步后，使用 Loader 编译完所有模块后，得到了每个模块编译后的最终内容以及他们之间的依赖关系
- 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 chunk, 再把每个 chunk 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会
- 输出完成：在确定好输入内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统

在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 Api 改变 Webpack 的运行结果

## Webpack 模块打包原理

Webpack 实际上为各个模块创造了一个可以导出和导入的环境，本质上并没有修改代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。

## Webpack 文件监听原理

当发现源码发生变化时，自动重新构建出新的输出文件

轮训判断文件的最后编译时间是否发生变化，如果某个文件发生了变化，并不会立即告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行

## Webpack 热更新原理

Webpack 的热更新又叫做热替换，即 HMR。这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。

HMR 的核心就是客户端从服务器拉取更新后的文件，准去说就是 chunk diff(chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 WebSocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。

客户端对比出查以后会向 WDS 发起 AJAX 请求来获取更改后的内容(文件列表、hash)，这样客户端就可以借助这些信息继续向 WDS 发起 jsonp 请求该 chunk 的增量更新。

后续部分由 HotModulePlugin 来完成(拿到增量更新之后如何处理? 哪些状态该保留? 哪些状态又需要更新?)，提供了相关 API 以供开发者针对自身场景进行处理，像 react-hot-laoder 和 vue-loader 都是借助这些 API 实现 HMR。

## 如何优化 Webpack 的构建速度

1. 使用高版本的 Webpack 和 Node.js
2. 多进程/多实例构建
3. 代码压缩
4. 图片压缩
5. 缩小打包作用域
   - exclude/include(确定 loader 规则范围)
   - resolve.modules 指明第三方模块的绝对路径(减少不必要的查找)
   - 对不需要解析的库进行忽略
   - 完全排除模块
   - 合理利用 alias
6. 提取页面公共资源
   - 基础包分离，将基础包通过 CDN 引入，不打入 bundle 中
   - 使用 SplitChunksPlugin 进行公共资源分离
7. DLL
   - 使用 DLLPlugin 进行分包，使用索引链接对 mainfest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间
8. 充分利用缓存提升二次构建速度
   - babel-loader 开启缓存
   - terser-webpack-plugin 开启缓存
   - 使用 cache-loader 或者 hard-source-webpack-plugin
9. Tree shaking
   - 打包过程中检测工程中没有使用过的模块并进行标记，在资源压缩时将他们从最终的 bundle 中去掉，在开发中尽可能使用 ES6 Module 的模块，提高 tree-shaking 效率
   - 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就是转换过的 CommonJS 形式的模块，无法进行 tree-shaking
   - 去掉无用的 css 代码

## 代码分割的本质

代码分割的本质就是在 **源代码直接上线** 和 **打包成唯一脚本 main.bundle.js** 这两种极端方案之间的一种更适合时机场景的中间状态。
用可接受的服务器性能压力增加来换取更好的用户体验
源代码直接上线：虽然过程可控，但 http 请求多，性能开销大
打包成唯一脚本：服务器压力小，但页面空白期常，用户体验差