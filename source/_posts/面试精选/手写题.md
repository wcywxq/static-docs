---
title: 手写题
date: 2021-05-25
categories: [面试, 手写题]
---

## 长列表虚拟滚动实现

### vue

```vue
<template>
  <div class="virtual-list">
    <section class="container" ref="container" @scroll="scrollView">
      <div class="scroll-bar" ref="scrollBar"></div>
      <ul ref="list" class="list">
        <li v-for="item in showList" :key="item">
          {{ item }}
        </li>
      </ul>
    </section>
  </div>
</template>
<script>
export default {
  name: "App",
  data() {
    return {
      list: [],
      childHeight: 30,
      maxCount: 10,
      start: 0,
      end: 10
    };
  },
  mounted() {
    this.list = Array.from({ length: 100000 }, (k, v) => v);
    // 计算滚动容器高度
    this.$refs.container.style.height = this.childHeight * this.maxCount + "px";
    // 计算总的数据需要的高度，构造滚动条高度
    this.$refs.scrollBar.style.height = this.childHeight * this.list.length + "px";
  },
  computed: {
    showList() {
      return this.list.slice(this.start, this.end);
    }
  },
  methods: {
    scrollView() {
      let scrollTop = this.$refs.container.scrollTop;
      this.start = Math.floor(scrollTop / this.childHeight);
      this.end = this.start + this.maxCount;
      this.$refs.list.style.top = this.start * this.childHeight + "px";
    }
  }
};
</script>
<style>
.virtual-list {
  text-align: center;
}

ul,
li {
  list-style: none;
}

.container {
  position: relative;
  overflow: scroll;
  border-bottom: 1px solid #ddd;
}

.list {
  position: absolute;
  width: 100%;
  top: 0;
  left: 0;
  text-align: left;
}

.list li {
  margin-bottom: 10px;
  line-height: 1.5;
  width: 100%;
  border-bottom: 1px dashed #1890ff;
  color: #52c41a;
  font-weight: bold;
}
</style>
```

### react

```jsx
import { useState, useRef, useMemo, useEffect } from "react";
import "./styles.css";

export default function App() {
  const containerRef = useRef();
  const scrollBarRef = useRef();
  const listRef = useRef();
  const [list, setList] = useState([]);
  const [options, setOptions] = useState({
    childrenHeight: 30,
    maxCount: 10,
    start: 0,
    end: 10
  });

  const sliceList = useMemo(() => {
    const { start, end } = options;
    return list.slice(start, end);
  }, [list, options]);

  useEffect(() => {
    const virtualList = Array.from({ length: 10000 }, (k, v) => v);
    setList(virtualList);
  }, []);

  useEffect(() => {
    const { childrenHeight, maxCount } = options;
    containerRef.current.style.height = `${childrenHeight * maxCount}px`;
    scrollBarRef.current.style.height = `${childrenHeight * list.length}px`;
  }, [list.length, options]);

  const scrollView = () => {
    const { childrenHeight, maxCount, start } = options;
    let scrollTop = containerRef.current.scrollTop;
    const startIndex = Math.floor(scrollTop / childrenHeight);
    setOptions(prevOptions => ({ ...prevOptions, start: startIndex }));
    const endIndex = startIndex + maxCount;
    setOptions(prevOptions => ({ ...prevOptions, end: endIndex }));
    listRef.current.style.top = `${start * childrenHeight}px`;
  };

  return (
    <div className="App">
      <section className="container" ref={containerRef} onScroll={scrollView}>
        <div className="scroll-bar" ref={scrollBarRef}></div>
        <ul className="list" ref={listRef}>
          {sliceList.map(item => (
            <li key={item}>{item}</li>
          ))}
        </ul>
      </section>
    </div>
  );
}
```

## 发布订阅模式

```js
class EventBus {
  constructor() {
    this.cache = {};
  }
  // 监听
  on(name, fn) {
    if (this.cache[name]) {
      this.cache[name].push(fn);
    } else {
      this.cache[name] = [fn];
    }
  }
  // 移除监听
  off(name, fn) {
    let tasks = this.cache[name];
    if (tasks) {
      const index = tasks.findIndex(f => f === fn || f.callback === fn);
      if (index >= 0) {
        tasks.splice(index, 1);
      }
    }
  }
  // 触发
  emit(name, once = false, ...args) {
    if (this.cache[name]) {
      let tasks = this.cache[name].slice();
      for (let fn of tasks) {
        fn(...args);
      }
      if (once) {
        delete this.cache[name];
      }
    }
  }
}

// 测试
const eventBus = new EventBus();
const fn1 = (name, age) => {
  console.log(`fn1: ${name} ${age}`);
};
const fn2 = (name, age) => {
  console.log(`fn2: ${name} ${age}`);
};
eventBus.on("fn1", fn1);
eventBus.on("fn2", fn2);
eventBus.emit("fn1", false, "张三", 20);
```

## Promise 实现

```js
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class Promise {
  constructor(executor) {
    // 状态
    this.status = PENDING;
    // success
    this.value = undefined;
    // error
    this.reason = undefined;
    // callback
    this.onResolvedCallbackList = [];
    this.onRejectedCallbackList = [];
    // success cb
    const resolve = value => {
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbackList.forEach(fn => fn());
      }
    };
    // error cb
    const reject = reason => {
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.reason = reason;
        this.onRejectedCallbackList.forEach(fn => fn());
      }
    };

    // 捕获异常
    try {
      executor(resolve, reject);
    } catch (err) {
      reject(err);
    }
  }

  resolvePromise(promise, next, resolve, reject) {
    // 避免循环引用
    if (next === promise) {
      return reject(new TypeError("Chaining cycle detected for promise #<Promise>"));
    }
    // 判断是否被调用过
    let called;
    // 判定类型
    if ((next !== null && typeof next === "object") || typeof next === "function") {
      try {
        if (typeof next.then === "function") {
          const resolveArg = next => {
            if (called) return;
            called = true;
            this.resolvePromise(promise, next, resolve, reject);
          };
          const rejectArg = err => {
            if (called) return;
            called = true;
            this.resolvePromise(promise, next, resolve, reject);
          };
          // 改变作用域 context
          next.then.call(next, resolveArg, rejectArg);
        } else {
          resolve(next);
        }
      } catch (err) {
        if (called) return;
        called = true;
        reject(err);
      }
    } else {
      // next 以参数执行 promise
      reject(next);
    }
  }

  then(onFulfilled, onRejected) {
    // 判断是否为函数, 不是则被忽略
    onFulfilled =
      typeof onFulfilled === "funciton"
        ? onFulfilled
        : function (val) {
            return val;
          };

    onRejected =
      typeof onRejected === "function"
        ? onRejected
        : function (err) {
            throw new Error(err);
          };

    // 每次调用 then 都会返回新的 Promise
    const promise = new Promise((resolve, reject) => {
      const resolveCb = () => {
        try {
          let next = onFulfilled(this.value);
          this.resolvePromise(promise, next, resolve, reject);
        } catch (err) {
          reject(err);
        }
      };
      const rejectCb = () => {
        try {
          let next = onRejected(this.reason);
          this.resolvePromise(promise, next, resolve, reject);
        } catch (err) {
          reject(err);
        }
      };
      if (this.status === FULFILLED) setTimeout(resolveCb, 0);
      if (this.status === REJECTED) setTimeout(rejectCb, 0);
      if (this.status === PENDING) {
        this.onResolvedCallbackList.push(resolveCb);
        this.onRejectedCallbackList.push(rejectCb);
      }
    });
    return promise;
  }

  catch(cb) {
    return this.then(null, cb);
  }

  static resolve(value) {
    if (value instanceof Promsie) return value;
    return new Promise((resolve, reject) => resolve(value));
  }

  static reject(reason) {
    return new Promise((_, reject) => reject(reason));
  }

  /**
   * @desc 成功返回 list, 失败返回最先失败的结果
   */
  static all(promiseList) {
    let index = 0,
      result = [];
    return new Promise((resolve, reject) => {
      let len = promiseList.length;
      for (let i = 0; i < len; i++) {
        let item = promiseList[i];
        Promise.resolve(item).then(
          value => {
            index++;
            result[i] = value;
            if (index === len) {
              return resolve(result);
            }
          },
          err => reject(err)
        );
      }
    });
  }
  /**
   * @desc 哪个跑得快先返回哪个，无论成功/失败
   */
  static race(promiseList) {
    return new Promise((resolve, reject) => {
      let len = promiseList.length;
      for (let i = 0; i < len; i++) {
        let item = promiseList[i];
        Promise.resolve(item).then(
          value => reoslve(value),
          err => reject(err)
        );
      }
    });
  }
  /**
   * @desc 不管成功 or 失败，会等所有实例都返回结果
   */
  static allSettled(promiseList) {
    return new Promise((resolve, reject) => {
      let len = promiseList.length;
      for (let i = 0; i < len; i++) {
        let item = promiseList[i];
        Promise.resolve(item).then(
          value => {
            result.push({ status: "fulfilled", value });
            if (result.length === len) return resolve(result);
          },
          err => {
            result.push({ status: "rejected", reason: err });
            if (result.length === len) return reject(result);
          }
        );
      }
    });
  }
  /**
   * @desc 全部失败才会失败，有一个成功则返回第一个成功的实例
   */
  static any(promiseList) {
    let index = 0;
    return new Promise((resolve, reject) => {
      let len = promiseList.length;
      if (len === 0) return;
      for (let i = 0; i < len; i++) {
        let item = promiseList[i];
        Promise.resolve(item).then(
          value => resolve(value),
          err => {
            index++;
            if (index === len) return reject(new Error("All promises were rejected"));
          }
        );
      }
    });
  }
}

console.log(4);
Promise.resolve()
  .then(() => {
    console.log(1);
    setTimeout(() => {
      console.log(3);
    }, 0);
  })
  .then(() => {
    console.log(2);
  });
setTimeout(() => {
  console.log(5);
}, 0);
```

## 防抖和节流

### 防抖和节流对比

- 防抖

> 触发高频事件后 n 秒内只执行一次，如果 n 秒内再次触发就会重新计算时间。

- 节流

> 触发高频事件后 n 秒内只执行一次，所以节流会稀释函数的执行频率。n 秒内再次触发也不会执行

- 两者对比

> 防抖是最后一个执行事件才会触发函数，节流在一定时间内会触发函数。

### 防抖

- 简单版

```js
function shallowDebounce(func, wait) {
  let timeout;
  return function (...args) {
    let context = this;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(function () {
      func.apply(context, args);
    }, wait);
  };
}
```

- 复杂版

```js
function debounce(func, wait, immediate) {
  let timeout = null;
  let fn = function (...args) {
    let context = this;
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      let callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait);
      if (callNow) {
        func.apply(context, args);
      }
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
  };
  fn.cancel = function () {
    clearTimeout(timeout);
    timeout = null;
  };
  return fn;
}
```

### 节流

- 简单版

```js
function shallowThrottle(func, wait) {
  let previous = 0;
  return function (...args) {
    let now = +new Date();
    let context = this;
    if (now - previous > wait) {
      func.apply(context, args);
      previous = now;
    }
  };
}
```

- 复杂版

```js
/**
 * @desc leading 立即执行一次
 * @desc trailing 执行结束后是否再执一次
 */ 
function throttle(func, wait, leading = true, trailing = true) {
  let timeout = null,
    previous = 0;
  let fn = function (...args) {
    let now = +new Date();
    let context = this;
    if (!previous && !leading) previous = now;
    // 剩余时间
    let remaining = wait - (now - previous);
    if (timeout) {
      clearTimeout(timeout);
      timeout = null;
    } else {
      if (remaining <= 0 || remaining > wait) {
        previous = now;
        func.apply(context, args);
      } else if (!timeout && trailing) {
        timeout = setTimeout(function () {
          previous = !leading ? 0 : +new Date();
          timeout = null;
          func.apply(context, args);
        }, remaining);
      }
    }
  };
  fn.cancel = function () {
    clearTimeout(timeout);
    previous = 0;
    timeout = null;
  };
  return fn;
}
```
