---
title: JS 面试精选
date: 2021-04-19
categories: [面试, JS]
---

## let/const

1. 声明的变量只在声明时的代码块内有效
2. 不存在变量的提升
3. 暂时性死区(在变量声明前使用会发生报错)
4. 不能够重复声明

## weakMap/weakSet

对于 weakMap 和 weakSet 来说不会计入垃圾回收

weakMap 的键名只能是对象

weakSet 成员只能是对象

## 什么是 JavaScript 事件循环

- 因为 js 是单线程执行的，在代码执行的过程中，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。
- 在执行同步代码的时候，如果遇到了异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件暂时挂起，继续执行执行栈中的其他任务。
- 当异步事件执行完毕后，再将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中等待执行。
- 任务队列分为
  - 宏任务队列
    > script 脚本的执行
    > setTimeout/setInterval/setImmediate
    > I/O 操作
    > UI 渲染
  - 微任务队列
    > promise 的回调
    > node 中的 process.nextTick
    > 对 DOM 变化监听的 MutationObserver
- 当当前执行栈中的事件执行完毕后，js 引擎会首先判断微任务队列中是否有任务可以执行。如果有就将微任务队列的队首事件压入执行栈中执行。当微任务队列中的任务都执行完成后，再去判断宏任务队列中的任务。

## 什么是事件队列

事件队列是一个存储着待执行任务的队列，其中的任务严格按照事件顺序执行，队头的任务率先执行，队尾的任务后执行。每次仅执行一个任务。

## 执行栈是什么

执行栈是类似函数调用栈的运行容器，执行栈为空，js 引擎检查事件队列是否为空，不为空则将第一个任务压入执行栈执行。

## js 原型

- 在 js 中，我们使用构造函数新建一个对象，每个构造函数内部都有一个 prototype 属性值，该属性值是一个对象，该对象包含了可以被该构造函数的所有实例所共享的属性和方法。
- 在我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性值，即这个对象的原型。

## js 原型链

当我们访问一个对象的属性时，若对象内部不存在这一属性，便会去它的原型对象里去找这个属性，同时这个原型对象又会有自己的原型，然后这样一直找下去，便形成了原型链

## js 原型特点

javascript 对象使用过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本，当我们修改原型时，与之相关的对象也会继承这一改变

## js 的几种继承方式

- 原型链继承

> 缺点: 引用类型数据会被所有实例所共享，会造成修改数据混乱; 创建子类时无法向超类型传参

- 借用构造函数继承

> 通过在子类函数中调用超类型的构造函数实现。解决了无法向超类传参数的缺点，但是无法实现函数方法的复用，同时超类定义的方法子类也无法访问。

- 组合式继承

> 将原型链继承和借用构造函继承组合使用，通过借用构造函数的方式来实现类型属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。缺点是调用了两次超类构造函数。

- 原型式继承

> 基于已有的对象创建新的对象。向函数中传递一个对象，然后返回一个以这个对象为原型的对象。Object.create() 方法就是原型式继承的实现，缺点同原型继承

- 寄生式继承

> 通过 Object.create 创建副本，对副本进行扩展，最后将副本返回

- 寄生组合式继承

> 缺点: 使用超类实例做子类型原型，多了不必要的属性。

## js 的栈和堆

- 栈(基本数据类型: number, string, boolean, undefined, null, symbol, bigInt)

> 占据空间小，大小固定，频繁使用。

- 堆(应用数据类型: object, array, function)

> 占据空间大，大小不固定

## 事件冒泡和事件捕获

- 事件冒泡(addEventListener 第三个参数为 false，则事件触发顺序为冒泡顺序)

> 目标元素事件先触发，然后父元素事件触发(从内部向外冒泡)

- 事件捕获(addEventListener 第三个参数为 true，则事件触发顺序为捕获顺序)

> 父元素事件先触发，然后目标元素事件触发(从外部向内部)

## 事件的执行顺序

- 先事件捕获(从 window -> document 依次往下执行)
- 再是对目标事件的处理
- 最后是事件冒泡

## js 闭包

闭包指的是有权访问另一个函数作用域中变量的函数，创建闭包最常见的方式就是在一个函数内创建另一个函数(本质就是函数的作用域链中保存着外部函数变量对象的引用)

## 实现 new 关键字

- 创建一个新的空对象
- 设置原型，将对象的原型设置为函数的 prototype 对象
- 让函数的 this 指向这个对象，执行构造函数中的代码
- 判断函数返回值类型，值类型 => 创建对象，引用类型 => 引用类型对象

```js
function ObjectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  if (typeof constructor !== "function") return;
  newObject = Object.create(constructor.prototype);
  result = constructor.apply(newObject, arguments);
  let flag = (result && typeof result !== "object") || typeof result === "function";
  return flag ? result : newObject;
}
```

## ajax 理解

ajax 是一种异步通信方式，直接由 js 脚本向服务器发起 http 通信，根据服务器返回的数据，更新网页响应部分而不刷新网页。

## 浏览器缓存

### 浏览器缓存机制

- 通过在一段时间内保留已接收到的 web 资源的一个副本，如果在有效时间内，发起了对这个资源的再一次请求，浏览器将直接使用缓存副本，而不是再发起请求。
- 可以提高页面的打开速度，减少不必要的带宽消耗.

### 浏览器缓存位置

- Service Worker

> Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件，如何匹配缓存，如何读取缓存，并且缓存是可持续性的。

- Memory Cache

> Memory Cahce 是内存中的缓存，读取内存中的数据肯定比读取磁盘中的数据快。但是内存缓存虽然读取高效，但是缓存持续性很短，会随着进程的释放而释放。

- Disk Cache

> Disk Cache 是存储在硬盘中的缓存，虽然读取速度慢，但是都可以存储到磁盘中，胜在容量和饿存储时效性上。

- Push Cache

> Push Cache 是 Http/2 中的内容，当以上三种缓存都没有命中时，它才会被使用，并且缓存时间也很短暂，只在 session 会话中存在，一旦会话结束将会被释放

- 网络请求

> 如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。

### 浏览器缓存策略

### 强缓存

强缓存可以通过设置两种 Http 头来实现，分别是 expries 和 cache-control。强缓存表示在缓存期间不需要发起请求，其 http 状态码为 200。

> expries 是 HTTP/1 的产物，表示资源会在设置的时间后过期，需要再次发起请求，因为 expries 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
> cache-control 出现于 HTTP/1.1，优先级高于 expries，该属性值表示资源会在 max-age 后贵气，过期后需再次发起请求。

#### 协商缓存

如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 Http 头实现: Last-Modified 和 Etag。

当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存的有效期。

- Last-Modified/If-Modified-Since

> Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，如果有更新则将新资源发送回，否则返回 304

> Last-Modified 的弊端:
> 如果本地打开缓存文件，即使没有对文件进行修改，还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源;
> 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端就会任务资源还是命中了，不会返回正确的资源

- ETag/If-None-Match

> 因为 Last-Modified 的弊端，所以在 Http/1.1 出现了 Etag

> Etag 类似于文件指纹，If-None-Match 会将当前 Etag 发送给服务器，询问该资源 Etag 是否变动，有变动的话就将新的资源发送回来。并且 Etag 优先级 > Last-Modified

> 如果什么缓存策略都没设置，浏览器会采用一个启发式算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间

## get 和 post 在缓存方面的区别

get 类似于查找，可用缓存；post 必须与数据库进行交互，不能使用缓存

## 浏览器跨域解决方案

1. jsonp
2. document.domain + iframe
3. location.hash + iframe
4. window.name + iframe
5. postMessage
6. 跨域资源共享 cors
7. nginx 反向代理
8. node.js 中间件代理(proxy)
9. websocket 原生支持跨域

## js 引擎的垃圾回收机制

- 标记清除法

> 对内存中存活对象做标记，标记结束后清除未被标记的

- 标记压缩法

> 使用内存碎片对内存分配

- 增量标记

> 垃圾回收时间长所产生，用来交替运行

## js 内存泄漏的几种原因

1. 意外的全局变量
2. 被遗忘的定时器或回调函数未解绑
3. 脱离 DOM 的引用
4. 不合理地使用闭包

## 前端安全

- xss 攻击

> 跨站脚本攻击，是一种代码注入攻击，可以盗取用户的 cookie
> 预防方式: 数据转义、资源白名单

- csrf 跨站请求伪造

> 攻击者诱导用户进入第三方网站，然后向被攻击网站发送跨站请求，如果此时用户处于登陆状态，则可盗用用户信息进行操作。
> 预防方式：进行同源检测，csrf token 进行随即验证

- 点击劫持

> 点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透初一个按钮诱导用户点击。
> 预防方式：通过在 http header 设置 x-frame-options 来防御 iframe 嵌套的点击劫持攻击

## 观察者模式对比发布订阅模式

> 发布订阅模式属于广义的观察者模式

> 观察者模式: 直接订阅目标事件

> 发布订阅模式: 中间多了一个调度中心，整体流程为：发布者 -> 调度中心 -> 调度者
