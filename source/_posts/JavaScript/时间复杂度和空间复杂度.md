---
title: keep-alive
date: 2021-04-15
categories: [JavaScript]
---

## 什么是复杂度分析

1. 数据结构和算法是解决 "如何让计算机以更快的时间、更省空间的解决问题"
2. 因此需要从执行时间和占用空间两个维度来评估数据结构和算法的性能。
3. 分别用时间复杂度和空间复杂度两个概念来描述性能问题，两个统称为复杂度。
4. 复杂度描述的是算法的执行时间(或占用空间)与数据规模的增长关系。

## 为什么要进行复杂度分析

1. 和性能测试相比，复杂度分析有不依赖执行环境、成本低、效率高、易操作、指导性强的特点。
2. 掌握复杂度分析，将可以编写出性能更优的代码，有利于降低系统开发和维护成本。

## 如何进行复杂度分析

### 大 O 表示法

算法的执行时间和每行代码的执行次数成正比，用 T(n)=O(f(n)) 表示，其中 T(n) 表示算法执行总时间，f(n) 表示每行代码执行的总次数，而 n 往往表示数据的规模，这就是大 O 时间复杂度表示法

### 时间复杂度

1. 定义

算法时间复杂度，也就是算法的时间量度

大 O 时间复杂度表示法实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的趋势，所以也叫渐进时间复杂度，简称时间复杂度。

- 例 1

  ```js
  // example 1
  function func() {
    console.log("Hi"); // 需要执行一次
    return 0; // 需要执行一次
  }
  ```

  > 此方法将会执行 2 次计算

- 例 2

  ```js
  function func(n) {
    for (let i = 0; i < n; i++) {
      // n + 1 次
      console.log("Hi"); // n 次
    }
    return 0; // 执行 1 次
  }
  ```

  > 此方法将会执行 (n + 1) + (n + 1) = 2n + 2 次计算

- 例 3

  ```js
  function func(n) {
    let sum = 0; // 1 次
    let i = 1; // 1 次
    let j = 1; // 1 次
    for (; i <= n; ++i) {
      // n 次
      j = 1; // n 次
      for (; j <= n; ++j) {
        // n * n 次
        sum = sum + i * j; // n * n 次
      }
    }
  }
  ```

  > 此方法将会执行 ( n2 + n2 + n + n + 1 + 1 +1 ) = 2n<sup>2</sup> +2n + 3 次计算

2. 特点

以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长 **变化趋势**，所以常量、低阶、系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时 **忽略** 这些项

因此，例 1 的时间复杂度为 T(n) = O(1)；例 2 的时间复杂度为 T(n) = O(n)；例 3 的时间复杂度为 T(n) = O(n<sup>2</sup>)

## 时间复杂度分析

### 只关注循环执行次数最多的一段代码

### 加法原则: 用复杂度等于量级最大的那段代码的复杂度

### 乘法原则: 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 多个规模求加法: 比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加

```js
function fn(m, n) {
  let sum = 0;
  let i = 1;
  for (; i < m; ++i) {
    sum = sum + i;
  }
  let sum2 = 0;
  let j = 1;
  for (; j < n; ++i) {
    sum2 = sum2 + j;
  }
  return sum + sum2;
}
```

> (公式: T1(m) + T2(n) = O(f(m) + g(n)))

### 多个规模求乘法: 比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相乘

```js
function fn(m, n) {
  let sum = 0;
  let i = 1;
  let j = 1;
  for (; i <= m; ++i) {
    j = 1;
    for (; j <= n; ++j) {
      sum = sum + i * j;
    }
  }
}
```

> 公式: T1(m) ✖️ T2(n) = O(f(m) ✖️ g(n)

## 常用的时间复杂度分析

### 多项式阶

- 常数阶 O(1)
- 对数阶 O(logn)

```js
// 对数阶
function fn(n) {
  let i = 1;
  while (i <= n) {
    i = i * 2;
  }
  return i;
}
function func(n) {
  let sum = 0;
  for (let i = 0; i <= n; ++i) {
    sum = sum + fn(n);
  }
  return sum;
}
```

> fn 的时间复杂度为 O(logn)，而 func 的时间复杂度为 O(n)，所以上面代码的时间复杂度为 T(n) = T1(logn) \* T2(n) = O(nlogn)

- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n<sup>2</sup>)
- 立方截 O(n<sup>3</sup>)

## 非多项式阶

随着数据规模的增长，算法的执行时间和空间占用爆增，这类算法性能极差

- 指数阶 O(2<sup>n</sup>)

```js
function fib(n) {
  if (n <= 1) {
    return 1;
  } else {
    return fib(n - 1) + fib(n - 2);
  }
}
```

- 阶乘阶 O(n!)

## 时间复杂度分类

- 最好情况时间复杂度
- 最坏情况时间复杂度
- 平均情况时间复杂度(加权时间复杂度 or 期望时间复杂度)
- 均摊时间复杂度

## 时间复杂度总结

常用时间复杂度所耗费的时间从小到大依次是:

O(1) < O(logn) < O(nlogin) < O(n) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

## 空间复杂度分析

时间复杂度的全称是渐近时间复杂度，表示算法的执行时间与数据规模之间的增长关系。

类比一下，空间复杂度全程就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。

1. 定义:

算法的空间复杂度通过计算算法所需的存储空间实现，算法的空间复杂度的算法公式计作: S(n) = O(f(n))，其中 n 为问题规模，f(n) 为语句关于 n 所占存储空间的函数

```js
function fn(n) {
  const newArr = []; // 第 2 行
  newArr.length = n; // 第 3 行
  for (let i = 0; i < n; ++i) {
    newArr[i] = i * i;
  }

  for (let j = n - 1; j >= 0; --j) {
    console.log(newArr[i]);
  }
}
```

跟时间复杂度分析一样，我们可以看到，第二行代码中，我们申请了一个空间存储变量 newArr，是个空数组。第 3 行把 newArr 的长度修改为长度为 n 的数组，每项的值为 undefined。除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)

我们常见的空间复杂度就是 O(1)、O(n)、O(n<sup>2</sup>)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时用不到

## 如何掌握好复杂度分析法

平时我们在写代码时，是用时间换空间还是空间换时间，可以根据算法的时间复杂度和空间复杂度来衡量
